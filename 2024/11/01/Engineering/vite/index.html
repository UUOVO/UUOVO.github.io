<!DOCTYPE html>
<html lang="zh-Hans,en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="x5-fullscreen" content="true">
<meta name="full-screen" content="yes">
<meta name="theme-color" content="#317EFB" />
<meta content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=0" name="viewport">
<meta name="description" content="一个基于原生 ESM 的前端开发和构建工具，提供极速的服务启动、热重载、按需编译、类型支持和插件系统。  优点 服务器启动速度快：通过将应用中的模块区分为依赖和源码两类   依赖：大多为在开发时不会变动的纯 JS 使用 esbuild 预构建依赖 esbuild 使用 Go 编写，并且比以 JS 编写的打包器预构建依赖快 10-100 倍   源码：包含一些非.js文件（例如 JSX，CSS 或">
<meta property="og:type" content="article">
<meta property="og:title" content="Vite --- 新一代前端构建工具">
<meta property="og:url" content="http://example.com/2024/11/01/Engineering/vite/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一个基于原生 ESM 的前端开发和构建工具，提供极速的服务启动、热重载、按需编译、类型支持和插件系统。  优点 服务器启动速度快：通过将应用中的模块区分为依赖和源码两类   依赖：大多为在开发时不会变动的纯 JS 使用 esbuild 预构建依赖 esbuild 使用 Go 编写，并且比以 JS 编写的打包器预构建依赖快 10-100 倍   源码：包含一些非.js文件（例如 JSX，CSS 或">
<meta property="og:locale">
<meta property="article:published_time" content="2024-11-01T08:52:16.698Z">
<meta property="article:modified_time" content="2024-11-05T06:41:21.414Z">
<meta property="article:author" content="UUOVO">
<meta property="article:tag" content="Vite">
<meta name="twitter:card" content="summary">

    <meta name="keywords" content="Vite">


<title >Vite --- 新一代前端构建工具</title>

<!-- Favicon -->

    <link href='/img/sitelogo16.svg?v=2.2.3' rel='icon' type='image/png' sizes='16x16' ></link>


    <link href='/img/sitelogo32.svg?v=2.2.3' rel='icon' type='image/png' sizes='32x32' ></link>


    <link href='/apple-touch-icon.png?v=2.2.3' rel='apple-touch-icon' sizes='180x180' ></link>


    <link href='/site.webmanifest' rel='manifest' ></link>


<!-- Plugin -->




    
<link rel="stylesheet" href="/css/plugins/bootstrap.row.css">

    
<link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.css">

    
<link rel="stylesheet" href="https://unpkg.com/swiper@4.5.1/dist/css/swiper.min.css">

    




<!-- Icon -->

    
<link rel="stylesheet" href="/css/plugins/font-awesome.min.css">




<!-- Variable -->
<script>window.ASYNC_CONFIG = {"hostname":"example.com","author":"UUOVO","root":"/","typed_text":["Web Developer"],"theme_version":"2.2.3","theme":{"switch":true,"default":"style-light"},"favicon":{"logo":"/img/sitelogo32.svg","icon16":"/img/sitelogo16.svg","icon32":"/img/sitelogo32.svg","apple_touch_icon":"apple-touch-icon.png","webmanifest":"/site.webmanifest","visibilitychange":true,"hidden":"failure.ico","show_text":"(/≧▽≦/)咦！又好了！","hide_text":"(●—●)喔哟，崩溃啦！"},"i18n":{"placeholder":"搜索文章...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）","author":"本文作者：","copyright_link":"本文链接：","copyright_license_title":"版权声明：","copyright_license_content":"本博客所有文章除特别声明外，均默认采用 undefined 许可协议。","copy_success":"复制成功","copy_failure":"复制失败","open_read_mode":"进入阅读模式","exit_read_mode":"退出阅读模式","notice_outdate_message":"距离上次更新已经 undefined 天了, 文章内容可能已经过时。","sticky":"置顶","just":"刚刚","min":"分钟前","hour":"小时前","day":"天前","month":"个月前"},"swup":false,"plugin":{"flickr_justified_gallery":"https://unpkg.com/flickr-justified-gallery@latest/dist/fjGallery.min.js"},"icons":{"sun":"far fa-sun","moon":"far fa-moon","play":"fas fa-play","email":"far fa-envelope","next":"fas fa-arrow-right","calendar":"far fa-calendar-alt","clock":"far fa-clock","user":"far fa-user","back_top":"fas fa-arrow-up","close":"fas fa-times","search":"fas fa-search","reward":"fas fa-hand-holding-usd","toc_tag":"fas fa-th-list","read":"fas fa-book-reader","arrows":"fas fa-arrows-alt-h","double_arrows":"fas fa-angle-double-down","copy":"fas fa-copy"},"icontype":"font","highlight":{"plugin":"highlighjs","theme":true,"copy":true,"lang":true,"title":"mac","height_limit":false},"toc":{"post_title":true},"live_time":{"start_time":"10/30/2024 17:00:00","prefix":"博客已萌萌哒运行 undefined 天"},"danmu":{"enable":true,"el":".trm-banner"},"covers":["/img/cover/cover-1.jpg","/img/cover/cover-2.jpg","/img/cover/cover-3.jpg","/img/cover/cover-4.jpg","/img/cover/cover-5.jpg","/img/cover/cover-6.jpg","/img/cover/cover-7.jpg","/img/cover/cover-8.png","/img/cover/cover-9.png","/img/cover/cover-10.jpg","/img/cover/cover-11.jpg"],"search":{"enable":true,"type":"local","href":"https://www.google.com/search?q=site:","domain":null,"path":"search.xml"}};</script>
<script id="async-page-config">window.PAGE_CONFIG = {"isPost":true,"isHome":false,"postUpdate":"2024-11-05 14:41:21"};</script>

<!-- Theme mode css -->
<link data-swup-theme rel="stylesheet" href="/css/index.css?v=2.2.3" id="trm-switch-style">
<script>
    let defaultMode = ASYNC_CONFIG.theme.default !=='auto' ?  ASYNC_CONFIG.theme.default : (window.matchMedia("(prefers-color-scheme: light)").matches ? 'style-light' : 'style-dark')
    let catchMode = localStorage.getItem('theme-mode') || defaultMode;
    let type = catchMode === 'style-dark' ? 'add' : 'remove';
    document.documentElement.classList[type]('dark')
</script>

<!-- CDN -->


    
    



<!-- Site Analytics -->

 
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body>

  <!-- app wrapper -->
  <div class="trm-app-frame">

    <!-- page preloader -->
    <div class="trm-preloader">
    <div class="trm-holder">
        <div class="preloader">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</div>
    <!-- page preloader end -->

    <!-- change mode preloader -->
    <div class="trm-mode-swich-animation-frame">
    <div class="trm-mode-swich-animation">
        <i class="i-sun"><i class="iconfont far fa-sun"></i></i>
        <div class="trm-horizon"></div>
        <i class="i-moon"><i class="iconfont far fa-moon"></i></i>
    </div>
</div>
    <!-- change mode preloader end -->

      <!-- scroll container -->
      <div id="trm-dynamic-content" class="trm-swup-animation">
        <div id="trm-scroll-container" class="trm-scroll-container" style="opacity: 0">
            <!-- top bar -->
            <header class="trm-top-bar">
	<div class="container">
		<div class="trm-left-side">
			<!-- logo -->
<a href="/" class="trm-logo-frame trm-anima-link">
    
        <img alt="logo" src="/img/sitelogo32.svg">
    
    
        <div class="trm-logo-text">
            UU<span>OVO</span>
        </div>
    
</a>
<!-- logo end -->
		</div>
		<div class="trm-right-side">
			<!-- menu -->
<div class="trm-menu">
    <nav>
        <ul>
            
            <li class="menu-item-has-children ">
                <a  href="/" target="">
                    首页
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/archives/" target="">
                    归档
                </a>
                
                <ul>
                    
                    <li>
                        <a  href="/tags/" target="">
                            标签
                        </a>
                    </li>
                    
                </ul>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/categories/" target="">
                    分类
                </a>
                
                <ul>
                    
                    <li>
                        <a  href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" target="">
                            微信小程序
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/" target="">
                            前端工程化工具
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/React/" target="">
                            React
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/VUE/" target="">
                            VUE
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/TypeScript/" target="">
                            TypeScript
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/JavaScript/" target="">
                            JavaScript
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/CSS&HTML/" target="">
                            CSS&HTML
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" target="">
                            网络与数据结构
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/uniapp/" target="">
                            uniapp
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/ThreeJS/" target="">
                            ThreeJS
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/Node/" target="">
                            Node
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/JQuery/" target="">
                            JQuery
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/ES6/" target="">
                            ES6
                        </a>
                    </li>
                    
                    <li>
                        <a  href="/categories/AJAX/" target="">
                            AJAX
                        </a>
                    </li>
                    
                </ul>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/gallery/" target="">
                    相册
                </a>
                
                <ul>
                    
                    <li>
                        <a  href="/gallery/wallpaper/" target="">
                            相册详情页
                        </a>
                    </li>
                    
                </ul>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/about/" target="">
                    关于
                </a>
                
                <ul>
                    
                    <li>
                        <a  href="/links/" target="">
                            友链
                        </a>
                    </li>
                    
                </ul>
                
            </li>
            
        </ul>
    </nav>
</div>
<!-- menu end -->
			
    <!-- mode switcher place -->
    <div class="trm-mode-switcher-place">
        <div class="trm-mode-switcher">
            <i class="iconfont far fa-sun"></i>
            <input class="tgl tgl-light" id="trm-swich" type="checkbox">
            <label class="trm-swich" for="trm-swich"></label>
            <i class="iconfont far fa-moon"></i>
        </div>
    </div>
    <!-- mode switcher place end -->

			
    
    <div id="trm-search-btn" class="trm-search-btn">
        <i class="iconfont fas fa-search"></i>
    </div>
     

		</div>
		<div class="trm-menu-btn">
			<span></span>
		</div>
	</div>
</header>
            <!-- top bar end -->

            <!-- body -->
            
<div class="trm-content-start">
    <!-- banner -->
    <div class="trm-banner">
    
    <!-- banner slideshow cover-->
    <div class="swiper-container trm-slideshow">
        <div class="swiper-wrapper">
            
            <div class="swiper-slide">
                <img style="object-position:top;object-fit:cover" src="https://pic.netbian.com/uploads/allimg/230124/002504-167449110430d8.jpg" alt="banner" class="trm-banner-cover top" data-swiper-parallax-y="-200" data-swiper-parallax-scale="1.2">
            </div>
            
            <div class="swiper-slide">
                <img style="object-position:top;object-fit:cover" src="https://img.shetu66.com/2023/07/04/1688440566649486.png" alt="banner" class="trm-banner-cover top" data-swiper-parallax-y="-200" data-swiper-parallax-scale="1.2">
            </div>
            
            <div class="swiper-slide">
                <img style="object-position:top;object-fit:cover" src="https://img.shetu66.com/2023/07/04/1688453333865029.png" alt="banner" class="trm-banner-cover top" data-swiper-parallax-y="-200" data-swiper-parallax-scale="1.2">
            </div>
            
        </div>
    </div>
    <!-- banner slideshow cover end -->
    

    <!-- banner content -->
    <div class="trm-banner-content trm-overlay">
        <div class="container">
            <div class="row">
                
                <div class="col-lg-4"></div>
                
                <div class="col-lg-8">

                    <!-- banner title -->
                    <div class="trm-banner-text ">
                        <div class="trm-label trm-mb-20">
                            NEWS LETTER
                        </div>
                        <h1 class="trm-mb-30 trm-hsmb-font">
                            Vite --- 新一代前端构建工具
                        </h1>

                        
                            <ul class="trm-breadcrumbs trm-label">
                                <li>
                                    <a href="/" class="trm-anima-link">Home</a>
                                </li>
                                <li>
                                    <span>
                                        2024
                                    </span>
                                </li>
                            </ul>
                        
                    </div>
                    <!-- banner title end -->

                    <!-- scroll hint -->
                    <span id="scroll-triger" class="trm-scroll-hint-frame">
                        <div class="trm-scroll-hint"></div>
                        <span class="trm-label">Scroll down</span>
                    </span>
                    <!-- scroll hint end -->

                </div>
            </div>
        </div>
    </div>
    <!-- banner content end -->
</div>
    <!-- banner end -->
    <div class="container">
        <div class="row">
            
                <div class="trm-page-sidebar col-lg-4 hidden-sm">
                    <!-- main card -->
                    <div class="trm-main-card-frame trm-sidebar">
    <div class="trm-main-card"> 
        <!-- card header -->
<div class="trm-mc-header">
    <div class="trm-avatar-frame trm-mb-20">
        <img alt="Avatar" class="trm-avatar" src="/img/avatar1.jpg">
    </div>
    <h5 class="trm-name trm-mb-15">
        UUOVO
    </h5>
    
        <div class="trm-label">
            I`m
            <span class="trm-typed-text">
                <!-- Words for theme.user.typedText -->
            </span>
        </div>
    
</div>
<!-- card header end -->
        <!-- sidebar social -->

<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<div class="trm-social">
    
        <a href="https://github.com/UUOVO" title="Github" rel="nofollow" target="_blank">
            <i class="iconfont fab fa-github"></i>
        </a>
    
        <a href="https://gitee.com/ovouu" title="Gitee" rel="nofollow" target="_blank">
            <i class="iconfont fab fa-google"></i>
        </a>
    
</div>

<!-- sidebar social end -->
        <!-- info -->
<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<ul class="trm-table trm-mb-20">
    
        <li>
            <div class="trm-label">
                Residence:
            </div>
            <div class="trm-label trm-label-light">
                Mars
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                City:
            </div>
            <div class="trm-label trm-label-light">
                City
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                Age:
            </div>
            <div class="trm-label trm-label-light">
                Age
            </div>
        </li>
    
</ul>
<!-- info end -->

        
    <div class="trm-divider trm-mb-40 trm-mt-40"></div>
    <!-- action button -->
    <div class="text-center">
        <a href="mailto:1370203877@qq.com" class="trm-btn">
            联系我
            <i class="iconfont far fa-envelope"></i>
        </a>
    </div>
    <!-- action button end -->

    </div>
</div>
                    <!-- main card end -->
                </div>
            
            <div class="trm-page-content col-lg-8">
                <div id="trm-content" class="trm-content">
                    <div class="trm-post-info row hidden-sm">
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-calendar-alt trm-icon"></i><br>
            11/01
        </div>
    </div>
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-clock trm-icon"></i><br>
            16:52
        </div>
    </div>
    <div class="col-sm-4">
        <div id="post-author" class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-user trm-icon"></i><br>
            UUOVO
        </div>
    </div>
</div>
<div class="trm-card ">
    <article id="article-container" class="trm-publication">
    <blockquote>
<p>一个基于原生 ESM 的前端开发和构建工具，提供极速的服务启动、热重载、按需编译、类型支持和插件系统。</p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>服务器启动速度快：通过将应用中的模块区分为依赖和源码两类</li>
</ol>
<ul>
<li>依赖：大多为在开发时不会变动的纯 JS<ul>
<li>使用 esbuild 预构建依赖</li>
<li>esbuild 使用 Go 编写，并且比以 JS 编写的打包器预构建依赖快 10-100 倍</li>
</ul>
</li>
<li>源码：包含一些非.js文件（例如 JSX，CSS 或者 组件）<ul>
<li>并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）</li>
<li>以原生 ESM 方式提供源码。实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码</li>
</ul>
</li>
</ul>
<ol start="2">
<li>快速更新</li>
</ol>
<ul>
<li>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，精确地使已编辑的模块与其最近的 HMR 边界之间的链失活。</li>
<li>同时利用 HTTP 头来加速整个页面的重新加载<br>- 源码模块的请求会根据 304 Not Modified 进行协商缓存<br>- 依赖模块请求则会通过 Cache-Control: max-age&#x3D;31536000,immutable 进行强缓存，一旦被缓存将不需要再次请求。</li>
</ul>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ol>
<li>一个开发服务器，基于原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的模块热更新（HMR）。</li>
<li>一套构建指令，使用 Rollup 打包代码，并且是预配置的，可输出用于生产环境的高度优化过的静态资源。</li>
</ol>
<h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><ul>
<li>支持原生 ESM语法的script标签</li>
<li>原生 ESM动态导入</li>
<li>import.meta的浏览器</li>
<li>传统浏览器可以通过插件@vitejs&#x2F;plugin-legacy支持</li>
</ul>
<h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><ul>
<li>提示：node版本要16+，14.18+</li>
<li>安装：npm create vite@latest 文件名 –template react-ts</li>
<li>注意：如果出现vite不是内部命令，可以执行npm i在执行npm run dev</li>
<li>create-vite 是一个快速生成主流框架基础模板的工具。</li>
<li>可以用如 degit 之类的工具，使用社区模版来搭建项目。<ul>
<li>npx degit user&#x2F;project my-project</li>
<li>npx degit user&#x2F;project#main my-project  &#x2F;&#x2F; 使用 main 作为默认分支</li>
</ul>
</li>
</ul>
<h3 id="index-html与项目根目录"><a href="#index-html与项目根目录" class="headerlink" title="index.html与项目根目录"></a>index.html与项目根目录</h3><ol>
<li>index.html</li>
</ol>
<ul>
<li>是项目的入口文件。</li>
<li>Vite 将index.html视为源码和模块图的一部分。标签指向源码，url能自动转换</li>
</ul>
<ol start="2">
<li>根目录：即服务文件的位置，以 <root> 代称。</li>
</ol>
<ul>
<li>源码中的绝对 URL 路径将以项目的 “根” 作为基础来解析。</li>
<li>能够处理依赖关系，解析处于根目录外的文件位置。</li>
<li>Vite 也支持多个 .html 作入口点的 多页面应用模式。</li>
</ul>
<ol start="3">
<li>指定替代根目录</li>
</ol>
<ul>
<li>vite serve some&#x2F;sub&#x2F;dir</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><p>npm依赖解析和预构建</p>
<ul>
<li>将会检测到所有被加载源文件中的此类裸模块导入（import { someMethod } from ‘my-dep’），并执行以下操作:</li>
</ul>
<ol>
<li>预构建,提高页面加载速度，并将 CommonJS&#x2F;UMD 转换为 ESM 格式。预构建由 esbuild 执行，这使冷启动时间快。</li>
<li>重写导入为合法的 URL以便浏览器能够正确导入。</li>
<li>依赖是强缓存的,通过 HTTP 头来缓存请求得到的依赖。</li>
</ol>
</li>
<li><p>模块热替换(create-vite 创建应用程序时已有)</p>
<ul>
<li>具有 HMR 功能的框架可以利用该 API 提供即时、准确的更新，而无需重新加载页面或清除应用程序状态。</li>
</ul>
</li>
<li><p>TypeScript</p>
<ul>
<li>仅执行 .ts 文件的转译工作，不执行任何类型检查（构建命令之外运行 tsc –noEmit 或 单独的进程中运行 tsc –noEmit –watch 或 使用 vite-plugin-checker插件）</li>
<li>使用 esbuild 将 ts 转译到 js，约是 tsc 速度的20~30倍，HMR 更新反映到浏览器的时间小于 50ms。</li>
<li>使用仅含类型的导入和导出形式的语法可以避免 “仅含类型的导入被不正确打包” 的问题</li>
<li>TypeScript编译器选项<ul>
<li>“isolatedModules”:true —支持转译功能</li>
<li>“skipLibCheck”: true —在一些库（如：vue）不支持isolatedModules时用</li>
<li>“useDefineForClassFields”: true —ts的target是ES或更高，默认。</li>
<li>代码库难迁移，可以用rollup-plugin-friendly-type-imports</li>
</ul>
</li>
</ul>
</li>
<li><p>客户端类型</p>
<ul>
<li>默认类型定义是写给它的 Node.js API,要补充到Vite 应用的客户端代码环境中，<ul>
<li>添加一个 d.ts 声明文件：<code>/// &lt;reference types=&quot;vite/client&quot; /&gt;</code></li>
<li>或者将 vite&#x2F;client 添加到 tsconfig.json 中的 compilerOptions.types 下：</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;types&quot;</span>: [<span class="string">&quot;vite/client&quot;</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这将会提供以下类型定义补充：</p>
<ul>
<li>资源导入 (例如：导入一个 .svg 文件)</li>
<li>import.meta.env 上 Vite 注入的环境变量的类型定义</li>
<li>import.meta.hot 上的 HMR API 类型定义</li>
<li>TIP：要覆盖默认的类型定义，请在三斜线注释前添加定义。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如，要为 <span class="title class_">React</span> 组件中的 *.<span class="property">svg</span> 文件定义类型：</span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.svg&#x27;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="attr">content</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">React</span>.<span class="property">SVGProps</span>&lt;<span class="title class_">SVGElement</span>&gt;&gt;</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">default</span> content</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;vite/client&quot; /&gt; </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Vue</p>
<ul>
<li>第一优先级支持</li>
<li>Vue3 单文件组件支持：@vitejs&#x2F;plugin-vue</li>
<li>Vue3 JSX 支持：@vitejs&#x2F;plugin-vue-jsx</li>
<li>Vue2.7 SFC支持：@vitejs&#x2F;plugin-vue2</li>
<li>Vue2.7 JSX支持：underfin&#x2F;plugin-vue2-jsx</li>
</ul>
</li>
<li><p>JSX</p>
<ul>
<li>不在 React 或 Vue 中使用 JSX，自定义的 jsxFactory 和 jsxFragment 也可以使用 esbuild选项进行配置。<ul>
<li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">如<span class="title class_">Preact</span>：</span><br><span class="line">  <span class="comment">// vite.config.js</span></span><br><span class="line">  <span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="attr">esbuild</span>: &#123;</span><br><span class="line">      <span class="attr">jsxFactory</span>: <span class="string">&#x27;h&#x27;</span>,</span><br><span class="line">      <span class="attr">jsxFragment</span>: <span class="string">&#x27;Fragment&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">	使用 jsxInject为 <span class="variable constant_">JSX</span> 注入 helper，以避免手动导入：</span><br><span class="line">  <span class="comment">// vite.config.js</span></span><br><span class="line">  <span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="attr">esbuild</span>: &#123;</span><br><span class="line">      <span class="attr">jsxInject</span>: <span class="string">`import React from &#x27;react&#x27;`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>CSS</p>
<ul>
<li><p>导入 .css 文件将会把内容插入到 <code>&lt;style&gt;</code> 标签中，同时也带有 HMR 支持。也能够以字符串的形式检索处理后的、作为其模块默认导出的 CSS。</p>
</li>
<li><p>@import 内联和变基</p>
<ul>
<li>通过 postcss-import 预配置支持了 CSS @import 内联，Vite 的路径别名也遵从 CSS @import。</li>
<li>Sass 和 Less 文件也支持 @import 别名和 URL 变基。</li>
</ul>
</li>
<li><p>PostCSS</p>
<ul>
<li>如果项目包含有效的 PostCSS 配置 (例如 postcss.config.js)，将会自动应用于所有已导入的 CSS。</li>
</ul>
</li>
<li><p>CSS Modules</p>
<ul>
<li>任何以 .module.css 为后缀名的文件都被认为是CSS modules 文件。导入会返回相应的模块对象<ul>
<li>CSS modules 行为可以通过 css.modules 选项 进行配置。</li>
<li>css.modules.localsConvention 开启了 camelCase 格式变量名转换，可以使用按名导入。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example.module.css */</span></span><br><span class="line">.<span class="property">red</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*.js*/</span></span><br><span class="line"><span class="keyword">import</span> classes <span class="keyword">from</span> <span class="string">&#x27;./example.module.css&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">className</span> = classes.<span class="property">red</span></span><br><span class="line"><span class="comment">// .apply-color -&gt; applyColor</span></span><br><span class="line"><span class="keyword">import</span> &#123; applyColor &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.module.css&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">className</span> = applyColor   </span><br></pre></td></tr></table></figure>
<ul>
<li><p>CSS 预处理器：要安装依赖 </p>
<ul>
<li><p>.scss and .sass：npm add -D sass</p>
</li>
<li><p>.less ： npm add -D less</p>
</li>
<li><p>.styl and .stylus：npm add -D stylus</p>
</li>
<li><p>Sass 和 Less ，保证 Vite 别名也能被使用。</p>
</li>
<li><p>@import 别名和 URL 变基不支持 Stylus。</p>
</li>
<li><p>url() 中的相对路径引用的，与根文件不同目录中的 Sass&#x2F;Less 文件会自动变基。</p>
</li>
<li><p>单文件组件，可以通过 <code>&lt;style lang=&quot;sass&quot;&gt;</code>形式自动开启。</p>
</li>
<li><p>在文件扩展名前加上 .module 来结合使用 CSS modules 和预处理器。</p>
</li>
<li><p>禁用CSS注入页面</p>
</li>
<li><p>自动注入 CSS 内容的行为可以通过 ?inline 参数来关闭。</p>
</li>
<li><p>在关闭时，被处理过的 CSS 字符串将会作为该模块的默认导出，但样式并没有被注入到页面中。</p>
<ul>
<li>import styles from ‘.&#x2F;foo.css’ &#x2F;&#x2F; 样式将会注入页面</li>
<li>import otherStyles from ‘.&#x2F;bar.css?inline’ &#x2F;&#x2F; 样式不会注入页面</li>
</ul>
</li>
</ul>
</li>
<li><p>静态资源处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">导入一个静态资源会返回解析后的 <span class="variable constant_">URL</span>：</span><br><span class="line"><span class="keyword">import</span> imgUrl <span class="keyword">from</span> <span class="string">&#x27;./img.png&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hero-img&#x27;</span>).<span class="property">src</span> = imgUrl</span><br><span class="line">添加一些特殊的查询参数可以更改资源被引入的方式：</span><br><span class="line"><span class="comment">// 显式加载资源为一个 URL</span></span><br><span class="line"><span class="keyword">import</span> assetAsURL <span class="keyword">from</span> <span class="string">&#x27;./asset.js?url&#x27;</span></span><br><span class="line"><span class="comment">// 以字符串形式加载资源</span></span><br><span class="line"><span class="keyword">import</span> assetAsString <span class="keyword">from</span> <span class="string">&#x27;./shader.glsl?raw&#x27;</span></span><br><span class="line"><span class="comment">// 加载为 Web Worker</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Worker</span> <span class="keyword">from</span> <span class="string">&#x27;./worker.js?worker&#x27;</span></span><br><span class="line"><span class="comment">// 在构建时 Web Worker 内联为 base64 字符串</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">InlineWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./worker.js?worker&amp;inline&#x27;</span></span><br><span class="line">	<span class="string">``</span><span class="string">`			</span></span><br><span class="line"><span class="string">- JSON - 可以被直接导入,支持具名导入：</span></span><br><span class="line"><span class="string">  - import json from &#x27;./example.json&#x27; // 导入整个对象</span></span><br><span class="line"><span class="string">  - import &#123; field &#125; from &#x27;./example.json&#x27; // 对一个根字段使用具名导入 —— 有效帮助 treeshaking！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Glob导入</span></span><br><span class="line"><span class="string">  - 支持使用特殊的 import.meta.glob 函数从文件系统导入多个模块：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="comment">//将dir文件夹下的所有js文件导入</span></span><br><span class="line">  <span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;./dir/*.js&#x27;</span>)</span><br><span class="line">  然后通过遍历modules的key来访问相应的模块</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> path <span class="keyword">in</span> modules) &#123;</span><br><span class="line">    modules[path]().<span class="title function_">then</span>(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(path, mod)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  匹配到的文件默认是懒加载的，通过动态导入实现，并会在构建时分离为独立的 chunk。</span><br><span class="line">  <span class="comment">//直接引入所有的模块，可以传入&#123;eager:true&#125;,作为第二参数</span></span><br><span class="line">  <span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;./dir/*.js&#x27;</span>, &#123; <span class="attr">eager</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>Glob 导入形式  <ul>
<li>支持以字符串形式导入文件。</li>
<li>使用了 Import Reflection 语法对导入进行断言：</li>
<li>const modules &#x3D; import.meta.glob(‘.&#x2F;dir&#x2F;*.js’, { as: ‘raw’ })</li>
</ul>
</li>
<li>多个匹配模式<ul>
<li>第一个参数是一个 glob 数组，例如：</li>
<li>const modules &#x3D; import.meta.glob([‘.&#x2F;dir&#x2F;<em>.js’, ‘.&#x2F;another&#x2F;</em>.js’])</li>
</ul>
</li>
<li>反面匹配模式(以 ! 作为前缀):排除匹配<ul>
<li>const modules &#x3D; import.meta.glob([‘.&#x2F;dir&#x2F;*.js’, ‘!**&#x2F;bar.js’])</li>
</ul>
</li>
<li>具名导入（部分导入）<ul>
<li>const modules &#x3D; import.meta.glob(‘.&#x2F;dir&#x2F;*.js’, { import: ‘setup’ })</li>
</ul>
</li>
<li>tree-shaking：移除 JavaScript 上下文中的未引用代码</li>
<li>与 eager 在一起时，可以对这些模块进行 tree-shaking<ul>
<li>{ import: ‘setup’, eager: true }</li>
</ul>
</li>
<li>设置 import 为 default 可以加载默认导出<ul>
<li>{import: ‘default’,eager: true}</li>
</ul>
</li>
<li>自定义查询 ：使用 query 选项<ul>
<li>{query: { foo: ‘bar’, bar: true }}</li>
<li>动态导入</li>
<li>const module &#x3D; await import(<code>./dir/$&#123;file&#125;.js</code>)</li>
</ul>
</li>
</ul>
</li>
<li><p>WebAssembly</p>
<ul>
<li>预编译的 .wasm 文件可以通过 ?init 来导入。默认导出一个初始化函数，返回值为所导出 wasm 实例对象的 Promise<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> init <span class="keyword">from</span> <span class="string">&#x27;./example.wasm?init&#x27;</span></span><br><span class="line"><span class="title function_">init</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">instance</span>) =&gt;</span> &#123;</span><br><span class="line">  instance.<span class="property">exports</span>.<span class="title function_">test</span>()</span><br><span class="line">&#125;)</span><br><span class="line">还可以将传递给 <span class="title class_">WebAssembly</span>.<span class="property">instantiate</span> 的导入对象作为其第二个参数：</span><br><span class="line"><span class="title function_">init</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: &#123;</span><br><span class="line">    <span class="attr">someFunc</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125;&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">在生产构建当中，体积小于 assetInlineLimit 的 .<span class="property">wasm</span> 文件将会被内联为 base64 字符串。否则，它们将作为资源复制到 dist 目录中，并按需获取。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Web Workers</p>
<ul>
<li>通过构造器导入<br>- Web Worker 可以使用 new Worker() 和 new SharedWorker() 导入。<br>- type: ‘module’可以创建模块</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./worker.js&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>), &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>带有查询后缀的导入</p>
<ul>
<li>在导入请求上添加 ?worker 或 ?sharedworker 查询参数来直接导入一个 web worker 脚本。<ul>
<li>默认导出会是一个自定义 worker 的构造函数：<ul>
<li>import MyWorker from ‘.&#x2F;worker?worker’</li>
<li>const worker &#x3D; new MyWorker()</li>
</ul>
</li>
<li>如果想将 worker 内联为 base64 字符串，添加 inline 查询参数：<ul>
<li>import MyWorker from ‘.&#x2F;worker?worker&amp;inline’</li>
</ul>
</li>
<li>如果想要以一个 URL 的形式读取该 worker，添加 url 这个 query：<ul>
<li>import MyWorker from ‘.&#x2F;worker?worker&amp;url’</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>构建优化</p>
<ul>
<li>CSS代码分割<ul>
<li>自动地将一个异步 chunk 模块中使用到的 CSS 代码抽取出来并为其生成一个单独的文件。这个 CSS 文件将在该异步 chunk 加载完成时自动通过一个 <link> 标签载入，该异步 chunk 会保证只在 CSS 加载完毕后再执行，避免发生 FOUC 。</li>
<li>禁用 CSS 代码分割：通过设置 build.cssCodeSplit:false</li>
</ul>
</li>
<li>预加载指令生成<ul>
<li>为入口 chunk 和它们在打包出的 HTML 中的直接引入自动生成 <link rel="modulepreload"> 指令。</li>
</ul>
</li>
<li>异步chunk加载优化<ul>
<li>将使用一个预加载步骤自动重写代码，来分割动态导入调用，以实现当 A 被请求时，C 也将 同时 被请求：Entry —&gt; (A + C)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul>
<li>添加一个插件<ul>
<li>安装好插件，然后在vite.config.js 配置文件中的 plugins 数组中引入</li>
</ul>
</li>
<li>强制插件排序<ul>
<li>使用 enforce 修饰符来强制插件的位置:<ul>
<li>pre：在 Vite 核心插件之前调用该插件</li>
<li>post：在 Vite 构建插件之后调用该插件</li>
<li>default：在 Vite 核心插件之后调用该插件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...<span class="title function_">image</span>(),</span><br><span class="line">      <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>按需应用<ul>
<li>如果插件在服务或构建期间按需使用，请使用 apply 属性指明它们仅在 ‘build’ 或 ‘serve’ 模式时调用：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typescript2 <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-typescript2&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...<span class="title function_">typescript2</span>(),</span><br><span class="line">      <span class="attr">apply</span>: <span class="string">&#x27;build&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="依赖预构建（仅会在开发模式下应用）"><a href="#依赖预构建（仅会在开发模式下应用）" class="headerlink" title="依赖预构建（仅会在开发模式下应用）"></a>依赖预构建（仅会在开发模式下应用）</h3><ul>
<li><p>目的</p>
<ul>
<li>CommonJS和UMD兼容性: 将作为 CommonJS&#x2F;UMD 发布的依赖项转换为 ESM。</li>
<li>将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</li>
</ul>
</li>
<li><p>自动依赖搜寻</p>
<ul>
<li>如果没有找到相应的缓存，将抓取源码，并自动寻找引入的依赖项，并将这些依赖项作为预构建包的入口点。</li>
<li>在服务器已经启动之后，如果遇到一个新的依赖关系导入，且不在缓存中，将重新运行依赖构建进程并重新加载页面。</li>
</ul>
</li>
<li><p>Monorepo 和链接依赖</p>
<ul>
<li>monorepo 启动，该仓库中的某个包可能会成为另一个包的依赖。</li>
<li>Vite 会自动侦测没有从 node_modules 解析的依赖项，并将链接的依赖视为源码。</li>
<li>会分析被链接依赖的依赖列表。但被链接的依赖导出要为 ESM 格式。如果不是，在配置里将此依赖添加到 optimizeDeps.include和build.commonjsOptions.include 这两项中。</li>
<li>当这个被链接的依赖发生变更后，在重启开发服务器时在命令中带上 –force 选项让所有更改生效。</li>
<li>传递依赖项错误的去重，导致运行出错，使用npm pack 来修复<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="attr">include</span>: [<span class="string">&#x27;linked-dep&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">commonjsOptions</span>: &#123;</span><br><span class="line">      <span class="attr">include</span>: [<span class="regexp">/linked-dep/</span>, <span class="regexp">/node_modules/</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>自定义行为</p>
<ul>
<li>optimizeDeps.include：明确包含依赖依赖项很大或者是 CommonJS<ul>
<li>optimizeDeps.exclude：明确排除依赖项很小，并且已经是有效的 ESM</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存</p>
<ul>
<li>文件系统缓存<ul>
<li>Vite 会将预构建的依赖缓存到 node_modules&#x2F;.vite。它基于以下几个源来决定是否需要重新运行预构建步骤:<ol>
<li>补丁文件夹的修改时间</li>
<li>包管理器的 lockfile，例如 package-lock.json, yarn.lock，或者 pnpm-lock.yaml或者 bun.lockb</li>
<li>vite.config.js 中的相关字段<ol start="4">
<li>NODE_ENV 的值</li>
</ol>
</li>
</ol>
</li>
<li>只有在上述其中一项发生更改时，才需要重新运行预构建。</li>
<li>强制重新构建依赖，用 –force 命令行选项启动开发服务器，或者手动删除 node_modules&#x2F;.vite 目录。</li>
</ul>
</li>
<li>浏览器缓存<ul>
<li>已预构建的依赖请求使用 HTTP 头 max-age&#x3D;31536000,immutable 进行强缓存，一旦被缓存将不需要再次请求。<ul>
<li>如安装了不同的版本的依赖项，则会通过附加的版本查询自动失效。</li>
<li>如果想通过本地编辑来调试依赖项，则:</li>
</ul>
<ol>
<li>通过浏览器调试工具的 Network 选项卡暂时禁用缓存；</li>
<li>重启 Vite 开发服务器指定 –force 选项，来重新构建依赖项</li>
<li>重新载入页面。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><ul>
<li>将资源引入为 URL<ul>
<li>服务时引入一个静态资源会返回解析后的公共路径：<ul>
<li>import imgUrl from ‘.&#x2F;img.png’</li>
<li>document.getElementById(‘hero-img’).src &#x3D; imgUrl</li>
</ul>
</li>
<li>行为类似于 Webpack 的 file-loader。区别在于导入既可以使用绝对公共路径，也可以使用相对路径。<ul>
<li>url() 在 CSS 中的引用也以同样的方式处理。</li>
<li>Vue插件，Vue SFC模板中的资源引用都将自动转换为导入。</li>
<li>常见的图像、媒体和字体文件类型被自动检测为资源。使用 assetsInclude 选项扩展内部列表。</li>
<li>引用的资源作为构建资源图的一部分包括在内，将生成散列文件名，并可以由插件进行处理以进行优化。</li>
<li>较小的资源体积小于 assetsInlineLimit 选项值则会被内联为 base64 data URL。</li>
<li>Git LFS 占位符会自动排除在内联之外。要获得内联，请确保在构建之前通过 Git LFS 下载文件内容。<ul>
<li>默认情况下，TypeScript 不会将静态资源导入视为有效的模块。要解决这个问题，需要添加 vite&#x2F;client。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>显示 URL 引入<ul>
<li>未被包含在内部列表或 assetsInclude 中的资源，可以使用 ?url 后缀显式导入为一个 URL。</li>
</ul>
</li>
<li>将资源引入为 字符串<ul>
<li>资源可以使用 ?raw 后缀声明作为字符串引入。<ul>
<li>import shaderString from ‘.&#x2F;shader.glsl?raw</li>
</ul>
</li>
</ul>
</li>
<li>导入脚本作为Worker<ul>
<li>通过 ?worker 或 ?sharedworker 后缀导入为 web worker。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在生产构建中将会分离出 chunk</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Worker</span> <span class="keyword">from</span> <span class="string">&#x27;./shader.js?worker&#x27;</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>()</span><br><span class="line"><span class="comment">// sharedworker</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SharedWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./shader.js?sharedworker&#x27;</span></span><br><span class="line"><span class="keyword">const</span> sharedWorker = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>()</span><br><span class="line"><span class="comment">// 内联为 base64 字符串</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">InlineWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./shader.js?worker&amp;inline&#x27;</span></span><br><span class="line"><span class="string">``</span><span class="string">`				</span></span><br><span class="line"><span class="string">- public 目录</span></span><br><span class="line"><span class="string">	- 存放不会被源码引用、必须保持原有文件名、不想引入，只想得到url</span></span><br><span class="line"><span class="string">	- 目录默认是 &lt;root&gt;/public，但可以通过 publicDir 选项 来配置</span></span><br><span class="line"><span class="string">	- 注意：该目录资源不应该被js文件引用，应该使用/绝对路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- new URL(url, import.meta.url)</span></span><br><span class="line"><span class="string">  - 功能：暴露当前模块的 URL。</span></span><br><span class="line"><span class="string">	- 将它与原生的 URL 构造器 组合使用，在一个 JS 模块中，通过相对路径我们就能得到一个被完整解析的静态资源 URL：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="comment">// URL字符串必须是静态的</span></span><br><span class="line">  <span class="keyword">const</span> imgUrl = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./img.png&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>).<span class="property">href</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hero-img&#x27;</span>).<span class="property">src</span> = imgUrl</span><br><span class="line">字符串模板支持动态 <span class="variable constant_">URL</span>：</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getImageUrl</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">`./dir/<span class="subst">$&#123;name&#125;</span>.png`</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>).<span class="property">href</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="构建生产版本-vite-build"><a href="#构建生产版本-vite-build" class="headerlink" title="构建生产版本: vite build"></a>构建生产版本: vite build</h3><ul>
<li><p>浏览器兼容性</p>
<ul>
<li>支持原生 ESM script 标签、支持原生 ESM 动态导入 和 import.meta 的浏览器<ul>
<li>通过 build.target 配置项指定构建目标，最低支持 es2015。</li>
<li>默认情况下 Vite 只处理语法转译，且默认不包含任何 polyfill。</li>
</ul>
</li>
<li>传统浏览器可以通过插件 @vitejs&#x2F;plugin-legacy 来支持。兼容版的 chunk 只会在不支持原生 ESM 的浏览器中进行按需加载。</li>
</ul>
</li>
<li><p>公共基础路径</p>
<ul>
<li>在嵌套的公共路径下部署项目，需指定 base 配置项，然后所有资源的路径都将据此配置重写<ul>
<li>也可以通过命令行参数指定，例如 vite build –base&#x3D;&#x2F;my&#x2F;public&#x2F;path&#x2F;。</li>
</ul>
</li>
<li>当访问过程中需要使用动态连接的 url 时，可以使用全局注入的 import.meta.env.BASE_URL 变量，它的值为公共基础路径。<ul>
<li>注意:这个变量在构建时会被静态替换，因此必须按 import.meta.env.BASE_URL 的原样出现</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义构建</p>
<ul>
<li>通过 build.rollupOptions 直接调整底层的 Rollup 选项</li>
</ul>
</li>
<li><p>产物分块策略</p>
<ul>
<li>通过配置 build.rollupOptions.output.manualChunks 来自定义 chunk 分割策略.<ul>
<li>默认的策略是将 chunk 分割为 index 和 vendor。可以通过在配置文件中添加 splitVendorChunkPlugin 来继续使用 “分割 Vendor Chunk” 策略</li>
<li>也可用工厂函数 splitVendorChunk({ cache: SplitVendorChunkCache }) 来提供该策略，cache.reset() 需要在 buildStart 阶段被调用。</li>
</ul>
</li>
</ul>
</li>
<li><p>文件变化时重新构建</p>
<ul>
<li>vite build –watch 来启用 rollup 的监听器。<ul>
<li>或直接通过 build.watch 调整底层的 WatcherOptions 选项。</li>
</ul>
</li>
</ul>
</li>
<li><p>多页面应用模式</p>
<ul>
<li>在构建过程中，只需指定多个 .html 文件作为入口点</li>
<li>如果指定了另一个根目录，在解析输入路径时，__dirname 的值将仍然是 vite.config.js 文件所在的目录。因此，需要把对应入口文件的 root 的路径添加到 resolve 的参数中。</li>
</ul>
</li>
<li><p>库模式</p>
<ul>
<li>这个库要进行发布构建时，使用 build.rollupOptions.external 配置项确保将那些不想打包进库的依赖进行外部化处理</li>
<li>在 package.json 中使用如下格式。来暴露多个入口起点：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./dist/my-lib.mjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./dist/my-lib.cjs&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;./secondary&quot;</span>: &#123;<span class="comment">//暴露多个入口起点使用这种形式</span></span><br><span class="line">      <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./dist/secondary.mjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./dist/secondary.cjs&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意：<ol>
<li>如果 package.json 不包含 “type”: “module”，Vite 会生成不同的文件后缀名以兼容 Node.js。.js 会变为 .mjs 而 .cjs 会变为 .js 。</li>
<li>在库模式下，所有 import.meta.env.* 用法在构建生产时都会被静态替换。但是，process.env.* 的用法不会被替换。如果不允许这样做，使用 define: { ‘process.env.NODE_ENV’: ‘“production”‘ } 。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="部署静态站点"><a href="#部署静态站点" class="headerlink" title="部署静态站点"></a>部署静态站点</h3><ul>
<li><p>构建应用：npm run build</p>
</li>
<li><p>本地测试应用：构建后运行npm run preview </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;preview&quot;</span>: <span class="string">&quot;vite preview --port 8080&quot;</span> <span class="comment">// 配置服务的运行端口</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>GitHub Pages</p>
<ol>
<li>在 vite.config.js 中设置正确的 base。</li>
</ol>
<ul>
<li>部署在 https:&#x2F;&#x2F;<USERNAME>.github.io&#x2F; 上，省略 base 使其默认为 ‘&#x2F;‘</li>
<li>部署在 https:&#x2F;&#x2F;<USERNAME>.github.io&#x2F;<REPO>&#x2F; 上，设置 base 为 ‘&#x2F;<REPO>&#x2F;‘</li>
</ul>
<ol start="2">
<li>进入仓库 settings 页面的 GitHub Pages 配置，选择部署来源为“GitHub Actions”</li>
</ol>
</li>
<li><p>GitLab Pages 配合 GitLab CI</p>
<ol>
<li>在 vite.config.js 中设置正确的 base。</li>
</ol>
<ul>
<li>部署在 https:&#x2F;&#x2F;<USERNAME or GROUP>.gitlab.io&#x2F; 上，省略 base 使其默认为 ‘&#x2F;‘。</li>
<li>部署在 https:&#x2F;&#x2F;<USERNAME or GROUP>.gitlab.io&#x2F;<REPO>&#x2F; 上，设置 base 为 ‘&#x2F;<REPO>&#x2F;‘。</li>
</ul>
<ol start="2">
<li>在项目根目录创建一个 .gitlab-ci.yml 文件，并包含以下内容<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image</span>: <span class="attr">node</span>:<span class="number">16.5</span><span class="number">.0</span></span><br><span class="line"><span class="attr">pages</span>:</span><br><span class="line">  <span class="attr">stage</span>: deploy</span><br><span class="line">  <span class="attr">cache</span>:</span><br><span class="line">    <span class="attr">key</span>:</span><br><span class="line">      <span class="attr">files</span>:</span><br><span class="line">        - package-lock.<span class="property">json</span></span><br><span class="line">      <span class="attr">prefix</span>: npm</span><br><span class="line">    <span class="attr">paths</span>:</span><br><span class="line">      - node_modules/</span><br><span class="line">  <span class="attr">script</span>:</span><br><span class="line">    - npm install</span><br><span class="line">    - npm run build</span><br><span class="line">    - cp -a dist/. public/</span><br><span class="line">  <span class="attr">artifacts</span>:</span><br><span class="line">    <span class="attr">paths</span>:</span><br><span class="line">      - public</span><br><span class="line">  <span class="attr">rules</span>:</span><br><span class="line">     - <span class="attr">if</span>: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="环境变量与模式"><a href="#环境变量与模式" class="headerlink" title="环境变量与模式"></a>环境变量与模式</h3><ul>
<li><p>环境变量</p>
<ul>
<li>import.meta.env.MODE: {string} 应用运行的模式。</li>
<li>import.meta.env.BASE_URL: {string} 部署应用时的基本 URL。他由base 配置项决定。</li>
<li>import.meta.env.PROD: {boolean} 应用是否运行在生产环境。</li>
<li>import.meta.env.DEV: {boolean} 应用是否运行在开发环境 (永远与 import.meta.env.PROD相反)。</li>
<li>import.meta.env.SSR: {boolean} 应用是否运行在 server 上。</li>
</ul>
</li>
<li><p>生产环境替换</p>
<ul>
<li>在生产环境中，在引用环境变量时请使用完全静态的字符串。</li>
<li>对于 JavaScript 字符串，可以使用 unicode 零宽度空格来分割这个字符串，例如： ‘import.meta\u200b.env.MODE’。</li>
<li>对于 Vue 模板或其他编译到 JavaScript 字符串的 HTML，可以使用 <wbr> 标签，例如：import.meta.<wbr>env.MODE。</li>
</ul>
</li>
<li><p>.env文件</p>
<ul>
<li>.env                # 所有情况下都会加载</li>
<li>.env.local          # 所有情况下都会加载，但会被 git 忽略</li>
<li>.env.[mode]         # 只在指定模式下加载</li>
<li>.env.[mode].local   # 只在指定模式下加载，但会被 git 忽略</li>
<li>环境加载优先级<ul>
<li>Vite 执行时已经存在的环境变量有最高的优先级，不会被覆盖。</li>
<li>一份用于指定模式的文件（例如 .env.production）会比通用形式的优先级更高（例如 .env）。</li>
<li>.env 类文件会在 Vite 启动一开始时被加载，而改动会在重启服务器后生效。</li>
</ul>
</li>
<li>加载的环境变量也会通过 import.meta.env 以字符串形式暴露给客户端源码</li>
<li>为了防止意外地将一些环境变量泄漏到客户端，只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理的代码。</li>
</ul>
</li>
<li><p>TypeScript 的智能提示</p>
<ul>
<li>获取以 VITE_ 为前缀的用户自定义环境变量的 TypeScript 智能提示：</li>
<li>在 src 目录下创建一个 env.d.ts 文件，接着按下面这样增加 ImportMetaEnv 的定义：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;vite/client&quot; /&gt;</span></span><br><span class="line">interface <span class="title class_">ImportMetaEnv</span> &#123;</span><br><span class="line">  readonly <span class="attr">VITE_APP_TITLE</span>: string</span><br><span class="line">  <span class="comment">// 更多环境变量...</span></span><br><span class="line">&#125;</span><br><span class="line">interface <span class="title class_">ImportMeta</span> &#123;</span><br><span class="line">  readonly <span class="attr">env</span>: <span class="title class_">ImportMetaEnv</span></span><br><span class="line">&#125;</span><br><span class="line">如果代码依赖于浏览器环境的类型，比如 <span class="variable constant_">DOM</span> 和 <span class="title class_">WebWorker</span>，可以在 tsconfig.<span class="property">json</span> 中修改 lib 字段来获取类型支持。</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;WebWorker&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>模式</p>
<ul>
<li>默认情况下，开发服务器 (dev 命令) 运行在 development模式，而 build 命令则运行在 production 模式。</li>
<li>通过传递 –mode 选项标志来覆盖命令使用的默认模式: vite build –mode staging</li>
</ul>
</li>
</ul>
<h3 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h3><ul>
<li><p>情景逻辑</p>
<ul>
<li>如果需要执行 SSR 和客户端间情景逻辑，可以使用：<br>-if (import.meta.env.SSR) { &#x2F;&#x2F; … 仅在服务端执行的逻辑 }</li>
</ul>
</li>
<li><p>生产环境构建</p>
<ol>
<li>正常生成一个客户端构建；</li>
<li>再生成一个 SSR 构建，使其通过 import() 直接加载，这样便无需再使用 Vite 的 ssrLoadModule；</li>
</ol>
<ul>
<li>注意:使用 –ssr 标志表明这将会是一个 SSR 构建。同时需要指定 SSR 的入口。</li>
</ul>
<ol start="3">
<li>在 server.js 中，通过 process.env.NODE_ENV 条件分支，需要添加一些用于生产环境的特定逻辑：</li>
</ol>
<ul>
<li>使用 dist&#x2F;client&#x2F;index.html 作为模板，而不是根目录的 index.html，因为前者包含了到客户端构建的正确资源链接。</li>
<li>使用 import(‘.&#x2F;dist&#x2F;server&#x2F;entry-server.js’) </li>
<li>将 vite 开发服务器的创建和所有使用都移到 dev-only 条件分支后面，然后添加静态文件服务中间件来服务 dist&#x2F;client 中的文件。</li>
</ul>
</li>
<li><p>生成预加载指令</p>
<ul>
<li>使用 –ssrManifest 标志，这将会在构建输出目录中生成一份 ssr-manifest.json：<ul>
<li>“build:client”: “vite build –outDir dist&#x2F;client –ssrManifest”,</li>
<li>@vitejs&#x2F;plugin-vue 会自动注册使用的组件模块 ID 到相关的 Vue SSR 上下文：</li>
</ul>
</li>
</ul>
</li>
<li><p>预渲染 &#x2F; SSG</p>
<ul>
<li>预先知道某些路由所需的路由和数据，可以使用与生产环境 SSR 相同的逻辑将这些路由预先渲染到静态 HTML中。</li>
</ul>
</li>
<li><p>SSR 外部化</p>
<ul>
<li>当运行 SSR 时依赖会由 Vite 的 SSR 转换模块系统作外部化。<ul>
<li>如果依赖需要被 Vite 的管道转换,可以添加到 ssr.noExternal</li>
<li>对于采用链接的依赖，它们将默认不会被外部化</li>
</ul>
</li>
</ul>
</li>
<li><p>SSR 专有插件逻辑</p>
<ul>
<li>一些框架，会根据客户端渲染和服务端渲染的区别，将组件编译成不同的格式。可以向以下的插件钩子中，给 Vite 传递额外的 options 对象，对象中包含 ssr 属性来支持根据情景转换：<ul>
<li>resolveId</li>
<li>load</li>
<li>transform</li>
</ul>
</li>
</ul>
</li>
<li><p>SSR 构建目标</p>
<ul>
<li>SSR 构建的默认目标为 node 环境，但也可以让服务运行在 Web Worker 上。可以将ssr.target 设置为 webworker，以将目标配置为 Web Worker。</li>
</ul>
</li>
<li><p>SSR 构建产物</p>
<ul>
<li>通过设置 ssr.noExternal 为 true 来将 SSR 打包成单个 JavaScript 文件。这将会做两件事：<ul>
<li>将所有依赖视为 noExternal（非外部化）</li>
<li>若任何 Node.js 内置内容被引入，将抛出一个错误</li>
</ul>
</li>
</ul>
</li>
<li><p>Vite CLI</p>
<ul>
<li>CLI 命令 $ vite dev 和 $ vite preview 也可以用于 SSR 应用：可以将SSR 中间件通过 configureServer 添加到开发服务器、以及通过 configurePreviewServer 添加到预览服务器。</li>
</ul>
</li>
<li><p>SSR 格式</p>
<ul>
<li>默认情况下，Vite 生成的 SSR 打包产物是 ESM 格式。<ul>
<li>如果SSR 项目不能使用 ESM，可以通过 Vite v2 外部启发式方法设置 legacy.buildSsrCjsExternalHeuristics: true 生成 CJS 格式的产物。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="后端集成-自定义"><a href="#后端集成-自定义" class="headerlink" title="后端集成(自定义)"></a>后端集成(自定义)</h3><ol>
<li>在的 Vite 配置中配置入口文件和启用创建 manifest：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="comment">// 在 outDir 中生成 manifest.json</span></span><br><span class="line">    <span class="attr">manifest</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">			<span class="comment">// 覆盖默认的 .html 入口</span></span><br><span class="line">			<span class="attr">input</span>: <span class="string">&#x27;/path/to/main.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果没有禁用 module preload 的 polyfill，还需在入口处添加此 polyfill：</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vite/modulepreload-polyfill&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>在开发环境中，在服务器的 HTML 模板中注入以下内容：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是在开发环境中</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;http://localhost:5173/@vite/client&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:5173/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="string">&quot;为了正确地提供资源，有两种选项：&quot;</span></span><br><span class="line">  <span class="number">1.</span> 确保服务器被配置过，将会拦截代理资源请求给到 <span class="title class_">Vite</span> 服务器</span><br><span class="line">  <span class="number">2.</span> 设置 server.<span class="property">origin</span> 以求生成的资源链接将以服务器 <span class="variable constant_">URL</span> 形式被解析而非一个相对路径</span><br><span class="line"><span class="string">&quot;如果正使用 @vitejs/plugin-react 配合 React，还需要在上述脚本前添加下面这个，因为插件不能修改正在服务的 HTML&quot;</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> <span class="title class_">RefreshRuntime</span> <span class="keyword">from</span> <span class="string">&#x27;http://localhost:5173/@react-refresh&#x27;</span></span><br><span class="line">  <span class="title class_">RefreshRuntime</span>.<span class="title function_">injectIntoGlobalHook</span>(<span class="variable language_">window</span>)</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">$RefreshReg$</span> = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">$RefreshSig$</span> = <span class="function">() =&gt;</span> <span class="function">(<span class="params">type</span>) =&gt;</span> type</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">__vite_plugin_react_preamble_installed__</span> = <span class="literal">true</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">// 如果是在生产环境中</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/assets/&#123;&#123; manifest[&#x27;main.js&#x27;].css &#125;&#125;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/assets/&#123;&#123; manifest[&#x27;main.js&#x27;].file &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>在生产环境中：在运行 vite build 之后，一个 manifest.json 文件将与静态资源文件一同生成。</li>
</ol>
<ul>
<li>清单是一个 Record&lt;name, chunk&gt; 结构的对象。</li>
<li>对于 入口 或动态入口 chunk，键是相对于项目根目录的资源路径。</li>
<li>对于非入口 chunk，键是生成文件的名称并加上前缀 _。</li>
<li>Chunk 将信息包含在其静态和动态导入上（两者都是映射到清单中相应 chunk 的键)，以及任何与之相关的 CSS 和资源文件。</li>
<li>可以使用这个文件来渲染链接或者用散列文件名预加载指令</li>
</ul>
<h3 id="插件API"><a href="#插件API" class="headerlink" title="插件API"></a>插件API</h3><ul>
<li><p>约定</p>
<ul>
<li>如果插件不使用 Vite 特有的钩子，可以作为兼容 Rollup 的插件来实现：<ul>
<li>Rollup 插件应该有一个带 rollup-plugin- 前缀、语义清晰的名称。</li>
<li>在 package.json 中包含 rollup-plugin 和 vite-plugin 关键字</li>
</ul>
</li>
<li>对于 Vite 专属的插件：<ul>
<li>Vite 插件应该有一个带 vite-plugin- 前缀、语义清晰的名称。</li>
<li>在 package.json 中包含 vite-plugin 关键字。</li>
</ul>
</li>
<li>只适用于特定的框架的插件：<ul>
<li>vite-plugin-vue- 前缀作为 Vue 插件</li>
<li>vite-plugin-react- 前缀作为 React 插件</li>
<li>vite-plugin-svelte- 前缀作为 Svelte 插件</li>
</ul>
</li>
</ul>
</li>
<li><p>插件配置</p>
<ul>
<li>用户会将插件添加到项目的 devDependencies 中并使用数组形式的 plugins 选项配置它们。该数组将在内部被扁平化（flatten）。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> vitePlugin <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-feature&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rollupPlugin <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-feature&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vitePlugin</span>(), <span class="title function_">rollupPlugin</span>()] <span class="comment">// 可以接受将多个插件作为单个元素的预设</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>转换自定义文件类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileRegex = <span class="regexp">/\.(my-file-ext)$/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">myPlugin</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;transform-file&#x27;</span>,</span><br><span class="line">    <span class="title function_">transform</span>(<span class="params">src, id</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fileRegex.<span class="title function_">test</span>(id)) &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">code</span>: <span class="title function_">compileFileToJS</span>(src),</span><br><span class="line">          <span class="attr">map</span>: <span class="literal">null</span> <span class="comment">// 如果可行将提供 source map</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟模块</p>
<ul>
<li>一种很实用的模式，使可以对使用 ESM 语法的源文件传入一些编译时信息。然后在js文件中引入。</li>
<li>在 Vite（以及 Rollup）中都以 virtual: 为前缀。</li>
</ul>
</li>
<li><p>通用钩子</p>
<ul>
<li>以下钩子在服务器启动时被调用：<ul>
<li>options</li>
<li>buildStart</li>
</ul>
</li>
<li>以下钩子会在每个传入模块请求时被调用：<ul>
<li>resolveId</li>
<li>load</li>
<li>transform</li>
</ul>
</li>
<li>以下钩子在服务器关闭时被调用：<ul>
<li>buildEnd</li>
<li>closeBundle</li>
</ul>
</li>
<li>注意 moduleParsed 钩子在开发中是不会被调用的。可以认为 Vite 的开发服务器只调用了 rollup.rollup() 而没有调用 bundle.generate()。</li>
</ul>
</li>
<li><p>Vite 独有钩子</p>
<ul>
<li>config<ul>
<li>类型：(config: UserConfig, env: { mode: string, command: string }) &#x3D;&gt; UserConfig | null | void<ul>
<li>种类：async, sequential</li>
</ul>
</li>
<li>在解析 Vite 配置前调用。钩子接收原始用户配置和一个描述配置环境的变量，包含正在使用的 mode 和 command。它可以返回一个将被深度合并到现有配置中的部分配置对象，或者直接改变配置。</li>
</ul>
</li>
<li>configResolved<ul>
<li>类型：(config: ResolvedConfig) &#x3D;&gt; void | Promise<void></li>
<li>种类：async, parallel</li>
<li>在解析 Vite 配置后调用。使用这个钩子读取和存储最终解析的配置。</li>
</ul>
</li>
<li>configureServer<ul>
<li>类型：(server: ViteDevServer) &#x3D;&gt; (() &#x3D;&gt; void) | void | Promise&lt;(() &#x3D;&gt; void) | void&gt;</li>
<li>种类：async, sequential</li>
<li>注入后置中间件：<ul>
<li>configureServer 钩子将在内部中间件被安装前调用。如果想注入一个在内部中间件之后运行的中间件，可以从 configureServer 返回一个函数，将会在内部中间件安装后被调用<br>-存储服务器访问</li>
</ul>
</li>
</ul>
</li>
<li>configurePreviewServer<ul>
<li>类型：(server: { middlewares: Connect.Server, httpServer: http.Server }) &#x3D;&gt; (() &#x3D;&gt; void) | void | Promise&lt;(() &#x3D;&gt; void) | void&gt;</li>
<li>种类：async, sequential</li>
<li>用于预览服务器。configurePreviewServer 钩子也是在其他中间件安装前被调用的。想要在其他中间件之后安装一个插件，可以从 configurePreviewServer返回一个函数，它将会在内部中间件被安装之后再调用</li>
</ul>
</li>
<li>transformIndexHtml：转换 index.html 的专用钩子。<ul>
<li>类型： IndexHtmlTransformHook | { enforce?: ‘pre’ | ‘post’, transform: IndexHtmlTransformHook }</li>
<li>种类： async, sequential</li>
<li>钩子接收当前的 HTML 字符串和转换上下文。上下文在开发期间暴露ViteDevServer实例，在构建期间暴露 Rollup 输出的包。</li>
<li>这个钩子可以是异步的，并且可以返回以下其中之一:<ol>
<li>经过转换的 HTML 字符串</li>
<li>注入到现有HTML中的标签描述符对象数组({tag, attrs, children})。每个标签也可以指定它应该被注入到哪里（默认是在 <head> 之前）</li>
<li>一个包含 { html, tags } 的对象</li>
</ol>
</li>
</ul>
</li>
<li>handleHotUpdate<ul>
<li>类型： (ctx: HmrContext) &#x3D;&gt; Array<ModuleNode> | void | Promise&lt;Array<ModuleNode> | void&gt;</li>
<li>执行自定义 HMR 更新处理。钩子接收一个带有以下签名的上下文对象：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">HmrContext</span> &#123;</span><br><span class="line">  <span class="attr">file</span>: string</span><br><span class="line">  <span class="attr">timestamp</span>: number</span><br><span class="line">  <span class="attr">modules</span>: <span class="title class_">Array</span>&lt;<span class="title class_">ModuleNode</span>&gt; <span class="comment">//是受更改文件影响的模块数组。</span></span><br><span class="line">  <span class="attr">read</span>: <span class="function">() =&gt;</span> string | <span class="title class_">Promise</span>&lt;string&gt;  <span class="comment">//异步读函数，它返回文件的内容</span></span><br><span class="line">  <span class="attr">server</span>: <span class="title class_">ViteDevServer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>插件顺序</p>
<ul>
<li>一个 Vite 插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是pre 或 post。解析后的插件将按照以下顺序排列：<ul>
<li>Alias</li>
<li>带有 enforce: ‘pre’ 的用户插件</li>
<li>Vite 核心插件</li>
<li>没有 enforce 值的用户插件</li>
<li>Vite 构建用的插件</li>
<li>带有 enforce: ‘post’ 的用户插件</li>
<li>Vite 后置构建插件（最小化，manifest，报告</li>
</ul>
</li>
</ul>
</li>
<li><p>Rollup 插件兼容性</p>
<ul>
<li>只要 Rollup 插件符合以下标准，它就应该像 Vite 插件一样工作：<ul>
<li>没有使用 moduleParsed 钩子。</li>
<li>它在打包钩子和输出钩子之间没有很强的耦合。</li>
</ul>
</li>
<li>如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。它的工作原理与 Vite 插件的 enforce: ‘post’ 和 apply: ‘build’ 相同。</li>
</ul>
</li>
<li><p>路径规范化</p>
<ul>
<li>Vite在解析路径时使用 POSIX 分隔符（ &#x2F; ），同时保留了 Windows 中的卷名。<ul>
<li>Rollup 在默认情况下保持解析的路径不变，因此解析的路径在 Windows 中会使用 win32 分隔符（ \ ）。</li>
</ul>
</li>
</ul>
</li>
<li><p>过滤与include&#x2F;exclde模式</p>
<ul>
<li>暴露 @rollup&#x2F;pluginutils 的 createFilter 函数，以支持 Vite 独有插件和集成使用标准的 include&#x2F;exclude 过滤模式</li>
</ul>
</li>
<li><p>客户端与服务端间通信</p>
<ul>
<li>服务端到客户端<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">在插件一侧，我们可以使用 server.<span class="property">ws</span>.<span class="property">send</span> 去给所有客户端广播事件：</span><br><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [&#123;</span><br><span class="line">    <span class="title function_">configureServer</span>(<span class="params">server</span>) &#123;</span><br><span class="line">      server.<span class="property">ws</span>.<span class="title function_">send</span>(<span class="string">&#x27;my:greetings&#x27;</span>, &#123; <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br><span class="line">在客户端侧，使用 hot.<span class="property">on</span> 去监听事件：</span><br><span class="line"><span class="comment">// client side</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">on</span>(<span class="string">&#x27;my:greetings&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">msg</span>) <span class="comment">// hello</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`				</span></span><br><span class="line"><span class="string">  - 客户端到服务端</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">为了从客户端向服务端发送事件，使用 hot.<span class="property">send</span>：</span><br><span class="line">  <span class="comment">// client side</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">    <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">send</span>(<span class="string">&#x27;my:from-client&#x27;</span>, &#123; <span class="attr">msg</span>: <span class="string">&#x27;Hey!&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">然后使用 server.<span class="property">ws</span>.<span class="property">on</span> 并在服务端监听这些事件：</span><br><span class="line">  <span class="comment">// vite.config.js</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [&#123;</span><br><span class="line">      <span class="title function_">configureServer</span>(<span class="params">server</span>) &#123;</span><br><span class="line">        server.<span class="property">ws</span>.<span class="title function_">on</span>(<span class="string">&#x27;my:from-client&#x27;</span>, <span class="function">(<span class="params">data, client</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message from client:&#x27;</span>, data.<span class="property">msg</span>) <span class="comment">// Hey!</span></span><br><span class="line">          <span class="comment">// reply only to the client (if needed)</span></span><br><span class="line">          client.<span class="title function_">send</span>(<span class="string">&#x27;my:ack&#x27;</span>, &#123; <span class="attr">msg</span>: <span class="string">&#x27;Hi! I got your message!&#x27;</span> &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
<li>自定义事件的 TypeScript 类型定义指南<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可以通过扩展 <span class="title class_">CustomEventMap</span> 这个 interface 来为自定义事件标注类型：</span><br><span class="line"><span class="comment">// events.d.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vite/types/customEvent&#x27;</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;vite/types/customEvent&#x27;</span> &#123;</span><br><span class="line">  interface <span class="title class_">CustomEventMap</span> &#123;</span><br><span class="line">     <span class="string">&#x27;custom:foo&#x27;</span>: &#123; <span class="attr">msg</span>: string &#125;</span><br><span class="line">     <span class="comment">// &#x27;event-key&#x27;: payload</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="客户端-HMR-API-：通过-import-meta-hot-对象暴露手动-HMR-API。"><a href="#客户端-HMR-API-：通过-import-meta-hot-对象暴露手动-HMR-API。" class="headerlink" title="客户端 HMR API ：通过 import.meta.hot 对象暴露手动 HMR API。"></a>客户端 HMR API ：通过 import.meta.hot 对象暴露手动 HMR API。</h3><ul>
<li>必需的条件守卫<ul>
<li>确保用<code>一个条件语句</code>守护<code>所有 HMR API</code> 的使用<ul>
<li>if (import.meta.hot) { &#x2F;&#x2F; HMR 代码 }</li>
</ul>
</li>
</ul>
</li>
<li>TypeScript 的智能提示<ul>
<li>在 src 目录中创建env.d.ts，以便 TypeScript 获取类型定义：<ul>
<li><code>/// &lt;reference types=&quot;vite/client&quot; /&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>hot.accept(cb)：接收模块自身<ul>
<li>参数:接收已更新模块的回调函数：</li>
<li>“接受” 热更新的模块被认为是 HMR 边界。</li>
</ul>
</li>
<li>hot.accept(deps, cb)：接受直接依赖项的更新，而无需重新加载自身<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupSideEffect</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title function_">setupSideEffect</span>()</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./foo.js&#x27;</span>, <span class="function">(<span class="params">newFoo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调函数接收到更新后的&#x27;./foo.js&#x27; 模块</span></span><br><span class="line">    newFoo?.<span class="title function_">foo</span>()</span><br><span class="line">		<span class="comment">// 你可以使用新的模块实例来决定是否使其失效。</span></span><br><span class="line">		  <span class="keyword">if</span> (<span class="title function_">cannotHandleUpdate</span>(<span class="variable language_">module</span>)) &#123;</span><br><span class="line">		    <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">invalidate</span>()</span><br><span class="line">		  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 也可以接受一个依赖模块的数组：</span></span><br><span class="line">  <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(</span><br><span class="line">    [<span class="string">&#x27;./foo.js&#x27;</span>, <span class="string">&#x27;./bar.js&#x27;</span>],</span><br><span class="line">    <span class="function">(<span class="params">[newFooModule, newBarModule]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 回调函数接收一个更新后模块的数组</span></span><br><span class="line">    &#125;</span><br><span class="line">   )</span><br><span class="line">	<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">dispose</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 清理副作用</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>hot.dispose(cb)：<ul>
<li>一个接收自身的模块或一个期望被其他模块接收的模块可以使用 hot.dispose 来清除任何由其更新副本产生的持久副作用</li>
</ul>
</li>
<li>hot.prune(cb): 注册一个回调，当模块在页面上不再被导入时调用</li>
<li>hot.data：在同一个更新模块的不同实例之间持久化.将信息从模块的前一个版本传递到下一个版本</li>
<li>hot.decline()：目前是一个空操作并暂留用于向后兼容。</li>
<li>hot.invalidate():指明某模块是不可热更新的,建议在 accept 回调中调用 invalidate</li>
<li>hot.on(event, cb)：监听自定义 HMR 事件。以下事件自动触发：<ul>
<li>‘vite:beforeUpdate’ 当更新即将被应用时（例如，一个模块将被替换）</li>
<li>‘vite:afterUpdate’ 当更新已经被应用时<ul>
<li>‘vite:beforeFullReload’ 当完整的重载即将发生时</li>
</ul>
</li>
<li>‘vite:beforePrune’ 当不再需要的模块即将被剔除时</li>
<li>‘vite:invalidate’ 当使用import.meta.hot.invalidate()使一个模块失效时<ul>
<li>‘vite:error’ 当发生错误时（例如，语法错误）</li>
</ul>
</li>
</ul>
</li>
<li>hot.send(event, data)：发送自定义事件到 Vite 开发服务器。</li>
</ul>
<h3 id="Javascript-API-—-看手册"><a href="#Javascript-API-—-看手册" class="headerlink" title="Javascript API — 看手册"></a>Javascript API — 看手册</h3>
</article>
    
    

</div>
<div class="trm-post-next-prev row">
    <div class="col-lg-12">
        <!-- title -->
        <h5 class="trm-title-with-divider">
            其他文章
            <span data-number="02"></span>
        </h5>
    </div>
    
        <div class="col-lg-6">
    <div class="trm-older-publications-card trm-scroll-animation trm-active-el">
        <div class="trm-older-publication">
            
            <a class="trm-op-top trm-anima-link" href="/2024/11/01/Engineering/webpack--%E7%AC%AC%E4%BA%8C%E7%AF%87%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3/">
                <span class="trm-op-cover">
                    <img alt="cover" class="no-fancybox" src="/img/cover/cover-1.jpg">
                </span>
                <h6 class="trm-op-title">webpack --- 第二篇</h6>
            </a>
            <div class="trm-divider trm-mb-15 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>24/11/01</li>
                <li>16:52</li>
                <li>前端工程化工具</li>
            </ul>
        </div>
    </div>
</div>
    
    
        <div class="col-lg-6">
    <div class="trm-older-publications-card trm-scroll-animation trm-active-el">
        <div class="trm-older-publication">
            
            <a class="trm-op-top trm-anima-link" href="/2024/11/01/Engineering/Next/">
                <span class="trm-op-cover">
                    <img alt="cover" class="no-fancybox" src="/img/cover/cover-1.jpg">
                </span>
                <h6 class="trm-op-title">Next --- React 开发框架</h6>
            </a>
            <div class="trm-divider trm-mb-15 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>24/11/01</li>
                <li>16:52</li>
                <li>前端工程化工具</li>
            </ul>
        </div>
    </div>
</div>
    
</div>

    



                    <div class="trm-divider footer-divider"></div>

                    <!-- footer -->
                    <footer class="trm-footer-card trm-scroll-animation">

    

    
        <div class="trm-footer-item">
            <span>© 2024.10.30 - 2024</span>
            <span class="footer-separator"data-separator=" · "></span>
            <span class="trm-accent-color">UUOVO</span>
        </div>
    

    
        <div class="trm-footer-item">
            <span>
                由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0
            </span>
            <span class="footer-separator" data-separator=" | "></span>
            <span> 
                主题 - 
                <a rel="noopener" href='https://github.com/MaLuns/hexo-theme-async' target='_blank'>Async</a>
                v2.2.3
            </span>
        </div>
      

    
        <div class="trm-footer-item blog-run-long"></div>
     

     
</footer>
                    <!-- footer end -->

                </div>
            </div>
        </div>
    </div>
</div>
            <!-- body end -->

            

    <div id="post-toc" class="trm-post-toc">
      <div class="trm-post-toc-header">
        目录导航
				<span id="post-toc-top">
					置顶
				</span>
      </div>
      <div class="trm-post-toc-content">
        <ol class="trm-toc"><li class="trm-toc-item trm-toc-level-3" title="优点"><a rel="nofollow" class="trm-toc-link" href="#优点"><span class="trm-toc-number">1.</span> <span class="trm-toc-text">优点</span></a></li><li class="trm-toc-item trm-toc-level-3" title="组成部分"><a rel="nofollow" class="trm-toc-link" href="#组成部分"><span class="trm-toc-number">2.</span> <span class="trm-toc-text">组成部分</span></a></li><li class="trm-toc-item trm-toc-level-3" title="浏览器支持"><a rel="nofollow" class="trm-toc-link" href="#浏览器支持"><span class="trm-toc-number">3.</span> <span class="trm-toc-text">浏览器支持</span></a></li><li class="trm-toc-item trm-toc-level-3" title="创建应用"><a rel="nofollow" class="trm-toc-link" href="#创建应用"><span class="trm-toc-number">4.</span> <span class="trm-toc-text">创建应用</span></a></li><li class="trm-toc-item trm-toc-level-3" title="index.html与项目根目录"><a rel="nofollow" class="trm-toc-link" href="#index-html与项目根目录"><span class="trm-toc-number">5.</span> <span class="trm-toc-text">index.html与项目根目录</span></a></li><li class="trm-toc-item trm-toc-level-3" title="功能"><a rel="nofollow" class="trm-toc-link" href="#功能"><span class="trm-toc-number">6.</span> <span class="trm-toc-text">功能</span></a></li><li class="trm-toc-item trm-toc-level-3" title="插件"><a rel="nofollow" class="trm-toc-link" href="#插件"><span class="trm-toc-number">7.</span> <span class="trm-toc-text">插件</span></a></li><li class="trm-toc-item trm-toc-level-3" title="依赖预构建（仅会在开发模式下应用）"><a rel="nofollow" class="trm-toc-link" href="#依赖预构建（仅会在开发模式下应用）"><span class="trm-toc-number">8.</span> <span class="trm-toc-text">依赖预构建（仅会在开发模式下应用）</span></a></li><li class="trm-toc-item trm-toc-level-3" title="静态资源处理"><a rel="nofollow" class="trm-toc-link" href="#静态资源处理"><span class="trm-toc-number">9.</span> <span class="trm-toc-text">静态资源处理</span></a></li><li class="trm-toc-item trm-toc-level-3" title="构建生产版本: vite build"><a rel="nofollow" class="trm-toc-link" href="#构建生产版本-vite-build"><span class="trm-toc-number">10.</span> <span class="trm-toc-text">构建生产版本: vite build</span></a></li><li class="trm-toc-item trm-toc-level-3" title="部署静态站点"><a rel="nofollow" class="trm-toc-link" href="#部署静态站点"><span class="trm-toc-number">11.</span> <span class="trm-toc-text">部署静态站点</span></a></li><li class="trm-toc-item trm-toc-level-3" title="环境变量与模式"><a rel="nofollow" class="trm-toc-link" href="#环境变量与模式"><span class="trm-toc-number">12.</span> <span class="trm-toc-text">环境变量与模式</span></a></li><li class="trm-toc-item trm-toc-level-3" title="服务端渲染（SSR）"><a rel="nofollow" class="trm-toc-link" href="#服务端渲染（SSR）"><span class="trm-toc-number">13.</span> <span class="trm-toc-text">服务端渲染（SSR）</span></a></li><li class="trm-toc-item trm-toc-level-3" title="后端集成(自定义)"><a rel="nofollow" class="trm-toc-link" href="#后端集成-自定义"><span class="trm-toc-number">14.</span> <span class="trm-toc-text">后端集成(自定义)</span></a></li><li class="trm-toc-item trm-toc-level-3" title="插件API"><a rel="nofollow" class="trm-toc-link" href="#插件API"><span class="trm-toc-number">15.</span> <span class="trm-toc-text">插件API</span></a></li><li class="trm-toc-item trm-toc-level-3" title="客户端 HMR API ：通过 import.meta.hot 对象暴露手动 HMR API。"><a rel="nofollow" class="trm-toc-link" href="#客户端-HMR-API-：通过-import-meta-hot-对象暴露手动-HMR-API。"><span class="trm-toc-number">16.</span> <span class="trm-toc-text">客户端 HMR API ：通过 import.meta.hot 对象暴露手动 HMR API。</span></a></li><li class="trm-toc-item trm-toc-level-3" title="Javascript API — 看手册"><a rel="nofollow" class="trm-toc-link" href="#Javascript-API-—-看手册"><span class="trm-toc-number">17.</span> <span class="trm-toc-text">Javascript API — 看手册</span></a></li></ol>
      </div>
    </div>

            
<div class="trm-fixed-container">
    
        <div class="trm-fixed-btn post-toc-btn" data-title="目录">
            <i class="iconfont fas fa-th-list"></i>
        </div>
    
    
        <div class="trm-fixed-btn" data-title="阅读模式" onclick="asyncFun.switchReadMode()">
            <i class="iconfont fas fa-book-reader"></i>
        </div>
    
    
        <div class="trm-fixed-btn hidden-md" data-title="单栏和双栏切换" onclick="asyncFun.switchSingleColumn()">
            <i class="iconfont fas fa-arrows-alt-h"></i>
        </div>
    
    <div id="trm-back-top" class="trm-fixed-btn" data-title="回到顶部">
        <i class="iconfont fas fa-arrow-up"></i>
    </div>
</div>
        </div>
      </div>
      <!-- scroll container end -->
  </div>
  <!-- app wrapper end -->

  
    <div class="trm-search-popup">
        <div class="trm-search-wrapper">
            <div class="form trm-search-form">
                <div class="trm-search-input-icon">
                    <i class="iconfont fas fa-search"></i>
                </div>
                <input class="trm-search-input" type="text" placeholder="搜索文章...">
                <div class="trm-search-btn-close">
                    <i class="iconfont fas fa-times"></i>
                </div>
            </div>
            <div class="trm-search-result-container">
                <div class="trm-search-empty">
                    请输入关键词进行搜索
                </div>
            </div>
            <div class="trm-search-footer">
                <div class="trm-search-stats"></div>
                <ul class="trm-search-commands">
                    <li>
                        <kbd class="command-palette-commands-key">
                            <svg width="15" height="15" aria-label="Escape key" role="img">
                                <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
                                    stroke-width="1.2">
                                    <path
                                        d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956">
                                    </path>
                                </g>
                            </svg>
                        </kbd>
                        <span class="command-palette-Label">to close</span>
                    </li>
                </ul>
            </div>
        </div>
    </div>

  <!-- Plugin -->




    
    
<script src="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>

    
<script src="https://unpkg.com/swiper@4.5.1/dist/js/swiper.min.js"></script>


    
        <script src="/js/plugins/typing.js?v=2.2.3"></script>
    

    
        
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js"></script>

        <script src="/js/plugins/local_search.js?v=2.2.3"></script>
    

    <!-- 数学公式 -->
    

    <!-- 评论插件 -->
    
        

        
    

		
			<script src="/js/plugins/danmu.js?v=2.2.3"></script>
		




    <!-- Service Worker -->
    
    <!-- baidu push -->
    


<script id="async-script" src="/js/main.js?v=2.2.3"></script>

<!-- CDN -->


    

    

    



</body>

</html>