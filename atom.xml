<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-01T09:52:10.173Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lodash</title>
    <link href="http://example.com/2024/11/01/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Lodash/"/>
    <id>http://example.com/2024/11/01/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Lodash/</id>
    <published>2024-11-01T09:45:24.092Z</published>
    <updated>2024-11-01T09:52:10.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>只有存在node_modules，并且引入了lodash的内置插件包，才可以使用</p></blockquote><ul><li><h3 id="uniqueId-‘prefix’"><a href="#uniqueId-‘prefix’" class="headerlink" title="uniqueId(‘prefix’)"></a>uniqueId(‘prefix’)</h3><ul><li>返回的是一个带前缀的自增id</li></ul></li><li><h3 id="⭐-toPath-‘-6-4-f-45-5-f-2’"><a href="#⭐-toPath-‘-6-4-f-45-5-f-2’" class="headerlink" title="⭐ toPath(‘[6],4, [f[45[5]]],f,2’)"></a>⭐ toPath(‘[6],4, [f[45[5]]],f,2’)</h3><ul><li>把字符串里的属性返回成数组 ，适合两个深层数组合并，<code>对象不行</code></li></ul></li><li><h3 id="times-n-type-fn"><a href="#times-n-type-fn" class="headerlink" title="times(n, type | fn )"></a>times(n, type | fn )</h3><ul><li>默认返回一个调用了n次的index类型的数组</li></ul></li><li><h3 id="⭐-times-3-stubString"><a href="#⭐-times-3-stubString" class="headerlink" title="⭐ times(3, stubString)"></a>⭐ times(3, stubString)</h3><ul><li>结合times创建一个有长度且初始值为空的数组</li></ul></li><li><h3 id="rangeRight-start默认0-end-间隔"><a href="#rangeRight-start默认0-end-间隔" class="headerlink" title="rangeRight(start默认0, end, 间隔)"></a>rangeRight(start默认0, end, 间隔)</h3><ul><li>返回一个不包括end值的start到end值的范围内的新数字数组，且是<code>降序</code></li></ul></li><li><h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><ul><li>返回一个不包括end值的start到end值的范围内的新数字数组<code>升序</code>。</li></ul></li><li><h3 id="const-func-overSome-返回结果-func-1-21-5"><a href="#const-func-overSome-返回结果-func-1-21-5" class="headerlink" title="const func &#x3D; overSome([返回结果]);func([1,21,5])"></a>const func &#x3D; overSome([返回结果]);func([1,21,5])</h3><ul><li>返回的是带有返回条件的新函数</li></ul></li><li><h3 id="map-‘a-2-’-‘c-0-’-methodOf-object"><a href="#map-‘a-2-’-‘c-0-’-methodOf-object" class="headerlink" title="map([‘a[2]’, ‘c[0]’], methodOf(object))"></a>map([‘a[2]’, ‘c[0]’], methodOf(object))</h3><ul><li>通过map来调用methods上对象的方法，返回新的结果</li></ul></li><li><h3 id="constant-value"><a href="#constant-value" class="headerlink" title="constant(value)"></a>constant(value)</h3><ul><li>创建一个值，返回新的<code>常量函数</code></li></ul></li><li><h3 id="defaultTo-value-defaultValue"><a href="#defaultTo-value-defaultValue" class="headerlink" title="defaultTo(value, defaultValue)"></a>defaultTo(value, defaultValue)</h3><ul><li>如果value为NaN, null, 或者 undefined，那么返回defaultValue<code>默认值</code>。</li></ul></li><li><h3 id="pad-要填充的字符串-填充长度-填充的字符"><a href="#pad-要填充的字符串-填充长度-填充的字符" class="headerlink" title="pad(要填充的字符串, 填充长度, 填充的字符)"></a>pad(要<code>填充</code>的字符串, 填充长度, 填充的字符)</h3><ul><li>字符串长度小于填充长度左右平均填充，不平均截断超出的</li></ul></li><li><h3 id="chain-value"><a href="#chain-value" class="headerlink" title="chain(value)"></a><code>chain(value)</code></h3><ul><li><code>启用</code>显示链模式，<code>解除</code>用<code>value()</code></li></ul></li><li><h3 id="assign-object-source"><a href="#assign-object-source" class="headerlink" title="assign(object, [source])"></a>assign(object, [source])</h3><ul><li>有四个， 把<code>对象分配到目标</code>对象上</li></ul></li><li><h3 id="findKey-object-fn"><a href="#findKey-object-fn" class="headerlink" title="findKey(object ,fn)"></a>findKey(object ,fn)</h3><ul><li>在object上返回一个符合条件的的key（返回找到的第一个）</li></ul></li><li><h3 id="findLastKey-object-fn"><a href="#findLastKey-object-fn" class="headerlink" title="findLastKey(object ,fn)"></a>findLastKey(object ,fn)</h3><ul><li>在object上返回一个符合条件的的key（返回反方向找到的第一个）</li></ul></li><li><h3 id="for开头的遍历对象无法保证遍历顺序，-加In的标识遍历到原型上"><a href="#for开头的遍历对象无法保证遍历顺序，-加In的标识遍历到原型上" class="headerlink" title="for开头的遍历对象无法保证遍历顺序， 加In的标识遍历到原型上"></a>for开头的遍历对象无法保证遍历顺序， 加In的标识遍历到原型上</h3></li><li><h3 id="invert-object"><a href="#invert-object" class="headerlink" title="invert(object)"></a>invert(object)</h3><ul><li>返回一个键值倒置后的对象，如果有重复的值，后面的值会覆盖前面的值</li></ul></li><li><h3 id="castArray-value"><a href="#castArray-value" class="headerlink" title="castArray(value)"></a>castArray(value)</h3><ul><li>强制转为数组，返回转换后的数组</li></ul></li><li><h3 id="⭐-isEqual-value-other"><a href="#⭐-isEqual-value-other" class="headerlink" title="⭐ isEqual(value,other)"></a>⭐ isEqual(value,other)</h3><ul><li>执行深比较确定两者的值是否相等，不管是对象还是数组都可以比较，适用于判断是否编辑过</li></ul></li><li><h3 id="⭐-throttle-要节流的函数-wait-节流的毫秒，默认为0-options-节流"><a href="#⭐-throttle-要节流的函数-wait-节流的毫秒，默认为0-options-节流" class="headerlink" title="⭐ throttle(要节流的函数, [wait&#x3D;节流的毫秒，默认为0], [options&#x3D;]) 节流"></a>⭐ throttle(要节流的函数, [wait&#x3D;节流的毫秒，默认为0], [options&#x3D;]) 节流</h3><ul><li>options.leading &#x3D; true : 指定调用在节流开始前</li><li>options.trailing &#x3D; true : 指定调用在节流结束后</li></ul></li><li><h3 id="zip"><a href="#zip" class="headerlink" title="zip([],[],[])"></a>zip([],[],[])</h3><ul><li>将各个数组的相同的index提取出来组成一个新数组并返回</li></ul></li><li><h3 id="upzip"><a href="#upzip" class="headerlink" title="upzip()"></a>upzip()</h3><ul><li>还原，把zip后的数组还原回zip前的数组</li></ul></li><li><h3 id="zipWith-array-fn-unzipWith-array-fn"><a href="#zipWith-array-fn-unzipWith-array-fn" class="headerlink" title="zipWith(array, fn)&#x2F;unzipWith(array, fn)"></a>zipWith(array, fn)&#x2F;unzipWith(array, fn)</h3></li><li><h3 id="without-要检查的数组，要剔除的值"><a href="#without-要检查的数组，要剔除的值" class="headerlink" title="without(要检查的数组，要剔除的值)"></a>without(要检查的数组，要剔除的值)</h3><ul><li>返回过滤后的新数组</li></ul></li><li><h3 id="uniq-array"><a href="#uniq-array" class="headerlink" title="uniq(array)"></a>uniq(array)</h3><ul><li>返回一个去重后的新数组</li></ul></li><li><h3 id="用at方法读取尾元素-任意位置"><a href="#用at方法读取尾元素-任意位置" class="headerlink" title="用at方法读取尾元素&#x2F;任意位置"></a>用at方法读取尾元素&#x2F;任意位置</h3><ul><li>const array &#x3D; [ 1, 2, 3, 4, 5 ]</li><li>const lastEle &#x3D; array.at(-1) &#x2F;&#x2F; 5</li><li>const ele1 &#x3D; array.at(0) &#x2F;&#x2F; 1</li></ul></li><li><h3 id="pick-object-props"><a href="#pick-object-props" class="headerlink" title="pick(object, [props])"></a>pick(object, [props])</h3><ul><li>创建一个从object中选中的属性的对象<ul><li>const object &#x3D; {‘a’:1,’b’:2,’c’:3}</li><li>_.pick(object,[‘a’,c’’]) &#x3D;&#x3D;&gt; {‘a’:1,’c’:3}</li></ul></li></ul></li><li><h3 id="omit-object-props-反向版-pick"><a href="#omit-object-props-反向版-pick" class="headerlink" title="omit(object,[props]):反向版_.pick"></a>omit(object,[props]):反向版_.pick</h3><ul><li>_.omit(object,[‘a’,’c’]) &#x3D;&#x3D;&gt; {‘b’:’2’}</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;只有存在node_modules，并且引入了lodash的内置插件包，才可以使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;uniqueId-‘prefix’&quot;&gt;&lt;a href=&quot;#uniqueId-‘prefix’&quot; </summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>ESlint</title>
    <link href="http://example.com/2024/11/01/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/eslint/"/>
    <id>http://example.com/2024/11/01/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/eslint/</id>
    <published>2024-11-01T09:45:24.090Z</published>
    <updated>2024-11-01T09:47:15.097Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>js代码的检查工具</p></blockquote><ul><li>下载: npm i eslint -D</li><li>使用:<ul><li>生成配置文件 npx eslint –init</li><li>检查js文件   npx eslint 目录名</li></ul></li><li>命中的规则:<ul><li>字符串必须使用单引号<ul><li>语句结尾不能有分号</li></ul></li><li>文件的最后必须要有换行</li></ul></li></ul><h3 id="eslint结合git"><a href="#eslint结合git" class="headerlink" title="eslint结合git"></a>eslint结合git</h3><ul><li>husky: 哈士奇, 为Git仓库设置钩子程序</li><li>使用<ul><li>在仓库初始化完毕之后再去安装哈士奇</li><li>在package.json文件写配置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;husky&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;pre-commit&quot;</span>: <span class="string">&quot;npm run lint&quot;</span>   </span><br><span class="line">    <span class="comment">// 在git commit之前一定要通过npm run lint的检查</span></span><br><span class="line">    <span class="comment">// 只有npm run lint不报错时 commit才能真正的运行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;js代码的检查工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;下载: npm i eslint -D&lt;/li&gt;
&lt;li&gt;使用:&lt;ul&gt;
&lt;li&gt;生成配置文件 npx eslint –init&lt;/li&gt;
&lt;li&gt;检查js文件   npx </summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Babel</title>
    <link href="http://example.com/2024/11/01/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/babel/"/>
    <id>http://example.com/2024/11/01/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/babel/</id>
    <published>2024-11-01T09:45:24.087Z</published>
    <updated>2024-11-01T09:48:18.135Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://babel.docschina.org/docs/en/">Babel</a></p><blockquote><p>一个Javascript compiler<br>一个工具链，主要用于在当前和就的浏览器或环境中，将ES2015+转换为Javascript 向后兼容版本的代码</p></blockquote><ul><li>转换语法</li><li>源代码转换</li><li>Polyfill目标环境中缺少的功能</li><li>可以转换JSX</li><li>删除类型注释(可以安装 Flow preset 和 Typescript preset 来做类型检查)<ol><li>flow preset – js的静态类型检查器<br>  安装 ：npm install –save-dev @babel&#x2F;preset-flow<br> 使用 ：const square &#x3D; (n: number) : number &#x3D;&gt; n * n</li><li>typescript preset – ts的静态类型检查器<br> 安装 ：npm install –save-dev @babel&#x2F;preset-typescript<br> 使用 ：const Greeter(greeting: string) { this.greeting &#x3D; greeting }</li></ol></li><li>可以插件化</li><li>可调试 – 支持Source map</li><li>遵循ECMAScript标准</li><li>可压缩 – 提供assumptions选项</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;a href=&quot;https://babel.docschina.org/docs/en/&quot;&gt;Babel&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个Javascript compiler&lt;br&gt;一个工具链，主要用于在当前和就的浏览器或环境中，将ES2015+转换</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>配置文件</title>
    <link href="http://example.com/2024/11/01/Engineering/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2024/11/01/Engineering/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2024-11-01T08:52:16.774Z</published>
    <updated>2024-11-01T09:43:49.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tsconfig-json的配置文件"><a href="#tsconfig-json的配置文件" class="headerlink" title="tsconfig.json的配置文件"></a>tsconfig.json的配置文件</h3><ul><li>compileOnSave: true,让IDE在保存文件的时候根据tsconfig.json重新生成文件。</li><li>compilerOptions: 编译选项，可以被忽略，有默认值<ul><li>allowJs：默认为false，是否支持js&#x2F;.jsx文件</li><li>typeRoots: 默认编译所有@types包，编译指定typeRoots下的所有@types包</li><li>types：只有被列出来的包才会被包含，指定types来禁用自动引入@types包</li><li>其余选项请看文档<a href="https://typescript.bootcss.com/compiler-options.html">https://typescript.bootcss.com/compiler-options.html</a></li></ul></li><li>files：指定一个包含相对或绝对文件路径的列表,且总是会被包含在内，exclude设置无效</li><li>outDir: 指定的目录下的文件永远会被编译器排除，除非明确地使用”files”将其包含进来</li><li>include: 包含编译的文件\   &#x2F; *：匹配0&#x2F;n个字符</li><li><pre><code>                   &#125;指定一个文件的glob匹配模式列表&#123;  ?：匹配一个任意字符</code></pre></li><li>exclude: 排除编译的文件&#x2F;                              \ **&#x2F;：递归匹配任意子目录<br>     默认排除 node_modules，bower_components，jspm_packages和<outDir>目录</li><li>给路径配置别名：<ul><li>首先给属性baseUrl: “.”,</li><li>其次在属性paths中配置</li><li>注意：在配置时要注意给&#x2F;*，才可以获取对应文件夹下的文件，一般ts提示飘红，很可能问题出在这</li><li>示例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span>,</span><br><span class="line"><span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line"><span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;@/*&quot;</span>: [<span class="string">&quot;src/*&quot;</span>],</span><br><span class="line"><span class="string">&quot;@component/*&quot;</span>: [<span class="string">&quot;component/*&quot;</span>],</span><br><span class="line"><span class="string">&quot;@utils/*&quot;</span>: [<span class="string">&quot;utils/*&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="webpack-配置文件"><a href="#webpack-配置文件" class="headerlink" title="webpack 配置文件"></a>webpack 配置文件</h3><ul><li>概念<ul><li>静态模块打包工具，处理应用程序时会在内部从一个或多个入口点构建一个依赖图，将项目中所需的每一个模块组合成一个或多个bundles，这些均为静态资源，用于展示内容。</li></ul></li><li>原理<ul><li>模块捆绑器： 将小块代码编译成更大更复杂的代码，运行在web浏览器</li></ul></li><li>核心<ul><li>入口(entry)、输出(output)、loader、插件(plugin)、模式(mode)、浏览器兼容(browser compatibility)、环境(environment)</li></ul></li><li>模块（模块的离散功能块）<ul><li>每个模块的表面积都比完整程序小，这使得验证、调试和测试变得微不足道。编写良好的模块提供了坚实的抽象和封装边界，因此每个模块在整个应用程序中都具有连贯的设计和明确的目的。</li></ul></li></ul><h3 id="sass-at-rules"><a href="#sass-at-rules" class="headerlink" title="sass at-rules"></a>sass at-rules</h3><ul><li>@use “sass:color” 基于现有颜色生成新颜色<ul><li>参数：<ul><li>color.red() 用于获取颜色的红色通道</li><li>color.green() 用于获取颜色的绿色通道</li><li>color.blue() 用于获取颜色的蓝色通道</li><li>color.hue() 用于获取颜色的色调</li><li>color.saturation() 用于获取颜色的饱和度</li><li>color.lightness() 用于获取颜色的亮度</li><li>color.whiteness() 用于获取颜色的白度</li><li>color.blackness() 用于获取颜色的黑度</li><li>color.alpha() 用于获取颜色的 alpha 通道</li></ul></li><li>方法：<ul><li>color.scale() 流畅地缩放的一个或多个属性(不包含本身)</li><li>color.change() 将颜色的一个或多个属性设置为新值。返回的是颜色值</li><li>color.adjust() 按固定量增加或减少一个或多个属性</li><li>透明度：<ul><li>color.scale()</li><li>color.adjust($color，$alpha：-$amount)（保留现有行为）</li></ul></li></ul></li></ul></li><li>@mixin<ul><li>跟@include在一起使用的时候可以把多个样式放在一起。</li><li>跟@each在一起使用搭配变量遍历meta.keywords(参数)</li><li>跟@content在一起，定义整个样式的基调，相当于样式的插槽</li><li>跟@media在一起，只有媒体查询的结果符合时，才会应用这一块内容</li></ul></li><li>@extend 继承<ul><li>selector.unify()： 函数返回一个与两个选择器的交集匹配的选择器</li><li>selector.extend()： 与@extend相似，用于单选择器</li><li>占位符选择器%： 仅用于扩展的样式规则</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;tsconfig-json的配置文件&quot;&gt;&lt;a href=&quot;#tsconfig-json的配置文件&quot; class=&quot;headerlink&quot; title=&quot;tsconfig.json的配置文件&quot;&gt;&lt;/a&gt;tsconfig.json的配置文件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="webpack" scheme="http://example.com/categories/webpack/"/>
    
    <category term="前端工程化工具" scheme="http://example.com/categories/webpack/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>埋点</title>
    <link href="http://example.com/2024/11/01/Engineering/%E5%9F%8B%E7%82%B9/"/>
    <id>http://example.com/2024/11/01/Engineering/%E5%9F%8B%E7%82%B9/</id>
    <published>2024-11-01T08:52:16.760Z</published>
    <updated>2024-11-01T09:43:08.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端监控"><a href="#前端监控" class="headerlink" title="前端监控"></a>前端监控</h3><ul><li>发现问题和解决问题</li><li>做产品的决策依据</li><li>提高技术的深度与广度</li></ul><h2 id="监控目标"><a href="#监控目标" class="headerlink" title="监控目标"></a>监控目标</h2><ul><li><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul><li>js错误：js执行错误或promise异常</li><li>资源异常：script、link等资源加载异常</li><li>接口错误：ajax或fetch请求接口异常</li><li>白屏：页面空白</li></ul></li><li><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><ul><li>加载时间：各个阶段的加载时间</li><li>TTFB首字节时间：浏览器发起第一个请求到数据返回第一个字节所消耗的时间，这个是时间包含了网络请求、后端处理时间</li><li>FP首次绘制：包括了任何用户自定义的背景绘制，它是将第一个像素点绘制到屏幕的时间</li><li>FCP首次内容绘制：浏览器将第一个DOM渲染到屏幕的时间，可以是任何文本、图像、SVG等的时间</li><li>FMP首次有意义的绘制：页面可用性的标准</li><li>FID首次输入延迟：用户首次和页面交互到页面响应交互的时间</li><li>卡顿：超过50ms的长任务</li></ul></li><li><h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><ul><li>PV：page view 即页面浏览器会点击量</li><li>UV：指访问某个站点的不同IP地址的人数</li><li>页面的停留时间： 用户在每一个页面的停留时间</li></ul></li></ul><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><ul><li>埋点 –&gt; 数据采集(前端做到这就行，后面交给阿里云) –&gt;  (阿里云日志服务)数据建模存储 –&gt; 数据传输(实时&#x2F;批量) –&gt; 数据统计(分析&#x2F;挖掘) –&gt;  支线一数据可视化(反馈) –&gt;  支线二报告与报警</li></ul><h3 id="直接接入现成的："><a href="#直接接入现成的：" class="headerlink" title="直接接入现成的："></a>直接接入现成的：</h3><ul><li>sentry <a href="https://docs.sentry.io/">https://docs.sentry.io/</a></li><li>fundebug <a href="https://www.fundebug.com/">https://www.fundebug.com/</a></li></ul><h2 id="常见的埋点方案"><a href="#常见的埋点方案" class="headerlink" title="常见的埋点方案"></a>常见的埋点方案</h2><ul><li><h3 id="代码埋点"><a href="#代码埋点" class="headerlink" title="代码埋点"></a>代码埋点</h3><ul><li>以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时，插入一段代码，保存这个监听行为或者直接监听行为以某一种数据格式直接传递给服务器端</li><li>优点： 在任意时刻，精确的发送或保存所需要的数据信息</li><li>缺点：工作量较大</li></ul></li><li><h3 id="可视化埋点"><a href="#可视化埋点" class="headerlink" title="可视化埋点"></a>可视化埋点</h3><ul><li>将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等，最后输出的代码耦合了业务代码和埋点代码</li><li>本质：用系统代替手工插入埋点代码</li></ul></li><li><h3 id="无痕埋点"><a href="#无痕埋点" class="headerlink" title="无痕埋点"></a>无痕埋点</h3><ul><li>前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来<ul><li>通过定期上传记录文件，配合文件解析，解析出来外面响应的数据，并生成可视化报告供专业人员分析</li><li>优点：采集全量数据，不会出现漏埋和误埋现象</li><li>缺点： 给数据传输和服务器增加压力，也无法灵活定制数据结构<br><a href="https://juejin.cn/post/7094899430356156446">埋点部署</a></li></ul></li></ul></li></ul><h3 id="sdk需要监控什么？"><a href="#sdk需要监控什么？" class="headerlink" title="sdk需要监控什么？"></a>sdk需要监控什么？</h3><ul><li>错误统计</li><li>行为日志埋点</li><li>PV&#x2F;UV统计</li></ul><h3 id="sdk功能拆分"><a href="#sdk功能拆分" class="headerlink" title="sdk功能拆分"></a>sdk功能拆分</h3><ol><li>参数注入</li><li>sdk初始化</li><li>pv统计、uv统计、用户埋点统计、错误监控、全局配置</li></ol><h3 id="同步错误：可以被try-catch捕获"><a href="#同步错误：可以被try-catch捕获" class="headerlink" title="同步错误：可以被try&#x2F;catch捕获"></a>同步错误：可以被try&#x2F;catch捕获</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;button </span><br><span class="line">onClick = &#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;tongbucuowu&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nam)</span><br><span class="line">&#125;<span class="keyword">catch</span>(error) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----同步错误----&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line">&gt;同步错误&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="异步错误：无法被try-catch捕获，可以使用window-onerror处理"><a href="#异步错误：无法被try-catch捕获，可以使用window-onerror处理" class="headerlink" title="异步错误：无法被try&#x2F;catch捕获，可以使用window.onerror处理"></a>异步错误：无法被try&#x2F;catch捕获，可以使用window.onerror处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;button </span><br><span class="line">onClick = &#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;yibucuowu&#x27;</span></span><br><span class="line">name.<span class="title function_">map</span>()</span><br><span class="line">&#125;<span class="keyword">catch</span>(error) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----异步错误----&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line">&gt;异步错误&lt;/button&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">mas,url,roe, col, error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="promise-错误："><a href="#promise-错误：" class="headerlink" title="promise 错误："></a>promise 错误：</h3><ul><li>window.onerror处理不了，可以使用catch捕获或者监听unhandledrejection事件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unhandledrejection&#x27;</span>, <span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异常&#x27;</span>,error)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="资源加载错误"><a href="#资源加载错误" class="headerlink" title="资源加载错误"></a>资源加载错误</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异常&#x27;</span>，error)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="error与onerror的区别"><a href="#error与onerror的区别" class="headerlink" title="error与onerror的区别"></a>error与onerror的区别</h3><ul><li>error: 可以写多个</li><li>onerror：只能写一个，后者会覆盖前者</li></ul><h3 id="手动捕获"><a href="#手动捕获" class="headerlink" title="手动捕获"></a>手动捕获</h3><ul><li>手动埋点：在回调函数中手动调用tracker函数</li><li>属性埋点：没有回调函数，直接在属性上传值，可获取到，改属性是定义函数时指定的</li><li>自动埋点（无痕埋点）：没有回调也没有属性设置值，就会获取元素的dom，不直观，交互存储压力大</li></ul><h3 id="pv统计："><a href="#pv统计：" class="headerlink" title="pv统计："></a>pv统计：</h3><ul><li>SPA应用之前只需要监听onload事件</li><li>SPA应用中分为hash路由和history路由</li></ul><h3 id="history路由："><a href="#history路由：" class="headerlink" title="history路由："></a>history路由：</h3><ul><li>主要依赖pushState和replaceState来实现，但这两种方法被popstate监听到，所以要重写</li><li>history.pushState(): 添加新的历史记录</li><li>history.replaceState(): 修改当前的记录项</li><li>history.back():返回上一页，回退</li><li>history.forward():前进一页，前进</li><li>history.go():调账到历史记录中的某一页</li><li>监听这一页的停留时间：监听到下一页进入的时间 - 进入这一页的时间</li><li>监听那一夜的停留时间，记录上一页的路径</li></ul><h3 id="hash路由：监听hashchange和重写replaceState"><a href="#hash路由：监听hashchange和重写replaceState" class="headerlink" title="hash路由：监听hashchange和重写replaceState"></a>hash路由：监听hashchange和重写replaceState</h3><h3 id="uv统计用户数量-统计uid，在初始化时只进行上报，其余有服务端处理"><a href="#uv统计用户数量-统计uid，在初始化时只进行上报，其余有服务端处理" class="headerlink" title="uv统计用户数量 统计uid，在初始化时只进行上报，其余有服务端处理"></a>uv统计用户数量 统计uid，在初始化时只进行上报，其余有服务端处理</h3><ul><li>fetch上报会有数据丢失，sendBeacon无数据丢失</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前端监控&quot;&gt;&lt;a href=&quot;#前端监控&quot; class=&quot;headerlink&quot; title=&quot;前端监控&quot;&gt;&lt;/a&gt;前端监控&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;发现问题和解决问题&lt;/li&gt;
&lt;li&gt;做产品的决策依据&lt;/li&gt;
&lt;li&gt;提高技术的深度与广度&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    <category term="前端工程化工具" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack迁移</title>
    <link href="http://example.com/2024/11/01/Engineering/webpack%E8%BF%81%E7%A7%BB/"/>
    <id>http://example.com/2024/11/01/Engineering/webpack%E8%BF%81%E7%A7%BB/</id>
    <published>2024-11-01T08:52:16.744Z</published>
    <updated>2024-11-01T09:39:40.697Z</updated>
    
    <content type="html"><![CDATA[<ul><li>webpack 3.0 到 4.0</li><li>webpack 4.0 到 5.0</li></ul><h2 id="v3-to-v4"><a href="#v3-to-v4" class="headerlink" title="v3 to v4"></a>v3 to v4</h2><ul><li>node.js 要更新到v6或更高</li><li>使用webpack需要安装脚手架</li><li>插件也需要更新</li><li>在配置添加mode选项。设置它为 ‘production’, ‘development’ or ‘无 (none)’</li><li>部分插件在对应的模式下已经集成，不需要配置</li><li>CommonsChunkPlugin 已被移除。可以使用 optimization.splitChunks 来代替</li><li>使用 import() 去加载非标准 ESM 时，其值已经被加载. 现在你需要通过 default 属性来得到 module.exports 中的取值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置的</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./non-esm.js&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">default</span>.<span class="title function_">sayHello</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用自定义 loader 去转化 .json 文件时，你需要更改模块中的 type，仍在使用的 json-loader 可从项目中移除。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/config\.json$/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;special-loader&#x27;</span>,</span><br><span class="line">     <span class="attr">type</span>: <span class="string">&#x27;javascript/auto&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li><li>module.loaders已被移除，并推荐使用 module.rules</li></ul><h2 id="v4-to-v5"><a href="#v4-to-v5" class="headerlink" title="v4 to v5"></a>v4 to v5</h2><ul><li>node.js 要更新到10.13.0 (LTS)或更高</li><li>全部升级到最新可用版本</li><li>移除所有废弃的特性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;webpack 3.0 到 4.0&lt;/li&gt;
&lt;li&gt;webpack 4.0 到 5.0&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;v3-to-v4&quot;&gt;&lt;a href=&quot;#v3-to-v4&quot; class=&quot;headerlink&quot; title=&quot;v3 to v4&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="webpack" scheme="http://example.com/categories/webpack/"/>
    
    <category term="前端工程化工具" scheme="http://example.com/categories/webpack/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack --- 第一篇</title>
    <link href="http://example.com/2024/11/01/Engineering/webpack--%E7%AC%AC%E4%B8%80%E7%AF%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2024/11/01/Engineering/webpack--%E7%AC%AC%E4%B8%80%E7%AF%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2024-11-01T08:52:16.737Z</published>
    <updated>2024-11-01T09:39:10.314Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>是JavaScript应用程序的静态模块打包器。当webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有模块打包成一个或多个bundle。</p></blockquote><ul><li><h3 id="四个核心概念：入口-entry-、输出-output-、loader、插件-plugins"><a href="#四个核心概念：入口-entry-、输出-output-、loader、插件-plugins" class="headerlink" title="四个核心概念：入口(entry)、输出(output)、loader、插件(plugins)"></a>四个核心概念：入口(entry)、输出(output)、loader、插件(plugins)</h3></li><li><h3 id="依赖自动收集"><a href="#依赖自动收集" class="headerlink" title="依赖自动收集"></a>依赖自动收集</h3><ul><li>自动构建并基于你所引用或导出的内容推断出依赖的图谱。</li></ul></li><li><h3 id="webpack优点"><a href="#webpack优点" class="headerlink" title="webpack优点"></a>webpack优点</h3><ul><li>可以打包你的 JavaScript 应用程序（支持 ESM 和 CommonJS）；</li><li>可以扩展为支持许多不同的静态资源；</li><li>关心性能和加载时间；</li><li>始终在改进或添加新功能。</li></ul></li></ul><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><blockquote><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p></blockquote><h3 id="默认值：-src-index-js。也可在webpack-config-js中的module-exports里面配置entry-指定一个或多个不同的入口起点"><a href="#默认值：-src-index-js。也可在webpack-config-js中的module-exports里面配置entry-指定一个或多个不同的入口起点" class="headerlink" title="默认值：.&#x2F;src&#x2F;index.js。也可在webpack.config.js中的module.exports里面配置entry,指定一个或多个不同的入口起点"></a>默认值：.&#x2F;src&#x2F;index.js。也可在webpack.config.js中的module.exports里面配置entry,指定一个或多个不同的入口起点</h3><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><ul><li>单个入口<ul><li>用法：entry: string | Array<string></li><li>示例：entry: ‘.&#x2F;path&#x2F;to&#x2F;my&#x2F;entry&#x2F;file.js’</li></ul></li><li>对象语法：定义入口的最可扩展方式<ul><li>用法：entry: {[entryChunkName: string]: string | [string]&gt;}</li></ul></li><li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">  <span class="attr">app</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">  <span class="attr">adminApp</span>: <span class="string">&#x27;./src/adminApp.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>描述入口的对象<ul><li>dependOn: 当前入口所依赖的入口。必须在该入口被加载前被加载。</li><li>filename: 指定要输出的文件名称。</li><li>import: 启动时需加载的模块。</li><li>library: 指定 library 选项，为当前 entry 构建一个 library。</li><li>runtime: 运行时 chunk 的名字。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时 chunk。</li><li>publicPath: 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共 URL 地址。</li></ul></li><li>常用场景<ul><li>分离应用程序(app)和第三方库(vendor)入口</li><li>多页面程序<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析：告诉webpack需要三个独立分离的依赖图</span></span><br><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">  <span class="attr">pageOne</span>: <span class="string">&#x27;./src/pageOne/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">pageTwo</span>: <span class="string">&#x27;./src/pageTwo/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">pageThree</span>: <span class="string">&#x27;./src/pageThree/index.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote><p>告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。只能有一个output</p></blockquote><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值:"></a>默认值:</h3><ul><li>.&#x2F;dist，也可在webpack.config.js中的module.exports里面配置output属性</li></ul><h3 id="配置方式："><a href="#配置方式：" class="headerlink" title="配置方式："></a>配置方式：</h3><ul><li>output最低要求是，将它的值设置为一个对象，然后给输出文件的文件名配置output.filename</li><li>多个入口起点：使用占位符(substitutions)来确保每个文件具有唯一的名称<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span>, <span class="comment">//写入到./dist/filename</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li>高阶进阶</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/home/proj/cdn/assets/[fullhash]&#x27;</span>,</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;https://cdn.example.com/assets/[fullhash]/&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// publicPath: &#x27;&#x27; 时，在运行时通过入口起点文件中的 __webpack_public_path__ 动态设置</span></span><br><span class="line">__webpack_public_path__ = myRuntimePublicPath;  </span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><blockquote><p>让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。</p></blockquote><h3 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h3><ul><li>test 属性，识别出哪些文件会被转换。</li><li>use 属性，表示进行转换时，应该使用哪个 loader。</li></ul><h3 id="安装对应的loader"><a href="#安装对应的loader" class="headerlink" title="安装对应的loader"></a>安装对应的loader</h3><ul><li>npm install –save-dev css-loader ts-loader</li></ul><h3 id="使用loader"><a href="#使用loader" class="headerlink" title="使用loader"></a>使用loader</h3><ul><li><h3 id="配置方式：-1"><a href="#配置方式：-1" class="headerlink" title="配置方式："></a>配置方式：</h3><ul><li>在webpack.config.js中的config里的module.exports里面的module配置rules，指定loader</li><li>例：rules:[{test:&#x2F;.css$&#x2F;,use:’css-loader’},]</li><li>loader执行顺序: 从右到左（或从上到下）地取值（evaluate）&#x2F;执行（execute）</li></ul></li><li><h3 id="内联方式：在每个import语句中显式指定loader"><a href="#内联方式：在每个import语句中显式指定loader" class="headerlink" title="内联方式：在每个import语句中显式指定loader"></a>内联方式：在每个import语句中显式指定loader</h3></li><li><h3 id="使用-前缀，将禁用所有已配置的normal-loader"><a href="#使用-前缀，将禁用所有已配置的normal-loader" class="headerlink" title="使用!前缀，将禁用所有已配置的normal loader"></a>使用!前缀，将禁用所有已配置的normal loader</h3><ul><li>import Styles from ‘!style-loader!css-loader?modules!.&#x2F;styles.css’;</li></ul></li><li><h3 id="使用-前缀，将禁用所有已配置的loader-preLoader-loader-postLoader"><a href="#使用-前缀，将禁用所有已配置的loader-preLoader-loader-postLoader" class="headerlink" title="使用!!前缀，将禁用所有已配置的loader(preLoader, loader, postLoader)"></a>使用!!前缀，将禁用所有已配置的loader(preLoader, loader, postLoader)</h3><ul><li>import Styles from ‘!!style-loader!css-loader?modules!.&#x2F;styles.css’;</li></ul></li><li><h3 id="使用-前缀，将禁用所有已配置的preLoader和loader，但是不禁用postLoaders"><a href="#使用-前缀，将禁用所有已配置的preLoader和loader，但是不禁用postLoaders" class="headerlink" title="使用-!前缀，将禁用所有已配置的preLoader和loader，但是不禁用postLoaders"></a>使用-!前缀，将禁用所有已配置的preLoader和loader，但是不禁用postLoaders</h3><ul><li>import Styles from ‘-!style-loader!css-loader?modules!.&#x2F;styles.css’;</li><li>选项可以传递查询参数，例如 ?key&#x3D;value&amp;foo&#x3D;bar，或者一个 JSON 对象，例如 ?{“key”:”value”,”foo”:”bar”}</li></ul></li><li><h3 id="loader-特性"><a href="#loader-特性" class="headerlink" title="loader 特性"></a>loader 特性</h3><ul><li>支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。</li><li>可以是同步的，也可以是异步的。</li><li>运行在 Node.js 中，并且能够执行任何操作。</li><li>除了通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。</li></ul></li><li><h3 id="解析loader"><a href="#解析loader" class="headerlink" title="解析loader"></a>解析loader</h3><ul><li>遵循标准模块解析规则。多数情况下，loader 将从模块路径加载（通常是从 npm install, node_modules 进行加载）</li><li>loader 模块会导出为一个函数，并且编写为 Node.js 兼容的 JavaScript。loader 通常被命名为 xxx-loader。</li></ul></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><blockquote><p>webpack的支柱功能，用于执行从打包优化和压缩，一直到重新定义环境中的变量的任务。具有apply方法的js对象。</p></blockquote><ul><li>注意：如果在插件中使用了 webpack-sources 的 package，请使用 require(‘webpack’).sources 替代 require(‘webpack-sources’)，以避免持久缓存的版本冲突。</li><li>用法<ul><li>配置方式:<br>在webpack.config.js中，首先需要require() 它，然后添加一个new实例到module.exports里的plugins数组<ul><li>const HtmlWebpackPlugin &#x3D; require(‘html-webpack-plugin’); &#x2F;&#x2F; 通过 npm 安装<br>- const webpack &#x3D; require(‘webpack’); &#x2F;&#x2F; 访问内置的插件</li><li>plugins: [new webpack.ProgressPlugin(), &#x2F;&#x2F;用于自定义编译过程中的进度报告</li><li>new HtmlWebpackPlugin({template: ‘.&#x2F;src&#x2F;index.html’})]</li></ul></li><li>Node API方式<ul><li>const webpack &#x3D; require(‘webpack’); &#x2F;&#x2F; 访问 webpack 运行时(runtime)</li><li>const configuration &#x3D; require(‘.&#x2F;webpack.config.js’);</li><li>let compiler &#x3D; webpack(configuration);</li><li>new webpack.ProgressPlugin().apply(compiler);</li><li>compiler.run(function (err, stats) {});</li></ul></li></ul></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote><p>webpack 的配置文件是 JavaScript 文件，文件内导出了一个 webpack 配置的对象。</p></blockquote><ul><li>应避免操作<ul><li>当使用 webpack CLI 工具时，访问 CLI 参数（应编写自己的 CLI 工具替代，或者使用 –env）</li><li>导出不确定的结果（两次调用 webpack 应产生相同的输出文件）</li><li>编写超长的配置（应将配置文件拆分成多个）</li></ul></li><li>基本配置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./foo.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;foo.bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>多个target: 可以将其导出为多个配置</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><blockquote><p>在模块化编程中，开发者将程序分解为功能离散的chunk，并称为模块</p></blockquote><ul><li>支持的模块类型<ul><li>ECMAScript 模块</li><li>CommonJS 模块</li><li>AMD 模块</li><li>Assets</li><li>WebAssembly 模块</li></ul></li></ul><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><ul><li>通过选择development或production其中一个，来设置mode参数，启用相应模式下的 webpack 内置的优化</li><li>配置方式: 在webpack.config.js中的module.exports里mode：’production’</li><li>也可以分别配置development和production的配置文件，然后启动时调用对应的文件即可</li></ul><h2 id="浏览器兼容及环境"><a href="#浏览器兼容及环境" class="headerlink" title="浏览器兼容及环境"></a>浏览器兼容及环境</h2><ul><li>支持所有符合 ES5 标准 的浏览器（不支持 IE8 及以下版本）</li><li>import() 和 require.ensure() 需要 Promise</li><li>旧版本浏览器还需要提前加载 polyfill。</li><li>Webpack 5 运行于 Node.js v10.13.0+ 的版本</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;是JavaScript应用程序的静态模块打包器。当webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有模块打包成一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3</summary>
      
    
    
    
    <category term="webpack" scheme="http://example.com/categories/webpack/"/>
    
    <category term="前端工程化工具" scheme="http://example.com/categories/webpack/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack --- 第四篇</title>
    <link href="http://example.com/2024/11/01/Engineering/webpack--%E7%AC%AC%E5%9B%9B%E7%AF%87%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2024/11/01/Engineering/webpack--%E7%AC%AC%E5%9B%9B%E7%AF%87%E5%8E%9F%E7%90%86/</id>
    <published>2024-11-01T08:52:16.729Z</published>
    <updated>2024-11-01T09:33:45.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>entry： 编译入口，webpack编译器点</li><li>compiler： 编译管理器，webpack启动后会创建compiler对象，该对象一直存活直到结束退出</li><li>compilation：<code>单次</code>编译过程的管理器，比如watch &#x3D; true时，<code>运行过程中只有一个compiler</code>，但<code>每次</code>文件<code>变更</code>触发重新编译时，就会<code>创建</code>一个<code>新的compilation</code></li><li>dependence: 依赖对象，webpack基于该类型记录模块间依赖关系</li><li>module：webpack<code>内部所有资源</code>都会以”module”对象形式存在，所有关于<code>资源的操作、转译、合并都是以&quot;module&quot;为基本单位</code>进行的</li><li>chunk：编译完成准备输出时，webpack会将<code>module</code>按特定的规则<code>组织成</code>一个一个的chunk，这些chunk某种程度上<code>跟最终输出一一对应</code></li><li>loader：资源内容转换器，实现从内容A转换B的转换器</li><li>plugin：<code>webpack``构建过程</code>中，会在特定的时机<code>广播</code>对应的<code>事件</code>，插件<code>监听</code>这些<code>事件</code>，在特定的时间点<code>介入</code>编译过程</li></ul><h2 id="webpack内部原理"><a href="#webpack内部原理" class="headerlink" title="webpack内部原理"></a>webpack内部原理</h2><h3 id="主要部分："><a href="#主要部分：" class="headerlink" title="主要部分："></a>主要部分：</h3><ul><li>项目中使用的每个文件都是一个模块，通过互相引用，这些模块会形成一个图数据结构。在打包过程中，模块会被合并成 chunk。 chunk 合并成 chunk 组，并形成一个通过模块互相连接的图。</li></ul><h3 id="chunk-："><a href="#chunk-：" class="headerlink" title="chunk ："></a>chunk ：</h3><ul><li>两种形式：<ol><li>initial(初始化) 是入口起点的 main chunk。此 chunk 包含为入口起点指定的所有模块及其依赖项。</li><li>non-initial 是可以延迟加载的块。可能会出现在使用 动态导入(dynamic imports) 或者 SplitChunksPlugin 时。</li><li>每个 chunk 都有对应的 asset(资源)。</li></ol></li></ul><h3 id="output-："><a href="#output-：" class="headerlink" title="output ："></a>output ：</h3><ul><li>输出文件的名称会受配置中的两个字段的影响：</li></ul><ol><li>output.filename - 用于 initial chunk 文件</li><li>output.chunkFilename - 用于 non-initial chunk 文件</li></ol><ul><li>在某些情况下，使用 initial 和 non-initial 的 chunk 时，可以使用 output.filename。</li><li>常用占位符：</li></ul><ol><li>[id] - chunk id（例如 [id].js -&gt; 485.js）</li><li>[name] - chunk name（例如 [name].js -&gt; app.js）。如果 chunk 没有名称，则会使用其 id 作为名称</li><li>[contenthash] - 输出文件内容的 md4-hash（例如 [contenthash].js -&gt; 4ea6ff1de66c537eb9b2.js）</li></ol><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><h3 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h3><ul><li>负责整体编译流程的Compiler对象、负责编译Module的Complication对象。</li><li><code>最核心的功能</code>：将各种类型的资源，转译、组合、拼接、生成 JS 格式的 <code>bundler 文件</code>。</li><li>这个过程核心完成了<code>内容转换 + 资源合并</code>两种功能, 三个阶段<ul><li><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul><li>初始化参数：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li><li>创建编译器对象：用上一步得到的参数创建 Compiler 对象</li><li>初始化编译环境：注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等</li><li>开始编译：执行 compiler 对象的 run 方法</li><li>确定入口：根据配置中的 entry 找出所有的入口文件，调用compilition.addEntry 将入口文件转换为 dependence 对象</li></ul></li><li><h3 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h3><ul><li>编译模块make：根据entry对应的dependence<code>创建module对象</code>，<code>调用loader</code>将模块<code>转译为</code>标准<code>js</code>内容，<code>调用js解释器</code>将内容转换为<code>AST对象</code>，从中<code>找</code>到该模块<code>依赖的模块</code>，在递归。处理全部入口文件</li><li>完成模块编译：通过上一步，得到每个模块<del><code>被翻译后的内容</code></del>以及它们之间的<code>依赖关系图</code></li></ul></li><li><h3 id="生成阶段"><a href="#生成阶段" class="headerlink" title="生成阶段"></a>生成阶段</h3><ul><li>输出资源seal：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>写入文件系统emitAssets：根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul></li></ul></li><li>参考<ul><li><a href="https://juejin.cn/post/6949040393165996040">webpack核心原理</a></li><li><a href="https://gitmind.cn/app/docs/m1foeg1o?view=outline">webpack5知识体系</a></li></ul></li></ul><h3 id="PLugin解析"><a href="#PLugin解析" class="headerlink" title="PLugin解析"></a>PLugin解析</h3><ul><li><h3 id="什么是插件？"><a href="#什么是插件？" class="headerlink" title="什么是插件？"></a>什么是插件？</h3><ul><li>从形态上看，插件通常是一个带有aplly函数的类 ，apply运行时会得到参数compiler，以此为起点调用hook</li></ul></li><li><h3 id="什么时候触发什么钩子？"><a href="#什么时候触发什么钩子？" class="headerlink" title="什么时候触发什么钩子？"></a>什么时候触发什么钩子？</h3><ul><li>compiler.hooks.compilation<ul><li>触发时机：启动编译创建出 compilation 对象后触发</li></ul><ul><li>传递参数：当前编译的 compilation 对象</li><li>示例：很多插件基于此事件获取 compilation 实例</li></ul></li></ul><ul><li>compiler.hooks.make<ul><li>触发时机：正式开始编译时触发</li><li>传递参数：同样是当前编译的 compilation 对象</li><li>示例：webpack 内置的 EntryPlugin 基于此钩子实现 entry 模块的初始化</li></ul></li><li>compilation.hooks.optimizeChunks<ul><li>触发时机：seal 函数中，chunk 集合构建完毕后触发</li><li>传递参数：chunks 集合与 chunkGroups 集合</li><li>示例：SplitChunksPlugin 插件基于此钩子实现 chunk 拆分优化</li></ul></li><li>compiler.hooks.done<ul><li>触发时机：编译完成后触发</li><li>传递参数：stats 对象，包含编译过程中的各类统计信息</li><li>示例：webpack-bundle-analyzer 插件基于此钩子实现打包分析</li></ul></li><li>compilation.seal函数内部有optimizeModules和afterOptimizeModules这两个钩子<ul><li>optimizeModules： 优化已经编译出的modules</li><li>afterOptimizeModules：用于通知优化行为的结束</li></ul></li><li>apply从设计上只有输入，webpack不关心输出，所以在插件中只能调用类型实体的方法或更改实体的配置信息，来变更编译行为</li></ul></li><li><h3 id="如何让影响编译状态？"><a href="#如何让影响编译状态？" class="headerlink" title="如何让影响编译状态？"></a>如何让影响编译状态？</h3><ul><li>hooks回调内部通过修改状态、调用上下文api等方式对webpack产生side effect</li><li>webpack会将上下文信息以参数或this（compiler对象）形式传递给钩子回调，在回调中可以调用上下文对象的方法或者直接修改上下文对象属性的方式，对原定流程产生side effect</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;entry： 编译入口，webpack编译器点&lt;/li&gt;
&lt;li&gt;compiler： 编译管理器，webpack启动后会创建co</summary>
      
    
    
    
    <category term="webpack" scheme="http://example.com/categories/webpack/"/>
    
    <category term="前端工程化工具" scheme="http://example.com/categories/webpack/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack --- 第三篇</title>
    <link href="http://example.com/2024/11/01/Engineering/webpack--%E7%AC%AC%E4%B8%89%E7%AF%87%E4%BA%86%E8%A7%A3Tapable/"/>
    <id>http://example.com/2024/11/01/Engineering/webpack--%E7%AC%AC%E4%B8%89%E7%AF%87%E4%BA%86%E8%A7%A3Tapable/</id>
    <published>2024-11-01T08:52:16.721Z</published>
    <updated>2024-11-01T09:30:11.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h2><blockquote><p>了解webpack Plugin之前应该掌握Tapable<br>在 Webpack 的编译过程中，本质上通过 Tapable 实现了在编译过程中的一种<code>发布订阅者模式</code>的插件 Plugin 机制。</p></blockquote><ul><li>Tapable提供了一系列时间的发布订阅者API，通过Tapable使用者可以注册事件，从而在不同实际去触发注册的事件进行执行</li><li>官方提供的九种钩子<ul><li>SyncHook</li><li>SyncBailHook</li><li>SyncWaterfallHook</li><li>SyncLoopHook</li><li>AsyncParallelHook</li><li>AsyncParallelBaiHook</li><li>AsyncSeriesHook</li><li>AsyncSeriesBailHook</li><li>AsyncSeriesWaterfallHook</li></ul></li><li>Tapable中所有注册的事件可以分为同步、异步两种执行方式<ul><li>同步表示注册的事件函数会同步进行执行(Sync前缀)</li><li>异步表示注册的事件函数会异步进行执行(Async前缀)<ul><li>异步串行钩子(AsyncSeries)：可以被串联（连续按照顺序调用）执行的异步钩子函数</li><li>异步并行钩子(AsyncParalle)：可以被并联（并发调用）执行的异步钩子函数</li></ul></li><li>针对<code>同步钩子</code>来<code>tap</code>方法是唯一的注册事件的方法，通过<code>call</code>方法调用执行</li><li>异步钩子可以通过tap、tapAsync、tapPromise三种方式来注册，通过对应的call、callAsync、promise三种方式来触发注册的函数</li></ul></li><li>Tapable 按照执行机制分类<ul><li>Basic Hook：基本类型钩子，仅执行钩子注册的事件，不关心被调用事件的返回值</li><li>Waterfall： 瀑布类型的钩子，会在注册事件执行时将事件函数执行非undefined的返回值传递给接下来的事件函数作为参数，其他的与基本类型钩子类似</li><li>Bail：保险类型钩子，在基础类型钩子上增加一个保险机制，如果<code>任意一个注册函数</code>执行<code>返回非undefined</code>的值，那么<code>整个钩子执行过程</code>会<code>立即中断</code>，之后的注册事件就不会调用</li><li>Loop: 循环类型钩子，通过 call 调用时，如果<code>任意一个注册的事件</code>函数<code>返回值非 undefeind</code> ,那么会<code>立即重头开始重新执行</code>所有的注册事件函数，<code>直到所有</code>被注册的事件函数都<code>返回 undefined</code>。</li></ul></li><li>示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">SyncHook</span>, <span class="title class_">SyncBailHook</span>, <span class="title class_">SyncWaterfallHook</span>,<span class="title class_">SyncWaterfallHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;tapable&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&#x27;arg1&#x27;</span>,<span class="string">&#x27;arg2&#x27;</span>,<span class="string">&#x27;arg3&#x27;</span>]) <span class="comment">// 这个就换钩子名，其他一样</span></span><br><span class="line"># <span class="title class_">SyncHook</span></span><br><span class="line"><span class="comment">// 初始化同步钩子</span></span><br><span class="line">重点：数组中对应的字符串个数</span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">▫️▪ 通过tap函数监听对应的事件，注册事件时接受两个参数：</span><br><span class="line">▫️▪ ️第一个参数是 <span class="string">`字符串 | 对象`</span>，<span class="string">`仅作标识`</span></span><br><span class="line">▫️▪ 第二个参数表示<span class="string">`本次注册的函数`</span>，在调用时会执行这个函数</span><br><span class="line">hook.<span class="title function_">tap</span>(<span class="string">&#x27;flag1&#x27;</span>,<span class="function">(<span class="params">arg1,arg2,arg3</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 调用事件并传递执行参数</span></span><br><span class="line">▫️▪ 通过call方法传入对应的参数，调用注册在hook内部的事件函数执行，同时将call方法<span class="string">`传入的参数`</span><span class="string">`传递`</span>给<span class="string">`每一个`</span>注册的<span class="string">`事件`</span>函数作为<span class="string">`实参`</span>进行调用</span><br><span class="line">hook.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"># <span class="title class_">SyncBailHook</span></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">hook.<span class="title function_">tap</span>(<span class="string">&#x27;flag1&#x27;</span>,<span class="function">(<span class="params">arg1,arg2,arg3</span>) =&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 存在返回值，阻断后面注册事件的调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//调用事件</span></span><br><span class="line">hook.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>参考<br>  <a href="https://juejin.cn/post/7040982789650382855">Tapable讲解</a></li><li>拦截器<ul><li>Tapable 提供的所有 Hook 都支持注入 Interception ，可以通过拦截器对整个Tapable发布&#x2F;订阅流程进行监听。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hook.<span class="title function_">intercept</span>(&#123;</span><br><span class="line">  <span class="comment">// 每次通过 tap、tapAsync、tapPromise 方法注册事件函数时，会触发 register 拦截器。</span></span><br><span class="line">  <span class="comment">// 并且接受 tap 作为参数, 还可以对注册事件进行修改;</span></span><br><span class="line">  <span class="attr">register</span>: <span class="function">(<span class="params">tapInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;tapInfo.name&#125;</span> is doing its job`</span>);</span><br><span class="line">    <span class="keyword">return</span> tapInfo</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 通过hook实例对象上的call方法时候触发拦截器，接受的参数为调用 Hook 时传入的参数。</span></span><br><span class="line">  <span class="attr">call</span>: <span class="function">(<span class="params">arg1, arg2, arg3</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在调用被注册的每一个事件函数之前执行，接受参数为对应的 Tap 对象。</span></span><br><span class="line">  <span class="attr">tap</span>: <span class="function">(<span class="params">tap</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// loop类型钩子中 每次重新开始 loop 之前会执行该拦截器，拦截器函数接受的参数为调用时传入的参数。</span></span><br><span class="line">  <span class="attr">loop</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li>API<ul><li>Before &amp;&amp; stage<ul><li>before 属性的值为数组 | 字符串,值为注册事件对象时的名称，它可以让当前事件在对应标识事件<code>前</code>执行。</li><li>stage 属性的值为数字，<code>数字越大</code>事件回调<code>执行的越晚</code>，支持传入负数，不传默认为0</li></ul></li><li>使用：在注册事件函数，第一个参数为对象时，在这个对象添加stage和before来控制本次注册事件的执行时机</li><li>如果同时使用 before 和 stage 时，优先会处理 before ，在满足 before 的条件之后才会进行 stage 的判断。不建议同时使用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hook.<span class="title function_">tap</span>(&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;flag1&#x27;</span></span><br><span class="line">&#125;,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">hook.<span class="title function_">tap</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;flag2&#x27;</span>,</span><br><span class="line"><span class="comment">// flag2 会在flag1前执行</span></span><br><span class="line"><span class="attr">before</span>:<span class="string">&#x27;flag1&#x27;</span></span><br><span class="line">&#125;,<span class="function">()=&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li><li>HookMap<ul><li>辅助类，管理Hook <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建HookMap实例</span></span><br><span class="line"><span class="keyword">const</span> keyedHook = <span class="keyword">new</span> <span class="title class_">HookMap</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&#x27;arg&#x27;</span>]));</span><br><span class="line"><span class="comment">// 在keyedHook中创建一个name为key1的hook，同时为该hook通过tap注册事件 </span></span><br><span class="line">keyedHook.<span class="title function_">for</span>(<span class="string">&#x27;key1&#x27;</span>).<span class="title function_">tap</span>(<span class="string">&#x27;Plugin 1&#x27;</span>, <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Plugin 1&#x27;</span>, arg);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 从HookMap中拿到name为key1的hook</span></span><br><span class="line"><span class="keyword">const</span> hook = keyedHook.<span class="title function_">get</span>(<span class="string">&#x27;key1&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (hook) &#123;</span><br><span class="line">  <span class="comment">// 通过call方法触发Hook</span></span><br><span class="line">  hook.<span class="title function_">call</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>MultiHook – 不常见</li><li>Context – 即将废弃</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Tapable&quot;&gt;&lt;a href=&quot;#Tapable&quot; class=&quot;headerlink&quot; title=&quot;Tapable&quot;&gt;&lt;/a&gt;Tapable&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;了解webpack Plugin之前应该掌握Tapable&lt;br&gt;在 We</summary>
      
    
    
    
    <category term="webpack" scheme="http://example.com/categories/webpack/"/>
    
    <category term="前端工程化工具" scheme="http://example.com/categories/webpack/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack --- 第二篇</title>
    <link href="http://example.com/2024/11/01/Engineering/webpack--%E7%AC%AC%E4%BA%8C%E7%AF%87%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3/"/>
    <id>http://example.com/2024/11/01/Engineering/webpack--%E7%AC%AC%E4%BA%8C%E7%AF%87%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3/</id>
    <published>2024-11-01T08:52:16.710Z</published>
    <updated>2024-11-01T09:28:37.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块解析"><a href="#模块解析" class="headerlink" title="模块解析"></a>模块解析</h2><blockquote><p>resolver 是一个帮助寻找模块绝对路径的库。一个模块可以作为另一个模块的依赖模块，然后被后者引用。<br>resolver 帮助 webpack 从每个 require&#x2F;import 语句中，找到需要引入到 bundle 中的模块代码。 </p></blockquote><ul><li>当打包模块时，webpack 使用 enhanced-resolve 来解析文件路径。</li><li>webpack 中的解析规则<ul><li>使用 enhanced-resolve，webpack 能解析三种文件路径：<ul><li>绝对路径：import ‘&#x2F;home&#x2F;me&#x2F;file’;</li><li>相对路径：import ‘..&#x2F;src&#x2F;file1’;</li><li>模块路径：import ‘module&#x2F;lib&#x2F;file’;</li></ul></li></ul></li><li>在 resolve.modules 中指定的所有目录中检索模块。可以通过配置别名的方式来替换初始模块路径。</li><li>如果 package 中包含 package.json 文件，那么在 resolve.exportsFields 配置选项中指定的字段会被依次查找，package.json 中的第一个字段会根据 package 导出指南确定 package 中可用的 export。<ul><li>如果路径指向文件：<ul><li>如果文件具有扩展名，则直接将文件打包。</li><li>否则，将使用 resolve.extensions 选项作为文件扩展名来解析。</li></ul></li><li>如果路径指向文件夹，则寻找具有正确扩展名的文件：<ul><li>如果文件夹中包含 package.json 文件，则会根据 resolve.mainFields 配置中的字段顺序查找，并根据 package.json 中的符合配置要求的第一个字段来确定文件路径。</li><li>如果不存在 package.json 文件或 resolve.mainFields 没有返回有效路径，则会根据 resolve.mainFiles 配置选项中指定的文件名顺序查找，看是否能在 import&#x2F;require 的目录下匹配到一个存在的文件名。</li><li>然后使用 resolve.extensions 选项，以类似的方式解析文件扩展名。</li></ul></li></ul></li><li>解析loader<ul><li>resolveLoader 配置项可以为 loader 设置独立的解析规则。</li></ul></li><li>缓存<ul><li>每次文件系统访问文件都会被缓存，以便于更快触发对同一文件的多个并行或串行请求。在 watch 模式下，只有修改过的文件会被从缓存中移出。如果关闭 watch 模式，则会在每次编译前清理缓存</li></ul></li></ul><h2 id="Module-Federation"><a href="#Module-Federation" class="headerlink" title="Module Federation"></a>Module Federation</h2><blockquote><p>可以实现多个独立 Weppack 构建之间的共享模块和代码。它通过让每个构建的应用程序能够使用其他应用程序中的模块来提高代码共享和复用的效率。<br>多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。这通常被称作微前端。</p></blockquote><ul><li><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>基于 webpack的远程容器特性，允许将一个应用程序的某些模块打包为一个独立的、可远程加载的bundle，并在运行时动态加载这些模块。</li></ul></li><li><h3 id="主要优势"><a href="#主要优势" class="headerlink" title="主要优势"></a>主要优势</h3><ul><li>多个应用程序之间可以共享代码和模块，从而<code>减少重复代码量</code></li><li>应用程序可以更加灵活地划分为更小的子应用程序，从而<code>降低应用程序的复杂度</code></li><li>可以避免在应用程序之间传递大量数据，从而<code>提高应用程序的性能和效率</code></li><li>可以支持应用程序的动态加载和升级，从而实现<code>更好的版本管理和迭代</code></li></ul></li><li>底层概念<ul><li>区分本地模块和远程模块。</li><li>本地模块即为普通模块，是当前构建的一部分。</li><li>远程模块不属于当前构建，并在运行时从所谓的容器加载。</li><li>加载远程模块被认为是异步操作。当使用远程模块时，这些异步操作将被放置在远程模块和入口之间的下一个 chunk 的加载操作中。如果没有 chunk 加载操作，就不能使用远程模块。</li><li>chunk 的加载操作通常是通过调用 import() 实现的，但也支持像 require.ensure 或 require([…]) 之类的旧语法。</li><li>容器是由容器入口创建的，该入口暴露了对特定模块的异步访问。<ul><li>容器可以嵌套使用</li><li>容器可以使用来自其他容器的模块。</li><li>容器之间也可以循环依赖。</li></ul></li><li>暴露的访问分为两个步骤：<br>  加载模块（异步的）：将在 chunk 加载期间完成<br>  执行模块（同步的）：将在与其他（本地和远程）的模块交错执行期间完成</li></ul></li><li>高级概念<ul><li>每个构建都充当一个容器，也可将其他构建作为容器。</li><li>共享模块是指既可重写的又可作为向嵌套容器提供重写的模块。它们通常指向每个构建中的相同模块。</li><li>packageName 选项允许通过设置包名来查找所需的版本。默认情况下，它会自动推断模块请求，当想禁用自动推断时，请将 requiredVersion 设置为 false 。</li></ul></li><li>构建块<ul><li>ContainerPlugin：使用指定的公开模块来创建一个额外的容器入口。</li><li>ContainerReferencePlugin：将特定的引用添加到作为外部资源（externals）的容器中，并允许从这些容器中导入远程模块。它还会调用这些容器的 override API 来为它们提供重载。本地的重载（当构建也是一个容器时，通过 <strong>webpack_override</strong> 或 override API）和指定的重载被提供给所有引用的容器。</li><li>ModuleFederationPlugin：组合了ContainerPlugin和ContainerReferencePlugin</li></ul></li><li>概念目标<ul><li>既可以暴露，又可以使用 webpack 支持的任何模块类型</li><li>代码块加载应该并行加载所需的所有内容(web:到服务器的单次往返)</li><li>从使用者到容器的控制<ul><li>重写模块是一种单向操作</li><li>同级容器不能重写彼此的模块。</li></ul></li><li>概念适用于独立于环境</li><li>共享中的相对和绝对请求<ul><li>会一直提供，即使不使用</li><li>会将相对路径解析到 config.context</li><li>默认不会使用 requiredVersion</li></ul></li><li>共享中尾部带有 &#x2F;  的模块请求将匹配所有具有这个前缀的模块请求</li><li>共享中的模块请求<ul><li>只在使用时提供，并且提供所有匹配模块</li><li>会匹配构建中所有使用的相等模块请求</li><li>将从图中这个位置的 package.json 提取 requiredVersion</li><li>当你有嵌套的 node_modules 时，可以提供和使用多个不同的版本</li></ul></li></ul></li><li>用例<ul><li>每个页面单独构建<ul><li>可以单独部署每个页面。</li><li>在更新路由或添加新路由时部署主体应用程序。</li><li>单页应用的每个页面都是在单独的构建中从容器暴露出来的。</li><li>主体应用程序将常用库定义为共享模块，以避免在页面构建中出现重复。</li><li>主体应用程序(application shell)也是独立构建，会将所有页面作为远程模块来引用。</li></ul></li><li>将组件库作为容器<ul><li>可以单独部署对组件库的更改。</li><li>应用程序自动使用组件库的最新版本。</li><li>每个应用程序使用来自组件库容器的组件。</li><li>许多应用程序共享一个通用的组件库，将其构建成暴露所有组件的容器。</li></ul></li></ul></li><li>动态远程容器<ul><li>支持 get 和 init 方法。</li><li>init 是一个兼容 async 的方法，调用时，只含有一个参数：共享作用域对象(shared scope object)。此对象在远程容器中用作共享作用域，并由 host 提供的模块填充。可以利用它在运行时动态地将远程容器连接到 host 容器。<ul><li>容器尝试提供共享模块，但是如果共享模块已经被使用，则会发出警告，并忽略所提供的共享模块。容器仍能将其作为降级模块。</li><li>在尝试动态连接远程容器之前，确保已加载容器。</li><li>通过动态加载的方式，提供一个共享模块的不同版本，从而实现 A&#x2F;B 测试。</li></ul></li><li>基于Promise的动态Remote<ul><li>向 remote 传递一个 promise，其会在运行时被调用。</li><li>当使用该 API 时，必须 resolve 一个包含 get&#x2F;init API 的对象。</li></ul></li></ul></li><li>动态Public Path<ul><li>提供一个 host api 来设置 publicPath</li><li>场景：<br>在 <a href="https://my-host.com/app/">https://my-host.com/app/</a>* 上有一个 host 应用，并且在 <a href="https://foo-app.com/">https://foo-app.com</a> 上有一个子应用。子应用程序也挂载在 host 域上, 因此， <a href="https://foo-app.com/">https://foo-app.com</a> 可以通过 <a href="https://my-host.com/app/foo-app">https://my-host.com/app/foo-app</a> 访问，并且可以通过代理重定向到 <a href="https://foo-app.com/*%E3%80%82">https://foo-app.com/*。</a></li><li>从脚本推断公共路径并在运行时使用 <code>__webpack_public_path__module</code> 变量对其进行设置。</li></ul></li><li>故障排除<ul><li>Uncaught Error: Shared module is not available for eager consumption<ul><li>问题：应用程序正急切地执行一个作为全局主机运行的应用程序</li><li>解决：在模块联邦的高级 API 中将依赖设置为即时依赖</li></ul></li><li>Uncaught Error: Module “.&#x2F;Button” does not exist in container.<ul><li>问题：将 webpack beta.16 升级到 webpack beta.17 中</li><li>解决：在 ModuleFederationPlugin 里，更改 exposes，在Button加上.&#x2F;‘.&#x2F;Button’:’.&#x2F;src&#x2F;Button’</li></ul></li><li>Uncaught TypeError: fn is not a function<ul><li>问题：丢失了远程容器，或加载了容器</li><li>解决：使用前添加容器，或需将主机容器的远程容器文件也添加到 HTML 中</li></ul></li><li>来自多个 remote 的模块之间的冲突<ul><li>解决：加载多个模块，建议为你的远程构建设置output.uniqueName</li></ul></li></ul></li></ul><h2 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h2><blockquote><p>每当一个文件依赖另一个文件时，webpack 都会将文件视为直接存在依赖关系。当 webpack 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。 从入口开始，webpack 会递归的构建一个 依赖关系图，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 bundle通常只有一个可由浏览器加载。</p></blockquote><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><ul><li>用法：在 webpack 配置中设置 target 字段</li><li>每个 target 都包含各种 deployment（部署）&#x2F;environment（环境）特定的附加项，以满足其需求</li><li>多target：通过设置两个独立配置，来构建对 library 进行同构</li></ul><h2 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h2><blockquote><p>当 compiler 开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。这个数据集合称为 “manifest”，当完成打包并发送到浏览器时，runtime 会通过 manifest 来解析和加载模块。</p></blockquote><ul><li>runtime，以及伴随的 manifest 数据，主要是指：在浏览器运行过程中，webpack 用来连接模块化应用程序所需的所有代码。</li><li>在模块交互时，连接模块所需的加载和解析逻辑。包括：已经加载到浏览器中的连接模块逻辑，以及尚未加载模块的延迟加载逻辑。</li></ul><h2 id="模块热替换-hot-module-replacement"><a href="#模块热替换-hot-module-replacement" class="headerlink" title="模块热替换(hot module replacement)"></a>模块热替换(hot module replacement)</h2><blockquote><p>在应用程序运行过程中，替换、添加或删除 模块，而无需重新加载整个页面。</p></blockquote><ul><li>提高开发速度的方式：<ul><li>保留在完全重新加载页面期间丢失的应用程序状态。</li><li>只更新变更内容，以节省宝贵的开发时间。</li><li>在源代码中 CSS&#x2F;JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</li></ul></li><li>工作原理：<ul><li>在应用程序中<ol><li>应用程序要求 HMR runtime 检查更新。</li><li>HMR runtime 异步地下载更新，然后通知应用程序。</li><li>应用程序要求 HMR runtime 应用更新。</li><li>HMR runtime 同步地应用更新。</li><li>设置 HMR，使此进程自动触发更新，或者选择要求在用户交互时进行更新</li></ol></li><li>在 compiler 中<ul><li>除了普通资源，compiler 需要发出 “update”，将之前的版本更新到新的版本。”update” 由两部分组成：<ol><li>更新后的 manifest (JSON)</li><li>一个或多个 updated chunk (JavaScript)</li></ol></li></ul></li><li>在模块中<ul><li>HMR 是可选功能，只会影响包含 HMR 代码的模块。</li><li>如果一个模块没有 HMR 处理函数，更新就会冒泡。这意味着某个单独处理函数能够更新整个模块树。</li><li>如果在模块树的一个单独模块被更新，那么整组依赖模块都会被重新加载。</li></ul></li><li>在runtime中<ul><li>对于模块系统运行时，会发出额外代码，来跟踪模块parents和children关系。在管理方面，runtime 支持两个方法 check 和 apply。<br>  - check：发送一个 HTTP 请求来更新 manifest。如果请求失败，说明没有可用更新。如果请求成功，会将 updated chunk 列表与当前的 loaded chunk 列表进行比较。每个 loaded chunk 都会下载相应的 updated chunk。当所有更新 chunk 完成下载，runtime 就会切换到 ready 状态。<br>  - apply：将所有 updated module 标记为无效。对于每个无效 module，都需要在模块中有一个 update handler，或者在此模块的父级模块中有 update handler。否则，会进行无效标记冒泡，并且父级也会被标记为无效。继续每个冒泡，直到到达应用程序入口起点，或者到达带有 update handler 的 module。如果它从入口起点开始冒泡，则此过程失败。所有无效 module 都会被处理和解除加载。然后更新当前 hash，并且调用所有 accept handler。runtime 切换回 idle 状态，一切照常继续。</li></ul></li></ul></li><li>在开发环境，可以将 HMR 作为 LiveReload 的替代。webpack-dev-server 支持 hot 模式，在试图重新加载整个页面之前，hot 模式会尝试使用 HMR 来更新。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模块解析&quot;&gt;&lt;a href=&quot;#模块解析&quot; class=&quot;headerlink&quot; title=&quot;模块解析&quot;&gt;&lt;/a&gt;模块解析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;resolver 是一个帮助寻找模块绝对路径的库。一个模块可以作为另一个模块的依赖模块，然后被后者</summary>
      
    
    
    
    <category term="webpack" scheme="http://example.com/categories/webpack/"/>
    
    <category term="前端工程化工具" scheme="http://example.com/categories/webpack/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Vite --- 新一代前端构建工具</title>
    <link href="http://example.com/2024/11/01/Engineering/vite/"/>
    <id>http://example.com/2024/11/01/Engineering/vite/</id>
    <published>2024-11-01T08:52:16.698Z</published>
    <updated>2024-11-01T09:27:04.726Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个基于原生 ESM 的前端开发和构建工具，提供极速的服务启动、热重载、按需编译、类型支持和插件系统。</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>服务器启动速度快：通过将应用中的模块区分为依赖和源码两类</li></ol><ul><li>依赖：大多为在开发时不会变动的纯 JS<ul><li>使用 esbuild 预构建依赖</li><li>esbuild 使用 Go 编写，并且比以 JS 编写的打包器预构建依赖快 10-100 倍</li></ul></li><li>源码：包含一些非.js文件（例如 JSX，CSS 或者 组件）<ul><li>并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）</li><li>以原生 ESM 方式提供源码。实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码</li></ul></li></ul><ol start="2"><li>快速更新</li></ol><ul><li>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，精确地使已编辑的模块与其最近的 HMR 边界之间的链失活。</li><li>同时利用 HTTP 头来加速整个页面的重新加载<br>- 源码模块的请求会根据 304 Not Modified 进行协商缓存<br>- 依赖模块请求则会通过 Cache-Control: max-age&#x3D;31536000,immutable 进行强缓存，一旦被缓存将不需要再次请求。</li></ul><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ol><li>一个开发服务器，基于原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的模块热更新（HMR）。</li><li>一套构建指令，使用 Rollup 打包代码，并且是预配置的，可输出用于生产环境的高度优化过的静态资源。</li></ol><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><ul><li>支持原生 ESM语法的script标签</li><li>原生 ESM动态导入</li><li>import.meta的浏览器</li><li>传统浏览器可以通过插件@vitejs&#x2F;plugin-legacy支持</li></ul><h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><ul><li>提示：node版本要16+，14.18+</li><li>安装：npm create vite@latest 文件名 –template react-ts</li><li>注意：如果出现vite不是内部命令，可以执行npm i在执行npm run dev</li><li>create-vite 是一个快速生成主流框架基础模板的工具。</li><li>可以用如 degit 之类的工具，使用社区模版来搭建项目。<ul><li>npx degit user&#x2F;project my-project</li><li>npx degit user&#x2F;project#main my-project  &#x2F;&#x2F; 使用 main 作为默认分支</li></ul></li></ul><h3 id="index-html与项目根目录"><a href="#index-html与项目根目录" class="headerlink" title="index.html与项目根目录"></a>index.html与项目根目录</h3><ol><li>index.html</li></ol><ul><li>是项目的入口文件。</li><li>Vite 将index.html视为源码和模块图的一部分。标签指向源码，url能自动转换</li></ul><ol start="2"><li>根目录：即服务文件的位置，以 <root> 代称。</li></ol><ul><li>源码中的绝对 URL 路径将以项目的 “根” 作为基础来解析。</li><li>能够处理依赖关系，解析处于根目录外的文件位置。</li><li>Vite 也支持多个 .html 作入口点的 多页面应用模式。</li></ul><ol start="3"><li>指定替代根目录</li></ol><ul><li>vite serve some&#x2F;sub&#x2F;dir</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><p>npm依赖解析和预构建</p><ul><li>将会检测到所有被加载源文件中的此类裸模块导入（import { someMethod } from ‘my-dep’），并执行以下操作:</li></ul><ol><li>预构建,提高页面加载速度，并将 CommonJS&#x2F;UMD 转换为 ESM 格式。预构建由 esbuild 执行，这使冷启动时间快。</li><li>重写导入为合法的 URL以便浏览器能够正确导入。</li><li>依赖是强缓存的,通过 HTTP 头来缓存请求得到的依赖。</li></ol></li><li><p>模块热替换(create-vite 创建应用程序时已有)</p><ul><li>具有 HMR 功能的框架可以利用该 API 提供即时、准确的更新，而无需重新加载页面或清除应用程序状态。</li></ul></li><li><p>TypeScript</p><ul><li>仅执行 .ts 文件的转译工作，不执行任何类型检查（构建命令之外运行 tsc –noEmit 或 单独的进程中运行 tsc –noEmit –watch 或 使用 vite-plugin-checker插件）</li><li>使用 esbuild 将 ts 转译到 js，约是 tsc 速度的20~30倍，HMR 更新反映到浏览器的时间小于 50ms。</li><li>使用仅含类型的导入和导出形式的语法可以避免 “仅含类型的导入被不正确打包” 的问题</li><li>TypeScript编译器选项<ul><li>“isolatedModules”:true —支持转译功能</li><li>“skipLibCheck”: true —在一些库（如：vue）不支持isolatedModules时用</li><li>“useDefineForClassFields”: true —ts的target是ES或更高，默认。</li><li>代码库难迁移，可以用rollup-plugin-friendly-type-imports</li></ul></li></ul></li><li><p>客户端类型</p><ul><li>默认类型定义是写给它的 Node.js API,要补充到Vite 应用的客户端代码环境中，<ul><li>添加一个 d.ts 声明文件：<code>/// &lt;reference types=&quot;vite/client&quot; /&gt;</code></li><li>或者将 vite&#x2F;client 添加到 tsconfig.json 中的 compilerOptions.types 下：</li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;types&quot;</span>: [<span class="string">&quot;vite/client&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这将会提供以下类型定义补充：</p><ul><li>资源导入 (例如：导入一个 .svg 文件)</li><li>import.meta.env 上 Vite 注入的环境变量的类型定义</li><li>import.meta.hot 上的 HMR API 类型定义</li><li>TIP：要覆盖默认的类型定义，请在三斜线注释前添加定义。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如，要为 <span class="title class_">React</span> 组件中的 *.<span class="property">svg</span> 文件定义类型：</span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.svg&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">content</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">React</span>.<span class="property">SVGProps</span>&lt;<span class="title class_">SVGElement</span>&gt;&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> content</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;vite/client&quot; /&gt; </span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Vue</p><ul><li>第一优先级支持</li><li>Vue3 单文件组件支持：@vitejs&#x2F;plugin-vue</li><li>Vue3 JSX 支持：@vitejs&#x2F;plugin-vue-jsx</li><li>Vue2.7 SFC支持：@vitejs&#x2F;plugin-vue2</li><li>Vue2.7 JSX支持：underfin&#x2F;plugin-vue2-jsx</li></ul></li><li><p>JSX</p><ul><li>不在 React 或 Vue 中使用 JSX，自定义的 jsxFactory 和 jsxFragment 也可以使用 esbuild选项进行配置。<ul><li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">如<span class="title class_">Preact</span>：</span><br><span class="line">  <span class="comment">// vite.config.js</span></span><br><span class="line">  <span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="attr">esbuild</span>: &#123;</span><br><span class="line">      <span class="attr">jsxFactory</span>: <span class="string">&#x27;h&#x27;</span>,</span><br><span class="line">      <span class="attr">jsxFragment</span>: <span class="string">&#x27;Fragment&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">使用 jsxInject为 <span class="variable constant_">JSX</span> 注入 helper，以避免手动导入：</span><br><span class="line">  <span class="comment">// vite.config.js</span></span><br><span class="line">  <span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="attr">esbuild</span>: &#123;</span><br><span class="line">      <span class="attr">jsxInject</span>: <span class="string">`import React from &#x27;react&#x27;`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>CSS</p><ul><li><p>导入 .css 文件将会把内容插入到 <code>&lt;style&gt;</code> 标签中，同时也带有 HMR 支持。也能够以字符串的形式检索处理后的、作为其模块默认导出的 CSS。</p></li><li><p>@import 内联和变基</p><ul><li>通过 postcss-import 预配置支持了 CSS @import 内联，Vite 的路径别名也遵从 CSS @import。</li><li>Sass 和 Less 文件也支持 @import 别名和 URL 变基。</li></ul></li><li><p>PostCSS</p><ul><li>如果项目包含有效的 PostCSS 配置 (例如 postcss.config.js)，将会自动应用于所有已导入的 CSS。</li></ul></li><li><p>CSS Modules</p><ul><li>任何以 .module.css 为后缀名的文件都被认为是CSS modules 文件。导入会返回相应的模块对象<ul><li>CSS modules 行为可以通过 css.modules 选项 进行配置。</li><li>css.modules.localsConvention 开启了 camelCase 格式变量名转换，可以使用按名导入。</li></ul></li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example.module.css */</span></span><br><span class="line">.<span class="property">red</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*.js*/</span></span><br><span class="line"><span class="keyword">import</span> classes <span class="keyword">from</span> <span class="string">&#x27;./example.module.css&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">className</span> = classes.<span class="property">red</span></span><br><span class="line"><span class="comment">// .apply-color -&gt; applyColor</span></span><br><span class="line"><span class="keyword">import</span> &#123; applyColor &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.module.css&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">className</span> = applyColor   </span><br></pre></td></tr></table></figure><ul><li><p>CSS 预处理器：要安装依赖 </p><ul><li><p>.scss and .sass：npm add -D sass</p></li><li><p>.less ： npm add -D less</p></li><li><p>.styl and .stylus：npm add -D stylus</p></li><li><p>Sass 和 Less ，保证 Vite 别名也能被使用。</p></li><li><p>@import 别名和 URL 变基不支持 Stylus。</p></li><li><p>url() 中的相对路径引用的，与根文件不同目录中的 Sass&#x2F;Less 文件会自动变基。</p></li><li><p>单文件组件，可以通过 <code>&lt;style lang=&quot;sass&quot;&gt;</code>形式自动开启。</p></li><li><p>在文件扩展名前加上 .module 来结合使用 CSS modules 和预处理器。</p></li><li><p>禁用CSS注入页面</p></li><li><p>自动注入 CSS 内容的行为可以通过 ?inline 参数来关闭。</p></li><li><p>在关闭时，被处理过的 CSS 字符串将会作为该模块的默认导出，但样式并没有被注入到页面中。</p><ul><li>import styles from ‘.&#x2F;foo.css’ &#x2F;&#x2F; 样式将会注入页面</li><li>import otherStyles from ‘.&#x2F;bar.css?inline’ &#x2F;&#x2F; 样式不会注入页面</li></ul></li></ul></li><li><p>静态资源处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">导入一个静态资源会返回解析后的 <span class="variable constant_">URL</span>：</span><br><span class="line"><span class="keyword">import</span> imgUrl <span class="keyword">from</span> <span class="string">&#x27;./img.png&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hero-img&#x27;</span>).<span class="property">src</span> = imgUrl</span><br><span class="line">添加一些特殊的查询参数可以更改资源被引入的方式：</span><br><span class="line"><span class="comment">// 显式加载资源为一个 URL</span></span><br><span class="line"><span class="keyword">import</span> assetAsURL <span class="keyword">from</span> <span class="string">&#x27;./asset.js?url&#x27;</span></span><br><span class="line"><span class="comment">// 以字符串形式加载资源</span></span><br><span class="line"><span class="keyword">import</span> assetAsString <span class="keyword">from</span> <span class="string">&#x27;./shader.glsl?raw&#x27;</span></span><br><span class="line"><span class="comment">// 加载为 Web Worker</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Worker</span> <span class="keyword">from</span> <span class="string">&#x27;./worker.js?worker&#x27;</span></span><br><span class="line"><span class="comment">// 在构建时 Web Worker 内联为 base64 字符串</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">InlineWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./worker.js?worker&amp;inline&#x27;</span></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">- JSON - 可以被直接导入,支持具名导入：</span></span><br><span class="line"><span class="string">  - import json from &#x27;./example.json&#x27; // 导入整个对象</span></span><br><span class="line"><span class="string">  - import &#123; field &#125; from &#x27;./example.json&#x27; // 对一个根字段使用具名导入 —— 有效帮助 treeshaking！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Glob导入</span></span><br><span class="line"><span class="string">  - 支持使用特殊的 import.meta.glob 函数从文件系统导入多个模块：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="comment">//将dir文件夹下的所有js文件导入</span></span><br><span class="line">  <span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;./dir/*.js&#x27;</span>)</span><br><span class="line">  然后通过遍历modules的key来访问相应的模块</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> path <span class="keyword">in</span> modules) &#123;</span><br><span class="line">    modules[path]().<span class="title function_">then</span>(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(path, mod)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  匹配到的文件默认是懒加载的，通过动态导入实现，并会在构建时分离为独立的 chunk。</span><br><span class="line">  <span class="comment">//直接引入所有的模块，可以传入&#123;eager:true&#125;,作为第二参数</span></span><br><span class="line">  <span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;./dir/*.js&#x27;</span>, &#123; <span class="attr">eager</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><ul><li>Glob 导入形式  <ul><li>支持以字符串形式导入文件。</li><li>使用了 Import Reflection 语法对导入进行断言：</li><li>const modules &#x3D; import.meta.glob(‘.&#x2F;dir&#x2F;*.js’, { as: ‘raw’ })</li></ul></li><li>多个匹配模式<ul><li>第一个参数是一个 glob 数组，例如：</li><li>const modules &#x3D; import.meta.glob([‘.&#x2F;dir&#x2F;<em>.js’, ‘.&#x2F;another&#x2F;</em>.js’])</li></ul></li><li>反面匹配模式(以 ! 作为前缀):排除匹配<ul><li>const modules &#x3D; import.meta.glob([‘.&#x2F;dir&#x2F;*.js’, ‘!**&#x2F;bar.js’])</li></ul></li><li>具名导入（部分导入）<ul><li>const modules &#x3D; import.meta.glob(‘.&#x2F;dir&#x2F;*.js’, { import: ‘setup’ })</li></ul></li><li>tree-shaking：移除 JavaScript 上下文中的未引用代码</li><li>与 eager 在一起时，可以对这些模块进行 tree-shaking<ul><li>{ import: ‘setup’, eager: true }</li></ul></li><li>设置 import 为 default 可以加载默认导出<ul><li>{import: ‘default’,eager: true}</li></ul></li><li>自定义查询 ：使用 query 选项<ul><li>{query: { foo: ‘bar’, bar: true }}</li><li>动态导入</li><li>const module &#x3D; await import(<code>./dir/$&#123;file&#125;.js</code>)</li></ul></li></ul></li><li><p>WebAssembly</p><ul><li>预编译的 .wasm 文件可以通过 ?init 来导入。默认导出一个初始化函数，返回值为所导出 wasm 实例对象的 Promise<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> init <span class="keyword">from</span> <span class="string">&#x27;./example.wasm?init&#x27;</span></span><br><span class="line"><span class="title function_">init</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">instance</span>) =&gt;</span> &#123;</span><br><span class="line">  instance.<span class="property">exports</span>.<span class="title function_">test</span>()</span><br><span class="line">&#125;)</span><br><span class="line">还可以将传递给 <span class="title class_">WebAssembly</span>.<span class="property">instantiate</span> 的导入对象作为其第二个参数：</span><br><span class="line"><span class="title function_">init</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: &#123;</span><br><span class="line">    <span class="attr">someFunc</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125;&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">在生产构建当中，体积小于 assetInlineLimit 的 .<span class="property">wasm</span> 文件将会被内联为 base64 字符串。否则，它们将作为资源复制到 dist 目录中，并按需获取。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Web Workers</p><ul><li>通过构造器导入<br>- Web Worker 可以使用 new Worker() 和 new SharedWorker() 导入。<br>- type: ‘module’可以创建模块</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./worker.js&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>), &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>带有查询后缀的导入</p><ul><li>在导入请求上添加 ?worker 或 ?sharedworker 查询参数来直接导入一个 web worker 脚本。<ul><li>默认导出会是一个自定义 worker 的构造函数：<ul><li>import MyWorker from ‘.&#x2F;worker?worker’</li><li>const worker &#x3D; new MyWorker()</li></ul></li><li>如果想将 worker 内联为 base64 字符串，添加 inline 查询参数：<ul><li>import MyWorker from ‘.&#x2F;worker?worker&amp;inline’</li></ul></li><li>如果想要以一个 URL 的形式读取该 worker，添加 url 这个 query：<ul><li>import MyWorker from ‘.&#x2F;worker?worker&amp;url’</li></ul></li></ul></li></ul></li><li><p>构建优化</p><ul><li>CSS代码分割<ul><li>自动地将一个异步 chunk 模块中使用到的 CSS 代码抽取出来并为其生成一个单独的文件。这个 CSS 文件将在该异步 chunk 加载完成时自动通过一个 <link> 标签载入，该异步 chunk 会保证只在 CSS 加载完毕后再执行，避免发生 FOUC 。</li><li>禁用 CSS 代码分割：通过设置 build.cssCodeSplit:false</li></ul></li><li>预加载指令生成<ul><li>为入口 chunk 和它们在打包出的 HTML 中的直接引入自动生成 <link rel="modulepreload"> 指令。</li></ul></li><li>异步chunk加载优化<ul><li>将使用一个预加载步骤自动重写代码，来分割动态导入调用，以实现当 A 被请求时，C 也将 同时 被请求：Entry —&gt; (A + C)</li></ul></li></ul></li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li>添加一个插件<ul><li>安装好插件，然后在vite.config.js 配置文件中的 plugins 数组中引入</li></ul></li><li>强制插件排序<ul><li>使用 enforce 修饰符来强制插件的位置:<ul><li>pre：在 Vite 核心插件之前调用该插件</li><li>post：在 Vite 构建插件之后调用该插件</li><li>default：在 Vite 核心插件之后调用该插件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...<span class="title function_">image</span>(),</span><br><span class="line">      <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>按需应用<ul><li>如果插件在服务或构建期间按需使用，请使用 apply 属性指明它们仅在 ‘build’ 或 ‘serve’ 模式时调用：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typescript2 <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-typescript2&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...<span class="title function_">typescript2</span>(),</span><br><span class="line">      <span class="attr">apply</span>: <span class="string">&#x27;build&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="依赖预构建（仅会在开发模式下应用）"><a href="#依赖预构建（仅会在开发模式下应用）" class="headerlink" title="依赖预构建（仅会在开发模式下应用）"></a>依赖预构建（仅会在开发模式下应用）</h3><ul><li><p>目的</p><ul><li>CommonJS和UMD兼容性: 将作为 CommonJS&#x2F;UMD 发布的依赖项转换为 ESM。</li><li>将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</li></ul></li><li><p>自动依赖搜寻</p><ul><li>如果没有找到相应的缓存，将抓取源码，并自动寻找引入的依赖项，并将这些依赖项作为预构建包的入口点。</li><li>在服务器已经启动之后，如果遇到一个新的依赖关系导入，且不在缓存中，将重新运行依赖构建进程并重新加载页面。</li></ul></li><li><p>Monorepo 和链接依赖</p><ul><li>monorepo 启动，该仓库中的某个包可能会成为另一个包的依赖。</li><li>Vite 会自动侦测没有从 node_modules 解析的依赖项，并将链接的依赖视为源码。</li><li>会分析被链接依赖的依赖列表。但被链接的依赖导出要为 ESM 格式。如果不是，在配置里将此依赖添加到 optimizeDeps.include和build.commonjsOptions.include 这两项中。</li><li>当这个被链接的依赖发生变更后，在重启开发服务器时在命令中带上 –force 选项让所有更改生效。</li><li>传递依赖项错误的去重，导致运行出错，使用npm pack 来修复<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="attr">include</span>: [<span class="string">&#x27;linked-dep&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">commonjsOptions</span>: &#123;</span><br><span class="line">      <span class="attr">include</span>: [<span class="regexp">/linked-dep/</span>, <span class="regexp">/node_modules/</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>自定义行为</p><ul><li>optimizeDeps.include：明确包含依赖依赖项很大或者是 CommonJS<ul><li>optimizeDeps.exclude：明确排除依赖项很小，并且已经是有效的 ESM</li></ul></li></ul></li><li><p>缓存</p><ul><li>文件系统缓存<ul><li>Vite 会将预构建的依赖缓存到 node_modules&#x2F;.vite。它基于以下几个源来决定是否需要重新运行预构建步骤:<ol><li>补丁文件夹的修改时间</li><li>包管理器的 lockfile，例如 package-lock.json, yarn.lock，或者 pnpm-lock.yaml或者 bun.lockb</li><li>vite.config.js 中的相关字段<ol start="4"><li>NODE_ENV 的值</li></ol></li></ol></li><li>只有在上述其中一项发生更改时，才需要重新运行预构建。</li><li>强制重新构建依赖，用 –force 命令行选项启动开发服务器，或者手动删除 node_modules&#x2F;.vite 目录。</li></ul></li><li>浏览器缓存<ul><li>已预构建的依赖请求使用 HTTP 头 max-age&#x3D;31536000,immutable 进行强缓存，一旦被缓存将不需要再次请求。<ul><li>如安装了不同的版本的依赖项，则会通过附加的版本查询自动失效。</li><li>如果想通过本地编辑来调试依赖项，则:</li></ul><ol><li>通过浏览器调试工具的 Network 选项卡暂时禁用缓存；</li><li>重启 Vite 开发服务器指定 –force 选项，来重新构建依赖项</li><li>重新载入页面。</li></ol></li></ul></li></ul></li></ul><h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><ul><li>将资源引入为 URL<ul><li>服务时引入一个静态资源会返回解析后的公共路径：<ul><li>import imgUrl from ‘.&#x2F;img.png’</li><li>document.getElementById(‘hero-img’).src &#x3D; imgUrl</li></ul></li><li>行为类似于 Webpack 的 file-loader。区别在于导入既可以使用绝对公共路径，也可以使用相对路径。<ul><li>url() 在 CSS 中的引用也以同样的方式处理。</li><li>Vue插件，Vue SFC模板中的资源引用都将自动转换为导入。</li><li>常见的图像、媒体和字体文件类型被自动检测为资源。使用 assetsInclude 选项扩展内部列表。</li><li>引用的资源作为构建资源图的一部分包括在内，将生成散列文件名，并可以由插件进行处理以进行优化。</li><li>较小的资源体积小于 assetsInlineLimit 选项值则会被内联为 base64 data URL。</li><li>Git LFS 占位符会自动排除在内联之外。要获得内联，请确保在构建之前通过 Git LFS 下载文件内容。<ul><li>默认情况下，TypeScript 不会将静态资源导入视为有效的模块。要解决这个问题，需要添加 vite&#x2F;client。</li></ul></li></ul></li></ul></li><li>显示 URL 引入<ul><li>未被包含在内部列表或 assetsInclude 中的资源，可以使用 ?url 后缀显式导入为一个 URL。</li></ul></li><li>将资源引入为 字符串<ul><li>资源可以使用 ?raw 后缀声明作为字符串引入。<ul><li>import shaderString from ‘.&#x2F;shader.glsl?raw</li></ul></li></ul></li><li>导入脚本作为Worker<ul><li>通过 ?worker 或 ?sharedworker 后缀导入为 web worker。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在生产构建中将会分离出 chunk</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Worker</span> <span class="keyword">from</span> <span class="string">&#x27;./shader.js?worker&#x27;</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>()</span><br><span class="line"><span class="comment">// sharedworker</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SharedWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./shader.js?sharedworker&#x27;</span></span><br><span class="line"><span class="keyword">const</span> sharedWorker = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>()</span><br><span class="line"><span class="comment">// 内联为 base64 字符串</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">InlineWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./shader.js?worker&amp;inline&#x27;</span></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">- public 目录</span></span><br><span class="line"><span class="string">- 存放不会被源码引用、必须保持原有文件名、不想引入，只想得到url</span></span><br><span class="line"><span class="string">- 目录默认是 &lt;root&gt;/public，但可以通过 publicDir 选项 来配置</span></span><br><span class="line"><span class="string">- 注意：该目录资源不应该被js文件引用，应该使用/绝对路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- new URL(url, import.meta.url)</span></span><br><span class="line"><span class="string">  - 功能：暴露当前模块的 URL。</span></span><br><span class="line"><span class="string">- 将它与原生的 URL 构造器 组合使用，在一个 JS 模块中，通过相对路径我们就能得到一个被完整解析的静态资源 URL：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="comment">// URL字符串必须是静态的</span></span><br><span class="line">  <span class="keyword">const</span> imgUrl = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./img.png&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>).<span class="property">href</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hero-img&#x27;</span>).<span class="property">src</span> = imgUrl</span><br><span class="line">字符串模板支持动态 <span class="variable constant_">URL</span>：</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getImageUrl</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">`./dir/<span class="subst">$&#123;name&#125;</span>.png`</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>).<span class="property">href</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="构建生产版本-vite-build"><a href="#构建生产版本-vite-build" class="headerlink" title="构建生产版本: vite build"></a>构建生产版本: vite build</h3><ul><li><p>浏览器兼容性</p><ul><li>支持原生 ESM script 标签、支持原生 ESM 动态导入 和 import.meta 的浏览器<ul><li>通过 build.target 配置项指定构建目标，最低支持 es2015。</li><li>默认情况下 Vite 只处理语法转译，且默认不包含任何 polyfill。</li></ul></li><li>传统浏览器可以通过插件 @vitejs&#x2F;plugin-legacy 来支持。兼容版的 chunk 只会在不支持原生 ESM 的浏览器中进行按需加载。</li></ul></li><li><p>公共基础路径</p><ul><li>在嵌套的公共路径下部署项目，需指定 base 配置项，然后所有资源的路径都将据此配置重写<ul><li>也可以通过命令行参数指定，例如 vite build –base&#x3D;&#x2F;my&#x2F;public&#x2F;path&#x2F;。</li></ul></li><li>当访问过程中需要使用动态连接的 url 时，可以使用全局注入的 import.meta.env.BASE_URL 变量，它的值为公共基础路径。<ul><li>注意:这个变量在构建时会被静态替换，因此必须按 import.meta.env.BASE_URL 的原样出现</li></ul></li></ul></li><li><p>自定义构建</p><ul><li>通过 build.rollupOptions 直接调整底层的 Rollup 选项</li></ul></li><li><p>产物分块策略</p><ul><li>通过配置 build.rollupOptions.output.manualChunks 来自定义 chunk 分割策略.<ul><li>默认的策略是将 chunk 分割为 index 和 vendor。可以通过在配置文件中添加 splitVendorChunkPlugin 来继续使用 “分割 Vendor Chunk” 策略</li><li>也可用工厂函数 splitVendorChunk({ cache: SplitVendorChunkCache }) 来提供该策略，cache.reset() 需要在 buildStart 阶段被调用。</li></ul></li></ul></li><li><p>文件变化时重新构建</p><ul><li>vite build –watch 来启用 rollup 的监听器。<ul><li>或直接通过 build.watch 调整底层的 WatcherOptions 选项。</li></ul></li></ul></li><li><p>多页面应用模式</p><ul><li>在构建过程中，只需指定多个 .html 文件作为入口点</li><li>如果指定了另一个根目录，在解析输入路径时，__dirname 的值将仍然是 vite.config.js 文件所在的目录。因此，需要把对应入口文件的 root 的路径添加到 resolve 的参数中。</li></ul></li><li><p>库模式</p><ul><li>这个库要进行发布构建时，使用 build.rollupOptions.external 配置项确保将那些不想打包进库的依赖进行外部化处理</li><li>在 package.json 中使用如下格式。来暴露多个入口起点：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./dist/my-lib.mjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./dist/my-lib.cjs&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;./secondary&quot;</span>: &#123;<span class="comment">//暴露多个入口起点使用这种形式</span></span><br><span class="line">      <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./dist/secondary.mjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./dist/secondary.cjs&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>注意：<ol><li>如果 package.json 不包含 “type”: “module”，Vite 会生成不同的文件后缀名以兼容 Node.js。.js 会变为 .mjs 而 .cjs 会变为 .js 。</li><li>在库模式下，所有 import.meta.env.* 用法在构建生产时都会被静态替换。但是，process.env.* 的用法不会被替换。如果不允许这样做，使用 define: { ‘process.env.NODE_ENV’: ‘“production”‘ } 。</li></ol></li></ul></li></ul><h3 id="部署静态站点"><a href="#部署静态站点" class="headerlink" title="部署静态站点"></a>部署静态站点</h3><ul><li><p>构建应用：npm run build</p></li><li><p>本地测试应用：构建后运行npm run preview </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;preview&quot;</span>: <span class="string">&quot;vite preview --port 8080&quot;</span> <span class="comment">// 配置服务的运行端口</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>GitHub Pages</p><ol><li>在 vite.config.js 中设置正确的 base。</li></ol><ul><li>部署在 https:&#x2F;&#x2F;<USERNAME>.github.io&#x2F; 上，省略 base 使其默认为 ‘&#x2F;‘</li><li>部署在 https:&#x2F;&#x2F;<USERNAME>.github.io&#x2F;<REPO>&#x2F; 上，设置 base 为 ‘&#x2F;<REPO>&#x2F;‘</li></ul><ol start="2"><li>进入仓库 settings 页面的 GitHub Pages 配置，选择部署来源为“GitHub Actions”</li></ol></li><li><p>GitLab Pages 配合 GitLab CI</p><ol><li>在 vite.config.js 中设置正确的 base。</li></ol><ul><li>部署在 https:&#x2F;&#x2F;<USERNAME or GROUP>.gitlab.io&#x2F; 上，省略 base 使其默认为 ‘&#x2F;‘。</li><li>部署在 https:&#x2F;&#x2F;<USERNAME or GROUP>.gitlab.io&#x2F;<REPO>&#x2F; 上，设置 base 为 ‘&#x2F;<REPO>&#x2F;‘。</li></ul><ol start="2"><li>在项目根目录创建一个 .gitlab-ci.yml 文件，并包含以下内容<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image</span>: <span class="attr">node</span>:<span class="number">16.5</span><span class="number">.0</span></span><br><span class="line"><span class="attr">pages</span>:</span><br><span class="line">  <span class="attr">stage</span>: deploy</span><br><span class="line">  <span class="attr">cache</span>:</span><br><span class="line">    <span class="attr">key</span>:</span><br><span class="line">      <span class="attr">files</span>:</span><br><span class="line">        - package-lock.<span class="property">json</span></span><br><span class="line">      <span class="attr">prefix</span>: npm</span><br><span class="line">    <span class="attr">paths</span>:</span><br><span class="line">      - node_modules/</span><br><span class="line">  <span class="attr">script</span>:</span><br><span class="line">    - npm install</span><br><span class="line">    - npm run build</span><br><span class="line">    - cp -a dist/. public/</span><br><span class="line">  <span class="attr">artifacts</span>:</span><br><span class="line">    <span class="attr">paths</span>:</span><br><span class="line">      - public</span><br><span class="line">  <span class="attr">rules</span>:</span><br><span class="line">     - <span class="attr">if</span>: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="环境变量与模式"><a href="#环境变量与模式" class="headerlink" title="环境变量与模式"></a>环境变量与模式</h3><ul><li><p>环境变量</p><ul><li>import.meta.env.MODE: {string} 应用运行的模式。</li><li>import.meta.env.BASE_URL: {string} 部署应用时的基本 URL。他由base 配置项决定。</li><li>import.meta.env.PROD: {boolean} 应用是否运行在生产环境。</li><li>import.meta.env.DEV: {boolean} 应用是否运行在开发环境 (永远与 import.meta.env.PROD相反)。</li><li>import.meta.env.SSR: {boolean} 应用是否运行在 server 上。</li></ul></li><li><p>生产环境替换</p><ul><li>在生产环境中，在引用环境变量时请使用完全静态的字符串。</li><li>对于 JavaScript 字符串，可以使用 unicode 零宽度空格来分割这个字符串，例如： ‘import.meta\u200b.env.MODE’。</li><li>对于 Vue 模板或其他编译到 JavaScript 字符串的 HTML，可以使用 <wbr> 标签，例如：import.meta.<wbr>env.MODE。</li></ul></li><li><p>.env文件</p><ul><li>.env                # 所有情况下都会加载</li><li>.env.local          # 所有情况下都会加载，但会被 git 忽略</li><li>.env.[mode]         # 只在指定模式下加载</li><li>.env.[mode].local   # 只在指定模式下加载，但会被 git 忽略</li><li>环境加载优先级<ul><li>Vite 执行时已经存在的环境变量有最高的优先级，不会被覆盖。</li><li>一份用于指定模式的文件（例如 .env.production）会比通用形式的优先级更高（例如 .env）。</li><li>.env 类文件会在 Vite 启动一开始时被加载，而改动会在重启服务器后生效。</li></ul></li><li>加载的环境变量也会通过 import.meta.env 以字符串形式暴露给客户端源码</li><li>为了防止意外地将一些环境变量泄漏到客户端，只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理的代码。</li></ul></li><li><p>TypeScript 的智能提示</p><ul><li>获取以 VITE_ 为前缀的用户自定义环境变量的 TypeScript 智能提示：</li><li>在 src 目录下创建一个 env.d.ts 文件，接着按下面这样增加 ImportMetaEnv 的定义：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;vite/client&quot; /&gt;</span></span><br><span class="line">interface <span class="title class_">ImportMetaEnv</span> &#123;</span><br><span class="line">  readonly <span class="attr">VITE_APP_TITLE</span>: string</span><br><span class="line">  <span class="comment">// 更多环境变量...</span></span><br><span class="line">&#125;</span><br><span class="line">interface <span class="title class_">ImportMeta</span> &#123;</span><br><span class="line">  readonly <span class="attr">env</span>: <span class="title class_">ImportMetaEnv</span></span><br><span class="line">&#125;</span><br><span class="line">如果代码依赖于浏览器环境的类型，比如 <span class="variable constant_">DOM</span> 和 <span class="title class_">WebWorker</span>，可以在 tsconfig.<span class="property">json</span> 中修改 lib 字段来获取类型支持。</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;WebWorker&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>模式</p><ul><li>默认情况下，开发服务器 (dev 命令) 运行在 development模式，而 build 命令则运行在 production 模式。</li><li>通过传递 –mode 选项标志来覆盖命令使用的默认模式: vite build –mode staging</li></ul></li></ul><h3 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h3><ul><li><p>情景逻辑</p><ul><li>如果需要执行 SSR 和客户端间情景逻辑，可以使用：<br>-if (import.meta.env.SSR) { &#x2F;&#x2F; … 仅在服务端执行的逻辑 }</li></ul></li><li><p>生产环境构建</p><ol><li>正常生成一个客户端构建；</li><li>再生成一个 SSR 构建，使其通过 import() 直接加载，这样便无需再使用 Vite 的 ssrLoadModule；</li></ol><ul><li>注意:使用 –ssr 标志表明这将会是一个 SSR 构建。同时需要指定 SSR 的入口。</li></ul><ol start="3"><li>在 server.js 中，通过 process.env.NODE_ENV 条件分支，需要添加一些用于生产环境的特定逻辑：</li></ol><ul><li>使用 dist&#x2F;client&#x2F;index.html 作为模板，而不是根目录的 index.html，因为前者包含了到客户端构建的正确资源链接。</li><li>使用 import(‘.&#x2F;dist&#x2F;server&#x2F;entry-server.js’) </li><li>将 vite 开发服务器的创建和所有使用都移到 dev-only 条件分支后面，然后添加静态文件服务中间件来服务 dist&#x2F;client 中的文件。</li></ul></li><li><p>生成预加载指令</p><ul><li>使用 –ssrManifest 标志，这将会在构建输出目录中生成一份 ssr-manifest.json：<ul><li>“build:client”: “vite build –outDir dist&#x2F;client –ssrManifest”,</li><li>@vitejs&#x2F;plugin-vue 会自动注册使用的组件模块 ID 到相关的 Vue SSR 上下文：</li></ul></li></ul></li><li><p>预渲染 &#x2F; SSG</p><ul><li>预先知道某些路由所需的路由和数据，可以使用与生产环境 SSR 相同的逻辑将这些路由预先渲染到静态 HTML中。</li></ul></li><li><p>SSR 外部化</p><ul><li>当运行 SSR 时依赖会由 Vite 的 SSR 转换模块系统作外部化。<ul><li>如果依赖需要被 Vite 的管道转换,可以添加到 ssr.noExternal</li><li>对于采用链接的依赖，它们将默认不会被外部化</li></ul></li></ul></li><li><p>SSR 专有插件逻辑</p><ul><li>一些框架，会根据客户端渲染和服务端渲染的区别，将组件编译成不同的格式。可以向以下的插件钩子中，给 Vite 传递额外的 options 对象，对象中包含 ssr 属性来支持根据情景转换：<ul><li>resolveId</li><li>load</li><li>transform</li></ul></li></ul></li><li><p>SSR 构建目标</p><ul><li>SSR 构建的默认目标为 node 环境，但也可以让服务运行在 Web Worker 上。可以将ssr.target 设置为 webworker，以将目标配置为 Web Worker。</li></ul></li><li><p>SSR 构建产物</p><ul><li>通过设置 ssr.noExternal 为 true 来将 SSR 打包成单个 JavaScript 文件。这将会做两件事：<ul><li>将所有依赖视为 noExternal（非外部化）</li><li>若任何 Node.js 内置内容被引入，将抛出一个错误</li></ul></li></ul></li><li><p>Vite CLI</p><ul><li>CLI 命令 $ vite dev 和 $ vite preview 也可以用于 SSR 应用：可以将SSR 中间件通过 configureServer 添加到开发服务器、以及通过 configurePreviewServer 添加到预览服务器。</li></ul></li><li><p>SSR 格式</p><ul><li>默认情况下，Vite 生成的 SSR 打包产物是 ESM 格式。<ul><li>如果SSR 项目不能使用 ESM，可以通过 Vite v2 外部启发式方法设置 legacy.buildSsrCjsExternalHeuristics: true 生成 CJS 格式的产物。</li></ul></li></ul></li></ul><h3 id="后端集成-自定义"><a href="#后端集成-自定义" class="headerlink" title="后端集成(自定义)"></a>后端集成(自定义)</h3><ol><li>在的 Vite 配置中配置入口文件和启用创建 manifest：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="comment">// 在 outDir 中生成 manifest.json</span></span><br><span class="line">    <span class="attr">manifest</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line"><span class="comment">// 覆盖默认的 .html 入口</span></span><br><span class="line"><span class="attr">input</span>: <span class="string">&#x27;/path/to/main.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果没有禁用 module preload 的 polyfill，还需在入口处添加此 polyfill：</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vite/modulepreload-polyfill&#x27;</span></span><br></pre></td></tr></table></figure></li><li>在开发环境中，在服务器的 HTML 模板中注入以下内容：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是在开发环境中</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;http://localhost:5173/@vite/client&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:5173/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="string">&quot;为了正确地提供资源，有两种选项：&quot;</span></span><br><span class="line">  <span class="number">1.</span> 确保服务器被配置过，将会拦截代理资源请求给到 <span class="title class_">Vite</span> 服务器</span><br><span class="line">  <span class="number">2.</span> 设置 server.<span class="property">origin</span> 以求生成的资源链接将以服务器 <span class="variable constant_">URL</span> 形式被解析而非一个相对路径</span><br><span class="line"><span class="string">&quot;如果正使用 @vitejs/plugin-react 配合 React，还需要在上述脚本前添加下面这个，因为插件不能修改正在服务的 HTML&quot;</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> <span class="title class_">RefreshRuntime</span> <span class="keyword">from</span> <span class="string">&#x27;http://localhost:5173/@react-refresh&#x27;</span></span><br><span class="line">  <span class="title class_">RefreshRuntime</span>.<span class="title function_">injectIntoGlobalHook</span>(<span class="variable language_">window</span>)</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">$RefreshReg$</span> = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">$RefreshSig$</span> = <span class="function">() =&gt;</span> <span class="function">(<span class="params">type</span>) =&gt;</span> type</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">__vite_plugin_react_preamble_installed__</span> = <span class="literal">true</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">// 如果是在生产环境中</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/assets/&#123;&#123; manifest[&#x27;main.js&#x27;].css &#125;&#125;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/assets/&#123;&#123; manifest[&#x27;main.js&#x27;].file &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li>在生产环境中：在运行 vite build 之后，一个 manifest.json 文件将与静态资源文件一同生成。</li></ol><ul><li>清单是一个 Record&lt;name, chunk&gt; 结构的对象。</li><li>对于 入口 或动态入口 chunk，键是相对于项目根目录的资源路径。</li><li>对于非入口 chunk，键是生成文件的名称并加上前缀 _。</li><li>Chunk 将信息包含在其静态和动态导入上（两者都是映射到清单中相应 chunk 的键)，以及任何与之相关的 CSS 和资源文件。</li><li>可以使用这个文件来渲染链接或者用散列文件名预加载指令</li></ul><h3 id="插件API"><a href="#插件API" class="headerlink" title="插件API"></a>插件API</h3><ul><li><p>约定</p><ul><li>如果插件不使用 Vite 特有的钩子，可以作为兼容 Rollup 的插件来实现：<ul><li>Rollup 插件应该有一个带 rollup-plugin- 前缀、语义清晰的名称。</li><li>在 package.json 中包含 rollup-plugin 和 vite-plugin 关键字</li></ul></li><li>对于 Vite 专属的插件：<ul><li>Vite 插件应该有一个带 vite-plugin- 前缀、语义清晰的名称。</li><li>在 package.json 中包含 vite-plugin 关键字。</li></ul></li><li>只适用于特定的框架的插件：<ul><li>vite-plugin-vue- 前缀作为 Vue 插件</li><li>vite-plugin-react- 前缀作为 React 插件</li><li>vite-plugin-svelte- 前缀作为 Svelte 插件</li></ul></li></ul></li><li><p>插件配置</p><ul><li>用户会将插件添加到项目的 devDependencies 中并使用数组形式的 plugins 选项配置它们。该数组将在内部被扁平化（flatten）。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> vitePlugin <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-feature&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rollupPlugin <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-feature&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vitePlugin</span>(), <span class="title function_">rollupPlugin</span>()] <span class="comment">// 可以接受将多个插件作为单个元素的预设</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>转换自定义文件类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileRegex = <span class="regexp">/\.(my-file-ext)$/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">myPlugin</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;transform-file&#x27;</span>,</span><br><span class="line">    <span class="title function_">transform</span>(<span class="params">src, id</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fileRegex.<span class="title function_">test</span>(id)) &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">code</span>: <span class="title function_">compileFileToJS</span>(src),</span><br><span class="line">          <span class="attr">map</span>: <span class="literal">null</span> <span class="comment">// 如果可行将提供 source map</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>虚拟模块</p><ul><li>一种很实用的模式，使可以对使用 ESM 语法的源文件传入一些编译时信息。然后在js文件中引入。</li><li>在 Vite（以及 Rollup）中都以 virtual: 为前缀。</li></ul></li><li><p>通用钩子</p><ul><li>以下钩子在服务器启动时被调用：<ul><li>options</li><li>buildStart</li></ul></li><li>以下钩子会在每个传入模块请求时被调用：<ul><li>resolveId</li><li>load</li><li>transform</li></ul></li><li>以下钩子在服务器关闭时被调用：<ul><li>buildEnd</li><li>closeBundle</li></ul></li><li>注意 moduleParsed 钩子在开发中是不会被调用的。可以认为 Vite 的开发服务器只调用了 rollup.rollup() 而没有调用 bundle.generate()。</li></ul></li><li><p>Vite 独有钩子</p><ul><li>config<ul><li>类型：(config: UserConfig, env: { mode: string, command: string }) &#x3D;&gt; UserConfig | null | void<ul><li>种类：async, sequential</li></ul></li><li>在解析 Vite 配置前调用。钩子接收原始用户配置和一个描述配置环境的变量，包含正在使用的 mode 和 command。它可以返回一个将被深度合并到现有配置中的部分配置对象，或者直接改变配置。</li></ul></li><li>configResolved<ul><li>类型：(config: ResolvedConfig) &#x3D;&gt; void | Promise<void></li><li>种类：async, parallel</li><li>在解析 Vite 配置后调用。使用这个钩子读取和存储最终解析的配置。</li></ul></li><li>configureServer<ul><li>类型：(server: ViteDevServer) &#x3D;&gt; (() &#x3D;&gt; void) | void | Promise&lt;(() &#x3D;&gt; void) | void&gt;</li><li>种类：async, sequential</li><li>注入后置中间件：<ul><li>configureServer 钩子将在内部中间件被安装前调用。如果想注入一个在内部中间件之后运行的中间件，可以从 configureServer 返回一个函数，将会在内部中间件安装后被调用<br>-存储服务器访问</li></ul></li></ul></li><li>configurePreviewServer<ul><li>类型：(server: { middlewares: Connect.Server, httpServer: http.Server }) &#x3D;&gt; (() &#x3D;&gt; void) | void | Promise&lt;(() &#x3D;&gt; void) | void&gt;</li><li>种类：async, sequential</li><li>用于预览服务器。configurePreviewServer 钩子也是在其他中间件安装前被调用的。想要在其他中间件之后安装一个插件，可以从 configurePreviewServer返回一个函数，它将会在内部中间件被安装之后再调用</li></ul></li><li>transformIndexHtml：转换 index.html 的专用钩子。<ul><li>类型： IndexHtmlTransformHook | { enforce?: ‘pre’ | ‘post’, transform: IndexHtmlTransformHook }</li><li>种类： async, sequential</li><li>钩子接收当前的 HTML 字符串和转换上下文。上下文在开发期间暴露ViteDevServer实例，在构建期间暴露 Rollup 输出的包。</li><li>这个钩子可以是异步的，并且可以返回以下其中之一:<ol><li>经过转换的 HTML 字符串</li><li>注入到现有HTML中的标签描述符对象数组({tag, attrs, children})。每个标签也可以指定它应该被注入到哪里（默认是在 <head> 之前）</li><li>一个包含 { html, tags } 的对象</li></ol></li></ul></li><li>handleHotUpdate<ul><li>类型： (ctx: HmrContext) &#x3D;&gt; Array<ModuleNode> | void | Promise&lt;Array<ModuleNode> | void&gt;</li><li>执行自定义 HMR 更新处理。钩子接收一个带有以下签名的上下文对象：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">HmrContext</span> &#123;</span><br><span class="line">  <span class="attr">file</span>: string</span><br><span class="line">  <span class="attr">timestamp</span>: number</span><br><span class="line">  <span class="attr">modules</span>: <span class="title class_">Array</span>&lt;<span class="title class_">ModuleNode</span>&gt; <span class="comment">//是受更改文件影响的模块数组。</span></span><br><span class="line">  <span class="attr">read</span>: <span class="function">() =&gt;</span> string | <span class="title class_">Promise</span>&lt;string&gt;  <span class="comment">//异步读函数，它返回文件的内容</span></span><br><span class="line">  <span class="attr">server</span>: <span class="title class_">ViteDevServer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>插件顺序</p><ul><li>一个 Vite 插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是pre 或 post。解析后的插件将按照以下顺序排列：<ul><li>Alias</li><li>带有 enforce: ‘pre’ 的用户插件</li><li>Vite 核心插件</li><li>没有 enforce 值的用户插件</li><li>Vite 构建用的插件</li><li>带有 enforce: ‘post’ 的用户插件</li><li>Vite 后置构建插件（最小化，manifest，报告</li></ul></li></ul></li><li><p>Rollup 插件兼容性</p><ul><li>只要 Rollup 插件符合以下标准，它就应该像 Vite 插件一样工作：<ul><li>没有使用 moduleParsed 钩子。</li><li>它在打包钩子和输出钩子之间没有很强的耦合。</li></ul></li><li>如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。它的工作原理与 Vite 插件的 enforce: ‘post’ 和 apply: ‘build’ 相同。</li></ul></li><li><p>路径规范化</p><ul><li>Vite在解析路径时使用 POSIX 分隔符（ &#x2F; ），同时保留了 Windows 中的卷名。<ul><li>Rollup 在默认情况下保持解析的路径不变，因此解析的路径在 Windows 中会使用 win32 分隔符（ \ ）。</li></ul></li></ul></li><li><p>过滤与include&#x2F;exclde模式</p><ul><li>暴露 @rollup&#x2F;pluginutils 的 createFilter 函数，以支持 Vite 独有插件和集成使用标准的 include&#x2F;exclude 过滤模式</li></ul></li><li><p>客户端与服务端间通信</p><ul><li>服务端到客户端<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">在插件一侧，我们可以使用 server.<span class="property">ws</span>.<span class="property">send</span> 去给所有客户端广播事件：</span><br><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [&#123;</span><br><span class="line">    <span class="title function_">configureServer</span>(<span class="params">server</span>) &#123;</span><br><span class="line">      server.<span class="property">ws</span>.<span class="title function_">send</span>(<span class="string">&#x27;my:greetings&#x27;</span>, &#123; <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br><span class="line">在客户端侧，使用 hot.<span class="property">on</span> 去监听事件：</span><br><span class="line"><span class="comment">// client side</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">on</span>(<span class="string">&#x27;my:greetings&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">msg</span>) <span class="comment">// hello</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">  - 客户端到服务端</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">为了从客户端向服务端发送事件，使用 hot.<span class="property">send</span>：</span><br><span class="line">  <span class="comment">// client side</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">    <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">send</span>(<span class="string">&#x27;my:from-client&#x27;</span>, &#123; <span class="attr">msg</span>: <span class="string">&#x27;Hey!&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">然后使用 server.<span class="property">ws</span>.<span class="property">on</span> 并在服务端监听这些事件：</span><br><span class="line">  <span class="comment">// vite.config.js</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [&#123;</span><br><span class="line">      <span class="title function_">configureServer</span>(<span class="params">server</span>) &#123;</span><br><span class="line">        server.<span class="property">ws</span>.<span class="title function_">on</span>(<span class="string">&#x27;my:from-client&#x27;</span>, <span class="function">(<span class="params">data, client</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message from client:&#x27;</span>, data.<span class="property">msg</span>) <span class="comment">// Hey!</span></span><br><span class="line">          <span class="comment">// reply only to the client (if needed)</span></span><br><span class="line">          client.<span class="title function_">send</span>(<span class="string">&#x27;my:ack&#x27;</span>, &#123; <span class="attr">msg</span>: <span class="string">&#x27;Hi! I got your message!&#x27;</span> &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li><li>自定义事件的 TypeScript 类型定义指南<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可以通过扩展 <span class="title class_">CustomEventMap</span> 这个 interface 来为自定义事件标注类型：</span><br><span class="line"><span class="comment">// events.d.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vite/types/customEvent&#x27;</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;vite/types/customEvent&#x27;</span> &#123;</span><br><span class="line">  interface <span class="title class_">CustomEventMap</span> &#123;</span><br><span class="line">     <span class="string">&#x27;custom:foo&#x27;</span>: &#123; <span class="attr">msg</span>: string &#125;</span><br><span class="line">     <span class="comment">// &#x27;event-key&#x27;: payload</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="客户端-HMR-API-：通过-import-meta-hot-对象暴露手动-HMR-API。"><a href="#客户端-HMR-API-：通过-import-meta-hot-对象暴露手动-HMR-API。" class="headerlink" title="客户端 HMR API ：通过 import.meta.hot 对象暴露手动 HMR API。"></a>客户端 HMR API ：通过 import.meta.hot 对象暴露手动 HMR API。</h3><ul><li>必需的条件守卫<ul><li>确保用<code>一个条件语句</code>守护<code>所有 HMR API</code> 的使用<ul><li>if (import.meta.hot) { &#x2F;&#x2F; HMR 代码 }</li></ul></li></ul></li><li>TypeScript 的智能提示<ul><li>在 src 目录中创建env.d.ts，以便 TypeScript 获取类型定义：<ul><li><code>/// &lt;reference types=&quot;vite/client&quot; /&gt;</code></li></ul></li></ul></li><li>hot.accept(cb)：接收模块自身<ul><li>参数:接收已更新模块的回调函数：</li><li>“接受” 热更新的模块被认为是 HMR 边界。</li></ul></li><li>hot.accept(deps, cb)：接受直接依赖项的更新，而无需重新加载自身<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupSideEffect</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title function_">setupSideEffect</span>()</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./foo.js&#x27;</span>, <span class="function">(<span class="params">newFoo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调函数接收到更新后的&#x27;./foo.js&#x27; 模块</span></span><br><span class="line">    newFoo?.<span class="title function_">foo</span>()</span><br><span class="line"><span class="comment">// 你可以使用新的模块实例来决定是否使其失效。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">cannotHandleUpdate</span>(<span class="variable language_">module</span>)) &#123;</span><br><span class="line">    <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">invalidate</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 也可以接受一个依赖模块的数组：</span></span><br><span class="line">  <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(</span><br><span class="line">    [<span class="string">&#x27;./foo.js&#x27;</span>, <span class="string">&#x27;./bar.js&#x27;</span>],</span><br><span class="line">    <span class="function">(<span class="params">[newFooModule, newBarModule]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 回调函数接收一个更新后模块的数组</span></span><br><span class="line">    &#125;</span><br><span class="line">   )</span><br><span class="line"><span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">dispose</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 清理副作用</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>hot.dispose(cb)：<ul><li>一个接收自身的模块或一个期望被其他模块接收的模块可以使用 hot.dispose 来清除任何由其更新副本产生的持久副作用</li></ul></li><li>hot.prune(cb): 注册一个回调，当模块在页面上不再被导入时调用</li><li>hot.data：在同一个更新模块的不同实例之间持久化.将信息从模块的前一个版本传递到下一个版本</li><li>hot.decline()：目前是一个空操作并暂留用于向后兼容。</li><li>hot.invalidate():指明某模块是不可热更新的,建议在 accept 回调中调用 invalidate</li><li>hot.on(event, cb)：监听自定义 HMR 事件。以下事件自动触发：<ul><li>‘vite:beforeUpdate’ 当更新即将被应用时（例如，一个模块将被替换）</li><li>‘vite:afterUpdate’ 当更新已经被应用时<ul><li>‘vite:beforeFullReload’ 当完整的重载即将发生时</li></ul></li><li>‘vite:beforePrune’ 当不再需要的模块即将被剔除时</li><li>‘vite:invalidate’ 当使用import.meta.hot.invalidate()使一个模块失效时<ul><li>‘vite:error’ 当发生错误时（例如，语法错误）</li></ul></li></ul></li><li>hot.send(event, data)：发送自定义事件到 Vite 开发服务器。</li></ul><h3 id="Javascript-API-—-看手册"><a href="#Javascript-API-—-看手册" class="headerlink" title="Javascript API — 看手册"></a>Javascript API — 看手册</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个基于原生 ESM 的前端开发和构建工具，提供极速的服务启动、热重载、按需编译、类型支持和插件系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点</summary>
      
    
    
    
    <category term="前端工程化工具" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Next --- React 开发框架</title>
    <link href="http://example.com/2024/11/01/Engineering/Next/"/>
    <id>http://example.com/2024/11/01/Engineering/Next/</id>
    <published>2024-11-01T08:52:16.693Z</published>
    <updated>2024-11-01T09:23:51.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul><li>直观的、 <code>基于页面</code>的路由系统（并支持<code>动态路由</code>）</li><li><code>预渲染</code>。支持在页面级的<code>静态生成</code> (SSG) 和<code>服务器端渲染</code> (SSR)</li><li>自动代码拆分，提升页面加载速度</li><li>具有经过优化的预取功能的<code>客户端路由</code></li><li>内置 CSS 和 Sass 的支持，并支持任何<code>CSS-in-JS</code>库</li><li>开发环境支持<code>快速刷新</code></li><li>利用 Serverless Functions 及 <code>API 路由</code>构建 API 功能</li><li>完全可扩展</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>前提：node 版本需要12.22.0 及更高</li><li>创建：<code>npx create-next-app@latest --typescript</code></li><li>运行：<code>npm run dev</code>启动服务器，访问<code>http://localhost:3000</code></li><li>安装：<code>npm install next react react-dom</code></li><li>配置：在package.json文件添加<code>scripts</code>配置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;next dev&quot;</span>, <span class="comment">// 开发模式启动</span></span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;next build&quot;</span>, <span class="comment">// 构建生产环境</span></span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;next start&quot;</span>, <span class="comment">// 启动生产环境服务器</span></span><br><span class="line">  <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;next lint&quot;</span> <span class="comment">// 设置内置ESLint配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="页面-Pages"><a href="#页面-Pages" class="headerlink" title="页面(Pages)"></a>页面(Pages)</h2><ul><li>在next.js中，page就是React组件，文件存放在<code>pages</code>目录下，每个page都使用其文件名作为路由，通过<code>/文件名</code>访问<ul><li>支持有<code>动态路由的pages</code>，如文件名为<code>pages/posts/[id].js</code>,通过<code>posts/1</code>访问</li></ul></li><li><h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><ul><li>默认情况下将预渲染每个pege，即预先为每个page生成HTML文件</li></ul></li><li><b>水合</b>：当浏览器加载一个page时，其Javascript代码将运行并使页面完全具有交互性的过程。</li><li>两种形式的预渲染：<ul><li><strong>静态生成</strong>(推荐)：HTML在<code>构建时</code>生成，并在每次页面请求时重用</li><li><strong>服务端渲染</strong>：在<code>每次页面请求时</code>重新生成HTML</li></ul></li><li>允许每个页面选择渲染方式，CDN可以在没有额外配置的情况下缓存静态生成的页面提高性能</li><li><h3 id="静态生成-—-生成带有或不带有数据的页面"><a href="#静态生成-—-生成带有或不带有数据的页面" class="headerlink" title="静态生成 — 生成带有或不带有数据的页面"></a>静态生成 — 生成带有或不带有数据的页面</h3><ul><li><code>生成不带有数据的静态页面</code>：不涉及获取外部数据，只需构建时为页面生成HTML文件</li><li><code>生成带有数据的页面</code>:<ul><li>页面<code>内容</code>取决于外部数据: 使用<code>getStaticProps</code></li><li>页面<code>paths</code>取决于外部数据：使用<code>getStaticPaths + getStaticProps</code></li></ul></li><li>尽可能使用静态生成如：营销页面，博客文章、简历、产品列表、帮助文档</li><li>静态生成不满足使用的解决方案：静态生成+<code>客户端渲染</code>，<code>服务端渲染</code></li></ul></li><li><h3 id="服务端渲染-—-也被称为SSR或动态渲染"><a href="#服务端渲染-—-也被称为SSR或动态渲染" class="headerlink" title="服务端渲染 — 也被称为SSR或动态渲染"></a>服务端渲染 — 也被称为SSR或动态渲染</h3><ul><li>使用：<code>getServerSideProps</code></li></ul></li></ul><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><ul><li><code>getStaticProps</code>（静态生成）：仅在<code>构建时</code>获取数据。</li><li><code>getStaticPaths</code>（静态生成）：根据数据指定预渲染页面的动态路由。</li><li><code>getServerSideProps</code>（服务器端渲染）：获取每个请求的数据。</li><li><h3 id="getStaticProps"><a href="#getStaticProps" class="headerlink" title="getStaticProps"></a>getStaticProps</h3><ul><li>返回一个对象</li><li><code>context</code>包含:<ul><li>params: 使用动态路由页面的路由参数     </li><li>preview：是否处于预览模式。true&#x2F;undefined     </li><li>previewData：setPreviewData设置的预览数据集</li><li>locale：活动区域设置(前提：启用国际路由)</li><li>locales：所有支持的区域设置(前提：启用国际路由)</li><li>defaultLocale：配置的默认区域设置(前提：启用国际路由)</li></ul></li><li><code>props</code>：可选对象，包含页面组件将接受的props</li><li><code>revalidate</code>：可选的次数，单位秒，默认false，具体看<a href="#ref1">增量静态生成</a></li><li><code>notFound</code>：可选的布尔值，允许页面返回404和页面</li><li><code>redirect</code>：可选的重定向值，允许重定向到内部和外部资源，构建时不允许重定向<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GetStaticProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getStaticProps</span>: <span class="title class_">GetStaticProps</span> = <span class="title function_">async</span> (context) =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="增量静态再生-ISR-–-基于每个页面使用静态生成，而无需重新构建整个站点。"><a href="#增量静态再生-ISR-–-基于每个页面使用静态生成，而无需重新构建整个站点。" class="headerlink" title="增量静态再生(ISR) – 基于每个页面使用静态生成，而无需重新构建整个站点。"></a><p id="ref1">增量静态再生(ISR)</p> – 基于每个页面使用静态生成，而无需重新构建整个站点。</h3><ul><li>使用<code>revalidate：number</code>启用，当对在生成时预呈现的页面发出请求时，它最初将显示缓存的页面。过程如下：<ul><li>初始请求之后和10秒之前对页面的任何请求也会被缓存并即时缓存</li><li>number秒窗口之后，下一个请求仍将显示缓存(过时)页面</li><li>next会在后台触发页面重新生成</li><li>生成成功后，next使缓存失效并显示更新的产品页面；失败则页面保持不变</li></ul></li></ul></li><li><h3 id="读取文件：process-cwd"><a href="#读取文件：process-cwd" class="headerlink" title="读取文件：process.cwd()"></a>读取文件：<code>process.cwd()</code></h3><ul><li>文件可以直接从<code>getStaticProps</code>中的文件系统中读取。即必须获取文件的完整路径</li><li>next将代码编译到一个单独的目录中<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> postsDirectory = path.<span class="title function_">join</span>(process.<span class="title function_">cwd</span>(),<span class="string">&#x27;posts&#x27;</span>) </span><br><span class="line">  <span class="comment">// 使用 fs.readdir(postsDirectory)来读取这个目录</span></span><br><span class="line">  <span class="keyword">const</span> filenames = <span class="keyword">await</span> fs.<span class="title function_">readdir</span>(postsDirectory)</span><br><span class="line">  <span class="keyword">const</span> posts = filenames.<span class="title function_">map</span>(<span class="title function_">async</span> (filename) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> filePath = path.<span class="title function_">join</span>(postsDirectory, filename)</span><br><span class="line">    <span class="keyword">const</span> fileContents = <span class="keyword">await</span> fs.<span class="title function_">readFile</span>(filePath, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      filename,</span><br><span class="line">      <span class="attr">content</span>: fileContents,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">posts</span>: <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(posts),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="getStaticPaths"><a href="#getStaticPaths" class="headerlink" title="getStaticPaths"></a>getStaticPaths</h3><ul><li>静态预呈现使用动态路由的页面时使用</li><li><h4 id="paths键-必选"><a href="#paths键-必选" class="headerlink" title="paths键(必选)"></a>paths键(必选)</h4><ul><li>如果页面使用可选的捕获所有路由，使用null、[]、undefined或 false来呈现最根路径， 如果在<code>page/[[...slug]]</code>,使用slug:false,则静态生成页面”&#x2F;“</li></ul></li><li><h4 id="fallback键-必选"><a href="#fallback键-必选" class="headerlink" title="fallback键(必选)"></a>fallback键(必选)</h4><ul><li><code>fallback：false</code>:则任何<code>未返回的路径都将导致404</code>，不经常添加新页面可用</li><li><code>fallback: true</code>:返回的路径将在构建时由<code>getStaticProps</code>呈现为HTML，在生成时<code>未生成的路径不会生成404</code>,提供<a href="#ref2">回退版本</a>,从用户角度看，页面将从回退页面交换到整个页面。有大量依赖于数据的静态页面可用。</li><li><code>fallback:blocking</code>:阻塞原因，每条路径只发生一次。构建时尚未生成的路径不会导致404。相反Next将对第一个请求进行SSR，并返回生成的HTML。完成后，浏览器将接收生成路径的 HTML。Next将此路径添加到预呈现页面的列表中。</li></ul></li><li><h4 id="回退页面"><a href="#回退页面" class="headerlink" title="回退页面"></a><p id="ref2">回退页面</p></h4><ul><li>页面的props将为空。使用router.isFallback可以检测是否正在渲染回退，如果只为true的话<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticPaths</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">paths</span>: [</span><br><span class="line">      &#123; <span class="attr">params</span>: &#123; ... &#125;&#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">fallback</span>: <span class="literal">true</span>,<span class="literal">false</span>,or <span class="string">&#x27;blocking&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GetStaticPaths</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getStaticPaths</span>: <span class="title class_">GetStaticPaths</span> = <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h3 id="getServerSideProps"><a href="#getServerSideProps" class="headerlink" title="getServerSideProps"></a>getServerSideProps</h3><ul><li>仅当需要预呈现其数据必须在请求时提取的页面时，才应使用。getStaticProps到第一个字节的时间（TTFB）将比慢，因为服务器必须计算每个请求的结果，并且如果没有额外的配置，CDN就无法缓存结果。</li><li>返回一个对象</li><li><code>context</code>包含:<ul><li>params: 使用动态路由页面的路由参数</li><li>req: http 传入信息对象，以及其它内置的解析助手</li><li>res: http返回对象</li><li>query: 查询字符串的对象</li><li>preview：是否处于预览模式。true&#x2F;undefined     </li><li>previewData：setPreviewData设置的预览数据集</li><li>resolvedUrl: 请求URL的规范化版本，去掉客户端转换的前缀并包括原始查询值</li><li>locale：活动区域设置(前提：启用国际路由)</li><li>locales：所有支持的区域设置(前提：启用国际路由)</li><li>defaultLocale：配置的默认区域设置(前提：启用国际路由)</li></ul></li><li><code>props</code>：可选对象，包含页面组件将接受的props</li><li><code>notFound</code>：可选的布尔值，允许页面返回404和页面</li><li><code>redirect</code>：可选的重定向值，允许重定向到内部和外部资源，构建时不允许重定向</li><li>在getServerSideProps中提供req中间件:req<ul><li>req.cookies: 一个包含请求发送的cookie的对象。默认为｛｝<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GetServerSideProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getServerSideProps</span>: <span class="title class_">GetServerSideProps</span> = <span class="title function_">async</span> (context) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h3 id="在客户端获取数据"><a href="#在客户端获取数据" class="headerlink" title="在客户端获取数据"></a>在客户端获取数据</h3><ul><li>使用场景：如果页面包含频繁更新的数据，并且不需要预呈现数据。用户面板页面。</li><li>首先，立即显示没有数据的页面。页面的部分内容可以使用静态生成进行预渲染。您可以显示丢失数据的加载状态。然后，在客户端获取数据，并在准备好后显示。</li></ul></li><li><h3 id="SWR"><a href="#SWR" class="headerlink" title="SWR"></a>SWR</h3><ul><li>next团队创建的React数据获取挂钩</li><li>处理缓存、重新验证、焦点跟踪、间隔重新蚀刻等<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useSWR <span class="keyword">from</span> <span class="string">&#x27;swr&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetcher</span> = (<span class="params">url</span>) =&gt; <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Profile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useSWR</span>(<span class="string">&#x27;/api/user&#x27;</span>, fetcher)</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>failed to load<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">if</span> (!data) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello &#123;data.name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="内置对-CSS-的支持"><a href="#内置对-CSS-的支持" class="headerlink" title="内置对 CSS 的支持"></a>内置对 CSS 的支持</h2><ul><li>允许在js文件import css文件</li><li><h3 id="添加全局样式表"><a href="#添加全局样式表" class="headerlink" title="添加全局样式表"></a>添加全局样式表</h3><ul><li>创建一个<code>pages/_app.js</code>文件，然后<code>import</code> css文件</li></ul></li><li><h3 id="从node-modules目录import样式"><a href="#从node-modules目录import样式" class="headerlink" title="从node_modules目录import样式"></a>从<code>node_modules</code>目录import样式</h3><ul><li>可以在应用程序的任何位置导入</li><li>全局样式表还是要在<code>pages/_app.js</code>导入</li><li>其它的对应组件页面导入</li></ul></li><li><h3 id="添加组件级CSS"><a href="#添加组件级CSS" class="headerlink" title="添加组件级CSS"></a>添加组件级CSS</h3><ul><li>CSS模块支持的文件命名格式：<code>[name].module.css</code></li><li>CSS模块时一项可选功能，仅对带有<code>.module.css</code>扩展名的文件启用</li></ul></li><li><h3 id="对Sass的支持"><a href="#对Sass的支持" class="headerlink" title="对Sass的支持"></a>对Sass的支持</h3><ul><li>文件后缀必须为：<code>.module.scss</code>或<code>.module.sass</code></li><li>记得安装sass： <code>npm i sass</code></li><li><h3 id="自定义Sass参数：使用next-config-js文件中的sassOptions属性进行配置"><a href="#自定义Sass参数：使用next-config-js文件中的sassOptions属性进行配置" class="headerlink" title="自定义Sass参数：使用next.config.js文件中的sassOptions属性进行配置"></a>自定义Sass参数：使用<code>next.config.js</code>文件中的<code>sassOptions</code>属性进行配置</h3></li><li><h3 id="Sass变量"><a href="#Sass变量" class="headerlink" title="Sass变量"></a>Sass变量</h3></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xxx.module.scss</span></span><br><span class="line">$primary-<span class="attr">color</span>: #64FF00</span><br><span class="line">:<span class="keyword">export</span> &#123;</span><br><span class="line">  <span class="attr">primaryColor</span>: $primary-color</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pages/_app.js</span></span><br><span class="line"><span class="keyword">import</span> variables <span class="keyword">from</span> <span class="string">&quot;../xxx.module.scss&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MyApp</span>(<span class="params">&#123;Component, pageProps&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">color</span>=<span class="string">&#123;variables.primaryColor&#125;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>CSS-in-JS<ul><li>内联样式：<code>&lt;p style=&#123;&#123; color: 'red' &#125;&#125;&gt;内联&lt;/p&gt;</code></li><li>引入<a href="https://github.com/vercel/styled-jsx">styled-jsx</a>以支持作用于隔离的css，支持类似于Web组件的shadow css单不支持服务端渲染且仅支持js</li></ul></li></ul><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ul><li><h3 id="自定义单个共享布局：自己封装想要的布局组件然后应用在全局中"><a href="#自定义单个共享布局：自己封装想要的布局组件然后应用在全局中" class="headerlink" title="自定义单个共享布局：自己封装想要的布局组件然后应用在全局中"></a>自定义单个共享布局：自己封装想要的布局组件然后应用在全局中</h3></li><li><h3 id="多个布局-嵌套布局：自己定义多个布局组件，然后使用getLayout实现，"><a href="#多个布局-嵌套布局：自己定义多个布局组件，然后使用getLayout实现，" class="headerlink" title="多个布局 | 嵌套布局：自己定义多个布局组件，然后使用getLayout实现，"></a>多个布局 | 嵌套布局：自己定义多个布局组件，然后使用getLayout实现，</h3><ul><li>这种布局支持状态持久性，因为React组件书在页面转换之间保持，这个过程叫<code>协调</code>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Layout</span> <span class="keyword">from</span> <span class="string">&#x27;../component/layout&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NestedLayout</span> <span class="keyword">from</span> <span class="string">&#x27;../component/nested-layout&#x27;</span></span><br><span class="line"><span class="comment">// ts引入import type &#123; ReactElement &#125; from &#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts模式给page添加类型ReactElement </span></span><br><span class="line"><span class="title class_">Page</span>.<span class="property">getLayout</span> = <span class="keyword">function</span> <span class="title function_">getLayout</span>(<span class="params">page</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">Layout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">NestedLayout</span>&gt;</span>&#123;page&#125;<span class="tag">&lt;/<span class="name">NestedLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// page/_app.js</span></span><br><span class="line"><span class="comment">// ts模式下需要定义布局类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MyApp</span>(<span class="params">&#123;Component, pageProps&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> getLayout = <span class="title class_">Component</span>.<span class="property">getLayout</span> || (<span class="function"><span class="params">page</span> =&gt;</span> page)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getLayout</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><ul><li>Image组件<code>next/image</code>是HTML元素<code>&lt;img/&gt;</code>的扩展</li><li>使用图像组件：import Image from ‘next&#x2F;image’， <code>&lt;Image src=&#123;&#125; /&gt;</code></li></ul><h3 id="本地图像"><a href="#本地图像" class="headerlink" title="本地图像"></a>本地图像</h3><ul><li>要先引入，使用import，next将根据导入的文件自动确定图像的width和height</li></ul><h3 id="远程映像：需要提供src、width、height、alt"><a href="#远程映像：需要提供src、width、height、alt" class="headerlink" title="远程映像：需要提供src、width、height、alt"></a>远程映像：需要提供src、width、height、alt</h3><h3 id="域名：访问远程映像单仍使用内置的next-Image-Optimization-API，则src保留为默认设置"><a href="#域名：访问远程映像单仍使用内置的next-Image-Optimization-API，则src保留为默认设置" class="headerlink" title="域名：访问远程映像单仍使用内置的next Image Optimization API，则src保留为默认设置"></a>域名：访问远程映像单仍使用内置的next Image Optimization API，则src保留为默认设置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">images</span>: &#123;</span><br><span class="line">    <span class="comment">// 这个地址是远程映像的图片的绝对地址</span></span><br><span class="line">    <span class="attr">domains</span>: [<span class="string">&#x27;examplae.com&#x27;</span>, <span class="string">&#x27;example2.com&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先权：’priority’添加到图像中，成为每个页面的最大内容绘制-LCP-元素"><a href="#优先权：’priority’添加到图像中，成为每个页面的最大内容绘制-LCP-元素" class="headerlink" title="优先权：’priority’添加到图像中，成为每个页面的最大内容绘制(LCP)元素"></a>优先权：’priority’添加到图像中，成为每个页面的最大内容绘制(LCP)元素</h3><ul><li>LCP 元素通常是页面视口中可见的最大图像或文本块</li></ul><h3 id="图像大小调整"><a href="#图像大小调整" class="headerlink" title="图像大小调整"></a>图像大小调整</h3><ul><li>自动： 使用静态导入</li><li>显式地：通过包含<code>height</code>和<code>width</code></li><li>隐式地：通过使用<code>layout=&quot;fill&quot;</code>,使图像展开填充父元素</li><li><h3 id="不知道图像大小的情况下调整"><a href="#不知道图像大小的情况下调整" class="headerlink" title="不知道图像大小的情况下调整"></a>不知道图像大小的情况下调整</h3><ul><li>使用<code>layout=&quot;fill&quot;</code>,使用fill、contain或cover的objectFit属性以及objectPosition属性来定义</li><li>规范化图像：自己做的图，自己规范图像大小</li><li>修改API调用</li><li>如果以上都不适用，则将按照<code>&lt;img /&gt;</code>元素的标准在页面上运行</li></ul></li></ul><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul><li>建议对内部<code>&lt;img&gt;</code>设置样式的方法是将Image组件上的className设置为导入的CSS模块的值。className的值将自动应用于基础的<code>&lt;img&gt;</code>元素。</li><li>当使用<code>layout=&#39;fill&#39;</code>时，父元素必须具有<code>position:relative</code>(必要的)</li><li>当使用<code>layout=&#39;responsive&#39;</code>时，父元素必须具有<code>display:block</code>(div的默认值，应另行指定)</li></ul><h2 id="字体优化"><a href="#字体优化" class="headerlink" title="字体优化"></a>字体优化</h2><ul><li>第一内容绘制（FCP）和最大内容绘制（LCP）</li><li>使用：<code>import Head from &#39;next/head&#39;</code></li><li>要添加web字体，使用<code>&lt;Head&gt;&lt;/Head&gt;</code>包裹</li><li>如果不想要优化，在next.config.js中设置<code>optimizeFonts: false</code></li></ul><h2 id="脚本组件"><a href="#脚本组件" class="headerlink" title="脚本组件"></a>脚本组件</h2><ul><li>脚本组件<code>next/script</code>是HTML元素<code>&lt;script&gt;</code>的扩展</li><li>使用：<code>import Script from &#39;next/script&#39;</code>， <code>&lt;Script src=&quot;第三方路径&quot; strategy=&quot;策略属性&quot; /&gt;</code></li></ul><h3 id="strategy：决定何时加载第三方脚本"><a href="#strategy：决定何时加载第三方脚本" class="headerlink" title="strategy：决定何时加载第三方脚本"></a>strategy：决定何时加载第三方脚本</h3><ul><li>beforeInteractive:在页面交互之前加载</li><li>afterInteractive：（默认）：在页面变成交互式后立即加载</li><li>lazyOnload:在空闲时间加载</li><li><h3 id="beforeInteractive"><a href="#beforeInteractive" class="headerlink" title="beforeInteractive"></a>beforeInteractive</h3><ul><li>从服务器注入到初始HTML中，并在执行自绑定JavaScript之前运行。</li><li>此策略应用于在<code>页面交互之前需要获取和执行的任何关键脚本</code></li></ul></li><li><h3 id="afterInteractive"><a href="#afterInteractive" class="headerlink" title="afterInteractive"></a>afterInteractive</h3><ul><li>被注入客户端，并将在Next.js对页面进行水合后运行。</li><li>这种策略应该用于<code>不需要尽快加载的脚本，并且可以在页面交互后立即获取和执行</code>。</li><li><h3 id="lazyOnload"><a href="#lazyOnload" class="headerlink" title="lazyOnload"></a>lazyOnload</h3><ul><li>在获取所有资源后以及空闲时间内加载较晚。</li><li>此策略应用于<code>后台或低优先级脚本</code>，这些脚本不需要在页面交互之前或之后立即加载。</li></ul></li></ul></li></ul><h3 id="内联脚本"><a href="#内联脚本" class="headerlink" title="内联脚本"></a>内联脚本</h3><ul><li>使用：将javascript放在{}中编写 或者在标签上使用<code>dangerouslySetInnerHTML</code>属性，但必须定义id属性</li><li>只能策略属性<code>不为beforeInteractive</code>时才能使用</li></ul><h3 id="加载后执行代码-onLoad"><a href="#加载后执行代码-onLoad" class="headerlink" title="加载后执行代码(onLoad)"></a>加载后执行代码(onLoad)</h3><ul><li>策略属性<code>不为lazyOnload</code>,都可以在加载后在标签上使用onLoad属性来执行代码</li></ul><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><h3 id="静态文件服务"><a href="#静态文件服务" class="headerlink" title="静态文件服务"></a>静态文件服务</h3><ul><li>将静态文件存放到根目录下的<code>public</code>目录中，并对外提供访问。public目录下的存放的静态文件对外访问路径yi<code>/</code>为起始路径，如”&#x2F;xxx.png”</li><li>要确保pages&#x2F;下的文件于静态文件无重名</li></ul><h3 id="快速刷新"><a href="#快速刷新" class="headerlink" title="快速刷新"></a>快速刷新</h3><ul><li>尝试在两次编辑之间保留零部件的状态。只要不更改参数或Hook调用的顺序，useState和useRef就会保留以前的值。</li><li>具有依赖关系的钩子将始终在快速刷新期间更新。在进行快速刷新时，依赖项列表将被忽略。</li><li>即使是空依赖项数组的useEffect，在快速刷新期间仍会重新运行一次。</li></ul><h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><ul><li>安装：<code>npm run lint</code></li><li>然后配置</li></ul><h2 id="路由-next-version-13"><a href="#路由-next-version-13" class="headerlink" title="路由  next version 13+"></a>路由  next version 13+</h2><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><ul><li><h3 id="App-路由"><a href="#App-路由" class="headerlink" title="App 路由"></a>App 路由</h3><ul><li>app目录和pages目录一起工作，也兼容pages页面的路由，但主要在app页面的路由</li><li><code>App Router的优先级高于Pages Router</code>。</li><li>默认情况下， app内的组件是<a href="#ref4">React服务器组件</a>。性能优化之一</li></ul></li><li><h3 id="路由片段"><a href="#路由片段" class="headerlink" title="路由片段"></a>路由片段</h3><ul><li>路径的<code>每个文件夹</code>代表<code>一个路由片段</code>。每个路线段都映射到网址路径中相应的片段。</li></ul></li><li><h3 id="嵌套路由-就是文件夹相互嵌套"><a href="#嵌套路由-就是文件夹相互嵌套" class="headerlink" title="嵌套路由: 就是文件夹相互嵌套"></a>嵌套路由: 就是文件夹相互嵌套</h3></li><li><h3 id="主机托管"><a href="#主机托管" class="headerlink" title="主机托管"></a>主机托管</h3><ul><li>app目录中可以放自己的文件和特殊文件等，因为只有page.js或route.js返回的内容是可公开寻址的</li><li>特殊文件：.js、.jsx、.tsx文件扩展名可用于特殊文件</li><li>私有文件：文件夹名：_folderName，表示该目录下的文件退出路由</li></ul></li><li><h3 id="高级路由模式"><a href="#高级路由模式" class="headerlink" title="高级路由模式"></a>高级路由模式</h3><ul><li><a href="#ref5">并行路由</a>：允许在同一视图中显示两个会多个可以独立导航的页面</li><li><a href="#ref6">拦截路由</a>：允许拦截一条路线并将其显示在另一条路线的上下文中。</li><li>布局更React差不多，template.js文件用来定义模板，layout.js用来定义布局， 嵌套要使用到children</li></ul></li><li><h3 id="修改"><a href="#修改" class="headerlink" title="修改&lt;head&gt;"></a>修改<code>&lt;head&gt;</code></h3><ul><li>通过到处layout.js或page.js文件中的metadata对象或generateMetadata功能来定义元数据</li></ul></li></ul><h3 id="链接和导航"><a href="#链接和导航" class="headerlink" title="链接和导航"></a>链接和导航</h3><ul><li><h3 id="导航的两种方式："><a href="#导航的两种方式：" class="headerlink" title="导航的两种方式："></a>导航的两种方式：</h3><ul><li>使用<code>&lt;Link href=&quot;“&gt;</code>组件, Link来自<code>&quot;next/link&quot;</code>， 动态可以使用模板字符串语法<ul><li>相当于vue的声明式导航</li><li><a href="https://next.nodejs.cn/docs/app/api-reference/functions/use-pathname/">usePathname</a>:检查链接是否处于活动状态，用于className判断</li><li>滚动到id：在url链接添加#id</li><li>禁用滚动恢复：添加属性scroll&#x3D;{false}，默认滚动</li></ul></li><li>使用<a href="https://next.nodejs.cn/docs/app/api-reference/functions/use-router/">useRouter 钩子</a><ul><li>相当于vue的编程式导航,</li><li><code>import &#123; useRouter, usePathname &#125; from &quot;next/navigation&quot;</code></li><li><code>const router = useRouter()</code></li><li><code>router.push(&#39;/dashboard&#39;, &#123; scroll: false &#125;)</code></li></ul></li></ul></li><li><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3></li></ul><ol><li>预请求: 用户访问路由之前在后台预加载路由的方法<ul><li><code>&lt;Link&gt;</code>组件：自动预取。静态<code>prefetch</code>默认为true，动态<code>prefetch</code>默认自动，只有共享布局向下直到为<code>30s</code>，预取并缓存第一个loading.js文件。可以显示即时加载状态。</li><li><code>router.prefetch()</code>: <code>useRouter</code>钩子编程式预取路由</li><li>预取在开发中不启用，仅在生产中启用</li></ul></li><li>缓存： Next有一个内存中客户端缓存，称为<code>路由缓存</code>。 当用户在app中导航时，prefetched路线段和访问过的路线的React Server组件有效负载将存储在缓存中。</li><li>部分渲染：仅在客户端上重新渲染导航时发生变化的路线段，并且保留所有共享段<ul><li>就是在同一文件夹下的不同文件不同路径，切换只渲染对应文件而不影响整体的文件</li></ul></li><li>软导航：仅渲染已更改的片段，同时保留 React 和浏览器状态，并且不会重新加载整个页面。<ul><li>默认，浏览器执行硬导航</li></ul></li><li>后退和前进导航<ul><li>默认，将保持向后和向前导航的滚动位置，并重用路由缓存中的路线段。</li></ul></li></ol><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul><li>在文件名称括上方括号（[folderName]）</li><li>动态端作为params属性将传递给layout、page、route和generateMetadata函数</li><li><h3 id="生成静态参数"><a href="#生成静态参数" class="headerlink" title="生成静态参数"></a>生成静态参数</h3><ul><li>generateStaticParams在构建时预动态路线段至静态生成路由结合起来</li><li>优点：智能检索数据</li></ul></li><li><h3 id="捕获所有片段-通过在方括号使用-folderName"><a href="#捕获所有片段-通过在方括号使用-folderName" class="headerlink" title="捕获所有片段: 通过在方括号使用[...folderName]"></a>捕获所有片段: 通过在方括号使用<code>[...folderName]</code></h3></li><li><h3 id="可选的包罗万象的段：-folderName"><a href="#可选的包罗万象的段：-folderName" class="headerlink" title="可选的包罗万象的段：[[...folderName]],"></a>可选的包罗万象的段：<code>[[...folderName]]</code>,</h3><ul><li>与捕获所有片段的区别：如果带可选参数，则不带参数的路由也会被匹配</li></ul></li></ul><h3 id="加载-UI-和流式传输"><a href="#加载-UI-和流式传输" class="headerlink" title="加载 UI 和流式传输"></a>加载 UI 和流式传输</h3><ul><li><h3 id="即时加载状态-后备UI"><a href="#即时加载状态-后备UI" class="headerlink" title="即时加载状态(后备UI)"></a>即时加载状态(后备UI)</h3><ul><li>在导航时立即显示</li><li>在文件加中创建loading.js，并嵌套在统一文件夹中的layout.js内。会自动将page.js文件和下面的所有子文件封装在<code>&lt;Suspense&gt;</code>边界中。</li><li>即使使用 以服务器为中心的路由，导航也是即时的。</li></ul></li><li><h3 id="使用-Suspense-的流式-自己看文档"><a href="#使用-Suspense-的流式-自己看文档" class="headerlink" title="使用 Suspense 的流式 自己看文档"></a>使用 Suspense 的流式 自己看文档</h3></li></ul><h3 id="错误处理error-js-文件"><a href="#错误处理error-js-文件" class="headerlink" title="错误处理error.js 文件"></a>错误处理error.js 文件</h3><ul><li>自动创建 React 误差边界、wraps 嵌套子段或 page.js 组件。</li><li>从 error.js 文件导出的 React 组件用作 fallback 组件。</li><li>如果在错误边界内抛出错误，则错误为 contained，回退组件为 rendered。</li><li>当回退错误组件处于活动状态时，布局 above 错误边界 maintain 其状态和 remain 交互，并且错误组件可以显示从错误中恢复的功能。</li><li><h3 id="从错误中恢复"><a href="#从错误中恢复" class="headerlink" title="从错误中恢复"></a>从错误中恢复</h3><ul><li>重试</li><li>使用reset()函数</li></ul></li><li><h3 id="处理布局中的错误"><a href="#处理布局中的错误" class="headerlink" title="处理布局中的错误"></a>处理布局中的错误</h3><ul><li>error.js边界<code>不捕获``同一段</code>的layout.js或template.js组件中抛出的错误</li><li>处理特定布局或模板的错误： 将error.js文件放置在布局的父段</li><li>处理根布局或模板的错误： 使用global-error.js</li></ul></li><li><h3 id="处理根布局中的错误"><a href="#处理根布局中的错误" class="headerlink" title="处理根布局中的错误"></a>处理根布局中的错误</h3><ul><li>根app&#x2F;error.js边界不捕获根app&#x2F;layout.js或app&#x2F;template.js组件中抛出的错误</li><li>处理： 使用文娱根app目录中的global-error.js</li><li>global-error.js错误边界封装entire应用，并且其后被组件在活动时替换根布局</li><li>即使定义了global-error.js，仍建议定义一个根error.js其后背组件将渲染within根布局</li></ul></li></ul><h3 id="并行路由"><a href="#并行路由" class="headerlink" title="并行路由"></a><p id="ref5">并行路由</p></h3><ul><li>允许同时或有条件地在同一布局中渲染一个或多个页面。允许根据条件渲染插槽</li><li>插槽：使用slots创建并行路由，按照@folder约定定义的，并作为props传递到同一级别的布局</li><li>children属性是一个隐式插槽，不需要映射到文件夹。即app&#x2F;page.js &#x3D;&#x3D;&#x3D; app&#x2F;@children&#x2F;page.js</li><li><h3 id="未匹配的路由-default-js"><a href="#未匹配的路由-default-js" class="headerlink" title="未匹配的路由 default.js"></a>未匹配的路由 default.js</h3><ul><li>默认情况下槽内渲染的内容将于当前URL匹配</li><li>在插槽文件夹下在新建default.js作为后备渲染</li></ul></li><li><h3 id="useSelectedLayoutSegment-s"><a href="#useSelectedLayoutSegment-s" class="headerlink" title="useSelectedLayoutSegment(s)"></a>useSelectedLayoutSegment(s)</h3><ul><li>都接收 parallelRoutesKey，它允许你读取该槽内的活动航路段。</li><li>当用户导航到 URL 栏中的 @auth&#x2F;login 或 &#x2F;login 时，loginSegments 将等于字符串 “login”</li></ul></li></ul><h3 id="拦截路由"><a href="#拦截路由" class="headerlink" title="拦截路由"></a><p id="ref6">拦截路由</p></h3><ul><li>允许从当前布局内应用的其他部分加载路由。</li><li>使用<code>(...)</code>来定义,在文件夹的名称哪里添加，类似于相对路径..&#x2F;,约定基于路由段<ul><li><code>(.)</code>: 匹配<code>同一水平</code>上的段</li><li><code>(..)</code>: 匹配<code>高一级</code>的段</li><li><code>(..)(..)</code>: 匹配<code>上面两级</code>的段</li><li><code>(...)</code>: 匹配root app目录中的段</li></ul></li></ul><h3 id="路由处理程序"><a href="#路由处理程序" class="headerlink" title="路由处理程序"></a>路由处理程序</h3><ul><li>使用 Web 请求 和 响应 API 为给定路由创建自定义请求处理程序</li><li>仅在 app 目录中可用,相当于 pages 目录中的 API 路由，<br> 在app目录内的<code>route.js|ts</code>文件中定义<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> dynamic = <span class="string">&quot;force-dynamic&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">GET</span>(<span class="params">request: Request</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>支持的HTTP方法：GET、POST、PUT、PATCH、DELETE、HEAD 和 OPTIONS</li><li>扩展API：<code>NextRequest</code> 和 <code>NextResponse</code></li><li><h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><ul><li>缓存<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">GET</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;searchParams&#125; = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>)<span class="comment">// 将Request对象与GET方法一起使用时存在</span></span><br><span class="line">  <span class="keyword">const</span> id = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;id&#x27;</span>) <span class="comment">// 将Request对象与GET方法一起使用时存在</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://data.mogodb.api.com/product/<span class="subst">$&#123;id&#125;</span>`</span> &#123;</span><br><span class="line">    <span class="attr">methods</span>: <span class="string">&#x27;POST&#x27;</span> <span class="comment">// post方法的情况存在</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;API-Key&#x27;</span>: process.<span class="property">env</span>.<span class="property">DATA_API_KEY</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Data</span>().<span class="title function_">toISOString</span>() &#125;) <span class="comment">// post方法的情况存在</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>(</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Response</span>.<span class="title function_">json</span>(&#123;data&#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>选择退出缓存<ul><li>将Request对象与GET方法一起使用</li><li>使用任何其它HTTP方法</li><li>像使用cookies和headers一样使用动态函数</li><li><code>片段配置选项</code>手动指定动态模式</li></ul></li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li>在缓存内容和路由匹配之前运行</li><li>使用项目根目录中的文件middleware.ts|js来定义中间件</li></ul><h2 id="数据获取-1"><a href="#数据获取-1" class="headerlink" title="数据获取"></a>数据获取</h2><h3 id="数据获取、缓存和重新验证"><a href="#数据获取、缓存和重新验证" class="headerlink" title="数据获取、缓存和重新验证"></a>数据获取、缓存和重新验证</h3><ul><li>四种方式获取数据<ul><li>在服务器上，使用fetch</li><li>在服务器上，带有第三方库</li><li>在客户端上，通过路由处理程序</li><li>在客户端，使用第三方库</li></ul></li><li><h3 id="在服务器上，使用fetch"><a href="#在服务器上，使用fetch" class="headerlink" title="在服务器上，使用fetch"></a>在服务器上，使用fetch</h3><ul><li>可以在服务器组件、路由处理程序 和 服务器操作 中将 fetch 与 async&#x2F;await 一起使用</li><li>在路由处理程序中，fetch 请求不会被记忆，因为路由处理程序不是 React 组件树的一部分。</li></ul></li><li><h3 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h3><ul><li>默认情况下， 会自动将fetch的返回值缓存到服务器上的数据缓存</li><li>数据缓存是持久的HTTP缓存。根据你的平台，缓存可以自动扩展并达到跨多个区域共享</li></ul></li><li><h3 id="重新验证数据"><a href="#重新验证数据" class="headerlink" title="重新验证数据"></a>重新验证数据</h3></li><li>是清除数据缓存并重新获取最新数据的过程。当数据变化时要确保显示最新数据时非常有用</li><li>两种方式：<ul><li><code>基于时间的重新验证</code>：定时更新。用于不经常更改且不重要的数据<ul><li>使用fetch的<code>next.revalidate</code>选项来设置资源的缓存生命周期</li><li><code>fetch(&quot;heeps://...&quot;,&#123; next: &#123; revalidate: 3600&#125;&#125;)</code></li></ul></li><li><code>按需重新验证</code>：根据时间手动重新验证数据。</li></ul></li><li>数据可以通过路径(revalidatePath)或通过<code>服务器动作</code>或<code>路由处理程序</code>内的缓存标签 (revalidateTag)按需重新验证</li><li>next 有一个缓存标记系统，用于使跨路由的fetch请求无效</li></ul><ol><li>使用fetch时，可以选择使用一个或多个标签来标记缓存条目<ul><li>fetch(‘https:&#x2F;&#x2F;…’, {next: {tags: [‘collection’]}})</li></ul></li><li>然后，调用revalidateTag来重新验证与改标签关联的条目<ul><li>import { revalidateTag } from ‘next&#x2F;cache’</li><li>export default async function action() { revalidateTag(‘collection’)}</li></ul></li></ol><ul><li><h3 id="选择退出数据缓存"><a href="#选择退出数据缓存" class="headerlink" title="选择退出数据缓存"></a>选择退出数据缓存</h3><ul><li>满足以下条件，则 fetch 请求将被缓存 not</li><li>cache: ‘no-store’ 添加到 fetch 请求中。个人</li><li>revalidate: 0 选项添加到各个 fetch 请求中。</li><li>fetch 请求位于使用 POST 方法的路由处理程序内部。</li><li>fetch 请求在使用 headers 或 cookies 之后出现。</li><li>使用 const dynamic &#x3D; ‘force-dynamic’ 航路段选项。</li><li>fetchCache 路由段选项默认配置为跳过缓存。</li><li>fetch 请求使用 Authorization 或 Cookie 标头，并且组件树中其上方有一个未缓存的请求。</li></ul></li></ul><h3 id="数据获取模式"><a href="#数据获取模式" class="headerlink" title="数据获取模式"></a>数据获取模式</h3><ol><li>在服务器上获取数据</li><li>在需要的地方获取数据： 在在数据组件使用fetch或react cache。因为fetch会自动记忆</li><li>流式(Streaming)和 悬念(Suspense) ：逐步渲染UI并将其增量流式传输到客户端</li><li>并行和顺序数据获取<ul><li>使用<code>顺序数据获取</code>，路由中的请求相互依赖，因此会创建瀑布。当因为一次提取取决于另一次提取的结果，或者希望在下一次提取之前满足某个条件以节省资源的情况使用。类似于react从布局中单独拎其中一个布局渲染完在回到原布局。</li><li>使用<code>并行数据获取</code>，路由中的请求会立即发起，同时加载数据。就是两个函数同时请求完然后布局在调用</li></ul></li><li>预加载数据<ul><li>创建<code>preload</code>函数。不必将Promise作为props传递下去。preload函数是一种模式，名字可自定义</li><li><code>export const preload = (id: string) =&gt; &#123;void getItem(id) // 预加载的函数API &#125;</code></li><li>然后在正常请求这个API(getItem)，最后页面函数直接调用preload即可</li></ul></li><li>使用 React cache、server-only 和预加载模式<ul><li>通过这种方法，可以与获取数据，缓存响应，并保证此数据获取只发生在服务器上<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; cache &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;server-only&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">preload</span> = (<span class="params">id: string</span>) =&gt; &#123; <span class="keyword">void</span> <span class="title function_">getItem</span>(id) &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getItem = <span class="title function_">cache</span>(<span class="title function_">async</span>(<span class="attr">id</span>: string) =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="形式和突变"><a href="#形式和突变" class="headerlink" title="形式和突变"></a>形式和突变</h3><ul><li><h3 id="仅服务器表单"><a href="#仅服务器表单" class="headerlink" title="仅服务器表单"></a>仅服务器表单</h3><ul><li>在函数顶部使用”use server”</li></ul></li><li><h3 id="重新验证数据-1"><a href="#重新验证数据-1" class="headerlink" title="重新验证数据"></a>重新验证数据</h3><ul><li>使用<code>revalidatePath(&#39;/&#39;)</code>使整个路线段失效或使用<code>revalidateTag()</code>使带有缓存标记的特定数据失效</li></ul></li><li><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul><li>使用<code>redirect(url)</code></li></ul></li><li><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><ul><li>使用required和type&#x3D;”email”等HTML验证进行基本表单验证</li></ul></li><li><h3 id="显示加载状态"><a href="#显示加载状态" class="headerlink" title="显示加载状态"></a>显示加载状态</h3><ul><li>当表单在服务器上提交时，使用<code>useFormStatus()</code>显示加载状态，只能用作服务器操作的form元素的子元素</li></ul></li><li><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>请求时一起返回</li></ul></li><li><h3 id="乐观的更新"><a href="#乐观的更新" class="headerlink" title="乐观的更新"></a>乐观的更新</h3><ul><li>使用<code>useOptimistic(messages,(state,newMessage) =&gt; [...state, &#123;message:newMessage&#125;])</code>在服务器操作完成之前乐观地更新 UI</li></ul></li><li><h3 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h3><ul><li>cookies().set(key,val)</li></ul></li><li><h3 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h3><ul><li>cookies().get(key)?.value</li></ul></li><li><h3 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h3><ul><li>cookies().delete(key)</li></ul></li></ul><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h3 id="服务器组件"><a href="#服务器组件" class="headerlink" title="服务器组件"></a><p id="ref4">服务器组件</p></h3><ul><li>三种不同的服务器渲染策略：<ul><li>静态渲染</li><li>动态渲染</li><li>流式</li></ul></li><li>优点：<ul><li>数据获取： 减少渲染所用时间及客户端发出的请求量 </li><li>安全</li><li>缓存： 可以重用</li><li>打包尺寸：对网速慢或设备差的用户有益</li><li>初始页面加载和首次内容绘制FCP：可以生成用户立即查看的页面</li><li>搜索引擎优化和社交网络共享性</li><li>流式：渲染分多块，按块渲染</li></ul></li></ul><h3 id="服务器组件是如何渲染的？"><a href="#服务器组件是如何渲染的？" class="headerlink" title="服务器组件是如何渲染的？"></a>服务器组件是如何渲染的？</h3><ul><li>渲染工作被分成几个块： <code>按个别路线段</code>和<code>悬念边界</code>，每个块都分两步渲染：</li><li>React将服务器组件渲染为一种称为<code>React服务器组件有效负载(RSC 有效负载)</code>的特殊数据格式。</li><li>Next.js 使用 RSC 有效负载和客户端组件 JavaScript 指令在服务器上呈现 HTML。</li><li>然后，在客户端：<ul><li>HTML用于立即显示路线的快速非交互式预览</li><li>React服务器组件有效负载用于协调客户端和服务器组件树，并更新DOM</li><li>JavaScript指令用于hydrate客户端组件并使应用具有交互性</li></ul></li><li><h3 id="静态渲染-默认"><a href="#静态渲染-默认" class="headerlink" title="静态渲染(默认)"></a>静态渲染(默认)</h3><ul><li>路线在构建时间渲染或在数据重新验证之后在后台验证。结果被缓存并可以推送到内容分发网络CDN</li><li>适用：已知内容</li></ul></li><li><h3 id="动态渲染"><a href="#动态渲染" class="headerlink" title="动态渲染"></a>动态渲染</h3><ul><li>在请求时间处为每个用户渲染路线</li><li>适用：个性化数据和仅在请求时才能直到的信息</li></ul></li></ul><h3 id="客户端组件"><a href="#客户端组件" class="headerlink" title="客户端组件"></a>客户端组件</h3><ul><li>在请求时在客户端上渲染交互式UI</li><li>优点：<ul><li>互动性: 客户端组件可以适用状态、效果和事件监听器，意味着可以向用户踢狗即时反馈并更新UI</li><li>浏览器API：客户端组件可以访问浏览器API</li></ul></li><li>使用： 在文件顶部添加<code>&quot;use client&quot;</code>,声明服务器和客户端组件模块之间的boundary</li><li><h3 id="客户端组件时如何渲染的？"><a href="#客户端组件时如何渲染的？" class="headerlink" title="客户端组件时如何渲染的？"></a>客户端组件时如何渲染的？</h3><ul><li>整页加载<ul><li>在服务器上：<ol><li>React 将服务器组件渲染为一种称为 React 服务器组件有效负载（RSC 有效负载） 的特殊数据格式，其中包括对客户端组件的引用。</li><li>Next.js 使用 RSC 有效负载和客户端组件 JavaScript 指令在服务器上呈现路由的 HTML。</li></ol></li><li>然后，在客户端：<ol><li>HTML 用于立即显示路线的快速非交互式初始预览。</li><li>React 服务器组件有效负载用于协调客户端和服务器组件树，并更新 DOM。</li><li>JavaScript 指令用于 hydrate 客户端组件并使其 UI 具有交互性。</li></ol></li></ul></li><li>后续导航<ul><li>在后续导航中，客户端组件完全在客户端上渲染，而不需要服务器渲染的 HTML。</li></ul></li></ul></li><li>这意味着客户端组件 JavaScript 包已下载并解析。 一旦包准备好，React 将使用 RSC Payload 来协调客户端和服务器组件树，并更新 DOM。</li></ul><h3 id="服务器和客户端组合模式"><a href="#服务器和客户端组合模式" class="headerlink" title="服务器和客户端组合模式"></a>服务器和客户端组合模式</h3><ul><li><h3 id="服务器组件模式"><a href="#服务器组件模式" class="headerlink" title="服务器组件模式"></a>服务器组件模式</h3><ul><li>组件之间共享数据</li><li>将仅服务器代码排除在客户端环境之外</li><li>使用第三方软件包和提供商</li></ul></li><li><h3 id="客户端组件-1"><a href="#客户端组件-1" class="headerlink" title="客户端组件"></a>客户端组件</h3><ul><li>将客户端组件移至树下</li><li>将属性从服务器传递到客户端组件（序列化）</li></ul></li><li><h3 id="交错服务器和客户端组件"><a href="#交错服务器和客户端组件" class="headerlink" title="交错服务器和客户端组件"></a>交错服务器和客户端组件</h3><ul><li>不支持的模式：将服务器组件导入客户端组件</li><li>支持的模式：将服务器组件作为 Props 传递给客户端组件<ul><li>使用 React children 属性在客户端组件中创建 “slot”。</li></ul></li></ul></li></ul><h3 id="Edge-和-Node-js-运行时"><a href="#Edge-和-Node-js-运行时" class="headerlink" title="Edge 和 Node.js 运行时"></a><a href="https://next.nodejs.cn/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes">Edge 和 Node.js 运行时</a></h3><ul><li>Node.js 运行时（默认）可以访问生态系统中的所有 Node.js API 和兼容包。</li><li>Edge 运行时 是基于 网络 API 的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;优点：&quot;&gt;&lt;a href=&quot;#优点：&quot; class=&quot;headerlink&quot; title=&quot;优点：&quot;&gt;&lt;/a&gt;优点：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;直观的、 &lt;code&gt;基于页面&lt;/code&gt;的路由系统（并支持&lt;code&gt;动态路由&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="前端工程化工具" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Mobx库</title>
    <link href="http://example.com/2024/11/01/Engineering/mobx%E5%BA%93/"/>
    <id>http://example.com/2024/11/01/Engineering/mobx%E5%BA%93/</id>
    <published>2024-11-01T08:52:16.683Z</published>
    <updated>2024-11-01T09:04:36.900Z</updated>
    
    <content type="html"><![CDATA[<ul><li>自动获取源自应用state的数据</li><li>机制：事件调用actions，使用actions来修改state，然后自动更新，更新的值会触发对应的值变化</li><li>安装：<a href="https://cn.mobx.js.org/">mobx的介绍</a></li><li>搭档：React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而MobX提供机制来存储和更新应用状态供 React 使用。</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><a href="#ref1">Observable state(可观察的状态)</a></li><li><a href="#ref2">Computed values(计算值)</a></li><li><a href="#ref3">React组件-@observer</a></li><li><a href="#ref4">Reactions(反应)</a></li><li><a href="#ref5">Actions(动作)</a></li><li>自定义reactions<ul><li>使用<a href="#ref6">autorun</a>、<a href="#ref7">reaction</a>和<a href="#ref8">when</a>来创建</li></ul></li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>简单，可扩展</li><li>保证参照完整性</li><li>高效</li></ul><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>将应用变成响应式的三个步骤<ul><li>定义状态并使其可观察<ul><li>使用observable</li></ul></li><li>创建视图以响应状态的变化<ul><li>使用@observer</li></ul></li><li>更改状态</li></ul></li></ul><h2 id="observable"><a href="#observable" class="headerlink" title="observable"></a><b id="ref1" style="color: green">observable</b></h2><ul><li>定义：使用<code>@observable</code>装饰器给现有的数据结构添加<code>可观察功能</code></li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li><p>observable(value)</p></li><li><p>@observable classProperty &#x3D; value</p></li><li><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><ul><li><code>Map</code>: 会返回一个新的Observable Map<ul><li>eg：const map &#x3D; observable.map({ key: “value”});map.set(“key”, “new value”);</li></ul></li><li><code>数组</code>：会返回一个Observable Array<ul><li>eg：const list &#x3D; observable([1,2,3])</li></ul></li><li><code>没有原型的对象</code>： 会被克隆并且所有属性都会被转换成可观察的<ul><li>eg:</li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title function_">observable</span>(&#123;</span><br><span class="line"><span class="comment">// 观察的属性</span></span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="string">&#x27;23&#x27;</span>,</span><br><span class="line"><span class="attr">show</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// 计算属性</span></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">labelText</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">show</span> ? <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> age: <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span> : <span class="variable language_">this</span>.<span class="property">name</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 动作</span></span><br><span class="line"><span class="title function_">setAge</span>(<span class="params">age</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">setAge</span>: action</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">autorun</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">labelTExt</span>))</span><br></pre></td></tr></table></figure><ul><li><code>有原型的对象</code>(原值类型值和引用类型值)：会返回一个Boxed Observable。在构造函数中使用extendObservable 或在类中使用@observable<ul><li>使用<code>.get()</code>可以<code>获取当前值</code>，使用<code>.set()</code>可以<code>更新值</code>，使用<code>antorun(()=&gt;&#123;&#125;)</code>来<code>监听</code>追踪值的<code>更改</code></li><li>eg： const temperature &#x3D; observable.box(20);temperature.set(25)</li></ul></li></ul><h3 id="decorators"><a href="#decorators" class="headerlink" title="decorators"></a>decorators</h3><ul><li>不使用observable，然后单独使用decorate来另外定义<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">name = <span class="string">&quot;John&quot;</span></span><br><span class="line">age = <span class="number">42</span></span><br><span class="line">showAge = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">labelText</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">showAge</span> ? <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> (age: <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>)`</span> : <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setAge</span>(<span class="params">age</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 decorate 时，所有字段都应该指定</span></span><br><span class="line"><span class="title function_">decorate</span>(<span class="title class_">Person</span>, &#123;</span><br><span class="line"><span class="attr">name</span>: observable,</span><br><span class="line"><span class="attr">age</span>: observable,</span><br><span class="line"><span class="attr">showAge</span>: observable,</span><br><span class="line"><span class="attr">labelText</span>: computed,</span><br><span class="line"><span class="attr">setAge</span>: action</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="computed"><a href="#computed" class="headerlink" title="(@)computed"></a><b id="ref2" style="color: green">(@)computed</b></h2><ul><li>定义：使用<code>@computed</code>装饰器或<code>(extend)Observable时调用的getter/setter</code>函数来<code>定义</code>数据发生变化时<code>自动更新的值</code></li></ul><h3 id="computed-与-autorun-的区别"><a href="#computed-与-autorun-的区别" class="headerlink" title="@computed 与 autorun 的区别"></a>@computed 与 autorun 的区别</h3><ul><li>@computed：响应式调用的表达式，响应式的产生一个可以被其它observer使用的值</li><li>autorun：响应式调用的表达式，与@computed区别，不产生新值，只想要效果</li></ul><h3 id="getter-与-setter"><a href="#getter-与-setter" class="headerlink" title="getter 与 setter"></a>getter 与 setter</h3><ul><li>正常情况下的示例：@computed get total(){ retuan this.price * this.amount}</li><li>正常情况下setter也不需要注解，因为是一个自动的动作</li><li>setter不能用来直接改变计算属性的值，但是可以用来逆向衍生</li><li><code>永远在getter之后定义setter</code></li><li>observable.object 和 extendObservable 都会自动将 getter 属性推导成计算属性,所以这两种情况不用添加装饰器<ul><li>示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> orderLine = observable.<span class="title function_">object</span>(&#123;</span><br><span class="line"><span class="attr">price</span>:<span class="number">0</span>，</span><br><span class="line"><span class="attr">amount</span>:<span class="number">1</span>,</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">total</span>() &#123;</span><br><span class="line">retuan <span class="variable language_">this</span>.<span class="property">price</span> * <span class="variable language_">this</span>.<span class="property">amount</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">total</span>(<span class="params">total</span>) &#123; </span><br><span class="line"><span class="comment">// 从total中推导出price</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">price</span> = total / <span class="variable language_">this</span>.<span class="property">amount</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="computed-expression-函数-不常用"><a href="#computed-expression-函数-不常用" class="headerlink" title="computed(expression) 函数(不常用)"></a>computed(expression) 函数(不常用)</h3><ul><li>使用场合：传递一个“在<code>observable.box</code>中”的计算值</li><li>示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable, computed&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> name = observable.<span class="title function_">box</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> upperCaseName = <span class="title function_">computed</span>(<span class="function">() =&gt;</span></span><br><span class="line">    name.<span class="title function_">get</span>().<span class="title function_">toUpperCase</span>()</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> disposer = upperCaseName.<span class="title function_">observe</span>(<span class="function"><span class="params">change</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(change.<span class="property">newValue</span>));</span><br><span class="line">name.<span class="title function_">set</span>(<span class="string">&quot;Dave&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="第二参数对象的可选参"><a href="#第二参数对象的可选参" class="headerlink" title="第二参数对象的可选参"></a>第二参数对象的可选参</h3><ul><li>name：字符串, 在 spy 和 MobX 开发者工具中使用的调试名称</li><li>context：在提供的表达式中使用的 this</li><li>set：要使用的setter函数。</li><li>equals：比较前一个值和后一个值的函数，相等不评估</li><li>requiresReaction：推荐为true</li><li>keepAlive：慎用，会造成内存泄露</li><li></li></ul><h3 id="内置比较器"><a href="#内置比较器" class="headerlink" title="内置比较器"></a>内置比较器</h3><ul><li>comparer.identity: 使用恒等 (&#x3D;&#x3D;&#x3D;) 运算符来判定两个值是否相同。</li><li>comparer.default: 等同于 comparer.identity，但还认为 NaN 等于 NaN 。</li><li>comparer.structural: 执行深层结构比较以确定两个值是否相同。</li></ul><h2 id="Autorun-自定义reactions"><a href="#Autorun-自定义reactions" class="headerlink" title="Autorun(自定义reactions)"></a><b id="ref6" style="color:green">Autorun(自定义reactions)</b></h2><h3 id="第二参数对象的可选参-1"><a href="#第二参数对象的可选参-1" class="headerlink" title="第二参数对象的可选参"></a>第二参数对象的可选参</h3><ul><li>delay：对reaction函数去抖动的数字，默认为0不抖动，以毫秒为单位</li><li>name：字符串，用于在例如spy事件中用作reaction的名称</li><li>onError： 处理reaction的错误</li><li>scheduler：设置自定义调度器已决定如何调度autorun函数的重新运行</li></ul><h2 id="When-自定义reactions"><a href="#When-自定义reactions" class="headerlink" title="When(自定义reactions)"></a><b id="ref8" style="color:green">When(自定义reactions)</b></h2><ul><li>语法：when(predicate: () &#x3D;&gt; boolean, effect?: () &#x3D;&gt; void, options?)</li><li>when 观察并运行给定的 predicate，直到返回true。 一旦返回 true，给定的 effect 就会被执行，然后 autorunner(自动运行程序) 会被清理。 该函数返回一个清理器以提前取消自动运行程序。</li></ul><h3 id="when-promise"><a href="#when-promise" class="headerlink" title="when-promise"></a>when-promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不提供effect返回一个promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">when</span>(<span class="function">() =&gt;</span> that.<span class="property">isVisible</span>)</span><br><span class="line">    <span class="comment">// 等等..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reaction-自定义reactions"><a href="#Reaction-自定义reactions" class="headerlink" title="Reaction(自定义reactions)"></a><b id="ref7" style="color:green">Reaction(自定义reactions)</b></h2><ul><li>antorun的变种，与anturun的区别，<code>创建时</code>reaction函数<code>不会直接运行</code>，只有在数据表达式<code>首次返回一个新值</code>后才会<code>运行</code>。在执行时访问任何observable都不会被追踪。</li><li>用法：reaction(() &#x3D;&gt; data, (data, reaction) &#x3D;&gt; { sideEffect }, options?)</li><li>简单理解：<code>reaction是computed(expression).observe(action(sideEffect)) 或 autorun(() =&gt; action(sideEffect)(expression)) 的语法糖。</code></li></ul><h3 id="用法解析"><a href="#用法解析" class="headerlink" title="用法解析"></a>用法解析</h3><ul><li>参数1为data函数，用来追踪并返回数据作为第二个函数的输入。</li><li>参数2为effect函数，接收的两个参数分别为<code>data函数返回的值</code>和<code>当前的reaction</code>,当前的reaction用来在执行期间清理reaction。<code>effect函数仅对data函数中访问的数据作出反应</code></li><li>返回一个清理函数</li></ul><h3 id="options可选参"><a href="#options可选参" class="headerlink" title="options可选参"></a>options可选参</h3><ul><li>fireImmediately: 布尔值，用来标识效果函数是否在数据函数第一次运行后立即触发。默认值是 false</li><li>其他的同autorun一样</li></ul><h2 id="observer"><a href="#observer" class="headerlink" title="@observer"></a><b id="ref3" style="color: green">@observer</b></h2><ul><li>用来将 React 组件转变成响应式组件，observer由mobx-react包提供</li><li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@observer <span class="keyword">class</span> <span class="title class_">Timer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.component</span> &#123;</span><br><span class="line"><span class="title function_">render</span> (</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>seconds:&#123;this.props.timerData.second&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>当observer需要组合其它装饰器或高阶组件时，请确保<code>observer是最深处(第一个应用)的装饰器</code>，否则不起效</li><li>使用<code>@observer装饰器</code> 与 <code>observer(class Timer ... &#123;&#125;)</code> 效果一样</li><li><code>陷阱</code>：使用以下方式初始化，组件不会有反应。<code>值需要通过引用来传递而不是通过字面量值来传递</code><ul><li>React.render(<Timer timerData={timerData.secondsPassed} />, document.body)</li></ul></li><li><code>无状态函数组件</code>：const Timer &#x3D; observer(({timerData}) &#x3D;&gt; <span>seconds:{timerData.second}</span>)</li><li><code>可观察的局部组件状态</code>：在使用@observer的类中使用@observable来观察属性。响应式状态会被render调用，也会调用componentWillUpdate 和 componentDidUpdate</li></ul><h3 id="使用-inject-将组件连接到提供的-stores"><a href="#使用-inject-将组件连接到提供的-stores" class="headerlink" title="使用 inject 将组件连接到提供的 stores"></a>使用 inject 将组件连接到提供的 stores</h3><ul><li>用法：inject(stores)(component) 或 @inject(stores) class Component…</li><li>示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = <span class="title function_">observable</span>(&#123;</span><br><span class="line">   <span class="attr">foreground</span>: <span class="string">&#x27;#000&#x27;</span>,</span><br><span class="line">   <span class="attr">background</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">colors</span>=<span class="string">&#123;colors&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">app</span> <span class="attr">stuff...</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = <span class="title function_">inject</span>(<span class="string">&quot;colors&quot;</span>)(<span class="title function_">observer</span>(<span class="function">(<span class="params">&#123; colors, label, onClick &#125;</span>) =&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">color:</span> <span class="attr">colors.foreground</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">backgroundColor:</span> <span class="attr">colors.background</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span>&#123;label&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">));</span><br><span class="line"><span class="comment">// 稍后..</span></span><br><span class="line">colors.<span class="property">foreground</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="comment">// 所有button都会更新</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="componentWillReact-生命周期钩子"><a href="#componentWillReact-生命周期钩子" class="headerlink" title="componentWillReact(生命周期钩子)"></a>componentWillReact(生命周期钩子)</h3><ul><li>当组件因为它观察的数据发生了改变，它会重新渲染，这时componentWillReact会被触发，方便组件追溯并找到导致渲染的操作</li></ul><h2 id="MobX-会对什么作出反应？"><a href="#MobX-会对什么作出反应？" class="headerlink" title="MobX 会对什么作出反应？"></a><b id="ref4" style="color: green">MobX 会对什么作出反应？</b></h2><ul><li>MobX 会对在<code>执行跟踪函数期间读取的任何现有的可观察属性做出反应。</code><ul><li>追踪函数：是computed表达式、observer组件的render()和when、reaction 和anturun的第一个入参函数</li><li>过程：只追踪哪些在函数执行时被读取的observable</li><li>读取：对象属性的间接引用，可用. 或 [] 形式完成</li></ul></li><li><code>只追踪同步</code>地访问数据</li><li>MobX 只会为数据是<code>直接通过 render 存取的 observer 组件</code>进行数据<code>追踪</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不接受参数，避免创建额外组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params">&#123; message &#125;</span>) =&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">SomeContainer</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">title</span> = <span class="string">&#123;()</span> =&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Observer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;() =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;message.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Observer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">/&gt;</span></span><br><span class="line">message.<span class="property">title</span> = <span class="string">&quot;Bar&quot;</span></span><br></pre></td></tr></table></figure>-<code> 避免在本地字段中缓存 observable</code></li><li>不会有反应的<ul><li>从observable获取的值，但是在追踪函数之外</li><li>在异步调用的代码块中读取的observable</li></ul></li></ul><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a><b id="ref5" style="color: green">Action</b></h2><ul><li>用法<ul><li>action(fn)</li><li>action(name, fn)</li><li>@action classMethod() {}</li><li>@action(name) classMethod () {}</li><li>@action boundClassMethod &#x3D; (args) &#x3D;&gt; { body }</li><li>@action(name) boundClassMethod &#x3D; (args) &#x3D;&gt; { body }</li><li>@action.bound classMethod() {}<ul><li>action.bound 不要和箭头函数一起使用；箭头函数已经是绑定过的并且不能重新绑定。</li></ul></li></ul></li><li>使用<ul><li>应该永远只对<code>修改</code>状态的函数使用动作。 只执行查找，过滤器等函数<code>不</code>应该被标记为动作</li></ul></li></ul><h3 id="编写异步-Actions"><a href="#编写异步-Actions" class="headerlink" title="编写异步 Actions"></a>编写异步 Actions</h3><ul><li><p>@action <code>只对当前运行的函数作出反应</code>，而不会对当前运行函数所调用的<code>函数(不包含在当前函数之内)</code>作出反应</p></li><li><p>runInAction(name?, thunk)</p><ul><li>接收代码块并在异步动作中执行。对于即时创建和执行动作非常有用</li></ul></li><li><p>promise 示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mobx.<span class="title function_">configure</span>(&#123; <span class="attr">enforceActions</span>: <span class="literal">true</span> &#125;) <span class="comment">// 不允许在动作之外进行状态修改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">@observable githubProjects = []</span><br><span class="line">@observable state = <span class="string">&quot;pending&quot;</span></span><br><span class="line">@action</span><br><span class="line"><span class="title function_">fetchProjects</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">githubProjects</span> = []</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;pending&quot;</span></span><br><span class="line"><span class="title function_">fetchGithubProjectsSomehow</span>().<span class="title function_">then</span>(<span class="variable language_">this</span>.<span class="property">fetchSuccess</span>, <span class="variable language_">this</span>.<span class="property">fetchError</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内联方法，缺点不能进行类型推导</span></span><br><span class="line"><span class="title function_">action</span>(<span class="string">&quot;fetchSuccess&quot;</span>, <span class="function"><span class="params">projects</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> filteredProjects = <span class="title function_">somePreprocessing</span>(projects)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">githubProjects</span> = filteredProjects</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;done&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">action</span>(<span class="string">&quot;fetchError&quot;</span>,<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;error&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>async&#x2F;await</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mobx.<span class="title function_">configure</span>(&#123; <span class="attr">enforceActions</span>: <span class="literal">true</span> &#125;) <span class="comment">// 不允许在动作之外进行状态修改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">@observable githubProjects = []</span><br><span class="line">@observable state = <span class="string">&quot;pending&quot;</span></span><br><span class="line">@action</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">fetchProjects</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">githubProjects</span> = []</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;pending&quot;</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">const</span> projects = <span class="keyword">await</span> <span class="title function_">fetchGithubProjectsSomehow</span>()</span><br><span class="line"><span class="keyword">const</span> filteredProjects = <span class="title function_">somePreprocessing</span>(projects)</span><br><span class="line"><span class="comment">// await 之后，再次修改状态需要动作:</span></span><br><span class="line"><span class="title function_">runInAction</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;done&quot;</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">githubProjects</span> = filteredProjects</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"><span class="title function_">runInAction</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;error&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flows</p></li><li><p>使用 function * 来代替 async，使用 yield 代替 await</p></li><li><p>其它与async&#x2F;await差不多，只能作为函数使用，不能作为装饰器</p></li></ul><h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><h3 id="toJS-value-options"><a href="#toJS-value-options" class="headerlink" title="toJS(value, options?)"></a>toJS(value, options?)</h3><ul><li>作用：递归地将一个observable对象转换成javascript解构。支持observable数组、对象、映射和原始类型</li><li>options：<ul><li>exportMapsAsObjects 是否将observable映射序列化为对象(true) 或JavaScript Map对象(false).默认true</li><li>detectCycles 如果监测到循环，则重现使用已经序列化的对象。可以防止无限递归。默认true</li></ul></li></ul><h3 id="extendObservable-target-properties-decorators-options"><a href="#extendObservable-target-properties-decorators-options" class="headerlink" title="extendObservable(target, properties, decorators?, options?)"></a>extendObservable(target, properties, decorators?, options?)</h3><ul><li>作用：用来向已存在的目标对象添加observable属性。属性映射中的所有键对都会导致目标上的新的observable属性被初始化为给定值。属性映射中的任意getters都会转化成计算属性。</li><li>使用deep:false使得新的属性变成浅的。即阻止它们的值自动转换成observables。</li><li>observable.object(object) 实际上是 extendObservable({}, object) 的别名</li></ul><h3 id="创建observable数据结构和reactions"><a href="#创建observable数据结构和reactions" class="headerlink" title="创建observable数据结构和reactions"></a>创建observable数据结构和reactions</h3><ul><li>Atoms可以用来通知MobX某些observable数据源被观察或发生了改变。当数据源被使用或不再使用时，MobX会通知atom</li><li>多数场景下，可以通过创建普通的observable并使用工具onBecomeObserved 或 onBecomeUnobserved在Mobx开始追踪observable时接收通知来避免创建atom</li></ul><h3 id="Intercept-Observe"><a href="#Intercept-Observe" class="headerlink" title="Intercept &amp; Observe"></a>Intercept &amp; Observe</h3><ul><li>作用：用来监测单个observable的变化。 intercept可以在变化作用域observable之前监测和修改变化。observe允许在observable变化之后拦截改变。</li></ul><h3 id="intercept-target-propertyName-interceptor"><a href="#intercept-target-propertyName-interceptor" class="headerlink" title="intercept(target,propertyName?, interceptor)"></a>intercept(target,propertyName?, interceptor)</h3><ul><li>target: 监测的observable </li><li>propertyName: 可选参数，用来指定某个属性进来拦截。注意，intercept(user.name, interceptor) 和 intercept(user, “name”, interceptor) 根本是完全不同的。前者尝试给 user.name(或许根本不是一个 observable) 里面的当前值添加一个拦截器，而后者拦截 user 的 name 属性的变化。</li><li>interceptor: 在每次变化作用于 observable 后调用的回调函数。接收一个用来描述变化的对象。</li></ul><h3 id="Observe-target-propertyName-listener-invokeImmediately"><a href="#Observe-target-propertyName-listener-invokeImmediately" class="headerlink" title="Observe(target, propertyName?, listener, invokeImmediately?)"></a>Observe(target, propertyName?, listener, invokeImmediately?)</h3><ul><li>target: 观察的 observable</li><li>propertyName: 可选参数，用来指定某个属性进行观察。注意，observe(user.name, listener) 和 observe(user, “name”, listener) 根本是完全不同的。前者观察 user.name(或许根本不是一个 observable) 里面的当前值，而后者观察 user 的 name 属性。</li><li>listener: 在<code>每次</code>变化作用于 observable 后调用的回调函数。接收一个用来描述变化的对象，除了装箱的 observable，它 <code>调用listener 的两个参数: newValue、oldValue</code>。</li><li>invokeImmediately: 默认是 false。如果想直接使用 observable 的状态(而不是等待第一次变化)调用 listener 的话，把它设置为 true。不是所有类型的 observable 都支持。</li><li>该函数返回一个disposer函数，当调用时取消观察者。</li><li>observe 会响应对应的变动，而像是 autorun 或 reaction 则会对新值做出响应</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;自动获取源自应用state的数据&lt;/li&gt;
&lt;li&gt;机制：事件调用actions，使用actions来修改state，然后自动更新，更新的值会触发对应的值变化&lt;/li&gt;
&lt;li&gt;安装：&lt;a href=&quot;https://cn.mobx.js.org/&quot;&gt;mobx的</summary>
      
    
    
    
    <category term="前端工程化工具" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2024/11/01/Engineering/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2024/11/01/Engineering/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-11-01T08:52:16.666Z</published>
    <updated>2024-11-01T09:01:33.793Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../img/Engineering/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="设计模式"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h2 id="高内聚，低耦合（五大基本原则SOLID简写）"><a href="#高内聚，低耦合（五大基本原则SOLID简写）" class="headerlink" title="高内聚，低耦合（五大基本原则SOLID简写）"></a>高内聚，低耦合（五大基本原则SOLID简写）</h2><ul><li>高层模块不依赖底层模块，即为依赖反转原则。</li><li>内部修改关闭，外部扩展开放，即为开放封闭原则。</li><li>聚合单一功能，即为单一功能原则。</li><li>低知识要求，对外接口简单，即为迪米特法则。</li><li>耦合多个接口，不如独立拆分，即为接口隔离原则。</li><li>合成复用，子类继承可替换父类，即为里式替换原则</li></ul><h2 id="为什么封装代码？"><a href="#为什么封装代码？" class="headerlink" title="为什么封装代码？"></a>为什么封装代码？</h2><ol><li>不会让内部变量污染外部</li><li>封装好的代码可以作为一个模块给外部调用</li><li>对扩展开放，对修改关闭，即开放关闭原则。外部不能修改内部源码，保证了内部的正确性；又留出扩展接口，提高灵活性。</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>在软件设计、开发过程中，针对特定场景、特定问题的较优解决方案。</li><li>一共分为3大类23种，下面为常用的几种：<ul><li>创建型模式：单例模式、工厂模式</li><li>结构型模式：适配器模式、装饰器模式</li><li>行为型模式：策略模式、观察者模式、发布订阅模式、访问者模式</li></ul></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>一个类只有一个实例，并提供一个访问它的全局访问点。</p></blockquote><ul><li>实现方法：<ul><li>Singleton: 特定类，需要访问的类</li><li>instance：单例，特定类的实例</li><li>getInstance: 获取单例的方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingLeton</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title class_">Singleton</span>.<span class="property">_instance</span>)&#123;</span><br><span class="line">            <span class="title class_">Singleton</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Singleton</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Singleton</span>.<span class="property">_instance</span> <span class="comment">//存在实例就返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1===s2) <span class="comment">//true</span></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">- 举例：vuex的store</span></span><br><span class="line"><span class="string">- 优点：节约资源，保证访问的一致性。</span></span><br><span class="line"><span class="string">- 缺点：扩展性不友好，因为单例模式没有接口</span></span><br><span class="line"><span class="string">- 场景：</span></span><br><span class="line"><span class="string">  - 如果一个类实例化过程消耗资源比较多，可以使用单例避免性能浪费</span></span><br><span class="line"><span class="string">  - 需要公共状态，可以使用单例保证访问一致性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 工厂模式</span></span><br><span class="line"><span class="string">&gt; 根据不同的，返回不同类的实例</span></span><br><span class="line"><span class="string">&gt; 核心思想：将对象的创建与对象的实现分离</span></span><br><span class="line"><span class="string">- 实现方法：</span></span><br><span class="line"><span class="string">  - Visitor：访问者，访问共仓的方法</span></span><br><span class="line"><span class="string">  - Factory；工厂，负责返回产品实例</span></span><br><span class="line"><span class="string">  - Product：产品，访问者从工厂拿到的产品实例</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">tag, data,children</span>)&#123;</span><br><span class="line">  <span class="comment">//各种判断 判断生成什么样的Vnode</span></span><br><span class="line">  <span class="keyword">if</span>(!tag)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">craeteEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(tag,data,children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>举例：document.createElement创建DOM元素,createElement(‘标签名’)</li><li>优点：良好的封装，扩展性良好，解耦了高层逻辑和底层产品类</li><li>缺点：给系统增加了抽象性，带来了额外的系统复杂度，不能滥用</li><li>场景：对象创建复杂，访问者无需了解创建过程。需要处理大量又相同、相似属性的小对象</li></ul><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote><p>用于解决兼容问题，接口&#x2F;方法&#x2F;数据不兼容，将其转换成访问者期望的格式进行使用。</p></blockquote><ul><li>必须包含目标（Target）、源（Adaptee）和适配器（Adapter）三个角色。</li><li>优点：可以使原有逻辑得到更好的复用，有助于避免大规模改写现有代码</li><li>缺点：会让系统变得零乱，明明调用 A，却被适配到了 B，不能滥用。</li><li>场景：<ul><li>想要使用一个已经存在的对象，但是接口不满足需求</li><li>想要创建一个可以复用的对象，而且确定需要和一些不兼容的对象一起工作</li></ul></li><li>使用：前提有多个不同接口的数据<ul><li>定义一个同意的数据结构</li><li>通过适配器模块，适配成访问者索要访问的数据格式</li><li>将多个不同接口的数据在这里定义号类型，然后其中的相似数据通过调用一个函数转换成一致的类型，然后适配器哪里每一个接口都遍历数据单独返回给对应接口，最终返回适配器列表。通过打.对应的列表。</li></ul></li></ul><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><blockquote><p>在不改变原对象的基础上，增加新属性、方法、功能（一个对象被另一个对象包装，在原对象上增加功能）</p></blockquote><ul><li>优点：对象的核心职责和装饰器功能去分开，可以通过动态增删装饰目标对象中的装饰逻辑</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>定义一系列算法，根据输入的参数决定使用哪个算法</p></blockquote><ul><li>举例： 双十一满减的活动，表单验证</li><li>优点：<ol><li>策略相互独立，可以互相切换。</li><li>提高了灵活性以及复用性，维护性。</li><li>可扩展性好，满足开闭原则。</li></ol></li><li>缺点：<ol><li>策略相互独立，一些复杂的算法逻辑无法共享，造成资源浪费。</li><li>用户在使用策略时，需要了解具体的策略实现。</li><li>不满足最少知识原则，增加了使用成本。</li></ol></li><li>场景：<ul><li>算法需要自由切换的场景。</li><li>多个算法只有行为上有些不同，可以考虑策略模式动态选择算法。</li><li>需要多重判断，可以考虑策略模式规避多重条件判断。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> priceCalculate = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> discountMap = &#123;</span><br><span class="line">    <span class="string">&#x27;discount200-20&#x27;</span>: <span class="keyword">function</span>(<span class="params">price</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> price - <span class="title class_">Math</span>.<span class="title function_">floor</span>(price / <span class="number">200</span>) * <span class="number">20</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;discount300-50&#x27;</span>: <span class="keyword">function</span>(<span class="params">price</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> price - <span class="title class_">Math</span>.<span class="title function_">floor</span>(price/<span class="number">300</span>) * <span class="number">50</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;discount500-100&#x27;</span>: <span class="keyword">function</span>(<span class="params">price</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> price - <span class="title class_">Math</span>.<span class="title function_">floor</span>(price/<span class="number">500</span>) * <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">addStategy</span>(<span class="params">stategyName,fn</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(discountMap[stategyName]) <span class="keyword">return</span>;</span><br><span class="line">        discountMap[stategyName] = fn;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">priceCal</span>(<span class="params">discountType,price</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> discountMap[discountType] &amp;&amp; discountMap[discountType](price);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">  <span class="comment">// 使用</span></span><br><span class="line">  priceCalculate.<span class="title function_">priceCal</span>(<span class="string">&#x27;discount200-20&#x27;</span>,<span class="number">250</span>); <span class="comment">// 230</span></span><br><span class="line">  priceCalculate.<span class="title function_">addStategy</span>(<span class="string">&#x27;discount800-200&#x27;</span>,<span class="keyword">function</span>(<span class="params">price</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> price - <span class="title class_">Math</span>.<span class="title function_">floor</span>(price/<span class="number">800</span>) * <span class="number">200</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote><p>一个对象（称为subject）维持一系列依赖于它的对象（称为observer），将有关状态的任何变更自动通知给它们（观察者）。</p></blockquote><ul><li>观察者模式中的角色有两类：观察者和被观察者。</li><li>优点：目标变化就会通知观察者，这是观察者模式最大的优点。</li><li>缺点：不灵活。目标和观察者是耦合在一起的，要实现观察者模式，必须同时引入被观察者和观察者才能达到响应式的效果。</li><li>实现：被观察者的类要添加&#x2F;移除&#x2F;通知观察者；观察者的类中要根据被观察者更新</li></ul><h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><blockquote><p>基于一个主题&#x2F;事件通道，希望接收通知的对象（称为subscriber）通过自定义事件订阅主题，被激活事件的对象（称为publisher）通过发布主题事件的方式被通知。</p></blockquote><ul><li>发布-订阅模式的角色有两类：发布者和订阅者</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventEmitter</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type] = <span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type].<span class="title function_">filter</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> event !== fn;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布</span></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">type</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">event</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Vue 双向绑定通过数据劫持和发布-订阅模式实现。<ol><li>通过DefineProperty劫持各个数据的setter和getter，并为每个数据添加一个订阅者列表，这个列表将会记录所有依赖这个数据的组件。响应式后的数据相当于消息的发布者。</li><li>每个组件都对应一个Watcher订阅者，当组件渲染函数执行时，会将本组件的Watcher加入到所依赖的响应式数据的订阅者列表中。相当于完成了一次订阅，这个过程叫做“依赖收集”。</li><li>当响应式数据发生变化时，会出setter，setter负责通知数据的订阅者列表中的Watcher，Watcher触发组件重新渲染来更新视图。视图层相当于消息的订阅者。</li></ol></li></ul><p><img src="/../../img/Engineering/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E4%B8%8E%E8%A7%82%E5%AF%9F%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB.webp" alt="发布订阅者与观察者的区别"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h2 id="观察者模式与发布订阅者模式的区别"><a href="#观察者模式与发布订阅者模式的区别" class="headerlink" title="观察者模式与发布订阅者模式的区别"></a>观察者模式与发布订阅者模式的区别</h2><ul><li>观察者模式：<ul><li>媒介： 观察者 –&gt; 被观察者(一有变化就通知被观察者)</li><li>方式： 同步，即当发生某些事件时，主题调用其所有观察者的适当方法3</li><li>松耦合： 观察者和被观察者松散耦合</li></ul></li><li>发布订阅者模式：<ul><li>媒介： 发布者 –&gt; 中间代理 –&gt; 订阅者 （通过中间代理通信）</li><li>方式： 异步（使用消息队列）</li><li>松耦合： 组件与观察者模式完全分离</li><li>模式： 更像是一种跨应用程序模式，可以驻留在两个不同的应用程序中。每一个都通过消息代理或消息队列进行通信。</li></ul></li></ul><h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h2><ul><li>优点：</li></ul><ol><li>时间解耦：注册的订阅行为由发布者决定何时调用，订阅者无需持续关注，由发布者负责通知。</li><li>对象解耦：发布者无需知道消息的接受者，只需遍历订阅该消息类型的订阅者发送消息，解耦了发布者和订阅者之间的联系，互不持有，都依赖于抽象。</li></ol><ul><li>缺点：</li></ul><ol><li>资源消耗：创建订阅者需要一定的时间和内存。</li><li>增加复杂度：弱化了联系，难以维护调用关系，增加了理解成本。</li></ol><ul><li>场景：各模块相互独立，存在一对多的依赖关系，依赖模块不稳定、依赖关系不稳定，各模块由不同的人员开发</li></ul><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><blockquote><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于其内部各个元素的新操作。访问者模式是一种将数据操作和数据结构分离的设计模式</p></blockquote><ul><li>场景：</li></ul><ol><li>对象结构比较稳定，但经常需要在此对象结构上定义新的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。</li></ol><ul><li>实现：在每个员工的类中添加一个public void accept(Visitor visitor){visitor.visit(this)}和各自对应的方法,在员工的基类中定义好共同的方法和核心方法public abstract void accept(Visitor visitor)，然后汇集到员工业务报表，并为访问者提供接口。定义Visitor的方法，访问员工，然后领导可以根据自己要访问的要求找到对应的数据。<ul><li>Visitor：接口或者抽象类，定义了对每个 Element 访问的行为，它的参数就是被访问的元素，它的方法个数理论上与元素的个数是一样的，因此，访问者模式要求元素的类型要稳定，如果经常添加、移除元素类，必然会导致频繁地修改 Visitor 接口，如果出现这种情况，则说明不适合使用访问者模式。</li><li>ConcreteVisitor：具体的访问者，它需要给出对每一个元素类访问时所产生的具体行为。</li><li>Element：元素接口或者抽象类，它定义了一个接受访问者（accept）的方法，其意义是指每一个元素都要可以被访问者访问。</li><li>ElementA、ElementB：具体的元素类，它提供接受访问的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li><li>ObjectStructure：定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素提供访问者访问。</li></ul></li><li>优点：</li></ul><ol><li>各角色责职分离，符合单一职责原则</li><li>具有优秀的扩展性</li><li>灵活性</li><li>使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化</li></ol><ul><li>缺点：</li></ul><ol><li>具体元素对访问者公布细节，违反了迪米特原则</li><li>具体元素变更时导致修改成本大</li><li>违反了依赖倒置原则，位类达到“区别对待”而依赖了具体类，没有依赖抽象<br><img src="/../../img/Engineering/UML%E8%AE%BE%E8%AE%A1%E5%9B%BE.webp" alt="UML设计图"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../img/Engineering/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png&quot; alt=&quot;设计模式&quot;  data-tag=&#39;post-image&#39; loading=&quot;lazy&quot; onerror=&#39;this</summary>
      
    
    
    
    <category term="前端工程化工具" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒</title>
    <link href="http://example.com/2024/11/01/%E6%8A%A5%E9%94%99%E6%8C%87%E5%8D%97/vscode%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2024/11/01/%E6%8A%A5%E9%94%99%E6%8C%87%E5%8D%97/vscode%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</id>
    <published>2024-11-01T08:50:56.159Z</published>
    <updated>2024-11-01T08:51:35.023Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒"><a href="#关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒" class="headerlink" title="关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒"></a>关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒</h3><ol><li>在项目中创建一个.prettierrc.json文件，然后配置好后</li><li>在.eslintrc中也配置对应prettier配置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.prettierrc.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;endOfLine&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">  <span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;semi&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .eslintrc</span></span><br><span class="line"><span class="string">&quot;prettier/prettier&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;error&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;endOfLine&quot;</span>: <span class="string">&quot;auto&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒&quot;&gt;&lt;a href=&quot;#关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒&quot; class=&quot;headerlink&quot; title=&quot;关于VSco</summary>
      
    
    
    
    <category term="问题与方案" scheme="http://example.com/categories/%E9%97%AE%E9%A2%98%E4%B8%8E%E6%96%B9%E6%A1%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Git找不到null文件</title>
    <link href="http://example.com/2024/11/01/%E6%8A%A5%E9%94%99%E6%8C%87%E5%8D%97/Git%E6%89%BE%E4%B8%8D%E5%88%B0null%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2024/11/01/%E6%8A%A5%E9%94%99%E6%8C%87%E5%8D%97/Git%E6%89%BE%E4%B8%8D%E5%88%B0null%E6%96%87%E4%BB%B6/</id>
    <published>2024-11-01T08:45:19.458Z</published>
    <updated>2024-11-01T08:49:54.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><ul><li>(二次)win10&#x2F;11安装git，出现 fatal: open &#x2F;dev&#x2F;null or dup failed: No Such file or directory</li></ul><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ol><li><p>首先打开注册表，win+R，输入regedit 打开:</p><br /></li><li><p>根据以下路径：<code>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Null</code></p><br /></li><li><p>没有的从另一台好的电脑导出，然后在导入，顺便把下面的这个文件复制一份。有的把默认项数值改为1</p><br /></li><li><p><code>c:\Windows\system32\drives\null.sys</code>，前往这个路径，把旧的先删除，然后换上没问题的文件。</p><br /></li><li><p>点击开始–&gt; 搜索 –&gt; cmd –&gt; 找到命令提示符用管理员身份打开（右键的命令无效，原因未知，最好按照这个路径找）</p><br /></li><li><p>执行<code>sc query null</code></p><br /></li><li><p>执行<code>sc start null</code>，成功则完成，以下步骤不用看。</p><br /></li><li><p>失败，出现<code>[SC] StartService 失败 577: Windows 无法验证此文件的数字签名。某软件或硬件最近有所更改，可能安装了签名错误或损毁的文件，或者安装的文件可能是来路不明的恶意软件。</code></p><br /></li><li><p>执行<code>sfc /scannow</code>，后重启电脑</p><br /></li><li><p>继续执行<code>sfc /scannow</code>，出现<code>windows资源保护找了了损坏文件并成功修复了它们</code>。或者<code>Windows 资源保护未找到任何完整性冲突</code>，表示无问题，以下步骤不用看</p><br /></li><li><p>再次执行<code>sfc /scannow</code></p><br /></li><li><p>执行完执行<code>Dism /Online /Cleanup-Image /ScanHealth</code></p><br /></li><li><p>执行完执行<code>Dism /Online /Cleanup-Image /CheckHealth</code></p><br /></li><li><p>执行完执行<code>DISM /Online /Cleanup-image /RestoreHealth</code></p><br /></li><li><p>重启电脑</p><br /></li><li><p><code>sfc /SCANNOW</code>，出现步骤10的情况，问题解决，以下步骤不用看</p><br /></li><li><p>仍为解决下载并运行<a href="https://go.microsoft.com/fwlink/?linkid=2156295">MediaCreationToolW11</a>，</p><br /></li><li><p>在“选择语言和版本”的界面，选择正确的系统版本，（通常来讲默认是和当前系统一样的版本，不用选择），在“选择要使用的介质”界面，请选择“ISO文件”。</p><br /></li><li><p>选择一个位置保存该文件（任意位置），下载完成后，双击打开该文件，找到setup.exe 文件，鼠标双击运行。</p><br /></li><li><p>在【你想执行哪种类型的安装】界面选择【升级：安装Windows并保留文件、设置和应用程序】。</p><br /></li><li><p>等待安装重启，完成后<code>sfc /scannow</code>，出现步骤10情况完成，安装git和TortiseGit（重启次数较多，扫描安装时间较长请耐心等待）</p><br /></li><li><p>git重装后，拉取提示（重装git，一定要卸载干净git，从设置-应用中卸载，并确保C盘隐藏文件ProgramData中的Git是否存在，存在表示卸载不干净）<br><code>Could not open repository.libgit2 returned: repository path &#39;F:/..../&#39; isnot owned by current user.</code><br><code>To add an exception for this directory, call:git config --global --add safe.directory F:/....</code></p><br /></li><li><p>在当前文件夹中右键打开Open Git Bash here ，输入<code>git config --global --add safe.directory 文件路径</code>，抄提示的那句话</p><br /></li><li><p>执行完，打开项目，<code>npm i</code>即可</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;(二次)win10&amp;#x2F;11安装git，出现 fatal: open &amp;#x2F;dev&amp;#x2F</summary>
      
    
    
    
    <category term="问题与方案" scheme="http://example.com/categories/%E9%97%AE%E9%A2%98%E4%B8%8E%E6%96%B9%E6%A1%88/"/>
    
    
  </entry>
  
  <entry>
    <title>VUE3-组件知识</title>
    <link href="http://example.com/2024/11/01/vue3/%E7%BB%84%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2024/11/01/vue3/%E7%BB%84%E4%BB%B6%E7%9F%A5%E8%AF%86/</id>
    <published>2024-11-01T06:39:25.213Z</published>
    <updated>2024-11-01T07:03:12.530Z</updated>
    
    <content type="html"><![CDATA[<ul><li>组件名格式：PascalCase</li></ul><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><pre><code>💠 全局注册💠 局部注册</code></pre><h3 id="全局注册-—-只有多个页面都要用到才使用全局"><a href="#全局注册-—-只有多个页面都要用到才使用全局" class="headerlink" title="全局注册 — 只有多个页面都要用到才使用全局"></a>全局注册 — 只有多个页面都要用到才使用全局</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">create</span>(&#123;&#125;)</span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;注册的名字&#x27;</span>, 写好的组件) --可以被链式调用</span><br></pre></td></tr></table></figure><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><ul><li>使用它的父组件引入且在components：{}中注册</li></ul><h2 id="Props声明-—-组件间通信父传子"><a href="#Props声明-—-组件间通信父传子" class="headerlink" title="Props声明 — 组件间通信父传子"></a>Props声明 — <code>组件间通信父传子</code></h2><ul><li>Prop名字的格式：camelCase</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li>子组件：在props定义好属性，然后使用</li><li>父组件：在组件中调用这个属性，传值</li></ul><h3 id="组件的props标注类型-—-ts"><a href="#组件的props标注类型-—-ts" class="headerlink" title="组件的props标注类型 — ts"></a>组件的props标注类型 — ts</h3><ul><li><h3 id="defineComponent-—-启用类型推导"><a href="#defineComponent-—-启用类型推导" class="headerlink" title="defineComponent() — 启用类型推导"></a>defineComponent() — 启用类型推导</h3></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> <span class="comment">// 类型： string | undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><h3 id="PropType-—-多层级时启用工具类"><a href="#PropType-—-多层级时启用工具类" class="headerlink" title="PropType — 多层级时启用工具类"></a>PropType — 多层级时启用工具类</h3></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">PropType</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">author</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">year</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">book</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Object</span> <span class="keyword">as</span> <span class="title class_">PropType</span>&lt;<span class="title class_">Book</span>&gt;,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">callback</span>: <span class="title class_">Function</span> <span class="keyword">as</span> <span class="title class_">PropType</span>&lt;<span class="function">(<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span> &gt;</span><br><span class="line">    <span class="comment">// validater 和 default ts版本低于4.7要使用箭头函数</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">book</span>.<span class="property">title</span> <span class="comment">// string</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callback</span>?.(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="💠-静态prop：prop-”只能传字符串”"><a href="#💠-静态prop：prop-”只能传字符串”" class="headerlink" title="💠 静态prop：prop&#x3D;”只能传字符串”"></a>💠 静态prop：prop&#x3D;”只能传字符串”</h3><h3 id="💠-动态prop：-prop-”可传多种类型”"><a href="#💠-动态prop：-prop-”可传多种类型”" class="headerlink" title="💠 动态prop：:prop&#x3D;”可传多种类型”"></a>💠 动态prop：:prop&#x3D;”可传多种类型”</h3><h3 id="💠-使用一个对象绑定多个prop：v-bind-”对象数据”"><a href="#💠-使用一个对象绑定多个prop：v-bind-”对象数据”" class="headerlink" title="💠 使用一个对象绑定多个prop：v-bind&#x3D;”对象数据”"></a>💠 使用一个对象绑定多个prop：v-bind&#x3D;”对象数据”</h3><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p><img src="/../../img/vue3/%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="单向数据流"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><ul><li>所有props都遵循着单向绑定原则</li><li>props因父组件的更新而变化</li><li>❌ 子组件更改prop</li></ul><h3 id="prop校验"><a href="#prop校验" class="headerlink" title="prop校验"></a>prop校验</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">props：&#123;</span><br><span class="line">  <span class="attr">propA</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: 该属性的类型</span><br><span class="line">    <span class="attr">default</span>: 该属性的默认值</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>  该属性必传</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">propB</span>: [类型A, 类型B] <span class="comment">// 多类型</span></span><br><span class="line">  <span class="attr">propC</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Object</span> | <span class="title class_">Function</span></span><br><span class="line">    <span class="title function_">default</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">propC</span>: &#123;</span><br><span class="line">    <span class="title function_">validator</span>(<span class="params">value</span>)&#123;&#125; <span class="comment">// 自定义类型校验函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h2><h3 id="触发与监听事件"><a href="#触发与监听事件" class="headerlink" title="触发与监听事件"></a>触发与监听事件</h3><ul><li><h3 id="子组件事件"><a href="#子组件事件" class="headerlink" title="子组件事件"></a>子组件事件</h3><ul><li>子组件上的要监听事件要调用『$emit』方法，通过传入事件名称来抛出一个事件</li><li>示例：<code>&lt;button @click=&quot;$emit(&#39;enlarge-text&#39;)&quot;&gt;文本&lt;/button&gt;</code></li></ul></li><li><h3 id="父组件事件"><a href="#父组件事件" class="headerlink" title="父组件事件"></a>父组件事件</h3><ul><li>通过『v-on 或 @ 』来选择性监听子组件上的事件</li><li>示例：<code>&lt;子组件名 @enlarge-text=&quot;表达式&quot;&gt; &lt;/子组件名&gt;</code></li></ul></li></ul><h3 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h3><ul><li>子组件：<code>$emit(事件名，事件参数)</code></li><li>父组件: <code>@事件名=&quot;(事件参数) =&gt; 表达式&quot;</code> 或者 <code>@事件名=&quot;事件处理函数&quot;</code> 然后在methods写方法</li></ul><h3 id="显式声明触发事件-标注类型-emits-ts"><a href="#显式声明触发事件-标注类型-emits-ts" class="headerlink" title="显式声明触发事件+标注类型 emits + ts"></a>显式声明触发事件+标注类型 emits + ts</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">emits</span>:[] <span class="comment">// 字符串数组语法</span></span><br><span class="line"><span class="attr">emits</span>:&#123;&#125; <span class="comment">//对象语法，支持校验</span></span><br><span class="line">示例：</span><br><span class="line"><span class="comment">// addBook为事件名，</span></span><br><span class="line"><span class="comment">// bookName为事件内的一个属性且类型为字符串</span></span><br><span class="line"><span class="attr">emits</span>:&#123;</span><br><span class="line">  <span class="title function_">addBook</span>(<span class="params"><span class="attr">payload</span>:&#123;bookName: <span class="built_in">string</span>&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> payload.<span class="property">bookNAme</span>.<span class="property">length</span> &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="attr">onSubmit</span>: &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&#x27;addBook&#x27;</span>,&#123;</span><br><span class="line">      <span class="attr">bookName</span>: <span class="string">&#x27;5655&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⭐-组件-v-model"><a href="#⭐-组件-v-model" class="headerlink" title="⭐ 组件 v-model"></a>⭐ 组件 v-model</h2><ul><li>默认情况下，v-model 在组件上都是使用 modelValue 作为 prop，并以 update:modelValue 作为对应的事件</li></ul><h3 id="组件上使用v-model实现双向绑定"><a href="#组件上使用v-model实现双向绑定" class="headerlink" title="组件上使用v-model实现双向绑定"></a>组件上使用v-model实现双向绑定</h3><ul><li><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ul><li>组件内的表单元素要有以下两行</li><li><code>:value=&quot;modelValue&quot;</code></li><li><code>@input=&quot;$emit(&#39;update:modelValue&#39;),$event.target.value&quot;</code></li></ul></li><li><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ul><li>使用具有 getter 和 setter 的 computed 属性<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;modelValue&#x27;</span>],</span><br><span class="line">  <span class="attr">emits</span>: [<span class="string">&#x27;update:modelValue&#x27;</span>],</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">modelValue</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:modelValue&#x27;</span>, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="v-model的参数-—-该方法适用于组件有多个-v-model-绑定"><a href="#v-model的参数-—-该方法适用于组件有多个-v-model-绑定" class="headerlink" title="v-model的参数 — 该方法适用于组件有多个 v-model 绑定"></a>v-model的参数 — 该方法适用于<code>组件有多个 v-model 绑定</code></h3><ul><li>通过给 v-model 指定一个参数来更改modelValue这个名<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 名字从modelValue改为title</span></span><br><span class="line">父组件: &lt;子组件名 v-<span class="attr">model</span>:title=<span class="string">&quot;&quot;</span> /&gt;</span><br><span class="line">子组件:</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: [<span class="string">&#x27;title&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">emits</span>: [<span class="string">&#x27;update:title&#x27;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:value</span>=<span class="string">&quot;title&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="处理-v-model-修饰符"><a href="#处理-v-model-修饰符" class="headerlink" title="处理 v-model 修饰符"></a>处理 v-model 修饰符</h3><ul><li>💠 自定义的修饰符 capitalize</li><li>示例：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">父组件： &lt;<span class="title class_">MyComponent</span> v-model.<span class="property">capitalize</span>=<span class="string">&quot;myText&quot;</span> /&gt;</span><br><span class="line">子组件：</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">modelValue</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">modelModifiers</span>: &#123;</span><br><span class="line">      <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123;&#125;) <span class="comment">// 默认触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">emits</span>: [<span class="string">&#x27;update:modelValue&#x27;</span>],</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 写给修饰符的对应事件</span></span><br><span class="line">    <span class="title function_">emitValue</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">modelModifiers</span>.<span class="property">capitalize</span>) &#123;</span><br><span class="line">        value = value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:modelValue&#x27;</span>,value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">input</span>=<span class="string">&quot;emitValue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="透传-Attributes：传递给一个组件，却没有被组件声明的属性或v-on"><a href="#透传-Attributes：传递给一个组件，却没有被组件声明的属性或v-on" class="headerlink" title="透传 Attributes：传递给一个组件，却没有被组件声明的属性或v-on"></a>透传 Attributes：传递给一个组件，却没有被组件声明的属性或v-on</h2><ul><li>例：<code>&lt;组件名 class=&quot;btn&quot;&gt;&lt;/组件名&gt;</code> ,这个组件的根元素就多了一个btn的类</li></ul><h3 id="单根节点：-有自动-attribute-透传行为"><a href="#单根节点：-有自动-attribute-透传行为" class="headerlink" title="单根节点： 有自动 attribute 透传行为"></a>单根节点： 有自动 attribute 透传行为</h3><ul><li>禁用Attributes继承： inheritAttrs: false</li><li>使用v-bind&#x3D;”$attrs” 可以让透传的attribute指定到目标元素</li></ul><h3 id="多根节点（一个组件多个子组件）：-没有自动-attribute-透传行为"><a href="#多根节点（一个组件多个子组件）：-没有自动-attribute-透传行为" class="headerlink" title="多根节点（一个组件多个子组件）： 没有自动 attribute 透传行为"></a>多根节点（一个组件多个子组件）： 没有自动 attribute 透传行为</h3><ul><li>必须使用v-bind&#x3D;”$attrs” 让透传的attribute指定到目标元素</li></ul><h2 id="插槽slot—在组件中添加"><a href="#插槽slot—在组件中添加" class="headerlink" title="插槽slot—在组件中添加"></a><code>插槽slot</code>—在组件中添加<slot /></h2><ul><li>插槽的内容无法访问到子组件的状态</li><li>v-slot 简写 #</li><li>具名插槽 — 适用一个组件多个插槽<code>&lt;slot name=&quot;&quot; /&gt;</code>(无名&#x3D;默认插槽)</li><li>父组件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">BaseLayout</span>&gt;</span><br><span class="line">  <span class="comment">// 当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 `&lt;template&gt; `节点都被隐式地视为默认插槽的内容。</span></span><br><span class="line">  <span class="comment">// 指定插入那个插槽</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:插槽名</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">插槽名</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">BaseLayout</span>&gt;</span><br></pre></td></tr></table></figure></li><li>动态插槽名： <code>&lt;template #[插槽名]&gt;&lt;/template&gt;</code></li><li>作用域插槽 — 插槽内容想要同时使用父组件域内和子组件域内的数据<ul><li>传递prop: <code>&lt;slot (name=&quot;header&quot;) message=&quot;hello&quot; /&gt;</code></li><li>接受插槽：<ul><li>默认插槽：<code>&lt;组件名 v-slot=&quot;slotProps&quot;&gt;&#123;&#123;slotProps.xxx&#125;&#125;&lt;/组件名&gt;</code></li><li>具名插槽：<code>&lt;组件名 #插槽名=&quot;插槽名Props&quot;&gt;&#123;&#123;&#125;&#125;&lt;/组件名&gt;</code></li></ul></li></ul></li></ul><h2 id="⭐-依赖注入"><a href="#⭐-依赖注入" class="headerlink" title="⭐ 依赖注入"></a>⭐ 依赖注入</h2><h3 id="Provide-—-为组件后代提供数据"><a href="#Provide-—-为组件后代提供数据" class="headerlink" title="Provide — 为组件后代提供数据"></a>Provide — 为组件后代提供数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exeport <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">provide</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用层-Provide-—-为整个应用层提供依赖app页面"><a href="#应用层-Provide-—-为整个应用层提供依赖app页面" class="headerlink" title="应用层 Provide — 为整个应用层提供依赖app页面"></a>应用层 Provide — 为整个应用层提供依赖app页面</h3><ul><li>app.provide(‘注入名’，值)</li></ul><h3 id="Inject-—-注入上层组件提供的数据"><a href="#Inject-—-注入上层组件提供的数据" class="headerlink" title="Inject — 注入上层组件提供的数据"></a>Inject — 注入上层组件提供的数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;message&#x27;</span>],</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>) <span class="comment">// test</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">fullMessage</span>: <span class="variable language_">this</span>.<span class="property">meaaage</span> <span class="comment">// data的时候拿得到this.message</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注入别名-默认值（不要求必须有提供者）"><a href="#注入别名-默认值（不要求必须有提供者）" class="headerlink" title="注入别名&#x2F;默认值（不要求必须有提供者）"></a>注入别名&#x2F;默认值（不要求必须有提供者）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject</span>: &#123;</span><br><span class="line">  别名: &#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&#x27;原注入名&#x27;</span>, <span class="comment">// 别名</span></span><br><span class="line">    <span class="attr">default</span>: <span class="string">&#x27;default value&#x27;</span>  <span class="comment">// 默认值，无提供者时</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和响应式数据配合使用"><a href="#和响应式数据配合使用" class="headerlink" title="和响应式数据配合使用"></a>和响应式数据配合使用</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 显式提供一个计算属性</span></span><br><span class="line">      <span class="attr">message</span>: <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="⭐-异步组件"><a href="#⭐-异步组件" class="headerlink" title="⭐ 异步组件"></a>⭐ 异步组件</h2><ul><li>仅在需要时再从服务器加载相关组件<code>defineAsyncComponent</code><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line">方法一：</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp1</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...从服务器获取组件</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="comment">/* 获取到的组件 */</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp2</span> = <span class="title function_">defineAsyncComponent</span>(&#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;组件路径&#x27;</span>),  <span class="comment">// 加载组件</span></span><br><span class="line">  <span class="attr">loadingComponent</span>: <span class="title class_">LoadingComponent</span>, <span class="comment">// 加载异步组件时使用的组件</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>, <span class="comment">// 展示加载组件前的延迟时间，默认为 200ms</span></span><br><span class="line">  <span class="attr">errorComponent</span>: <span class="title class_">ErrorComponent</span>, <span class="comment">// 加载失败后展示的组件</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 像使用其他一般组件一样使用 `AsyncComp`</span></span><br><span class="line"></span><br><span class="line">全局注册：</span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;MyComponent&#x27;</span>, <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./components/MyComponent.vue&#x27;</span>)</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">局部注册：</span><br><span class="line"><span class="attr">components</span>: &#123;</span><br><span class="line">  异步组件名: <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./components/MyComponent.vue&#x27;</span>)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="动态组件-—-适用于Tab界面"><a href="#动态组件-—-适用于Tab界面" class="headerlink" title="动态组件 — 适用于Tab界面"></a>动态组件 — 适用于Tab界面</h2><ul><li>当使用 <code>&lt;component :is=&quot;组件名/组件对象&quot;&gt;</code> 来在多个组件间作切换时，被切换掉的组件会被卸载。</li></ul><h2 id="DOM-模板-—-在-DOM-中直接书写-Vue-模板"><a href="#DOM-模板-—-在-DOM-中直接书写-Vue-模板" class="headerlink" title="DOM 模板 — 在 DOM 中直接书写 Vue 模板"></a>DOM 模板 — 在 DOM 中直接书写 Vue 模板</h2><ul><li>区分大小写，以kebab-case (短横线连字符) 形式</li><li>显示关闭标签<code>&lt;&gt;&lt;/&gt;</code></li><li>元素位置限制，<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;tr&gt;</code>等要放在特定元素中才会显示</li><li>解决办法：<ul><li><code>&lt;table&gt;&lt;tr is=&quot;vue:要放的组件名&quot; /&gt;&lt;/table&gt;</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;组件名格式：PascalCase&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;组件注册&quot;&gt;&lt;a href=&quot;#组件注册&quot; class=&quot;headerlink&quot; title=&quot;组件注册&quot;&gt;&lt;/a&gt;组件注册&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;💠 全局注册
💠 局部注册
&lt;</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>VUE3-组合式函数(参见react hook)</title>
    <link href="http://example.com/2024/11/01/vue3/%E7%BB%84%E5%90%88%E5%BC%8F%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2024/11/01/vue3/%E7%BB%84%E5%90%88%E5%BC%8F%E5%87%BD%E6%95%B0/</id>
    <published>2024-11-01T06:39:25.204Z</published>
    <updated>2024-11-01T07:07:33.938Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用 Vue 的组合式 API 来封装和<code>复用有状态逻辑</code>的函数 — 把js&#x2F;ts代码封装成一个方法。</p></blockquote><h2 id="约定和最佳实践"><a href="#约定和最佳实践" class="headerlink" title="约定和最佳实践"></a>约定和最佳实践</h2><ul><li><h3 id="命名-方法名以use开头-驼峰形式"><a href="#命名-方法名以use开头-驼峰形式" class="headerlink" title="命名 : 方法名以use开头,驼峰形式"></a>命名 : 方法名以use开头,驼峰形式</h3></li><li><h3 id="输入参数-—-unref"><a href="#输入参数-—-unref" class="headerlink" title="输入参数 — unref()"></a>输入参数 — unref()</h3></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useFeature</span>(<span class="params">maybeRef</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">unref</span>(maybeRef)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>约定：组合式函数始终返回一个包含多个 ref 的普通的非响应式对象（因为ref可以维持在解构过程中与组合式函数内状态的响应式连接）</li><li>reactive(组合式函数) – 以对象属性的形式来使用组合式函数中返回的状态</li></ul></li><li><h3 id="副作用：组件挂载后在调用生命周期钩子并及时清理"><a href="#副作用：组件挂载后在调用生命周期钩子并及时清理" class="headerlink" title="副作用：组件挂载后在调用生命周期钩子并及时清理"></a>副作用：组件挂载后在调用生命周期钩子并及时清理</h3></li><li><h3 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h3><ul><li>组合式函数在 <code>&lt;script setup&gt;</code> 或 <code>setup()</code> 钩子中，应始终被<code>同步</code>地调用。在某些场景下，也可以在 <code>onMounted()</code>中使用。</li></ul></li></ul><h2 id="在选项式-API-中使用组合式函数"><a href="#在选项式-API-中使用组合式函数" class="headerlink" title="在选项式 API 中使用组合式函数"></a>在选项式 API 中使用组合式函数</h2><ul><li>组合式函数必须在setup()中调用，且其返回的绑定必须在setup()中返回</li><li>示例： <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMouse &#125; <span class="keyword">from</span> <span class="string">&#x27;./mouse.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useFetch &#125; <span class="keyword">from</span> <span class="string">&#x27;./fetch.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMouse</span>()</span><br><span class="line">    <span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useFetch</span>(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; x, y, data, error &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// setup() 暴露的属性可以在通过 `this` 访问到</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...其他选项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="与其他模式比较"><a href="#与其他模式比较" class="headerlink" title="与其他模式比较"></a>与其他模式比较</h2><ul><li><h3 id="与-Mixin-的对比"><a href="#与-Mixin-的对比" class="headerlink" title="与 Mixin 的对比"></a>与 Mixin 的对比</h3><ul><li>Minxin存在短板，vue3不推荐使用，存在只为项目迁移的需求</li></ul></li><li><h3 id="与-无渲染组件-的对比"><a href="#与-无渲染组件-的对比" class="headerlink" title="与 无渲染组件 的对比"></a>与 无渲染组件 的对比</h3><ul><li>组合式函数不会产生额外的组件实例开销</li></ul></li><li><h3 id="与-React-Hooks-的对比"><a href="#与-React-Hooks-的对比" class="headerlink" title="与 React Hooks 的对比"></a>与 React Hooks 的对比</h3><ul><li>仅调用 setup() 或 <code>&lt;script setup&gt;</code> 的代码一次。不需要担心闭包变量的问题。组合式 API 也并不限制调用顺序，还可以有条件地进行调用。</li><li>Vue 的响应性系统运行时会自动收集计算属性和侦听器的依赖，因此无需手动声明依赖。</li><li>无需手动缓存回调函数来避免不必要的组件更新。Vue 细粒度的响应性系统能够确保在绝大部分情况下组件仅执行必要的更新。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;利用 Vue 的组合式 API 来封装和&lt;code&gt;复用有状态逻辑&lt;/code&gt;的函数 — 把js&amp;#x2F;ts代码封装成一个方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;约定和最佳实践&quot;&gt;&lt;a href=&quot;#约定和最佳实践&quot; cl</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>VUE3-自定义指令</title>
    <link href="http://example.com/2024/11/01/vue3/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
    <id>http://example.com/2024/11/01/vue3/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</id>
    <published>2024-11-01T06:39:25.198Z</published>
    <updated>2024-11-01T07:12:25.181Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何时使用自定义指令："><a href="#何时使用自定义指令：" class="headerlink" title="何时使用自定义指令："></a>何时使用自定义指令：</h3><ul><li>只有当所需功能<code>只能通过直接的 DOM 操作</code>来实现时</li></ul><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><h3 id="1、全局注册"><a href="#1、全局注册" class="headerlink" title="1、全局注册"></a>1、全局注册</h3><ul><li><code>app.directive(&#39;focus&#39;, &#123;&#125;)</code></li></ul><h3 id="2、局部注册"><a href="#2、局部注册" class="headerlink" title="2、局部注册"></a>2、局部注册</h3><ul><li><code>directives: &#123;foucs // 启用 v-focus&#125;</code></li></ul><h2 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h2><ul><li><h3 id="el"><a href="#el" class="headerlink" title="el"></a>el</h3><ul><li>指令绑定到的元素。用于直接操作 DOM。</li><li>除了 el 外，其他参数都是只读的</li></ul></li><li><h3 id="binding"><a href="#binding" class="headerlink" title="binding"></a>binding</h3><ul><li>一个对象，包含以下属性</li><li>value: 传递给指令的值</li><li>oldValue: 之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。</li><li>arg: 传递给指令的参数</li><li>modifiers: 一个包含修饰符的对象。例如在 v-my-directive.foo.bar 中，修饰符对象是 { foo: true, bar: true }。</li><li>instance: 使用该指令的组件实例</li><li>dir: 指令的定义对象</li></ul></li><li><h3 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h3><ul><li>代表绑定元素的底层 VNode</li></ul></li><li><h3 id="prevNode"><a href="#prevNode" class="headerlink" title="prevNode"></a>prevNode</h3><ul><li>之前的渲染中代表指令所绑定元素的 VNode</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myDirective = &#123;</span><br><span class="line">  <span class="comment">// 在绑定元素的属性或事件监听器应用前调用</span></span><br><span class="line">  <span class="title function_">created</span>(<span class="params">el, binding, vnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在元素被插入到 DOM 前调用</span></span><br><span class="line">  <span class="title function_">beforeMount</span>(<span class="params">el, binding, vnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在绑定元素的父组件及他自己的所有子节点都挂载完成后调用</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding, vnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定元素的父组件更新前调用</span></span><br><span class="line">  <span class="title function_">beforeUpdate</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在绑定元素的父组件及他自己的所有子节点都更新后调用</span></span><br><span class="line">  <span class="title function_">updated</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载前调用</span></span><br><span class="line">  <span class="title function_">beforeUnmount</span>(<span class="params">el, binding, vnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载后调用</span></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params">el, binding, vnode</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简化形式-—-仅用-mounted-和-updated-的指令"><a href="#简化形式-—-仅用-mounted-和-updated-的指令" class="headerlink" title="简化形式 — 仅用 mounted 和 updated 的指令"></a>简化形式 — 仅用 mounted 和 updated 的指令</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-color=<span class="string">&quot;color&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;color&#x27;</span>, <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这会在 `mounted` 和 `updated` 时都调用</span></span><br><span class="line">  el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="对象字面量-—-指令需要多个值"><a href="#对象字面量-—-指令需要多个值" class="headerlink" title="对象字面量 — 指令需要多个值"></a>对象字面量 — 指令需要多个值</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-demo=<span class="string">&quot;&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;&quot;</span> &gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;demo&#x27;</span>, <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(binding.<span class="property">value</span>.<span class="property">color</span>) <span class="comment">// =&gt; &quot;white&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(binding.<span class="property">value</span>.<span class="property">text</span>) <span class="comment">// =&gt; &quot;hello!&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不推荐在组件上使用自定义指令-—-多根组件"><a href="#不推荐在组件上使用自定义指令-—-多根组件" class="headerlink" title="不推荐在组件上使用自定义指令 — 多根组件"></a>不推荐在组件上使用自定义指令 — 多根组件</h3><pre><code>始终应用于组件的根节点，和透传 attributes 类似指令不能通过 v-bind=&quot;$attrs&quot; 来传递给一个不同的元素</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;何时使用自定义指令：&quot;&gt;&lt;a href=&quot;#何时使用自定义指令：&quot; class=&quot;headerlink&quot; title=&quot;何时使用自定义指令：&quot;&gt;&lt;/a&gt;何时使用自定义指令：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;只有当所需功能&lt;code&gt;只能通过直接的 DOM 操作&lt;/cod</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>VUE3-应用规模化</title>
    <link href="http://example.com/2024/11/01/vue3/%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96/"/>
    <id>http://example.com/2024/11/01/vue3/%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96/</id>
    <published>2024-11-01T06:39:25.194Z</published>
    <updated>2024-11-01T07:21:50.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="⭐-SFC–单文件组件（-vue）"><a href="#⭐-SFC–单文件组件（-vue）" class="headerlink" title="⭐ SFC–单文件组件（*.vue）"></a>⭐ SFC–单文件组件（*.vue）</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>Count is &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>预编译模板</li><li>组件作用域的css</li><li>组合式的API语法</li><li>模块热更新</li><li>自动补全，对表达式的类型检查</li></ul><h3 id="SFC如何工作？"><a href="#SFC如何工作？" class="headerlink" title="SFC如何工作？"></a>SFC如何工作？</h3><ol><li>Vue SFC 是一个框架指定的文件格式，</li><li>由 @vue&#x2F;compiler-sfc 编译为标准的 JavaScript 和 CSS</li><li>编译后的 SFC 可以像导入其他 ES 模块一样导入</li><li>SFC 中的 <code>&lt;style&gt;</code>标签一般会在开发时注入成原生的 <code>&lt;style&gt;</code> 标签以支持热更新，而生产环境下它们会被抽取、合并成单独的 CSS 文件。</li></ol><h2 id="项目脚手架"><a href="#项目脚手架" class="headerlink" title="项目脚手架"></a>项目脚手架</h2><h3 id="vite创建vue：npm-init-vue-latest"><a href="#vite创建vue：npm-init-vue-latest" class="headerlink" title="vite创建vue：npm init vue@latest"></a>vite创建vue：npm init vue@latest</h3><h3 id="Vue-Cli-建议用vite"><a href="#Vue-Cli-建议用vite" class="headerlink" title="Vue Cli 建议用vite"></a>Vue Cli 建议用vite</h3><h3 id="块提供类型检查"><a href="#块提供类型检查" class="headerlink" title="&lt;script lang=&quot;ts&quot;&gt; 块提供类型检查"></a><code>&lt;script lang=&quot;ts&quot;&gt;</code> 块提供类型检查</h3><p><a href="https://cn.vuejs.org/guide/typescript/overview.html">ts 搭配 vue 的一些事</a></p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul><li><h3 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h3><ul><li>在单页面应用中，客户端的js可以拦截页面的跳转请求</li></ul></li><li><h3 id="服务端路由"><a href="#服务端路由" class="headerlink" title="服务端路由"></a>服务端路由</h3><ul><li>服务器根据用户访问的 URL 路径返回不同的响应结果</li></ul></li></ul><h2 id="—-适用于多个组件共享一个共同的状态"><a href="#—-适用于多个组件共享一个共同的状态" class="headerlink" title=" — 适用于多个组件共享一个共同的状态"></a><a href="/2024/11/01/vue3/vuex/" title="VUE3-VUEX">状态管理vuex</a> — 适用于多个组件共享一个共同的状态</h2><h3 id="用响应式-API-做简单状态管理"><a href="#用响应式-API-做简单状态管理" class="headerlink" title="用响应式 API 做简单状态管理"></a>用响应式 API 做简单状态管理</h3><ul><li>data() 的返回值对象会通过 reactive() 函数转为响应式。</li><li>使用reactive() 来实现在多个组件实例间共享状态<ol><li>新建一个store文件夹，在下面新建一个index文件</li><li>从 vue 中引入 reactive，</li><li>暴露一个通过reactive()返回的数据和修改的方法</li><li>其他页面直接引入store&#x2F;index，在data中返回这个数据</li></ol></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title function_">modifies</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>使用其他响应式 API 如 ref() 或是 computed()，或是通过一个组合式函数来返回一个全局状态<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局状态，创建在模块作用域下</span></span><br><span class="line"><span class="keyword">const</span> globalCount = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 局部状态，每个组件都会创建</span></span><br><span class="line">  <span class="keyword">const</span> localCount = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    globalCount,</span><br><span class="line">    localCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="⭐-Pinia-推荐"><a href="#⭐-Pinia-推荐" class="headerlink" title="⭐ Pinia 推荐"></a>⭐ <code>Pinia</code> 推荐</h3><ul><li><a href="https://pinia.vuejs.org/zh/core-concepts/">⭐ Pinia官方文档</a></li><li><a href="/2024/11/01/vue3/Pinia/" title="VUE3-Pinia">VUE3-Pinia</a></li></ul><h2 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h2><ul><li><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>将组件在服务端直接渲染成 HTML 字符串，作为服务端响应返回给浏览器，最后在浏览器端将静态的 HTML“激活”(hydrate) 为能够交互的客户端应用</li></ul></li><li><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul><li>更快的首屏加载：<ul><li>服务端渲染的 HTML 无需等到所有的 JavaScript 都下载并执行完成之后才显示</li><li>数据获取过程在首次访问时在服务端完成</li></ul></li><li>统一的心智模型：<ul><li>使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换。</li></ul></li><li>更好的 SEO：<ul><li>搜索引擎爬虫可以直接看到完全渲染的页面。</li></ul></li></ul></li><li><h3 id="静态站点生成-SSG-预渲染"><a href="#静态站点生成-SSG-预渲染" class="headerlink" title="静态站点生成(SSG&#x2F;预渲染):"></a>静态站点生成(SSG&#x2F;预渲染):</h3><ul><li>首屏加载性能</li><li>花销更小，部署更容易</li><li>仅用于消费静态数据的页面</li><li>优化为数不多的营销页面的 SEO</li></ul></li></ul><p><a href="https://cn.vuejs.org/guide/scaling-up/ssr.html">SSR创建及注意事项</a></p><h2 id="性能的优化"><a href="#性能的优化" class="headerlink" title="性能的优化"></a>性能的优化</h2><ul><li><h3 id="页面加载优化"><a href="#页面加载优化" class="headerlink" title="页面加载优化"></a>页面加载优化</h3><ul><li>选用正确的架构  <ul><li>避免将其部署为纯客户端的 SPA，而是让服务器直接发送包含用户想要查看的内容的 HTML 代码</li><li>必须是 SPA，但还有其他的营销相关页面，请单独部署这些页面</li></ul></li><li>包体积与 Tree-shaking 优化<ul><li>尽可能地采用构建步骤 </li><li>在引入新的依赖项时要小心包体积膨胀 – 选择提供 ES 模块格式的依赖</li></ul></li><li>代码分割</li></ul></li><li><h3 id="更新优化"><a href="#更新优化" class="headerlink" title="更新优化"></a>更新优化</h3><ul><li>Props 稳定性<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ListItem</span></span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span></span><br><span class="line">  :id=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">  :active-id=<span class="string">&quot;activeId&quot;</span> /&gt;</span><br><span class="line">改</span><br><span class="line">&lt;<span class="title class_">ListItem</span></span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span></span><br><span class="line">  :id=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">  :active=<span class="string">&quot;item.id === activeId&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li><li>v-once : 渲染依赖运行时数据但无需再更新的内容</li><li>v-memo : 有条件地跳过某些大型子树或者 v-for 列表的更新</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;⭐-SFC–单文件组件（-vue）&quot;&gt;&lt;a href=&quot;#⭐-SFC–单文件组件（-vue）&quot; class=&quot;headerlink&quot; title=&quot;⭐ SFC–单文件组件（*.vue）&quot;&gt;&lt;/a&gt;⭐ SFC–单文件组件（*.vue）&lt;/h2&gt;&lt;figure cla</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
  </entry>
  
</feed>
