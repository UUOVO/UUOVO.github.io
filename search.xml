<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6-Date</title>
    <url>/2024/10/31/ES6/es6-Date()%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><ul>
<li>new Date() — 构造Date实例</li>
<li>new Date(年，月，日（可选），…)</li>
<li>.getFullYear() 获取年</li>
<li>.getMonth() 获取月</li>
<li>.getDate() 获取日</li>
<li>.getDay() 获取一周中每天的对应数值<br>（可以将需要展示对应天数的文本用数组形式显示，然后通过下标获取）</li>
<li>day 传 0 表示获取上个月最后一天<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> endDate = <span class="keyword">new</span> <span class="title class_">Date</span>(年, 月, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li>.valueOf 转换成时间戳</li>
<li>.toTimeString() 时间戳转字符串</li>
<li>.setHours(小时，分钟，秒) 设置时间</li>
<li><h3 id="习惯使用-，弱类型转换，把string类型转number类型"><a href="#习惯使用-，弱类型转换，把string类型转number类型" class="headerlink" title="习惯使用+，弱类型转换，把string类型转number类型"></a>习惯使用+，弱类型转换，把string类型转number类型</h3></li>
</ul>
<h3 id="借助插件减少代码量和一些工作"><a href="#借助插件减少代码量和一些工作" class="headerlink" title="借助插件减少代码量和一些工作"></a>借助插件减少代码量和一些工作</h3><ul>
<li><a href="https://dayjs.fenxianglu.cn/">DayJs</a><ul>
<li>使用方式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>当使用一些查询的方法时，有些依赖一些插件</li>
<li>要注意调用dayjs.extend(插件)，最好放在全局调用</li>
</ul>
</li>
</ul>
<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><ul>
<li>GMT 格林威治时间与东八区相差 8 个小时</li>
</ul>
<h3 id="UTC-0时区与本地时区的差值，单位为分钟"><a href="#UTC-0时区与本地时区的差值，单位为分钟" class="headerlink" title="UTC+0时区与本地时区的差值，单位为分钟"></a>UTC+0时区与本地时区的差值，单位为分钟</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTimezoneOffset</span>()</span><br></pre></td></tr></table></figure>
<h3 id="解决时区不同时间不同的问题"><a href="#解决时区不同时间不同的问题" class="headerlink" title="解决时区不同时间不同的问题"></a>解决时区不同时间不同的问题</h3><ul>
<li>首先获取零时区的时间<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> diff = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTimezoneOffset</span>() <span class="comment">// 先获取当前地区与零时区的时间差</span></span><br><span class="line"><span class="keyword">const</span> absTime = <span class="keyword">new</span> <span class="title class_">Date</span>.<span class="title function_">getTime</span>() + diff * <span class="number">60</span> * <span class="number">1000</span> <span class="comment">// 根据本地时间与时间差获取格林威治时间</span></span><br></pre></td></tr></table></figure></li>
<li>其次获取不同地区与零时区的时差<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> localTime = <span class="keyword">new</span> <span class="title class_">Date</span>(absTime + timeZone * <span class="number">60</span> * <span class="number">60</span> *<span class="number">1000</span>)  <span class="comment">// timeZone 传进来的时间单位小时，东为正西为负</span></span><br></pre></td></tr></table></figure></li>
<li>用零时区的时间加减与零时区的视察，得到各地的绝对时间</li>
<li>考虑夏令时<br>根据资料，获得美国和澳大利亚的夏令时规则：</li>
</ul>
<p>美国:<br>每年的3月第二个星期日02:00:00，时钟向前调整1小时，变为03:00:00，开始夏令时<br>每年的11月第一个星期日02:00:00，时钟向后调整1小时，变为01:00:00，结束夏令时</p>
<p>澳大利亚:<br>每年的10月第一个星期日02:00:00，时钟向前调整1小时，变为03:00:00，开始夏令时<br>每年的4月第一个星期日03:00:00，时钟向后调整1小时，变为02:00:00，结束夏令时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timeZone: 东n区为正，西n区为负, 单位为小时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getFullTimeInfo</span> = (<span class="params">timeZone, country, spliter</span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取本地时间与格林威治时间的时间差(注意是分钟，记得转换)</span></span><br><span class="line">	<span class="keyword">const</span> diff = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTimezoneOffset</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据本地时间和时间差获得格林威治时间</span></span><br><span class="line">	<span class="keyword">const</span> absTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() + diff * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据格林威治时间和各地时区，得到各地时区的时间</span></span><br><span class="line">	<span class="keyword">let</span> localTime = <span class="keyword">new</span> <span class="title class_">Date</span>(absTime + timeZone * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 考虑夏令时</span></span><br><span class="line">	<span class="comment">// judgeDST是我封装好的一个判断夏令时的方法</span></span><br><span class="line">	<span class="keyword">const</span> isDST = <span class="title function_">judgeDST</span>(localTime, country);</span><br><span class="line">	<span class="keyword">if</span> (isDST) &#123;</span><br><span class="line">		localTime = <span class="keyword">new</span> <span class="title class_">Date</span>(absTime + (timeZone + <span class="number">1</span>) * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">time</span>: <span class="title function_">formatTime</span>(localTime, spliter).<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>).<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">2</span>).<span class="title function_">join</span>(<span class="string">&#x27;:&#x27;</span>), </span><br><span class="line">		isDST</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-Generator和 Iterators</title>
    <url>/2024/10/31/ES6/es6-Generator/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">
  
<h2 id="Iterator-的遍历过程"><a href="#Iterator-的遍历过程" class="headerlink" title="Iterator 的遍历过程:"></a>Iterator 的遍历过程:</h2><ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br></pre></td></tr></table></figure></li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回两个值，value：当前成员的值，done：是否遍历结束，返回布尔值</li>
</ul>
</li>
<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br></pre></td></tr></table></figure></li>
<li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Generator-function"><a href="#Generator-function" class="headerlink" title="Generator (function*)"></a>Generator (function*)</h2><blockquote>
<p>Generator 是一种特殊的函数类型，可以在函数执行过程中暂停和恢复执行。它通过使用 yield 表达式来实现中断和恢复执行的功能。</p>
</blockquote>
<ul>
<li>函数体内部使用yield表达式，定义不同的内部状态</li>
<li>当 Generator 函数被调用时，它并不会立即执行，而是返回一个迭代器对象。每次调用迭代器对象的 next() 方法时，Generator 函数会<span class="key_words">『从上一次执行的位置继续执行，直到遇到下一个 yield 表达式或函数结束』</span>。<ul>
<li>Generator 函数将返回一个包含当前值和执行状态的对象，其中 value: yield 表达式的结果，done: 是否执行完毕。</li>
</ul>
</li>
</ul>
<h2 id="yield-后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口"><a href="#yield-后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口" class="headerlink" title="yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口"></a>yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> 用在表达式中要加一个圆括号</span><br><span class="line"><span class="keyword">let</span> generator = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = <span class="title function_">generator</span>();</span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="作为对象属性的-Generator-函数"><a href="#作为对象属性的-Generator-函数" class="headerlink" title="作为对象属性的 Generator 函数"></a>作为对象属性的 Generator 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * <span class="title function_">myGeneratorMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可迭代性"><a href="#可迭代性" class="headerlink" title="可迭代性"></a>可迭代性</h2><h3 id="for…of-会遍历可迭代对象"><a href="#for…of-会遍历可迭代对象" class="headerlink" title="for…of 会遍历可迭代对象"></a>for…of 会遍历可迭代对象</h3><ul>
<li>调用Symbol.iterator</li>
<li>Map 和 Set已实现Symbol.iterator方法</li>
</ul>
<h3 id="for…of-和-for…in-语句"><a href="#for…of-和-for…in-语句" class="headerlink" title="for…of 和 for…in 语句"></a>for…of 和 for…in 语句</h3><ul>
<li>都可以迭代一个列表</li>
<li>for…in 迭代的是对象的键的列表</li>
<li>for…of 迭代对象的键对应的值</li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-Module</title>
    <url>/2024/10/31/ES6/es6-Module/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="模块功能主要由两个命令构成：export和import"><a href="#模块功能主要由两个命令构成：export和import" class="headerlink" title="模块功能主要由两个命令构成：export和import"></a>模块功能主要由两个命令构成：export和import</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输出：<span class="keyword">export</span> <span class="keyword">default</span> 名字</span><br><span class="line">引入文件：<span class="keyword">import</span> 变量名 <span class="keyword">from</span> <span class="string">&#x27;默认输出文件的路径&#x27;</span>;</span><br><span class="line">输出方法：<span class="keyword">export</span> <span class="keyword">const</span> 方法名 = <span class="function">(<span class="params">变量</span>) =&gt;</span> &#123; <span class="keyword">return</span> 返回的结果 &#125;</span><br><span class="line">引入方法：<span class="keyword">import</span> &#123; 方法名 &#125; <span class="keyword">from</span> <span class="string">&#x27;路径&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="comment">//输出变量</span></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, lastName, year &#125;;</span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">可以使用<span class="keyword">as</span>关键字重命名。</span><br><span class="line"><span class="keyword">export</span> &#123; firstName <span class="keyword">as</span>  f, lastName, year &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; 输入的对象 &#125; <span class="keyword">from</span> <span class="string">&#x27;路径&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>多次执行同一语句，只执行一次</li>
</ul>
<h3 id="export-default-默认指定输出"><a href="#export-default-默认指定输出" class="headerlink" title="export default 默认指定输出"></a>export default 默认指定输出</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);<span class="comment">// 默认指定输出foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其它文件引入时可直接另起名字</span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;默认输出文件的路径&#x27;</span>;</span><br><span class="line"><span class="title function_">customName</span>(); <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">对比：<span class="keyword">import</span>是否用&#123; &#125;                    </span><br><span class="line">如果想在一条<span class="keyword">import</span>语句中，同时输入默认方法和其他接口，可以写成下面这样。</span><br><span class="line"><span class="keyword">import</span> _, &#123; each, forEach &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>; <span class="comment">//each as forEach    </span></span><br></pre></td></tr></table></figure>

<h3 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>; <span class="comment">// *表输出这个模块的所有模块和方法，但会忽略该模块的default方法</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;ns&#125;;<span class="comment">//但当前模块不能直接使用ns</span></span><br></pre></td></tr></table></figure>

<h3 id="import-类似于-Node-js-的require-方法"><a href="#import-类似于-Node-js-的require-方法" class="headerlink" title="import()类似于 Node.js 的require()方法"></a>import()类似于 Node.js 的require()方法</h3><ul>
<li>区别主要是前者是异步加载，后者是同步加载</li>
</ul>
<ol>
<li>按需加载<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./dialogBox.js&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">dialogBox</span> =&gt;</span> &#123;</span><br><span class="line">		dialogBox.<span class="title function_">open</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">/* Error handling */</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>条件加载 （if…else）  </li>
<li>动态模块路径<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="title function_">f</span>())</span><br><span class="line">.<span class="title function_">then</span>(...);      </span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>注意：不使用require()</li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-Promise(resolve,reject)</title>
    <url>/2024/10/31/ES6/es6-Promise/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>⭐ Promise的三个状态:<br> pending(进行时),fulfilled(已成功),rejected(已失败)</p>
</blockquote>
<h3 id="Promise-对象的状态改变，只有两种可能："><a href="#Promise-对象的状态改变，只有两种可能：" class="headerlink" title="Promise 对象的状态改变，只有两种可能："></a>Promise 对象的状态改变，只有两种可能：</h3><ul>
<li>从 pending 变为 fulfilled 和从 pending 变为 rejected。</li>
<li>只要这两种情况发生，则称为 resolved（已定型）。</li>
<li>配置请求器的基本格式：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">request</span> = (<span class="params">url, data = &#123;&#125;, method = <span class="string">&#x27;GET&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">		wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">			url,</span><br><span class="line">			method,</span><br><span class="line">			<span class="attr">data</span>: &#123; ...data, <span class="attr">cross</span>: <span class="number">1</span> &#125;,</span><br><span class="line">			<span class="title function_">success</span>(<span class="params">res</span>) &#123;</span><br><span class="line">				<span class="comment">//返回一个成功的数据 </span></span><br><span class="line">				<span class="title function_">resolve</span>(res.<span class="property">data</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="title function_">fail</span>(<span class="params">err</span>) &#123;</span><br><span class="line">				<span class="comment">//错误时返回错误信息</span></span><br><span class="line">				<span class="title function_">reject</span>(err.<span class="property">errMsg</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Promise有两个参数-且是函数-—-resolve和reject"><a href="#Promise有两个参数-且是函数-—-resolve和reject" class="headerlink" title="Promise有两个参数,且是函数 — resolve和reject"></a>Promise有两个参数,且是函数 — resolve和reject</h3><ul>
<li><p>async会返回一个promise,可通过传入promise函数来判断它的状态</p>
</li>
<li><p>resolve(): 成功的回调</p>
</li>
<li><p>reject()：失败的回调</p>
</li>
<li><p>.then(resolved的回调函数,rejected的回调函数)：</p>
<ul>
<li>为 Promise 实例添加状态改变时的回调函数，返回的是一个新的Promise实例</li>
</ul>
</li>
<li><p>.catch()：发生错误时的回调函数</p>
</li>
<li><p>.finally()：不管 Promise 对象最后状态如何，都会执行的操作(then方法的特例),不接受任何参数</p>
</li>
<li><p>.all()：用于将多个 Promise 实例，包装成一个新的 Promise 实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
<ul>
<li>只有p1、p2、p3的状态<span class="key_words">『都变成fulfilled，p的状态才会变成fulfilled』</span>，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要p1、p2、p3之中<span class="key_words">『有一个rejected，p的状态就变成rejected』</span>，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li>
</ul>
</li>
<li><p>.allSettled()：确定一组异步操作是否<span class="key_words">『都结束』</span>了（不管成功或失败），才会执行下一步</p>
</li>
<li><p>.any()：等到所有参数 Promise 变成rejected状态才会结束。</p>
</li>
</ul>
<h3 id="Promise-try-同步函数同步执行，异步函数异步执行"><a href="#Promise-try-同步函数同步执行，异步函数异步执行" class="headerlink" title="Promise.try() 同步函数同步执行，异步函数异步执行"></a>Promise.try() 同步函数同步执行，异步函数异步执行</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">try</span>(f);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-then第二参数和catch的区别？"><a href="#Promise-then第二参数和catch的区别？" class="headerlink" title="Promise then第二参数和catch的区别？"></a>Promise then第二参数和catch的区别？</h3><ul>
<li>两者都是用于处理Promise的rejected状态的情况</li>
<li>then方法的第二个参数<ul>
<li>如果Promise的状态变为rejected，then方法的第二个参数会被调用。该参数是一个函数，可以接受一个参数，即Promise返回的错误信息。当Promise被reject时，then方法的第二个参数会被调用，并打印出错误信息</li>
</ul>
</li>
<li>catch 方法<ul>
<li>相当于then方法的第二个参数，也用于处理Promise的rejected状态的情况。不同在于catch方法可以链式调用，而不需要在每次调用then方法时都传递第二个参数。当Promise被reject时，catch方法会被调用，并打印出错误信息</li>
</ul>
</li>
</ul>
<h3 id="async-函数的返回值"><a href="#async-函数的返回值" class="headerlink" title="async 函数的返回值"></a>async 函数的返回值</h3><ul>
<li>async函数在抛出返回值时，会根据返回值类型开启不同数目的微任务<ul>
<li>如果返回值为<span class="key_words">『非then，非promise』</span>，则不等待其他结果，<span class="key_words">『先返回自身』</span></li>
<li>如果返回值为『then』，则<span class="key_words">『等待1个then』</span>的时间，然后返回自身，再继续往下走</li>
<li>如果返回值为『promise』，则<span class="key_words">『等待2个then』</span>的时间，然后返回自身，再继续往下走(等待就是执行promise中的then)</li>
</ul>
</li>
<li>例子：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值为 非then，非promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testA</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">testA</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>));</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>))</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 then</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testB</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="title function_">then</span> (cb) &#123;</span><br><span class="line">				<span class="title function_">cb</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">testB</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>));</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>))</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>))</span><br><span class="line"><span class="comment">// 2 1 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值 promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testC</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="title function_">resolve</span>()</span><br><span class="line">	&#125;)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="title function_">testC</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>));</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">		.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>))</span><br><span class="line">		.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>))</span><br><span class="line">		.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 2 3 1 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>) ------------------------------ <span class="number">2</span> 执行async1函数，得到<span class="number">1</span></span><br><span class="line">	<span class="keyword">await</span> <span class="title function_">async2</span>() -------------------------------- <span class="number">3</span> 执行async2函数</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;AAA&#x27;</span>) ---------------------------- <span class="number">9</span> 等待async2函数执行完，得到<span class="variable constant_">AAA</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>) ------------------------------ <span class="number">3</span> 执行async2函数，得到<span class="number">3</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="title function_">resolve</span>() --------------------------------- <span class="number">5</span> 执行<span class="title class_">Promise</span>，返回值为<span class="title class_">Promise</span>，等待两个then</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>) -------------------------- <span class="number">4</span> <span class="title class_">Promise</span>构造器中代码属于同步代码，得到<span class="number">4</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>)		------------------------------- <span class="number">1</span> 同步代码先执行</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>) ------------------------------ <span class="number">11</span> 放入宏任务异步队列中</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>() ------------------------------------------ <span class="number">2</span> 执行async1函数</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>) ------------------------------ <span class="number">5</span> 执行<span class="title class_">Promise</span>，得到 <span class="number">7</span></span><br><span class="line">	<span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>) ------------------------------ <span class="number">7</span> 等待第一个then，得到 <span class="number">8</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>) ------------------------------ <span class="number">8</span> 等待第二个then，得到 <span class="number">9</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10&#x27;</span>) ----------------------------- <span class="number">10</span> 执行最后一个微任务then，得到 <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11&#x27;</span>) --------------------------------- <span class="number">6</span> 同步代码，得到 <span class="number">11</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="await-右值类型区别"><a href="#await-右值类型区别" class="headerlink" title="await 右值类型区别"></a>await 右值类型区别</h3><ul>
<li>非 then：会立即向微任务队列添加一个微任务then，但不需等待</li>
<li>then：需要等待一个 then 的时间之后执行</li>
<li>promise：接Promise类型(有确定的返回值)，会立即向微任务队列添加一个微任务then，但不需等待</li>
<li>示例：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*then*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">await</span> &#123;</span><br><span class="line">		<span class="title function_">then</span> (cb) &#123;</span><br><span class="line">			<span class="title function_">cb</span>();</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>))</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>))</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>))</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  1 3 4 2 5 6 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*promise*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="title function_">resolve</span>() <span class="comment">// 保持pending</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>))</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>))</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>))</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  1 3 2 4 5 6 7</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="promise-race"><a href="#promise-race" class="headerlink" title="promise.race"></a>promise.race</h3><ul>
<li>接受一个 Promise 数组并返回一个新的 Promise</li>
<li>返回的 Promise 将解析或拒绝其中一个 Promise 解析或拒绝的第一个值。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Fn</span> = <span class="function">(<span class="params">...params: any[]</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;any&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeLimit</span>(<span class="params">fn: Fn, t: number</span>): <span class="title class_">Fn</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> timeLimitPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="string">&quot;Time Limit Exceeded&quot;</span>), t)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>([timeLimitPromise, <span class="title function_">fn</span>(...args)]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise 和 async/await</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-async/await</title>
    <url>/2024/10/31/ES6/es6-aysnc%E5%92%8Cawait/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="async：是-Generator-函数的语法糖。返回一个Promise对象"><a href="#async：是-Generator-函数的语法糖。返回一个Promise对象" class="headerlink" title="async：是 Generator 函数的语法糖。返回一个Promise对象"></a>async：是 Generator 函数的语法糖。返回一个Promise对象</h3><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><ul>
<li>后面是Promise对象，返回该对象的结果，如果不是返回对应的值。后面是一个thenable对象（即定义了then方法的对象），那么await会将其等同于 Promise 对象。</li>
<li>async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>
</ul>
<h3 id="使用形式："><a href="#使用形式：" class="headerlink" title="使用形式："></a>使用形式：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; &#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>().<span class="title function_">then</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">cachePromise</span> = caches.<span class="title function_">open</span>(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getAvatar</span>(<span class="params">name</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">cachePromise</span>;</span><br><span class="line">	<span class="keyword">return</span> cache.<span class="title function_">match</span>(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> <span class="title class_">Storage</span>();</span><br><span class="line">storage.<span class="title function_">getAvatar</span>(<span class="string">&#x27;jake&#x27;</span>).<span class="title function_">then</span>(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul>
<li>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。</li>
</ul>
<h3 id="防止错误处理"><a href="#防止错误处理" class="headerlink" title="防止错误处理"></a>防止错误处理</h3><ul>
<li>多个await命令，可以统一放在try…catch结构中。</li>
<li>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()]);</span><br></pre></td></tr></table></figure></li>
<li>await命令只能用在async函数之中</li>
<li>可以保留运行堆栈</li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise 和 async/await</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-Set/Map构造函数</title>
    <url>/2024/10/31/ES6/es6-set%E5%92%8Cmap/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><blockquote>
<p>去重小能手</p>
</blockquote>
<h3 id="set去重"><a href="#set去重" class="headerlink" title="set去重"></a>set去重</h3><ol>
<li><p>去重数组成员: […set]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set =  <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set]) <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>去重字符串里面重复的字符:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)	<span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.from的去重数组成员</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dedupe</span> = (<span class="params">array</span>) =&gt; <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array))</span><br><span class="line"><span class="title function_">dedupe</span>([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])		<span class="comment">//	[1,2,3]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="创建Set构造函数：new-Set"><a href="#创建Set构造函数：new-Set" class="headerlink" title="创建Set构造函数：new Set()"></a>创建Set构造函数：new Set()</h3><h3 id="set操作方法："><a href="#set操作方法：" class="headerlink" title="set操作方法："></a>set操作方法：</h3><ul>
<li>Set.add(value)：添加某个值，返回set结构本身</li>
<li>Set.delete(value): 删除某个值，返回一个布尔值表删除是否成功</li>
<li>Set.has(value)： 返回一个布尔值，表该值是否为set成员</li>
<li>Set.clear()： 清除所有成员，无返回值</li>
<li>注意：<span class="key_words">『NAN相等，两个{}不相等』</span></li>
</ul>
<h3 id="Set结构转数组-Array-from"><a href="#Set结构转数组-Array-from" class="headerlink" title="Set结构转数组: Array.from()"></a>Set结构转数组: Array.from()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="创建一个Map构造函数：new-Map"><a href="#创建一个Map构造函数：new-Map" class="headerlink" title="创建一个Map构造函数：new Map()"></a>创建一个Map构造函数：new Map()</h3><h3 id="Map操作方法"><a href="#Map操作方法" class="headerlink" title="Map操作方法"></a>Map操作方法</h3><ul>
<li>.set(key，value)：添加某个值,如果key已经有值就更新</li>
<li>.get(key)：读取值，找不到key，返回undefined</li>
<li>.has(key)：返回一个布尔值，表示某个键是否在当前 Map 对象中</li>
<li>.delete(key)：删除某个键，返回一个布尔值表删除是否成功</li>
<li>.clear()：无返回值，清除所有成员</li>
</ul>
<h2 id="Set-Map-共同方法"><a href="#Set-Map-共同方法" class="headerlink" title="Set &#x2F; Map 共同方法"></a>Set &#x2F; Map 共同方法</h2><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><blockquote>
<p>Map默认entries， Set默认keys，Set中没有values，因为Set结构没有键名只有键值</p>
</blockquote>
<ul>
<li>.keys()：返回键名的遍历器</li>
<li>.values()：返回键值的遍历器</li>
<li>.entries()：返回键值对的遍历器([键名,键值])</li>
<li>.forEach()：使用回调函数遍历每个成员</li>
</ul>
<h3 id="实例属性："><a href="#实例属性：" class="headerlink" title="实例属性："></a>实例属性：</h3><ul>
<li>.size：返回Set&#x2F;Map实例的成员总数</li>
</ul>
<h2 id="reduce-累加器"><a href="#reduce-累加器" class="headerlink" title="reduce 累加器"></a>reduce 累加器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">reduce</span>(</span><br><span class="line">	<span class="function">(<span class="params">previousValue, currentValue, currentIndex, array</span>) =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;, </span><br><span class="line">	initialValue</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>previousValue: 数组第0位及后面相加返回的值，可指定初始值initial</li>
<li>currentValue: 数值的第二位起</li>
<li>currentIndex: 当前值位置</li>
</ul>
<h3 id="map-遍历"><a href="#map-遍历" class="headerlink" title=".map():遍历"></a>.map():遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set =<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">69</span>,<span class="number">74</span>,<span class="number">45</span>])</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> (x * <span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map= <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">.<span class="title function_">set</span>(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">.<span class="title function_">set</span>(<span class="number">2</span>,<span class="string">&quot;f&quot;</span>)</span><br><span class="line">.<span class="title function_">set</span>(<span class="number">3</span>,<span class="string">&quot;g&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>([...map].<span class="title function_">map</span>(<span class="function">(<span class="params">[k,v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;_&#x27;</span>+v]))</span><br></pre></td></tr></table></figure>
<h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title=".filter():过滤"></a>.filter():过滤</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set =<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">69</span>,<span class="number">74</span>,<span class="number">45</span>])</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> (x * <span class="number">2</span>) &gt; <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>([...map].<span class="title function_">filter</span>(<span class="function">(<span class="params">[k,v]</span>) =&gt;</span> k == <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h2 id="互转结构"><a href="#互转结构" class="headerlink" title="互转结构"></a>互转结构</h2><h3 id="map-转数组：-…map"><a href="#map-转数组：-…map" class="headerlink" title="map 转数组：[…map]"></a>map 转数组：[…map]</h3><h3 id="数组转map：new-Map-array"><a href="#数组转map：new-Map-array" class="headerlink" title="数组转map：new Map([array])"></a>数组转map：new Map([array])</h3><h3 id="map转对象"><a href="#map转对象" class="headerlink" title="map转对象"></a>map转对象</h3><ul>
<li>方案一：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map.<span class="title function_">entries</span>()) --- <span class="title class_">ESS10</span></span><br></pre></td></tr></table></figure></li>
<li>方案二： 键名为字符串，无损<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">strMapToObj</span> = (<span class="params">strMap</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span>[k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">		obj[k] = v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">	.<span class="title function_">set</span>(<span class="string">&#x27;yes&#x27;</span>,<span class="literal">true</span>)</span><br><span class="line">	.<span class="title function_">set</span>(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="title function_">strMapToObj</span>(<span class="params">myMap</span>) &#123;<span class="attr">yes</span>:<span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="对象转Map-Object-entries"><a href="#对象转Map-Object-entries" class="headerlink" title="对象转Map: Object.entries()"></a>对象转Map: Object.entries()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br></pre></td></tr></table></figure>

<h3 id="Map转JSON"><a href="#Map转JSON" class="headerlink" title="Map转JSON"></a>Map转JSON</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一： 键名都是字符串（对象JSON）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">strMapToJson</span> = (<span class="params">strMap</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">strMapToObj</span>(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToJson</span>(myMap)		<span class="comment">// &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二： 键名有非字符串（数组 JSON）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapToArrayJson</span> = (<span class="params">map</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>).<span class="title function_">set</span>(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line"><span class="title function_">mapToArrayJson</span>(myMap)		<span class="comment">// &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="JSON转Map"><a href="#JSON转Map" class="headerlink" title="JSON转Map"></a>JSON转Map</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常情况，所有键名都是字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">jsonToStrMap</span> = (<span class="params">jsonStr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">objToStrMap</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToStrMap</span>(<span class="string">&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;</span>)	</span><br><span class="line"><span class="comment">// Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">jsonToMap</span> = (<span class="params">jsonStr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToMap</span>(<span class="string">&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span>)		</span><br><span class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Map构造函数求value最大值"><a href="#Map构造函数求value最大值" class="headerlink" title="Map构造函数求value最大值"></a>Map构造函数求value最大值</h2><ul>
<li>只取value的最大值：Math.max(…m.values())</li>
<li>取最大值的key，value： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...m.<span class="title function_">entries</span>()].<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, e</span>) =&gt;</span> e[<span class="number">1</span>] &gt; a[<span class="number">1</span>] ? e : a)</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点：有多个相等的最大值获取不到</li>
</ul>
</li>
<li>取最大值的key，value:（相等也可）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">maxList</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="title class_">MaxEle</span> = []</span><br><span class="line">	<span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">			max = max &gt; value ? max : value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title class_">MaxEle</span> = [...map.<span class="title function_">entries</span>()].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item[<span class="number">1</span>] === max)</span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">MaxEle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Set() 和 Map()</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-字符串</title>
    <url>/2024/10/31/ES6/es6-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h2><ul>
<li>采用\uxxxx形式表示一个字符(\u0000~\uFFFF)</li>
<li>超范围的字符，必须用两个双字节的形式表示。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u20BB7&quot;</span>         <span class="comment">// &quot;7&quot;</span></span><br><span class="line"><span class="string">&quot;\uD842\uDFB7&quot;</span>    <span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"><span class="string">&quot;\u&#123;20BB7&#125;&quot;</span>       <span class="comment">// &quot;𠮷&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="js六种方法表字符"><a href="#js六种方法表字符" class="headerlink" title="js六种方法表字符"></a>js六种方法表字符</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\z&#x27;</span> === <span class="string">&#x27;z&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u&#123;7A&#125;&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="for…of循环遍历"><a href="#for…of循环遍历" class="headerlink" title="for…of循环遍历"></a>for…of循环遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(codePoint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Js-规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。"><a href="#Js-规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。" class="headerlink" title="Js 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。"></a>Js 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。</h2><ul>
<li>U+005C：反斜杠(reverse solidus)</li>
<li>U+000D：回车(carriage return)</li>
<li>U+2028：行分隔符(line separator)</li>
<li>U+2029：段分隔符(paragraph separator)</li>
<li>U+000A：换行符(line feed)</li>
</ul>
<h2 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify() 的改造"></a>JSON.stringify() 的改造</h2><ul>
<li>遇到0xD800到0xDFFF之间的单个码点，或不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;\u&#123;D834&#125;&#x27;</span>)        <span class="comment">// &quot;&quot;\\uD834&quot;&quot;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;\uDF06\uD834&#x27;</span>)   <span class="comment">// &quot;&quot;\\udf06\\ud834&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="模板字符串（反引号-标识）"><a href="#模板字符串（反引号-标识）" class="headerlink" title="模板字符串（反引号&#96;标识）"></a>模板字符串（反引号&#96;标识）</h2><ul>
<li>模板字符串中嵌入变量，需要将变量名写在${}之中。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br></pre></td></tr></table></figure></li>
<li>能调用函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert<span class="string">`hello`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">alert</span>([<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//先处理参数，之后调用函数</span></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">tag</span>([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h3><ul>
<li>从 Unicode 码点返回对应字符</li>
</ul>
<h3 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h3><ul>
<li>处理4 个字节储存的字符，返回一个字符的码点。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;𠮷a&#x27;</span>;   <span class="comment">// 0x20BB7</span></span><br><span class="line">s.<span class="title function_">codePointAt</span>(<span class="number">0</span>) <span class="comment">// 20  134071</span></span><br><span class="line">s.<span class="title function_">codePointAt</span>(<span class="number">1</span>) <span class="comment">// BB 57271</span></span><br><span class="line">s.<span class="title function_">codePointAt</span>(<span class="number">2</span>) <span class="comment">// 7 97  </span></span><br></pre></td></tr></table></figure></li>
<li>解决字符串参数位置识别不对：<ul>
<li>for…of循环<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;𠮷a&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ch.<span class="title function_">codePointAt</span>(<span class="number">0</span>).<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>扩展运算符（…）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...<span class="string">&#x27;𠮷a&#x27;</span>]; <span class="comment">// arr.length === 2</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(</span><br><span class="line">	<span class="function"><span class="params">ch</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(ch.<span class="title function_">codePointAt</span>(<span class="number">0</span>).<span class="title function_">toString</span>(<span class="number">16</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试是否是四个字节</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">is32Bit</span>(<span class="params">c</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> c.<span class="title function_">codePointAt</span>(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">is32Bit</span>(<span class="string">&quot;𠮷&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">is32Bit</span>(<span class="string">&quot;a&quot;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h3><ul>
<li>原有多少斜杠，<span class="key_words">『实际返回原来斜杠的两倍』</span>，但肉眼看不出来</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property">raw</span><span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>  <span class="comment">// 实际返回 &quot;Hi\\n5!&quot;，显示的是转义后的结果 &quot;Hi\n5!&quot;</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property">raw</span><span class="string">`Hi\\n`</span> === <span class="string">&quot;Hi\\\\n&quot;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><ul>
<li>将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化</li>
</ul>
<h3 id="includes-—-ES7"><a href="#includes-—-ES7" class="headerlink" title="includes() — ES7"></a>includes() — ES7</h3><ul>
<li>   含义：判断一个数组或字符串中是否包含一个指定的值</li>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">includes</span>(searchString, position)</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>searchString：要查找的字符串</li>
<li>position：字符串开始搜索sezrchString的起始位置，默认为0</li>
</ul>
</li>
<li>返回：布尔值，true表示存在</li>
</ul>
<h3 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith()"></a>startsWith()</h3><ul>
<li>含义: 参数字符串是否在原字符串的头部</li>
<li>返回: 布尔值</li>
</ul>
<h3 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith()"></a>endsWith()</h3><ul>
<li>含义：参数字符串是否在原字符串的尾部</li>
<li>返回: 布尔值</li>
</ul>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><ul>
<li>含义：将原字符串重复n次</li>
<li>返回：一个新字符串</li>
<li>示例：’hello’.repeat(2) &#x2F;&#x2F; “hellohello”</li>
<li>注意：<span class="key_words">『如果参数是小数会向上取整，负数或无穷会报错，0到-1和NaN等于0，字符串会转数字』</span></li>
</ul>
<h3 id="padStart-用于头部补全长度-—-ES8"><a href="#padStart-用于头部补全长度-—-ES8" class="headerlink" title="padStart()用于头部补全长度 — ES8"></a>padStart()用于头部补全长度 — ES8</h3><ul>
<li>含义：用另一个字符串填充当前字符串</li>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">padStart</span>(targetLength, padString)</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身</li>
<li>padString（可选）：填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的默认值为 “ “。</li>
</ul>
</li>
<li>返回值：在原字符串<sapn class="key_words">『开头』</span>填充指定的填充字符串直到目标长度所形成的新字符串。</li>
</ul>
<h3 id="padEnd-用于尾部补全长度-—-ES8"><a href="#padEnd-用于尾部补全长度-—-ES8" class="headerlink" title="padEnd()用于尾部补全长度 — ES8"></a>padEnd()用于尾部补全长度 — ES8</h3><ul>
<li>含义：用另一个字符串填充当前字符串</li>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">padEnd</span>(targetLength, padString)</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身</li>
<li>padString（可选）：填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的默认值为 “ “。</li>
</ul>
</li>
<li>返回值：在原字符串<sapn class="key_words">『末尾』</span>填充指定的填充字符串直到目标长度所形成的新字符串。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>);         <span class="comment">// &quot;       abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&quot;foo&quot;</span>);  <span class="comment">// &quot;foofoofabc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">6</span>,<span class="string">&quot;123465&quot;</span>); <span class="comment">// &quot;123abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">8</span>, <span class="string">&quot;0&quot;</span>);     <span class="comment">// &quot;00000abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">1</span>);          <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">10</span>);          <span class="comment">// &quot;abc       &quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">10</span>, <span class="string">&quot;foo&quot;</span>);   <span class="comment">// &quot;abcfoofoof&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">6</span>, <span class="string">&quot;123456&quot;</span>); <span class="comment">// &quot;abc123&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">1</span>);           <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="trimStart-—-ES10"><a href="#trimStart-—-ES10" class="headerlink" title="trimStart() — ES10"></a>trimStart() — ES10</h3><ul>
<li>含义：删除字符串开头的空白字符</li>
<li>别名：trimeLeft()</li>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">trimStart</span>()</span><br></pre></td></tr></table></figure></li>
<li>返回：一个新字符串</li>
</ul>
<h3 id="trimEnd-—-ES10"><a href="#trimEnd-—-ES10" class="headerlink" title="trimEnd() — ES10"></a>trimEnd() — ES10</h3><ul>
<li>含义: 删除字符串尾部的空白字符</li>
<li>别名：trimRight()</li>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">trimEnd</span>()</span><br></pre></td></tr></table></figure></li>
<li>返回：新字符串</li>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;    a b cd  &#x27;</span>;</span><br><span class="line">str.<span class="title function_">trimStart</span>();   <span class="comment">// &#x27;a b cd  &#x27;</span></span><br><span class="line">str.<span class="title function_">trimLeft</span>();    <span class="comment">// &#x27;a b cd  &#x27;</span></span><br><span class="line"></span><br><span class="line">str.<span class="title function_">trimEnd</span>()</span><br><span class="line">str.<span class="title function_">trimRight</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h3><ul>
<li>返回: 一个正则表达式在当前字符串的所有匹配，以数组的形式</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;test1test2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [...str.<span class="title function_">matchAll</span>(regexp)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array[<span class="number">0</span>]);  <span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array[<span class="number">1</span>]); <span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="replaceAll-pattern-replacement"><a href="#replaceAll-pattern-replacement" class="headerlink" title="replaceAll(pattern, replacement)"></a>replaceAll(pattern, replacement)</h3><ul>
<li>含义：所有匹配的pattern的部分都会被替换为replacement</li>
<li>返回：新字符串</li>
<li>参数：<ul>
<li>pattern：字符串 或者 带g的正则表达式</li>
<li>replacement：函数&#x2F;字符串，可以带有特殊字符</li>
</ul>
</li>
<li>特殊字符<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$&amp;：匹配的字符串</span><br><span class="line">$<span class="string">`：匹配结果前面的文本</span></span><br><span class="line"><span class="string">$&#x27;：匹配结果后面的文本</span></span><br><span class="line"><span class="string">$n：匹配成功的第n组内容，n是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式</span></span><br><span class="line"><span class="string">$$：指代美元符号$</span></span><br></pre></td></tr></table></figure></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.<span class="title function_">replaceAll</span>(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);  <span class="comment">// &#x27;aa..cc&#x27;</span></span><br><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.<span class="title function_">replaceAll</span>(<span class="regexp">/b/g</span>, <span class="string">&#x27;.&#x27;</span>);  <span class="comment">// &quot;aa..cc&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h3><ul>
<li>接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）</li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-函数的拓展</title>
    <url>/2024/10/31/ES6/es6-%E5%87%BD%E6%95%B0%E7%9A%84%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><ul>
<li>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h2><ul>
<li>有默认值的长度不被计算且后面不管是否有默认值都忽略                    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">a</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>如果x没有赋值就指向全局，赋值后指向所附的值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y = x</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">2</span>)</span><br><span class="line">rest参数 ...不算长度</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul>
<li>变量 &#x3D; 形参 &#x3D;&gt; 返回的表达式或数值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>this的指向：嵌套箭头函数的this最终指向最外层函数的this(<span class="desc">因为箭头函数没有自己的this</span>)</li>
<li>不能用call()、apply()、bind()这些方法去改变this的指向。</li>
<li>定义对象和动态this不使用箭头函数</li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-数值的拓展</title>
    <url>/2024/10/31/ES6/es6-%E6%95%B0%E5%80%BC%E7%9A%84%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="二八进制表示法"><a href="#二八进制表示法" class="headerlink" title="二八进制表示法"></a>二八进制表示法</h2><ul>
<li>八进制 前缀0o</li>
<li>二进制 前缀0b</li>
<li>转为十进制 使用Number方法</li>
</ul>
<h2 id="不支持数值分隔符（-）"><a href="#不支持数值分隔符（-）" class="headerlink" title="不支持数值分隔符（_）"></a>不支持数值分隔符（_）</h2><ul>
<li>Number()</li>
<li>parseInt() </li>
<li>parseFloat()</li>
</ul>
<h2 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h2><ul>
<li>Number.isFinite() 用来检查一个数值是否为有限的（finite）,不是数值返回false</li>
<li>Number.isNaN() 用来检查一个值是否为NaN。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">9</span>/<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;true&#x27;</span> / <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;true&#x27;</span> / <span class="string">&#x27;true&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Number-isInteger-是否为整数"><a href="#Number-isInteger-是否为整数" class="headerlink" title="Number.isInteger() 是否为整数"></a>Number.isInteger() 是否为整数</h2><ul>
<li>数值精度最多可以达到 53 个二进制位（<span class="desc">1 个隐藏位与 52 个有效位</span>）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">3.0000000000000002</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h2><ul>
<li>表示 1 与大于 1 的最小浮点数之间的差。（<span class="desc">最小误差范围</span>）</li>
</ul>
<h2 id="Number-MAX-SAFE-INTEGER和Number-MIN-SAFE-INTEGER"><a href="#Number-MAX-SAFE-INTEGER和Number-MIN-SAFE-INTEGER" class="headerlink" title="Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER"></a>Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER</h2><ul>
<li>这两个常量，用来表示这个范围的上下限<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>		<span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> === <span class="number">9007199254740991</span>		<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span> === -<span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>	<span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span> === -<span class="number">9007199254740991</span>			<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Number-isSafeInteger-则是用来判断一个整数是否落在这个范围之内。"><a href="#Number-isSafeInteger-则是用来判断一个整数是否落在这个范围之内。" class="headerlink" title="Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。"></a>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</h2><h2 id="Math-trunc-去除一个数的小数部分，返回整数部分。"><a href="#Math-trunc-去除一个数的小数部分，返回整数部分。" class="headerlink" title="Math.trunc()  去除一个数的小数部分，返回整数部分。"></a>Math.trunc()  去除一个数的小数部分，返回整数部分。</h2><ul>
<li>非数值，先转数值</li>
<li>控制或无法截取整数的值，返回NAN</li>
</ul>
<h2 id="Math-sign方法"><a href="#Math-sign方法" class="headerlink" title="Math.sign方法"></a>Math.sign方法</h2><ul>
<li>用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</li>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为 0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>数值</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-对象的拓展</title>
    <url>/2024/10/31/ES6/es6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><ul>
<li>方法一：用标识符作为属性名<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">foo</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>方法二：用表达式作为属性名<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj[<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>] = <span class="number">123</span></span><br></pre></td></tr></table></figure></li>
<li>注意：<span class="key_words">『属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象字面量</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义方法名</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span> + <span class="string">&#x27;ello&#x27;</span>]()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">hello</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数的name属性，返回函数名。对象方法也是函数"><a href="#函数的name属性，返回函数名。对象方法也是函数" class="headerlink" title="函数的name属性，返回函数名。对象方法也是函数"></a>函数的name属性，返回函数名。对象方法也是函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	<span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">foo</span>() &#123;&#125;,</span><br><span class="line">	<span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="property">sayNAme</span>.<span class="property">name</span>  <span class="comment">// &#x27;sayName&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name再该方法的属性的get和set上<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnProertyDescriptor</span>(person,<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">desc.<span class="property">get</span>.<span class="property">name</span> <span class="string">&quot;get foo&quot;</span></span><br><span class="line">desc.<span class="property">set</span>.<span class="property">name</span> <span class="string">&quot;set foo&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>特殊情况： <ul>
<li>bind方法创造的函数，name属性返回bound 加上原函数名；Function构造函数创造的函数，返回anonymous<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">Function</span>()).<span class="property">name</span> <span class="comment">// &quot;anonymous&quot;</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">doSomething.<span class="title function_">bind</span>().<span class="property">name</span> <span class="comment">//&quot;bound doSOmething&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>2、对象方法是一个Symbol值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	[key1]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj[key1].<span class="property">name</span> <span class="comment">// &#x27;description&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h2><h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><ul>
<li>for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li>
</ul>
<h3 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h3><ul>
<li>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</li>
</ul>
<h3 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h3><ul>
<li>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</li>
</ul>
<h3 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h3><ul>
<li>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。</li>
</ul>
<h3 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h3><ul>
<li>Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</li>
</ul>
<h3 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h3><ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(&#123; </span><br><span class="line">  [<span class="title class_">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> </span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="super-指向当前对象的原型对象"><a href="#super-指向当前对象的原型对象" class="headerlink" title="super 指向当前对象的原型对象"></a>super 指向当前对象的原型对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将proto设置为obj的原型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = &#123; ...[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]&#125;</span><br><span class="line">foo <span class="comment">// &#123;0:&quot;a&quot;,1:&quot;b&quot;,z:&quot;c&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对象的扩展运算符等同于使用Object.assign()方法。</li>
</ul>
<h2 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h2><h3 id="Object-is-值1，值2-判断两个值是否严格相等（-）"><a href="#Object-is-值1，值2-判断两个值是否严格相等（-）" class="headerlink" title="Object.is(值1，值2), 判断两个值是否严格相等（&#x3D;&#x3D;&#x3D;）"></a>Object.is(值1，值2), 判断两个值是否严格相等（&#x3D;&#x3D;&#x3D;）</h3><ul>
<li>+0不等于-0，NAN等于自身</li>
</ul>
<h3 id="Object-assign-方法用于对象的合并-浅拷贝"><a href="#Object-assign-方法用于对象的合并-浅拷贝" class="headerlink" title="Object.assign()方法用于对象的合并(浅拷贝)"></a>Object.assign()方法用于对象的合并(浅拷贝)</h3><ul>
<li>多参：<ul>
<li>Object.assign(复制存放地, 被复制对象, 被复制对象，…);</li>
</ul>
</li>
<li>一参：返回该参数<ul>
<li>undefined，null做首参则报错</li>
<li>参数非对象，转对象在返回</li>
<li>不拷贝enumerable: false</li>
</ul>
</li>
</ul>
<h3 id="Object-getOwnProertyDescriptor-—-ES8"><a href="#Object-getOwnProertyDescriptor-—-ES8" class="headerlink" title="Object.getOwnProertyDescriptor — ES8"></a>Object.getOwnProertyDescriptor — ES8</h3><ul>
<li>含义：获取一个对象的所有自身属性的描述符</li>
<li>语法：Object.getOwnPropertyDescriptors(obj)</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj);   <span class="comment">// [a: &#123;configurable: true, enumerable: true, value: 1, writable: true&#125;, b: &#123;configurable: true, enumerable: true, value: 2, writable: true&#125;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>浅拷贝：只要修改其中一个，其它的也会改变<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,obj1);</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>.<span class="property">b</span>)  </span><br><span class="line"></span><br><span class="line">obj2.<span class="property">a</span>.<span class="property">b</span> = <span class="number">4</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>.<span class="property">b</span>)</span><br></pre></td></tr></table></figure></li>
<li>同名属性替换（复制存放的对象属性如果跟被复制的对象属性一样，替换）</li>
<li>可以处理数组，但是会把数组视为对象</li>
</ol>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><ol>
<li>为对象添加属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将x属性和y属性添加到Point类的对象实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为对象添加 方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给SomeClass.prototype添加方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="title function_">someMethod</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">anotherMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>克隆对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>合并多个对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> = (<span class="params">target, ...sources</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-数组的拓展</title>
    <url>/2024/10/31/ES6/es6-%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="扩展运算符：…"><a href="#扩展运算符：…" class="headerlink" title="扩展运算符：…"></a>扩展运算符：…</h3><h3 id="Array-from-：转数组"><a href="#Array-from-：转数组" class="headerlink" title="Array.from()：转数组"></a>Array.from()：转数组</h3><h3 id="Array-of-：将一组值转为数组"><a href="#Array-of-：将一组值转为数组" class="headerlink" title="Array.of()：将一组值转为数组"></a>Array.of()：将一组值转为数组</h3><h3 id="copyWithin-："><a href="#copyWithin-：" class="headerlink" title="copyWithin()："></a>copyWithin()：</h3><ul>
<li>Array.copyWithin(定位, 从定位开始读, 停止读) ：复制到定位的位置（原有数据会覆盖），返回新数组</li>
</ul>
<h3 id="find-，findIndex-，findLast-，findLastIndex"><a href="#find-，findIndex-，findLast-，findLastIndex" class="headerlink" title="find()，findIndex()，findLast()，findLastIndex()"></a>find()，findIndex()，findLast()，findLastIndex()</h3><ul>
<li>find()：找出第一个符合条件的数组成员，没有返undefined           </li>
<li>findIndex()：找出第一个符合条件的数组成员，没有返-1</li>
<li>findLast()：从后面到前面找起</li>
<li>findLastIndex()：从后面到前面找起</li>
</ul>
<h3 id="fill-填充数，填充起始位，结束位-给值填充一个数组"><a href="#fill-填充数，填充起始位，结束位-给值填充一个数组" class="headerlink" title="fill(填充数，填充起始位，结束位)给值填充一个数组"></a>fill(填充数，填充起始位，结束位)给值填充一个数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)   <span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="toReversed-，toSorted-，toSpliced-，with-—-不改变原数组，而是返回原数组操作后的拷贝"><a href="#toReversed-，toSorted-，toSpliced-，with-—-不改变原数组，而是返回原数组操作后的拷贝" class="headerlink" title="toReversed()，toSorted()，toSpliced()，with() — 不改变原数组，而是返回原数组操作后的拷贝"></a>toReversed()，toSorted()，toSpliced()，with() — 不改变原数组，而是返回原数组操作后的拷贝</h3><ul>
<li>toReversed()对应reverse()，用来颠倒数组成员的位置。</li>
<li>toSorted()对应sort()，用来对数组成员排序。</li>
<li>toSpliced()对应splice()，用来在指定位置，删除指定数量的成员，并插入新成员。</li>
<li>with(index, value)对应splice(index, 1, value)，用来将指定位置的成员替换为新的值。</li>
</ul>
<h3 id="⭐-group-、groupToMap-—-将数组成员分组"><a href="#⭐-group-、groupToMap-—-将数组成员分组" class="headerlink" title="⭐ group()、groupToMap() — 将数组成员分组"></a>⭐ group()、groupToMap() — 将数组成员分组</h3><ul>
<li>group() 按照字符串分组<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">group</span>(<span class="function">(<span class="params">数组当前成员，该成员的索引，原数组</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>  条件 ? <span class="string">&#x27;分组名1&#x27;</span> ：<span class="string">&#x27;分组名2&#x27;</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>groupToMap() 按照对象分组<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">groupToMap</span>(<span class="function">(<span class="params">数组当前成员，该成员的索引，原数组</span>) =&gt;</span> &#123;<span class="keyword">return</span>  条件 ? 分组对象名<span class="number">1</span> ：分组对象名<span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure></li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> odd  = &#123; <span class="attr">odd</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> even = &#123; <span class="attr">even</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">array.<span class="title function_">groupToMap</span>(<span class="function">(<span class="params">num, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> num % <span class="number">2</span> === <span class="number">0</span> ? <span class="attr">even</span>: odd;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//  Map &#123; &#123;odd: true&#125;: [1, 3, 5], &#123;even: true&#125;: [2, 4] &#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="⭐-数组的空位"><a href="#⭐-数组的空位" class="headerlink" title="⭐ 数组的空位"></a>⭐ 数组的空位</h3><ul>
<li>Array(3) &#x2F;&#x2F; [, , ,]  —- 遍历空位识别为undefined</li>
<li>Array.from()、扩展运算符（…）、entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</li>
<li>copyWithin()会连空位一起拷贝。</li>
<li>fill()会将空位视为正常的数组位置。</li>
<li>for…of循环也会遍历空位。</li>
<li>map()方法遍历，空位是会跳过的。</li>
</ul>
<h3 id="Array-prototype-flat-扁平化嵌套数组-—-ES10"><a href="#Array-prototype-flat-扁平化嵌套数组-—-ES10" class="headerlink" title="Array.prototype.flat 扁平化嵌套数组 — ES10"></a>Array.prototype.flat 扁平化嵌套数组 — ES10</h3><ul>
<li>含义：按照深度去遍历数组，并将数组与遍历到的子数组中的元素合并到一个新数组并返回</li>
<li>返回值：返回一个新数组，不改变旧数组</li>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">flat</span>(depth)</span><br></pre></td></tr></table></figure></li>
<li>参数：可选，数组遍历的深度，默认是1</li>
<li>注意：flat()会溢出数组中的空项</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [[[[<span class="number">3</span>, <span class="number">4</span>]]]]];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">flat</span>();          <span class="comment">// [1, 2, [[[3, 4]]]]</span></span><br><span class="line">arr.<span class="title function_">flat</span>(<span class="number">3</span>);         <span class="comment">// [1, 2, [3, 4]]</span></span><br><span class="line">arr.<span class="title function_">flat</span>(-<span class="number">1</span>);        <span class="comment">// [1, 2, [[[[3, 4]]]]]</span></span><br><span class="line">arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);  <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap"></a>Array.prototype.flatMap</h3><ul>
<li>含义：映射函数映射数组（深度为1）的每个元素，然后压缩成一个新数组</li>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">flatMap</span>(</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">currentVal[,index[,array]]</span>)&#123;&#125;[,thisArg]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>callback： <ul>
<li>currentVal: 当前数组在处理的元素</li>
<li>index：可选，正在处理的元素索引</li>
<li>array：可选，被调用的数组</li>
</ul>
</li>
<li>thisArg：执行callback函数时所使用的this值</li>
</ul>
</li>
<li>返回值：返回一个新数组，并且每个元素都是回调函数的结果</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;My name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> newArr1 = arr.<span class="title function_">flatMap</span>(<span class="function"><span class="params">cur</span> =&gt;</span> cur.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>));  <span class="comment">// [&quot;My&quot;, &quot;name&quot;, &quot;is&quot;, &quot;&quot;, &quot;Lisa&quot;]</span></span><br><span class="line"><span class="keyword">let</span> newArr2 = arr.<span class="title function_">map</span>(<span class="function"><span class="params">cur</span> =&gt;</span> cur.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>));  <span class="comment">// [[&quot;My&quot;, &quot;name&quot;], [&quot;is&quot;], [&quot;&quot;], [&quot;Lisa&quot;]]</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery基础</title>
    <url>/2024/10/31/JQuery/JQuery%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="基本了解"><a href="#基本了解" class="headerlink" title="基本了解"></a>基本了解</h2><ul>
<li>定义：一个JS函数库，封装简化DOM操作(CRUD) | Ajax</li>
</ul>
<h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul>
<li>强大选择器: 方便快速查找DOM元素</li>
<li>隐式遍历(迭代): 一次操作多个元素</li>
<li>读写合一: 读数据 | 写数据用的是一个函数</li>
<li>链式调用: 可以通过.不断调用jQuery对象的方法</li>
<li>事件处理</li>
<li>DOM操作(CUD)</li>
<li>样式操作</li>
<li>动画</li>
<li>浏览器兼容</li>
</ul>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><ul>
<li>引入jQuery库</li>
<li>本地引入与CDN远程引入</li>
<li>测试版与生产版(压缩版)</li>
<li>使用jQuery</li>
<li>使用jQuery函数: $ &#x2F; jQuery</li>
<li>使用jQuery对象: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$xxx(执行$()得到的)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="JQuery的2把利器"><a href="#JQuery的2把利器" class="headerlink" title="JQuery的2把利器"></a>JQuery的2把利器</h2><h3 id="JQuery函数-jQuery"><a href="#JQuery函数-jQuery" class="headerlink" title="JQuery函数: $ &#x2F; jQuery"></a>JQuery函数: $ &#x2F; jQuery</h3><ul>
<li>jQuery向外暴露的就是jQuery函数, 可以直接使用</li>
<li>当函数使用: 『$(param)』<ul>
<li>param是<span class="key_words">『function』</span>: 相当于window.onload &#x3D; function(DOM加载完成后，执行此回调函数)</li>
<li>param是<span class="key_words">『选择器字符串』</span>: 查找所有匹配的DOM元素, 返回包含所有DOM元素的jQuery对象</li>
<li>param是<span class="key_words">『DOM对象』</span>: 将DOM元素对象包装为jQuery对象返回</li>
<li>param是<span class="key_words">『html标签字符串』</span>: 创建标签DOM元素对象并封装为jQuery对象返回</li>
</ul>
</li>
<li>当对象使用: 『$.xxx()』</li>
</ul>
<h3 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象: $()"></a>jQuery对象: $()</h3><ul>
<li>包含所有匹配的n个DOM元素的伪数组对象,执行$()返回的就是jQuery对象</li>
<li><span class="desc">如：$(‘p’),找到所有p标签的元素以数组的形式返回</span></li>
</ul>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul>
<li><a href="https://www.w3school.com.cn/jquery/jquery_ref_selectors.asp">选择器</a><blockquote>
<p>有特定语法规则(css选择器)的字符串</p>
</blockquote>
</li>
<li>用法：查找某个&#x2F;些DOM元素: $(selector)</li>
</ul>
<h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><ul>
<li>#id：id选择器</li>
<li>tagName：元素选择器</li>
<li>.class：属性选择器</li>
<li>*：任意标签</li>
<li>s1,s2,s3：多个选择器的并集(组合选择器)</li>
<li>s1s2s3：多个选择器的交集(相交选择器)</li>
</ul>
<h3 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h3><ul>
<li>查找子元素, 后代元素, 兄弟元素的选择器</li>
<li>parent &gt; child：在给定的父元素下匹配所有的子元素</li>
<li>ancestor descendant：在给定的祖先元素下匹配所有的后代元素</li>
<li>prev + next：匹配所有紧接在 prev 元素后的 next 元素</li>
<li>prev ~ siblings：匹配 prev 元素之后的所有 siblings 元素</li>
</ul>
<h3 id="选择器的过滤修饰符"><a href="#选择器的过滤修饰符" class="headerlink" title="选择器的过滤修饰符"></a>选择器的过滤修饰符</h3><ul>
<li>:first：选择第一个元素</li>
<li>:last：选择最后一个元素</li>
<li>:eq(index)：选择第index个元素，index从0开始</li>
<li>:lt(index)：选择前index个元素</li>
<li>:gt(index)：选择前index个之后的所有元素</li>
<li>:odd：选择所有奇数的元素</li>
<li>:even：选择所有偶数的元素</li>
<li>:not(selector)：选择所有不为selector的元素</li>
<li>:hidden：选择隐藏的属性</li>
<li>:visible：所有可见的元素</li>
<li>[attrName]：选择有attrName属性的元素</li>
<li>[attrName&#x3D;value]：选择所有attrName&#x3D;value的元素</li>
<li>:contains(content)：选择内容为content的元素</li>
<li>:header：所有标题元素 h1 - h6</li>
<li>:animated：所有动画元素</li>
</ul>
<h3 id="表单选择器的修饰符"><a href="#表单选择器的修饰符" class="headerlink" title="表单选择器的修饰符"></a>表单选择器的修饰符</h3><ul>
<li>:input：所有input元素</li>
<li>:text：所有 type&#x3D;”text” 的 input 元素</li>
<li>:checkbox：所有 type&#x3D;”checkbox” 的 input 元素<ul>
<li>eg：点击’全选’按钮实现全选&#x2F;全不选(按钮的点击事件里面应用)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;:checkbox&#x27;</span>).<span class="title function_">prop</span>(<span class="string">&#x27;checked&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">$(<span class="string">&#x27;:checkbox&#x27;</span>).<span class="title function_">prop</span>(<span class="string">&#x27;checked&#x27;</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>:submit、:reset、:button、:image、:file、:password、:radio：所有 type&#x3D;”xxx” 的 input 元素</li>
<li>:checked：所有被选中的 input 元素</li>
<li>:enabled：所有激活的 input 元素</li>
<li>:disabled：所有禁用的 input 元素</li>
<li>:selected：所有禁用的 input 元素</li>
</ul>
<h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><ul>
<li><a href="https://www.w3school.com.cn/jquery/jquery_ref_prop.asp">文档操作</a></li>
<li>操作标签的属性, 标签体文本</li>
</ul>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul>
<li>attr(name) | attr(name, value): 设置或返回匹配元素的属性和值<ul>
<li>eg：<span class="desc">读取第一个div的title属性</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div:first&#x27;</span>).<span class="title function_">attr</span>(<span class="string">&#x27;title&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>eg：给<span class="desc">所有的div设置name属性值为222</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">attr</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;222&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>val() | val(value): 读写标签的value<ul>
<li>eg: <span class="desc">得到输入框中的value值 </span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;:text&#x27;</span>).<span class="title function_">val</span>()</span><br></pre></td></tr></table></figure></li>
<li>eg: <span class="desc">将输入框的值设置为aaaaaa </span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;:text&#x27;</span>).<span class="title function_">val</span>(<span class="string">&#x27;aaaaaa&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>html() | html(htmlString): 读写标签体文本<ul>
<li>eg: <span class="desc">得到最后一个li的标签体文本</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;li:last&#x27;</span>).<span class="title function_">html</span>()</span><br></pre></td></tr></table></figure></li>
<li>eg: <span class="desc">设置第一个li的标签体为<code>&lt;h1&gt;mmmmmmmmm&lt;/h1&gt;</code></span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;li:first&#x27;</span>).<span class="title function_">html</span>(<span class="string">&#x27;&lt;h1&gt;mmmmmmmmm&lt;/h1&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>text(): 设置或返回匹配元素的内容</li>
<li>insertAfter(): 把匹配的元素插入到另一个指定的元素集合的后面。</li>
</ul>
<h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><ul>
<li>append() | appendTo(): 元素插入末尾</li>
<li>prepend() | prependTo(): 元素插入开头</li>
<li>before(): 在每个匹配的元素之前插入内容</li>
<li>after(): 在匹配的元素之后插入内容</li>
<li>addClass(classValue): 添加class</li>
<li>insertBefore(): 把匹配的元素插入到另一个指定的元素集合的前面。</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>remove(): 删除所有匹配元素的子元素</li>
<li>empty(): 除自己外删除所有匹配元素的子元素</li>
<li>removeAttr(name): 删除属性<ul>
<li>eg: <span class="desc">移除所有div的title属性</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">removeAttr</span>(<span class="string">&#x27;title&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>removeClass(classValue): 移除指定class</li>
<li>toggleClass(): 从匹配的元素中添加或删除一个类</li>
</ul>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul>
<li>replaceWith() | replaceAll(): 用新内容替换匹配的元素</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li><a href="https://www.w3school.com.cn/jquery/jquery_ref_prop.asp">事件</a></li>
</ul>
<h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><ul>
<li>eventName(function(){})：绑定对应事件名的监听<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#div&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);</span><br></pre></td></tr></table></figure></li>
<li>on(‘eventName’, function(){})：通用的绑定事件监听<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#div&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;) </span><br></pre></td></tr></table></figure></li>
<li>优缺点：<ul>
<li>eventName: 编码方便, 但只能加一个监听, 且有的事件监听不支持</li>
<li>on: 编码不方便, 可以添加多个监听, 且更通用</li>
</ul>
</li>
</ul>
<h3 id="解绑事件"><a href="#解绑事件" class="headerlink" title="解绑事件"></a>解绑事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">off</span>(<span class="string">&#x27;eventName&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><ul>
<li>理解: 将子元素的事件委托给父辈元素处理<ul>
<li>事件监听绑定在父元素上, 但事件发生在子元素上</li>
<li>事件会冒泡到父元素</li>
<li>但最终调用的事件回调函数的是子元素: event.target</li>
</ul>
</li>
<li>好处<ul>
<li><span class="key_words">『新增的元素没有事件监听』</span></li>
<li>减少监听的数量(n&#x3D;&#x3D;&gt;1)</li>
</ul>
</li>
<li>事件<ul>
<li>给对应选择器添加事件委托<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(parentSelector).<span class="title function_">delegate</span>(childselector, eventName, callback)</span><br></pre></td></tr></table></figure></li>
<li>给该元素移除事件委托<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(parentSelector).<span class="title function_">undelegate</span>(eventName)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="事件坐标"><a href="#事件坐标" class="headerlink" title="事件坐标"></a>事件坐标</h3><ul>
<li>event.offsetX, event.offsetY: 相对于事件元素左上角</li>
<li>event.clientX, event.clientY: 相对于视口的左上角</li>
<li>event.pageX, event.pageY: 相对于页面的左上角</li>
</ul>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ul>
<li>   keydown()：键盘按下时触发</li>
<li>   keyup()：键盘松开时触发</li>
</ul>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ul>
<li>   mousedown()： 鼠标点击按下触发</li>
<li>   mouseenter()：鼠标移动到当前元素时触发</li>
<li>   mouseleave()：鼠标离开该元素触发</li>
<li>   mousemove()：鼠标在该元素内移动触发</li>
<li>   mouseout()：鼠标移动到该元素或其子元素之外时触发</li>
<li>   mouseover()：鼠标移入该元素的子元素也会触发</li>
<li>   mouseup()：鼠标松开点击按钮的时候触发</li>
<li>hover(function(){}, function(){})：参数一相当于mouseenter(),参数二相当于mouseleave()</li>
</ul>
<h3 id="点击-触发"><a href="#点击-触发" class="headerlink" title="点击&#x2F;触发"></a>点击&#x2F;触发</h3><ul>
<li>   load()：进入页面时触发</li>
<li>unload()：卸载&#x2F;离开页面时触发</li>
<li>change()：事件改变就触发</li>
<li>click()：单机事件</li>
<li>dblclick()：双击事件</li>
<li>toggle()：绑定两个或多个事件处理器函数，当发生轮流的 click 事件时执行。</li>
</ul>
<h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><ul>
<li>scroll()：滚动事件</li>
<li>scrollTop() | scrollLeft(): 读&#x2F;写元素&#x2F;页面的滚动条位置</li>
<li>读取页面滚动条的Y坐标(兼容chrome和IE):<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>.<span class="property">body</span>).<span class="title function_">scrollTop</span>()+$(<span class="variable language_">document</span>.<span class="property">documentElement</span>).<span class="title function_">scrollTop</span>()</span><br></pre></td></tr></table></figure></li>
<li>页面滚动条滚动到指定位置(兼容chrome和IE)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;body,html&#x27;</span>).<span class="title function_">scrollTop</span>(<span class="number">60</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><ul>
<li>blur()：失去焦点的时候触发</li>
<li>select()：选中时触发</li>
<li>submit()：点击提交时触发</li>
<li>focus()：聚焦触发</li>
<li>阻止事件的默认行为: event.preventDefault()</li>
<li>   trigger()：所有匹配元素的指定事件</li>
<li>triggerHandler()：第一个被匹配元素的指定事件</li>
</ul>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="style样式"><a href="#style样式" class="headerlink" title="style样式"></a>style样式</h3><ul>
<li>css(styleName): 根据样式名得到对应的值</li>
<li>css(styleName, value): 设置一个样式</li>
<li>css({多个样式以键值对的形式存在}): 设置多个样式</li>
</ul>
<h3 id="位置坐标"><a href="#位置坐标" class="headerlink" title="位置坐标"></a>位置坐标</h3><ul>
<li>offset(): 读&#x2F;写当前元素坐标(原点是页面左上角)</li>
<li>position(): 读当前元素坐标(原点是父元素左上角)</li>
</ul>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><ul>
<li>width() | height(): width | height</li>
<li>innerWidth() | innerHeight(): width + padding</li>
<li>outerWidth() | outerHeight(): width + padding + border</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="基本遍历"><a href="#基本遍历" class="headerlink" title="基本遍历"></a>基本遍历</h3><ul>
<li>map(): 会返回一个新数组</li>
<li>each()</li>
</ul>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><blockquote>
<p>在jQuery对象内部的元素中找出部分匹配的元素, 并封装成新的jQuery对象返回</p>
</blockquote>
<ul>
<li>first()：选中第一个元素</li>
<li>last()：选中最后一个元素</li>
<li>eq(index): 选中第index个元素</li>
<li>filter(selector): 对当前元素提要求<ul>
<li>eg: <span class="desc">ul下li标签中title属性为hello的</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $lis= $(<span class="string">&#x27;ul &gt; li&#x27;</span>)</span><br><span class="line">$lis.<span class="title function_">filter</span>(<span class="string">&#x27;[title=hello]&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>not(selector): 对当前元素提要求, 并取反<ul>
<li>eg: <span class="desc">ul下li标签中title属性不为hello的</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$lis.<span class="title function_">not</span>(<span class="string">&#x27;[title=hello]&#x27;</span>) </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>has(selector): 对子孙元素提要求<ul>
<li>eg: <span class="desc">ul下li标签中有span子标签</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$lis.<span class="title function_">has</span>(<span class="string">&#x27;span&#x27;</span>) </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><blockquote>
<p>查找jQuery对象内部的元素的子孙&#x2F;兄弟&#x2F;父母元素, 并封装成新的jQuery对象返回</p>
</blockquote>
<ul>
<li>parent(): 父元素</li>
<li>children(selector): 子元素中找</li>
<li>find(selector): 后代元素中找</li>
<li>prevAll(selector): 前面所有的兄弟标签<ul>
<li>可以跟children()一起用，用链式连接</li>
</ul>
</li>
<li>nextAll(): 后面所有的兄弟标签<ul>
<li>可以跟children()一起用，用链式连接</li>
</ul>
</li>
<li>siblings(selector): 所有兄弟<ul>
<li>可以跟children()一起用，用链式连接</li>
</ul>
</li>
</ul>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul>
<li>在一定的时间内, 不断改变元素样式</li>
<li>slideDown()&#x2F;slideUp()&#x2F;slideToggle()： 滑动，按顺序使用</li>
<li>fadeOut()&#x2F;fadeIn()&#x2F;fadeToggle()：淡入淡出，按顺序使用</li>
<li>show()&#x2F;hide()&#x2F;toggle()：显隐</li>
<li>animate({结束时的样式}, time)：自定义动画</li>
<li>stop()：停止动画</li>
</ul>
<h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数:"></a>工具函数:</h2><ul>
<li>length&#x2F;size(): 得到dom元素的个数</li>
<li>[index]&#x2F;get(index): 得到指定下标对应的dom元素</li>
<li>index(): 得到当前dom元素在所有兄弟中的下标<ul>
<li>eg：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;当前的选择器&#x27;</span>)<span class="title function_">index</span>() </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>type(obj)：得到数据的类型</li>
<li>isArray(obj): 判断是否是数组</li>
<li>isFunction(obj): 判断是否是函数</li>
<li>parseJSON(json): 解析json字符串转换为js对象&#x2F;数组<ul>
<li>json对象: {key1:value1 , key2:value2}</li>
<li>json数组: [value1, value2]</li>
</ul>
</li>
<li>hasClass(): 检查匹配的元素是否拥有指定的类</li>
</ul>
<h2 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h2><ul>
<li>扩展jQuery函数对象的方法<ul>
<li>定义：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">extend</span>(&#123; </span><br><span class="line">	<span class="attr">xxx</span>: <span class="title function_">fuction</span>(<span class="params"></span>)&#123;&#125; <span class="comment">//this是$ </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>使用：$.xxx()</li>
</ul>
</li>
<li>扩展jQuery对象的方法<ul>
<li>定义：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.fn.<span class="title function_">extend</span>(&#123; </span><br><span class="line">	<span class="attr">xxx</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="comment">//this是jQuery对象 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>使用：$obj.xxx()</li>
</ul>
</li>
<li>多库共存<ul>
<li>jQuery.noConflict()：jQuery库释放$的使用权, 让另一个库正常使用, 此时jQuery库只能使用jQuery了</li>
</ul>
</li>
</ul>
<h2 id="window-onload与-document-ready"><a href="#window-onload与-document-ready" class="headerlink" title="window.onload与 $(document).ready()"></a>window.onload与 $(document).ready()</h2><ul>
<li>window.onload<ul>
<li>包括页面的图片加载完后才会回调(晚)</li>
<li>只能有一个监听回调</li>
</ul>
</li>
<li>$(document).ready()<ul>
<li>等同于: $(function(){})</li>
<li>页面加载完就回调(早)</li>
<li>可以有多个监听回调</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-编程风格</title>
    <url>/2024/10/31/ES6/es6-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li><p>块级作用域和上下文会改变用let</p>
</li>
<li><p>全局用常量const，表示不应该改变</p>
</li>
<li><p>静态字符串一律使用单引号或反引号。动态字符串使用反引号。</p>
</li>
<li><p>使用数组&#x2F;对象成员对变量赋值时和返回多个值时，优先使用解构赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [first, second] = arr;</span><br></pre></td></tr></table></figure></li>
<li><p>单行定义的对象，最后不以逗号结尾。多行，最后以逗号结尾</p>
</li>
<li><p>使用扩展运算符（…）拷贝数组，使用Array.from 方法，将类数组的对象转为数组</p>
</li>
<li><p>立即执行函数可以写成箭头函数的形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line">(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Welcome to the Internet.&#x27;</span>))();</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数(取代Function.prototype.bind，不应再用 self/_this/that 绑定 this)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">args</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">boundMethod</span> = (<span class="params">...params</span>) =&gt; method.<span class="title function_">apply</span>(<span class="variable language_">this</span>, params);</span><br></pre></td></tr></table></figure></li>
<li><p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">a, b, &#123; option = <span class="literal">false</span> &#125; = &#123;&#125;</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">concatenateAll</span>(<span class="params">...args</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> args.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用默认值语法设置函数参数的默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>key: value的数据结构，使用 Map 结构，模拟现实世界的实体对象时，使用 Object</p>
</li>
<li><p>用class取代需要 prototype 的操作，使用extends实现继承</p>
</li>
<li><p>import取代require()、export取代module.exports</p>
</li>
<li><p>模块只有一个输出值，使用export defaul</p>
<ul>
<li>输出的函数名的首字母应该小写，对象名的首字母应该大写</li>
</ul>
</li>
<li><p>在项目的根目录安装 ESLint</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save-dev eslint</span><br><span class="line">npm install --save-dev eslint-config-airbnb</span><br><span class="line">npm install --save-dev eslint-plugin-<span class="keyword">import</span> eslint-plugin-jsx-a11y eslint-plugin-react</span><br></pre></td></tr></table></figure></li>
<li><p>在项目的根目录下新建一个.eslintrc文件，配置 ESLint</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;extends&quot;</span>: <span class="string">&quot;eslint-config-airbnb&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise/async 与es5总结</title>
    <url>/2024/10/31/ES6/promise%E5%92%8Casync%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>ES5正常写法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getAjax</span>(url, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>Promise<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">get</span>(url).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>async await<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="title function_">async</span> () =&gt; &#123; <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">get</span>(url) &#125;)()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ES5与promise与async总结："><a href="#ES5与promise与async总结：" class="headerlink" title="ES5与promise与async总结："></a>ES5与promise与async总结：</h3><ul>
<li>ES5 写法和promise写法，主要区别在写法不同，promise可以让回调函数在.then的函数里执行</li>
<li>async和promise的写法在底层编译之后会自动转化成promise写法</li>
</ul>
<h3 id="Promise-实现原理"><a href="#Promise-实现原理" class="headerlink" title="Promise 实现原理"></a>Promise 实现原理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="literal">true</span>) &#123; <span class="comment">// 条件自己赋予</span></span><br><span class="line">			<span class="title function_">resolve</span>()</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="title function_">reject</span>()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">LcPromise</span>(fn)</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span>=<span class="string">&quot;greenyellow&quot;</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功的事&quot;</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line">p1.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span>=<span class="string">&quot;blue&quot;</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败的事&quot;</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>传入一个事件函数，不调用，当触发时，才调用</li>
<li>p1 Promise对象发送了异步操作，必然会有一个未来事件，在未来执行，这个过程有传入函数对象fn执行。函数fn里必然需要有成功执行和失败执行的函数</li>
</ul>
<h3 id="创建类构造对象"><a href="#创建类构造对象" class="headerlink" title="创建类构造对象"></a>创建类构造对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LcPromise</span>&#123;</span><br><span class="line">	<span class="comment">// ①指向代码</span></span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">		<span class="comment">// 将成功的事件函数集成在successList数组里</span></span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">successList</span> = []</span><br><span class="line">		<span class="comment">// 将失败的事件函数集成在failList数组里</span></span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">failList</span> = []</span><br><span class="line">		<span class="comment">// pending,fullfilled,rejected</span></span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;pending&quot;</span></span><br><span class="line">		<span class="comment">// 传入的函数对象（异步操作的函数内容）</span></span><br><span class="line">		<span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">resolveFn</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>,<span class="variable language_">this</span>.<span class="property">rejectFn</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ②指向代码</span></span><br><span class="line">	<span class="title function_">then</span>(<span class="params">successFn,failFn</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> successFn == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">successList</span>.<span class="title function_">push</span>(successFn)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> failFn == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">failFn</span>.<span class="title function_">push</span>(failFn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(failFn)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> failFn == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">failList</span>.<span class="title function_">push</span>(failFn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ③指向代码</span></span><br><span class="line">	<span class="title function_">resolveFn</span>(<span class="params">res</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;fullfilled&quot;</span></span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">successList</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span><br><span class="line">			<span class="comment">// 将成功的事件循环调用</span></span><br><span class="line">			<span class="title function_">item</span>(res)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;.<span class="title function_">rejectFn</span>(<span class="params">res</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">		<span class="comment">// 注册到的失败所有事件进行调用</span></span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">failList</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item,index</span>)&#123;</span><br><span class="line">			<span class="title function_">item</span>(res)</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">throw</span> <span class="title class_">Error</span>(res)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数的作用①<ul>
<li>声明成功函数放置的数组对象</li>
<li>声明失败函数放置的数组对象</li>
<li>定义初始化状态</li>
<li>调用传入进行执行异步内容的函数(<span class="desc">在未来有成功的结构时调用传入进去的成功函数，在未来失败时调用传入进去的失败函数</span>)</li>
</ul>
</li>
<li>将传入成功或者失败时需要调用的函数作用②：<ul>
<li>将成功和失败的函数传入成功成功和失败的数组里</li>
</ul>
</li>
<li>定义调用和失败的函数作用③:<ul>
<li>成功时调用成功数组里所有的函数，失败时调用失败数组里所有的函数</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise 和 async/await</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-解构赋值</title>
    <url>/2024/10/31/ES6/es6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>从数组和对象中提取值，对变量进行赋值</p>
</blockquote>
<h2 id="数组（一-一-对-应）"><a href="#数组（一-一-对-应）" class="headerlink" title="数组（一 一 对 应）"></a>数组（一 一 对 应）</h2><h3 id="完全解构（必须一一对应）："><a href="#完全解构（必须一一对应）：" class="headerlink" title="完全解构（必须一一对应）："></a>完全解构（必须一一对应）：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想赋后面的值的，且前面不赋值，则可以用&#x27;，&#x27;替代前面的参数,多少个参数多少个&#x27;，&#x27;</span></span><br><span class="line"><span class="comment">// 解构不成功的变量，值为undefined                </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="不完全解构（即等号左边的模式，只匹配一部分的等号左边的数组）："><a href="#不完全解构（即等号左边的模式，只匹配一部分的等号左边的数组）：" class="headerlink" title="不完全解构（即等号左边的模式，只匹配一部分的等号左边的数组）："></a>不完全解构（即等号左边的模式，只匹配一部分的等号左边的数组）：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><ul>
<li>数组&#x2F;对象成员严格等于undefined，默认值才会生效。</li>
<li>数组&#x2F;对象成员是null，默认值就不会生效<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];    </span><br><span class="line">x <span class="comment">// 1 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构失败，返回undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; opp &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">opp <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log赋值到log变量</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="variable language_">console</span>;</span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量名与属性名不一致（真正被赋值的是后者，而不是前者。）</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">p</span>: [</span><br><span class="line">		<span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">		&#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">	]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br><span class="line">p <span class="comment">// [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;] </span></span><br></pre></td></tr></table></figure>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li><p>如果要将一个<span class="key_words">『已经声明的变量』</span>用于解构赋值，必须非常小心。</p>
<pre><code> // 错误的写法                // 正确的写法
 let x;                      let x;
 &#123;x&#125; = &#123;x: 1&#125;;               (&#123;x&#125; = &#123;x: 1&#125;);
</code></pre>
</li>
<li><p>解构赋值允许等号左边的模式之中，不放置任何变量名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br></pre></td></tr></table></figure></li>
<li><p>数组本质是特殊的对象，因此对数组进行对象属性的解构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.<span class="property">length</span> - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li><p>不要使用圆括号</p>
</li>
</ol>
<h2 id="字符串（被转换成了一个类数组的对象）"><a href="#字符串（被转换成了一个类数组的对象）" class="headerlink" title="字符串（被转换成了一个类数组的对象）"></a>字符串（被转换成了一个类数组的对象）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似数组中length属性</span></span><br><span class="line"><span class="keyword">let</span> &#123;length : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="数值、布尔值（等号右边不管是什么，会先转为对象）"><a href="#数值、布尔值（等号右边不管是什么，会先转为对象）" class="headerlink" title="数值、布尔值（等号右边不管是什么，会先转为对象）"></a>数值、布尔值（等号右边不管是什么，会先转为对象）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined和null无法转为对象，会报错</span></span><br></pre></td></tr></table></figure>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ul>
<li>遍历时数组存在undefined，则会被默认值替代<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">x = <span class="string">&#x27;yes&#x27;</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, &#x27;yes&#x27;, 3 ]</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery应用</title>
    <url>/2024/10/31/JQuery/%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="表格的隔行变色"><a href="#表格的隔行变色" class="headerlink" title="表格的隔行变色"></a>表格的隔行变色</h3><ul>
<li>表格结构中使用:odd来选中偶数行，并使用attr来添加样式</li>
<li>表格结构：table&gt;thead(表头) tbody(表格内容与表头为兄弟)&gt;tr(行)&gt;td(列)</li>
<li>eg：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;table&gt;tbody&gt;tr:odd&#x27;</span>).<span class="title function_">attr</span>(<span class="string">&#x27;class&#x27;</span>,<span class="string">&#x27;写好的样式&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多tab切换"><a href="#多tab切换" class="headerlink" title="多tab切换"></a>多tab切换</h3><ul>
<li>tab按钮用 ul&gt;li 实现</li>
<li>按钮对应的内容区域使用相对定位</li>
<li>这个内容区域中有对应li数的div，每个div都使用绝对定位，固定在按钮切换展示的位置</li>
<li>然后给除了默认的div都加上样式display:none</li>
<li>定义一个变量index &#x3D; 0</li>
<li>获取到内容区域的div(获取到的是一个数组)</li>
<li>然后获取ul&gt;li的点击事件</li>
<li>拿到点击事件对应的currentIndex，<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">this</span>).<span class="title function_">index</span>()</span><br></pre></td></tr></table></figure></li>
<li>判断点击的currentIndex如果不等于index就设置display&#x3D;”none”,对应内容的索引的display&#x3D;”block”,index&#x3D;currentIndex</li>
</ul>
<h3 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h3><ul>
<li>样式就是一个固定在页面的按钮，点击回到最顶部</li>
<li>读取页面滚动条的Y轴坐标：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>.<span class="property">body</span>).<span class="title function_">scrollTop</span>()+$(<span class="variable language_">document</span>.<span class="property">documentElement</span>).<span class="title function_">scrollTop</span>()</span><br></pre></td></tr></table></figure></li>
<li>使用平滑的滚动回顶点，读取页面滚动条的Y轴坐标，如果偏移offset为0返回</li>
<li>定义滚动的总时长，定时的间隔，和每次间隔滚动多少(offest&#x2F;(总时长&#x2F;间隔))</li>
<li>使用定时器，将offset -&#x3D; 每次间隔滚动的长度，如果offset&lt;&#x3D;0，则offset&#x3D;0,清除定时器；如果&gt;0,$(‘html,body’).scrollTop(offset)</li>
</ul>
<h3 id="导航栏动态显示效果-悬停有下拉列表"><a href="#导航栏动态显示效果-悬停有下拉列表" class="headerlink" title="导航栏动态显示效果(悬停有下拉列表)"></a>导航栏动态显示效果(悬停有下拉列表)</h3><ul>
<li>样式写好，有列表的固定好并且隐藏</li>
<li>使用:has(ul)判断鼠标悬停时有无列表，使用hover事件，分别给两个函数添加下滑和上滑的动画效果</li>
</ul>
<h3 id="反选功能"><a href="#反选功能" class="headerlink" title="反选功能"></a>反选功能</h3><ul>
<li>获取所有checkbox的数组</li>
<li>使用each遍历checked的状态为checked的反选</li>
</ul>
<h3 id="全选-全不选"><a href="#全选-全不选" class="headerlink" title="全选&#x2F;全不选"></a>全选&#x2F;全不选</h3><ul>
<li>使用each给每个item的checked设置为true&#x2F;false</li>
</ul>
<h3 id="添加删除记录"><a href="#添加删除记录" class="headerlink" title="添加删除记录"></a>添加删除记录</h3><ul>
<li>输入的样式使用input，并给每个input添加对应的id</li>
<li>获取每个input的dom并使用val()获取值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;&lt;tr&gt;&lt;/tr&gt;&#x27;</span>)</span><br><span class="line">.<span class="title function_">append</span>(<span class="string">&#x27;&lt;td&gt;&#x27;</span>+inputDom.<span class="title function_">val</span>(),有几条写几条+<span class="string">&#x27;&lt;/td&gt;&#x27;</span>)</span><br><span class="line">.<span class="title function_">appendTo</span>(<span class="string">&#x27;追加到已存在的表格id的表格中&#x27;</span>)</span><br><span class="line">.<span class="title function_">find</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// 找到后代选择器中的a标签</span></span><br><span class="line">.<span class="title function_">click</span>(并点击触发删除事件)</span><br></pre></td></tr></table></figure></li>
<li>初始化值</li>
<li>删除事件：在删除事件中要先阻止默认事件，然后通过this和parent()获取删除这一行表格的dom</li>
<li>然后调用remove()即可</li>
</ul>
]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-3D变换中的改变层级的属性</title>
    <url>/2024/10/30/HTMLCSS/css%20-%203D%E5%8F%98%E6%8D%A2%E4%B8%AD%E7%9A%84%E6%94%B9%E5%8F%98%E5%B1%82%E7%BA%A7%E7%9A%84%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>transform-style 是用于辅助的，最好还是添加一下</li>
<li>perspective 和 transform:translateZ 为正值时可以使元素的层级提高到最前面</li>
</ul>
<h2 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h2><h3 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h3><ul>
<li>flat：将设置元素的子元素位于该元素的平面中,默认值</li>
<li>preserve-3d：将指示元素的子元素应位于 3D 空间中</li>
</ul>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>不能被子元素继承</li>
<li>效果作用于子元素,不作用于自身</li>
<li>要结合 transform 使用,否则没效果</li>
</ul>
<h3 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d</span><br></pre></td></tr></table></figure>

<h2 id="transform-translateZ"><a href="#transform-translateZ" class="headerlink" title="transform:translateZ()"></a>transform:translateZ()</h2><h3 id="理解Z轴："><a href="#理解Z轴：" class="headerlink" title="理解Z轴："></a>理解Z轴：</h3><ul>
<li>在 3D 变化中,元素的 Z 轴是指元素在初始情况下,从元素背面穿过元素指向元素正面的方向,初始状态下元素的 Z 轴值为 0,沿着 Z 轴往下移动,Z 轴值为负值,反之则为正值</li>
</ul>
<h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><ul>
<li>父元素没开启 3D 空间(transform: preserve-3d)的情况下,该属性无效</li>
<li>该属性是 3D 变化中控制元素 Z 轴移动的属性<ul>
<li>若兄弟元素有设置该属性,Z 轴值小的会处于 Z 轴值大的元素的下方</li>
<li>若兄弟元素都没设置,HTML 结构中,后写的元素在上方</li>
</ul>
</li>
</ul>
<h3 id="使用语法-1"><a href="#使用语法-1" class="headerlink" title="使用语法:"></a>使用语法:</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">translateZ</span>(<span class="number">100px</span>)</span><br></pre></td></tr></table></figure>

<h2 id="透视-perspective"><a href="#透视-perspective" class="headerlink" title="透视 perspective"></a>透视 perspective</h2><h3 id="原理：近大远小"><a href="#原理：近大远小" class="headerlink" title="原理：近大远小"></a>原理：近大远小</h3><h3 id="理解浏览器的坐标系："><a href="#理解浏览器的坐标系：" class="headerlink" title="理解浏览器的坐标系："></a>理解浏览器的坐标系：</h3><ul>
<li>浏览器平面为 Z&#x3D;0 的平面，坐标原点默认为图片的中心，可以通过更改透视原点进行更改。</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>该属性指定了观察者与 z&#x3D;0 平面的距离，使具有三维位置变换的元素产生透视效果。</li>
<li>perspective：视距，表示视点距离屏幕的长短。视点，用于模拟透视效果时人眼的位置。</li>
<li>perspectiveOrigin: 个人理解为视点的 xy 坐标，perspective 则是 z 坐标，三者可以再三维中确定视点的唯一位置。</li>
</ul>
<h3 id="使用语法-2"><a href="#使用语法-2" class="headerlink" title="使用语法"></a>使用语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">  <span class="attribute">perspective</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 单独定义的<span class="attribute">perspective</span>只在初次渲染时，投影在屏幕上</span><br><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">200px</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 会根据<span class="attribute">transform</span>动画的变化来进行重新渲染</span><br></pre></td></tr></table></figure>

<h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>不能被子元素继承</li>
<li>效果作用于子元素,不作用于自身</li>
<li>要在其它 3d 变换之前定义，否则无效</li>
<li>呈现 3d 效果的父元素要添加 transform-style：preserver-3d 属性</li>
<li>backface-visibility：用来定义元素不是正面朝向视点时的可视情况</li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>案例</tag>
        <tag>透视</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-动画篇</title>
    <url>/2024/10/30/HTMLCSS/css-%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="过渡（transition）"><a href="#过渡（transition）" class="headerlink" title="过渡（transition）"></a>过渡（transition）</h2><ul>
<li>通过过渡可以指定一个属性发生变化时的切换方式</li>
<li>必须外力推动，过渡效果是一次性，只能从边界开始或结束</li>
</ul>
<h3 id="简写语法"><a href="#简写语法" class="headerlink" title="简写语法"></a>简写语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>: property duration timing-function delay;</span><br></pre></td></tr></table></figure>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>transition-property: 指定要执行过渡的属性，多个属性间使用,隔开<ul>
<li>如果所有属性都需要过渡，则使用 all 关键字</li>
<li>注意：过渡时必须是从一个有效数值向另外一个有效数值进行过渡</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition-property</span>: height, width;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>transition-duration: 指定过渡效果的持续时间<ul>
<li>时间单位：s 和 ms 1s &#x3D; 1000ms</li>
</ul>
</li>
<li>transition-timing-function: 过渡的时序函数，指定过渡的执行的方式<ul>
<li>可选值：<ul>
<li>ease 默认值，慢速开始，先加速，再减速</li>
<li>linear 匀速运动</li>
<li>ease-in 加速运动</li>
<li>ease-out 减速运动</li>
<li>ease-in-out 先加速 后减速</li>
<li>cubic-bezier() 来指定时序函数<ul>
<li><a href="https://cubic-bezier.com/">https://cubic-bezier.com</a></li>
</ul>
</li>
</ul>
</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition-timing-function</span>: <span class="built_in">cubic-bezier</span>(.<span class="number">24</span>,.<span class="number">95</span>,.<span class="number">82</span>,-<span class="number">0.88</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>transition-delay: 过渡效果的延迟，等待一段时间后在执行过渡<ul>
<li>时间单位：s 和 ms</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition-delay</span>: <span class="number">2s</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="动画（animation）"><a href="#动画（animation）" class="headerlink" title="动画（animation）"></a>动画（animation）</h2><ul>
<li>过渡需要在某个属性发生变化时才会触发,而动画可以自动触发动态效果</li>
<li>设置动画效果，必须先要设置一个关键帧，关键帧设置了动画执行每一个步骤</li>
</ul>
<h3 id="关键帧"><a href="#关键帧" class="headerlink" title="关键帧"></a>关键帧</h3><ul>
<li>从 0%开始到 100%结束<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画名称 &#123;</span><br><span class="line">  <span class="number">0%</span>&#123;&#125;</span><br><span class="line">  <span class="number">100%</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>从 from 开始到 to 结束<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画名称 &#123;</span><br><span class="line">  <span class="selector-tag">from</span>&#123;&#125;</span><br><span class="line">  <span class="selector-tag">to</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="简写语法-1"><a href="#简写语法-1" class="headerlink" title="简写语法"></a>简写语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>: name duration timing-function delay iteration-count direction fill-mode play-state;</span><br></pre></td></tr></table></figure>

<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul>
<li>animation-name: 要对当前元素生效的关键帧的名字</li>
<li>animation-duration: 动画的执行时间</li>
<li>animation-delay：动画延时多久在执行</li>
<li>animation-timing-function: 指定动画以什么方式执行</li>
<li>animation-iteration-count：动画循环的次数<ul>
<li>可选值：number 次数 | infinite 无限执行</li>
</ul>
</li>
<li>animation-direction：指定动画运行的方向<ul>
<li>可选值：<ul>
<li>normal：默认值，从 from 向 to 运行 每次都是这样</li>
<li>reverse：从 to 向 from 运行 每次都是这样</li>
<li>alternate：从 from 向 to 运行 重复执行动画时反向执行</li>
<li>alternate-reverse：从 to 向 from 运行 重复执行动画时反向执行</li>
</ul>
</li>
</ul>
</li>
<li>animation-play-state: 设置动画的执行状态<ul>
<li>可选值：<ul>
<li>running：默认值 动画执行</li>
<li>paused：动画暂停</li>
</ul>
</li>
</ul>
</li>
<li>animation-fill-mode: 动画的填充模式<ul>
<li>可选值：<ul>
<li>none：默认值，动画执行完毕元素回到原来位置</li>
<li>forwards：动画执行完毕元素会停止在动画结束的位置</li>
<li>backwards：动画延时等待时，元素就会处于开始位置</li>
<li>both：结合了 forwards 和 backwards</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="变形（transform）"><a href="#变形（transform）" class="headerlink" title="变形（transform）"></a>变形（transform）</h2><ul>
<li>通过 CSS 来改变元素的形状或位置</li>
<li>变形不会影响到页面的布局</li>
</ul>
<h3 id="平移-translate"><a href="#平移-translate" class="headerlink" title="平移(translate)"></a>平移(translate)</h3><ul>
<li>translateX(x)：沿着 x 轴方向平移</li>
<li>translateY(y)：沿着 y 轴方向平移</li>
<li>translateZ(z)：沿着 z 轴方向平移</li>
<li>translate(x,y)：定义 2D 转换</li>
<li>translate3d(x,y,z)：定义 3D 转换</li>
<li>平移元素，百分比是相对于自身计算的</li>
<li>z 轴平移，调整元素在 z 轴的位置，正常情况就是调整元素和人眼之间的距离，距离越大，元素离人越近</li>
<li>z 轴平移属于立体效果（近大远小），默认情况下网页是不支持透视，如果需要看见效果，必须要设置网页的视距</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">100px</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="旋转-rotate"><a href="#旋转-rotate" class="headerlink" title="旋转(rotate)"></a>旋转(rotate)</h3><ul>
<li>rotateX(angle)：使元素沿着 x 轴的 2D 旋转指定的角度</li>
<li>rotateY(angle)：使元素沿着 y 轴的 2D 旋转指定的角度</li>
<li>rotateZ(angle)：使元素沿着 z 轴的 3D 旋转指定的角度</li>
<li>rotate(angle)：定义 2D 旋转，在参数中规定角度</li>
<li>rotate3d(x,y,z,angle)：定义 3D 旋转</li>
<li>backface-visibility: hidden;<ul>
<li>是否显示元素的背面</li>
<li>与旋转配合使用，当旋转到后面时元素消失</li>
</ul>
</li>
</ul>
<h3 id="缩放-scale"><a href="#缩放-scale" class="headerlink" title="缩放(scale)"></a>缩放(scale)</h3><ul>
<li>scaleX(x)：水平方向缩放</li>
<li>scaleY(y)：垂直方向缩放</li>
<li>scaleZ(z)：通过设置 Z 轴的值来定义 3D 缩放转换</li>
<li>scale(x,y)：定义 2D 缩放转换</li>
<li>scale3d(x,y,z)：定义 3D 缩放转换</li>
</ul>
<h3 id="倾斜-skew"><a href="#倾斜-skew" class="headerlink" title="倾斜(skew)"></a>倾斜(skew)</h3><ul>
<li>skew(x-angle,y-angle)：定义沿着 X 和 Y 轴的 2D 倾斜转换。</li>
<li>skewY(angle)：定义沿着 Y 轴的 2D 倾斜转换。</li>
</ul>
<h3 id="变换矩阵-matrix"><a href="#变换矩阵-matrix" class="headerlink" title="变换矩阵(matrix)"></a>变换矩阵(matrix)</h3><ul>
<li>matrix(n,n,n,n,n,n)：定义 2D 转换，使用六个值的矩阵。</li>
<li>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)：定义 3D 转换，使用 16 个值的 4x4 矩阵。</li>
</ul>
<h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><ul>
<li>语法：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>: x-axis y-axis z-axis;</span><br></pre></td></tr></table></figure></li>
<li>更换元素的位置</li>
<li>x-axis: 定义视图被置于 X 轴的何处<ul>
<li>left</li>
<li>right</li>
<li>center</li>
<li>length</li>
<li>%</li>
</ul>
</li>
<li>y-axis: 定义视图被置于 Y 轴的何处<ul>
<li>top</li>
<li>center</li>
<li>bottom</li>
<li>length</li>
<li>%</li>
</ul>
</li>
<li>z-axis: 定义视图被置于 Z 轴的何处<ul>
<li>length</li>
</ul>
</li>
<li>skewX(angle)：定义沿着 X 轴的 2D 倾斜转换。</li>
</ul>
<h3 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h3><ul>
<li>语法：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform-style</span>: <span class="built_in">flat</span>(表示所有子元素在 <span class="number">2</span>D 平面呈现) | <span class="built_in">preserve-3d</span>(表示所有子元素在 <span class="number">3</span>D 空间中呈现);</span><br></pre></td></tr></table></figure></li>
<li>让转换的子元素保留 3D 转换</li>
</ul>
<h3 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h3><ul>
<li>语法：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">perspective</span>: number|none;</span><br></pre></td></tr></table></figure></li>
<li>number： 元素距离视图的距离，单位像素<ul>
<li>none：默认值，不设置透视</li>
</ul>
</li>
<li><span class="key_words">『设置从何处查看一个元素的角度』</span></li>
<li>只影响 3D 转换元素</li>
</ul>
<h3 id="perspective-origin"><a href="#perspective-origin" class="headerlink" title="perspective-origin"></a>perspective-origin</h3><ul>
<li>语法：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">perspective-origin</span>: x-axis y-axis;</span><br></pre></td></tr></table></figure></li>
<li>定义 3D 元素所基于的 X 轴和 Y 轴。<span class="key_words">『设置以底部为基准，人从x轴或y轴看的角度』</span></li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">perspective</span>:<span class="number">150</span>;</span><br><span class="line">  <span class="attribute">perspective-origin</span>: <span class="number">10%</span> <span class="number">10%</span>;</span><br><span class="line">  -webkit-<span class="attribute">perspective</span>:<span class="number">150</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">  -webkit-<span class="attribute">perspective-origin</span>: <span class="number">10%</span> <span class="number">10%</span>; <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-浏览器滚动条</title>
    <url>/2024/10/30/HTMLCSS/css-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="Geogle-浏览器滚动条样式（其它浏览器也可以用）"><a href="#Geogle-浏览器滚动条样式（其它浏览器也可以用）" class="headerlink" title="Geogle 浏览器滚动条样式（其它浏览器也可以用）"></a>Geogle 浏览器滚动条样式（其它浏览器也可以用）</h2><h3 id="总览常用属性"><a href="#总览常用属性" class="headerlink" title="总览常用属性"></a>总览常用属性</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>::-webkit-scrollbar</td>
<td>滚动条整体样式</td>
</tr>
<tr>
<td>::-webkit-scrollbar-button</td>
<td>一设置滚动条样式，滚动条两端的按钮图标就消失，但可以重新设置图片、新样式</td>
</tr>
<tr>
<td>::-webkit-scrollbar-track</td>
<td>外层轨道</td>
</tr>
<tr>
<td>::-webkit-scrollbar-track-piece</td>
<td>内层轨道，它会覆盖外层轨道 scrollbar-track 的样式</td>
</tr>
<tr>
<td>::-webkit-scrollbar-thumb</td>
<td>滑块</td>
</tr>
<tr>
<td>::-webkit-scrollbar-thumb:hover</td>
<td>滑块悬浮</td>
</tr>
<tr>
<td>::-webkit-scrollbar-thumb:vertical:hover</td>
<td>纵向滑块悬浮</td>
</tr>
<tr>
<td>::-webkit-scrollbar-thumb:horizontal:hover</td>
<td>横向滑块悬浮</td>
</tr>
<tr>
<td>::-webkit-scrollbar-corner</td>
<td>边角，两个滚动条交汇处</td>
</tr>
</tbody></table>
<h3 id="webkit-scrollbar"><a href="#webkit-scrollbar" class="headerlink" title="::-webkit-scrollbar"></a>::-webkit-scrollbar</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*::-webkit-scrollbar &#123; // 加上*表示全局</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">2px</span>; // 纵向滚动条 宽度</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">2px</span>; // 横向滚动条 高度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="webkit-scrollbar-button"><a href="#webkit-scrollbar-button" class="headerlink" title="::-webkit-scrollbar-button"></a>::-webkit-scrollbar-button</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*::-webkit-scrollbar-button &#123; // 两端</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">10px</span>; // 因为::-webkit-scrollbar已经设置了宽度，这里的纵向宽不生效，横向高不生效</span><br><span class="line">	height: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="webkit-scrollbar-track"><a href="#webkit-scrollbar-track" class="headerlink" title="::-webkit-scrollbar-track"></a>::-webkit-scrollbar-track</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*::-webkit-scrollbar-track &#123; // 就是滑块底部整个区域</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="webkit-scrollbar-track-piece"><a href="#webkit-scrollbar-track-piece" class="headerlink" title="::-webkit-scrollbar-track-piece"></a>::-webkit-scrollbar-track-piece</h3><ul>
<li>同上，这个和::-webkit-scrollbar-track 二选一，效果一致</li>
</ul>
<h3 id="webkit-scrollbar-thumb"><a href="#webkit-scrollbar-thumb" class="headerlink" title="::-webkit-scrollbar-thumb"></a>::-webkit-scrollbar-thumb</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*::-webkit-scrollbar-thumb &#123; // 修改滑块的样式</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">80</span>, <span class="number">94</span>, <span class="number">77</span>); // 滑块颜色</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">5px</span>; // 滑块圆角</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="webkit-scrollbar-thumb-hover"><a href="#webkit-scrollbar-thumb-hover" class="headerlink" title="::-webkit-scrollbar-thumb:hover"></a>::-webkit-scrollbar-thumb:hover</h3><ul>
<li>横、纵滑块悬浮样式，统一颜色就选这个，有单独的颜色下面两个</li>
</ul>
<h3 id="webkit-scrollbar-thumb-vertical-hover"><a href="#webkit-scrollbar-thumb-vertical-hover" class="headerlink" title="::-webkit-scrollbar-thumb:vertical:hover"></a>::-webkit-scrollbar-thumb:vertical:hover</h3><ul>
<li>纵向滑块悬浮 |</li>
</ul>
<h3 id="webkit-scrollbar-thumb-horizontal-hover"><a href="#webkit-scrollbar-thumb-horizontal-hover" class="headerlink" title="::-webkit-scrollbar-thumb:horizontal:hover"></a>::-webkit-scrollbar-thumb:horizontal:hover</h3><ul>
<li>横向滑块悬浮</li>
</ul>
<h3 id="webkit-scrollbar-corner"><a href="#webkit-scrollbar-corner" class="headerlink" title="::-webkit-scrollbar-corner"></a>::-webkit-scrollbar-corner</h3><ul>
<li>当横向滑块在最左时，纵向滑块在最下时，有一个相交形成的区域</li>
<li>very small area</li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>滚动条</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-基础篇</title>
    <url>/2024/10/30/HTMLCSS/css-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="网页分为三个部分："><a href="#网页分为三个部分：" class="headerlink" title="网页分为三个部分："></a>网页分为三个部分：</h2><ul>
<li>结构(HTML)</li>
<li>表现(CSS) — 用来设置网页中元素的样式</li>
<li>行为(JavaScript)</li>
</ul>
<h2 id="使用-CSS-来修改元素的样式"><a href="#使用-CSS-来修改元素的样式" class="headerlink" title="使用 CSS 来修改元素的样式"></a>使用 CSS 来修改元素的样式</h2><h3 id="第一种方式-内联样式，行内样式"><a href="#第一种方式-内联样式，行内样式" class="headerlink" title="第一种方式(内联样式，行内样式)"></a>第一种方式(内联样式，行内样式)</h3><ul>
<li>在标签内部通过 style 属性来设置元素的样式</li>
<li>缺点：样式只能对一个标签生效</li>
<li>注意：开发时绝对不要使用内联样式</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red; font-size: 60px;&quot;</span>&gt;</span>少小离家老大回，乡音无改鬓毛衰<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第二种方式（内部样式表）"><a href="#第二种方式（内部样式表）" class="headerlink" title="第二种方式（内部样式表）"></a>第二种方式（内部样式表）</h3><ul>
<li>将样式编写到 head 中的 style 标签里,通过 CSS 的选择器来选中元素并为其设置各种样式</li>
<li>优点：<ul>
<li>可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用</li>
<li>方便对样式进行复用</li>
</ul>
</li>
<li>缺点：只能对一个网页起作用，不能跨页面进行复用</li>
</ul>
<h3 id="第三种方式-（外部样式表）-最佳实践"><a href="#第三种方式-（外部样式表）-最佳实践" class="headerlink" title="第三种方式 （外部样式表） 最佳实践"></a>第三种方式 （外部样式表） 最佳实践</h3><ul>
<li>可以将 CSS 样式编写到一个外部的 CSS 文件中,然后通过 link 标签来引入外部的 CSS 文件</li>
<li>优点：<ul>
<li>外部样式表需要通过 link 标签进行引入，使样式可以在不同页面之间进行复用</li>
<li>可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户的体验。</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./style.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><h3 id="父元素"><a href="#父元素" class="headerlink" title="父元素"></a>父元素</h3><ul>
<li>直接包含子元素的元素叫做父元素</li>
</ul>
<h3 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h3><ul>
<li>直接被父元素包含的元素是子元素</li>
</ul>
<h3 id="祖先元素"><a href="#祖先元素" class="headerlink" title="祖先元素"></a>祖先元素</h3><ul>
<li>直接或间接包含后代元素的元素叫做祖先元素</li>
<li>一个元素的父元素也是它的祖先元素</li>
</ul>
<h3 id="后代元素"><a href="#后代元素" class="headerlink" title="后代元素"></a>后代元素</h3><ul>
<li>直接或间接被祖先元素包含的元素叫做后代元素</li>
<li>子元素也是后代元素</li>
</ul>
<h3 id="兄弟元素"><a href="#兄弟元素" class="headerlink" title="兄弟元素"></a>兄弟元素</h3><ul>
<li>拥有相同父元素的元素是兄弟元素</li>
</ul>
<h2 id="样式的继承"><a href="#样式的继承" class="headerlink" title="样式的继承"></a>样式的继承</h2><ul>
<li>为一个元素设置的样式同时也会应用到它的后代元素上</li>
<li>继承是发生在祖先与后代之间的</li>
<li>继承的设计是为了方便开发，利用继承可以将一些通用的样式统一设置到共同的祖先元素上，这样只需设置一次即可让所有的元素都具有该样式</li>
<li>注意：并不是所有的样式都会被继承，比如背景相关的，布局相关等的这些样式都不会被继承。</li>
</ul>
<h3 id="样式的冲突"><a href="#样式的冲突" class="headerlink" title="样式的冲突"></a>样式的冲突</h3><ul>
<li>当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值时，此时就发生了样式的冲突。</li>
<li>发生样式冲突时，应用哪个样式由选择器的权重（优先级）决定</li>
</ul>
<h2 id="css-单位"><a href="#css-单位" class="headerlink" title="css 单位"></a>css 单位</h2><h3 id="长度单位："><a href="#长度单位：" class="headerlink" title="长度单位："></a>长度单位：</h3><ul>
<li>在 css 中使用的都是相对单位</li>
<li>px(<span class="desc">Pixels 像素</span>) <ul>
<li>屏幕（显示器）实际上是由一个一个的小点点构成的</li>
<li>不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰</li>
<li>所以同样的 200px 在不同的设备下显示效果不一样</li>
<li>web 开发中的主流，在分辨率的宽高中占 npx&#x2F;分辨率宽</li>
</ul>
</li>
<li>%(<span class="desc">百分比</span>) <ul>
<li>也可以将属性值设置为相对于其父元素属性的百分比</li>
<li>设置百分比可以使子元素跟随父元素的改变而改变</li>
<li>对于 font-size、line-height 等属性是基于期父元素的 font-size</li>
<li>对于 text-indent、margin、padding、width 等属性则是基于父元素的宽度</li>
</ul>
</li>
<li>em(<span class="desc">元素的字体高度</span>) <ul>
<li>em 是相对于元素的字体大小来计算的</li>
<li><span class="key_words">『基于当前元素&#x2F;父元素的font-size』</span>: 当前元素 12px 的话，font-size：12&#x2F;nem</li>
<li>1em &#x3D; 1font-size &#x3D; 16px</li>
<li>em 会根据字体大小的改变而改变</li>
<li>具有级联关系</li>
</ul>
</li>
<li>rem: 根元素(html)的 font-size <span class="desc">css3 新增</span><ul>
<li>rem 是相对于根元素的字体大小来计算</li>
<li>无级联</li>
<li>IE8 及以下、Safari 4、IOS 3.2 等不支持 rem</li>
</ul>
</li>
<li>ex: x-height，字母 x 的高度</li>
<li>ch: 字符 0 的宽度 <span class="desc">css3 新增</span></li>
<li>vw: 视窗宽度 viewpoint width <span class="desc">css3 新增</span><ul>
<li>1vw &#x3D; 视窗宽度的 1%</li>
</ul>
</li>
<li>vh: 视窗高度 viewpoint height <span class="desc">css3 新增</span><ul>
<li>1vh &#x3D; 视窗高度的 1%</li>
</ul>
</li>
<li>vmin: 以较小者为准 1vh <span class="desc">css3 新增</span></li>
<li>vmax: 以较大者为准 1v <span class="desc">css3 新增</span></li>
</ul>
<h3 id="角度单位-—-主要在动画旋转中使用"><a href="#角度单位-—-主要在动画旋转中使用" class="headerlink" title="角度单位 — 主要在动画旋转中使用"></a>角度单位 — 主要在动画旋转中使用</h3><ul>
<li>deg(度): 一个圆 360°</li>
<li>grad(梯度): 一个圆共 400 梯度</li>
<li>rad(弧度): 一个圆共 2Π 弧度</li>
<li>turn(转、圈): 一个圆共一圈</li>
<li>公式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">90deg = 100grad = 0.25turn ≈ 1.570796326794897rad</span><br></pre></td></tr></table></figure></li>
<li>使用：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">1turn</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="颜色单位"><a href="#颜色单位" class="headerlink" title="颜色单位"></a>颜色单位</h3><ul>
<li>在 CSS 中可以直接使用颜色名来设置各种颜色，<ul>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: red;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>RGB 值：<ul>
<li>RGB 通过三种颜色的不同浓度来调配出不同的颜色</li>
<li>R red，G green ，B blue</li>
<li>每一种颜色的范围在 0 - 255 (0% - 100%) 之间</li>
<li>语法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RGB(红色,绿色,蓝色)</span><br></pre></td></tr></table></figure></li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>RGBA:<ul>
<li>就是在 rgb 的基础上增加了一个 alpha 表示不透明度</li>
<li>需要四个值，前三个和 rgb 一样，第四个表示不透明度</li>
<li>1 表示完全不透明，0 表示完全透明，.5 半透明</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">106</span>,<span class="number">153</span>,<span class="number">85</span>,.<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>十六进制的 RGB 值：<ul>
<li>语法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#红色绿色蓝色</span><br></pre></td></tr></table></figure></li>
<li>颜色浓度通过 00-ff</li>
<li>如果颜色两位两位重复可以进行简写，#aabbcc –&gt; #abc</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: <span class="number">#ff0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>HSL 值 HSLA 值<ul>
<li>H 色相(0 - 360)</li>
<li>S 饱和度，颜色的浓度 0% - 100%</li>
<li>L 亮度，颜色的亮度 0% - 100%</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: <span class="built_in">hsla</span>(<span class="number">98</span>, <span class="number">48%</span>, <span class="number">40%</span>, <span class="number">0.658</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="CSS-预处理器-Sass、Less、Stylus-的区别"><a href="#CSS-预处理器-Sass、Less、Stylus-的区别" class="headerlink" title="CSS 预处理器 Sass、Less、Stylus 的区别"></a>CSS 预处理器 Sass、Less、Stylus 的区别</h2><h3 id="CSS-预处理器概念"><a href="#CSS-预处理器概念" class="headerlink" title="CSS 预处理器概念"></a>CSS 预处理器概念</h3><ul>
<li>是一种语言用来为 CSS 增加一些变成的特性，无需考虑浏览器兼容问题，例如你可以在 CSS 中使用变量，简单的程序逻辑、函数等在编程语言中的一些基本技巧，可以让 CSS 更加简洁，适应性更强，代码更直观等诸多好处 基本语法区别</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>Sass 是以.sass 为扩展名，Less 是以.less 为扩展名，Stylus 是以.styl 为扩展名 变量的区别</li>
<li>Sass 变量必须是以$开头的，然后变量和值之间使用冒号（：）隔开，和 css 属性是一样的。</li>
<li>Less 变量是以@开头的，其余 sass 都是一样的。</li>
<li>Stylus 对变量是没有任何设定的，可以是以$开头或者任意字符，而且变量之间可以冒号，空格隔开，但是在 stylus 中不能用@开头</li>
<li>三种预处理器都有：嵌套、运算符、颜色函数、导入、继承、混入。Stylus 还有一些高级特性。例如循环、判断等</li>
<li><a href="/2024/10/30/HTMLCSS/css%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-sass/" title="CSS预处理器-sass语法">CSS预处理器-sass语法</a></li>
<li><a href="/2024/10/30/HTMLCSS/css%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-less/" title="CSS预处理器-less语法">CSS预处理器-less语法</a></li>
</ul>
<h2 id="css3-篇"><a href="#css3-篇" class="headerlink" title="css3 篇"></a>css3 篇</h2><h3 id="box-shadow-设置元素阴影"><a href="#box-shadow-设置元素阴影" class="headerlink" title="box-shadow(设置元素阴影)"></a>box-shadow(<span class="desc">设置元素阴影</span>)</h3><ul>
<li>x-offset: 水平偏移量</li>
<li>y-offset: 处置偏移量</li>
<li>blur-radius: 可选，模糊半径，默认值为 0</li>
<li>spread-radius: 可选，扩散半径，默认值为 0</li>
<li>color: 可选，阴影颜色，默认继承元素的 color 属性</li>
<li>inset: 可选，是否内部阴影，默认为外部阴影</li>
</ul>
<h3 id="text-shadow-设置文本阴影"><a href="#text-shadow-设置文本阴影" class="headerlink" title="text-shadow(设置文本阴影)"></a>text-shadow(<span class="desc">设置文本阴影</span>)</h3><ul>
<li>x-offset: 水平偏移量</li>
<li>y-offset: 处置偏移量</li>
<li>blur-radius: 可选，模糊半径，默认值为 0</li>
<li>color: 可选，阴影颜色，默认继承元素的 color 属性</li>
</ul>
<h3 id="简-border-image-设置边框图片"><a href="#简-border-image-设置边框图片" class="headerlink" title="(简)border-image(设置边框图片)"></a>(简)border-image(<span class="desc">设置边框图片</span>)</h3><ul>
<li>border-image-source:url(): 图片路径</li>
<li>border-image-slice: 上右下左偏移量</li>
<li>border-image-width: 图片宽度</li>
<li>border-image-outset: 图边框图像超过边框盒的量，默认值为 0</li>
<li>border-image-repeat：stretch(拉伸) | repeat(重复) | round(缩放自适应) — 图片重复方式</li>
</ul>
<h3 id="border-radius-圆角半径"><a href="#border-radius-圆角半径" class="headerlink" title="border-radius(圆角半径)"></a>border-radius(<span class="desc">圆角半径</span>)</h3><h3 id="box-reflect-反射"><a href="#box-reflect-反射" class="headerlink" title="box-reflect(反射)"></a>box-reflect(<span class="desc">反射</span>)</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">box-reflect：<span class="attribute">none</span> | &lt;<span class="attribute">direction</span>&gt; &lt;offset&gt;? &lt;<span class="attribute">mask</span>-box-<span class="selector-tag">image</span>&gt;?</span><br></pre></td></tr></table></figure>
<ul>
<li>direction: 反射的方向，可选值为 above，below，left，right。</li>
<li>offset: 表示本体和反射之间的间隔，可设置为长度值也可设置为百分比。此参数可省略，默认为 0</li>
<li>mask-box-image: 用于设置反射的遮罩，可设置为渐变或者一个图片。此参数可省略。</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a><a href="/2024/10/30/HTMLCSS/html-%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%B8%83%E5%B1%80/" title="Html-媒体查询布局">Html-媒体查询布局</a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/2024/10/30/HTMLCSS/css-%E6%BB%A4%E9%95%9C%E7%AF%87/" title="CSS-滤镜篇">CSS-滤镜篇</a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="/2024/10/30/HTMLCSS/css-%E5%8A%A8%E7%94%BB/" title="CSS-动画篇">过渡(transition)、动画(animation)、形状转换(transform)</a></h3><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// Clamp(最小值，最大值和中间值的灵活单位)，值介于最小值和最大值之间它将使用中间值</span><br><span class="line"><span class="attribute">font-size</span>: <span class="built_in">clamp</span>(<span class="number">100%</span>,<span class="number">1rem</span> + <span class="number">2vw</span>,<span class="number">24px</span>)</span><br><span class="line">            ||</span><br><span class="line">font-size: <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="number">1rem</span>,<span class="number">4vw</span>), <span class="number">22px</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-文本背景篇</title>
    <url>/2024/10/30/HTMLCSS/css-%E6%96%87%E6%9C%AC%E8%83%8C%E6%99%AF%E7%AF%87/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="font"><a href="#font" class="headerlink" title="font"></a>font</h2><h3 id="font-face"><a href="#font-face" class="headerlink" title="font-face"></a>font-face</h3><ul>
<li>可以将服务器中的字体直接提供给用户去使用</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>:<span class="string">&#x27;myfont&#x27;</span> ;</span><br><span class="line">  <span class="comment">/* 服务器中字体的路径 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;./font/ZCOOLKuaiLe-Regular.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&quot;truetype&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字体相关的样式"><a href="#字体相关的样式" class="headerlink" title="字体相关的样式"></a>字体相关的样式</h3><ul>
<li>color：用来设置字体颜色</li>
<li>font-size：字体的大小</li>
<li>font-family：字体族（字体的格式）<ul>
<li>可选值：<ul>
<li>serif 衬线字体</li>
<li>sans-serif 非衬线字体</li>
<li>monospace 等宽字体</li>
</ul>
</li>
<li>font-family 可以同时指定多个字体，多个字体间使用,隔开</li>
<li>字体生效时优先使用第一个，第一个无法使用则使用第二个 以此类推</li>
</ul>
</li>
<li>font 简写属性<ul>
<li>语法：font: 字体大小&#x2F;行高 字体族</li>
<li>行高 可以省略不写 如果不写使用默认值</li>
</ul>
</li>
<li>font-weight：字重，字体的加粗<ul>
<li>可选值：<ul>
<li>normal：默认值 不加粗</li>
<li>bold：加粗</li>
<li>100-900：九个级别（没什么用）</li>
</ul>
</li>
</ul>
</li>
<li>font-style：字体的风格<ul>
<li>可选值：<ul>
<li>normal：正常的</li>
<li>italic：斜体</li>
</ul>
</li>
</ul>
</li>
<li>line-height：行高，文字占有的实际高度<ul>
<li>值：<ul>
<li>带有单位（px、em）的数值</li>
<li>一个整数，行高将会是字体的指定的倍数</li>
</ul>
</li>
<li>行高经常还用来设置文字的行间距</li>
<li>行高会在字体框的上下平均分配</li>
<li>行间距 &#x3D; 行高 - 字体大小</li>
<li>字体框<ul>
<li>字体框就是字体存在的格子，设置 font-size 实际上就是在设置字体框的高度</li>
</ul>
</li>
<li>将行高设置为和高度一样的值，使单行文字在一个元素中垂直居中</li>
</ul>
</li>
</ul>
<h3 id="图标字体（iconfont）"><a href="#图标字体（iconfont）" class="headerlink" title="图标字体（iconfont）"></a>图标字体（iconfont）</h3><ul>
<li>方案一：通过 font-face 的形式来对字体进行引入</li>
<li>方案二：fontawesome 使用步骤<ol>
<li>下载 <a href="https://fontawesome.com/">https://fontawesome.com/</a></li>
<li>解压</li>
<li>将 css 和 webfonts 移动到项目中</li>
<li>将 all.css 引入到网页中<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./fa/css/all.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<ol>
<li>使用图标字体</li>
</ol>
<ul>
<li><p>直接通过类名来使用图标字体</p>
</li>
<li><p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-bell&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:80px; color:red;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
<li><p>方案三：通过伪元素来设置图标字体</p>
<ol>
<li>找到要设置图标的元素通过 before 或 after 选中</li>
<li>在 content 中设置字体的编码</li>
<li>设置字体的样式</li>
</ol>
<ul>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;\f1b0&#x27;</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Font Awesome 5 Free&#x27;</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">900</span>;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方案四：通过实体来使用图标字体：</p>
<ul>
<li>&amp;#x 图标的编码;</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fas&quot;</span>&gt;</span><span class="symbol">&amp;#xf0f3;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="阿里的字体库"><a href="#阿里的字体库" class="headerlink" title="阿里的字体库"></a>阿里的字体库</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./iconfont/iconfont.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><h3 id="text-align：文本的水平对齐"><a href="#text-align：文本的水平对齐" class="headerlink" title="text-align：文本的水平对齐"></a>text-align：文本的水平对齐</h3><ul>
<li>left：左侧对齐</li>
<li>right：右对齐</li>
<li>center：居中对齐</li>
<li>justify：两端对齐</li>
</ul>
<h3 id="vertical-align：设置元素垂直对齐的方式"><a href="#vertical-align：设置元素垂直对齐的方式" class="headerlink" title="vertical-align：设置元素垂直对齐的方式"></a>vertical-align：设置元素垂直对齐的方式</h3><ul>
<li>baseline：默认值，基线对齐</li>
<li>top：顶部对齐</li>
<li>bottom：底部对齐</li>
<li>middle：居中对齐</li>
</ul>
<h3 id="text-decoration：设置文本修饰"><a href="#text-decoration：设置文本修饰" class="headerlink" title="text-decoration：设置文本修饰"></a>text-decoration：设置文本修饰</h3><ul>
<li>none：什么都没有</li>
<li>underline：下划线</li>
<li>line-through：删除线</li>
<li>overline：上划线</li>
</ul>
<h3 id="white-space：设置网页如何处理空白"><a href="#white-space：设置网页如何处理空白" class="headerlink" title="white-space：设置网页如何处理空白"></a>white-space：设置网页如何处理空白</h3><ul>
<li>normal：正常</li>
<li>nowrap：不换行</li>
<li>pre：保留空白</li>
</ul>
<h3 id="文本换行"><a href="#文本换行" class="headerlink" title="文本换行"></a>文本换行</h3><ul>
<li>word-wrap: break-word;强制换行<ul>
<li>根据单词换行，页面可能留有空间，如果长单词新起一行也放不下，才会强制断句</li>
</ul>
</li>
<li>word-break：break-all;强制换行<ul>
<li>根据页面宽度换行，页面空间充分利用</li>
</ul>
</li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="background-color：设置背景颜色"><a href="#background-color：设置背景颜色" class="headerlink" title="background-color：设置背景颜色"></a>background-color：设置背景颜色</h3><h3 id="background-image：设置背景图片"><a href="#background-image：设置背景图片" class="headerlink" title="background-image：设置背景图片"></a>background-image：设置背景图片</h3><ul>
<li>可以同时设置背景图片和背景颜色，这样背景颜色将会成为图片的背景色</li>
<li>如果背景的图片小于元素，则背景图片会自动在元素中平铺将元素铺满</li>
<li>如果背景的图片大于元素，将会一个部分背景无法完全显示</li>
<li>如果背景图片和元素一样大，则会直接正常显示</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;./img/1.png&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="background-repeat：用来设置背景的重复方式"><a href="#background-repeat：用来设置背景的重复方式" class="headerlink" title="background-repeat：用来设置背景的重复方式"></a>background-repeat：用来设置背景的重复方式</h3><ul>
<li>repeat 默认值 ， 背景会沿着 x 轴 y 轴双方向重复</li>
<li>repeat-x 沿着 x 轴方向重复</li>
<li>repeat-y 沿着 y 轴方向重复</li>
<li>no-repeat 背景图片不重复</li>
</ul>
<h3 id="background-position：用来设置背景图片的位置"><a href="#background-position：用来设置背景图片的位置" class="headerlink" title="background-position：用来设置背景图片的位置"></a>background-position：用来设置背景图片的位置</h3><ul>
<li>设置方式：<ol>
<li>通过 top left right bottom center 几个方位的词来设置背景图片的位置<br>使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是 center</li>
<li>通过偏移量来指定背景图片的位置：水平方向的偏移量 垂直方向变量</li>
</ol>
</li>
</ul>
<h3 id="background-clip：指定背景绘制区域"><a href="#background-clip：指定背景绘制区域" class="headerlink" title="background-clip：指定背景绘制区域"></a>background-clip：指定背景绘制区域</h3><ul>
<li>border-box：默认值，背景会出现在边框的下边</li>
<li>padding-box：背景不会出现在边框，只出现在内容区和内边距</li>
<li>content-box：背景只会出现在内容区</li>
</ul>
<h3 id="background-origin：背景图片的偏移量计算的原点"><a href="#background-origin：背景图片的偏移量计算的原点" class="headerlink" title="background-origin：背景图片的偏移量计算的原点"></a>background-origin：背景图片的偏移量计算的原点</h3><ul>
<li>padding-box：默认值，background-position 从内边距处开始计算</li>
<li>content-box：背景图片的偏移量从内容区处计算</li>
<li>border-box：背景图片的变量从边框处开始计算</li>
</ul>
<h3 id="background-size：设置背景图片的大小"><a href="#background-size：设置背景图片的大小" class="headerlink" title="background-size：设置背景图片的大小"></a>background-size：设置背景图片的大小</h3><ul>
<li>值情况：<ul>
<li>一个值：表示宽度，图片的高度隐式 auto</li>
<li>两个值：图片宽度 图片高度</li>
<li>关键字<ul>
<li>cover：图片的比例不变，将元素铺满</li>
<li>contain：图片比例不变，将图片在元素中完整显示</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="background-attachment：设置背景图片是否跟随元素移动"><a href="#background-attachment：设置背景图片是否跟随元素移动" class="headerlink" title="background-attachment：设置背景图片是否跟随元素移动"></a>background-attachment：设置背景图片是否跟随元素移动</h3><ul>
<li>scroll：默认值 背景图片会跟随元素移动</li>
<li>fixed：背景会固定在页面中，不会随元素移动</li>
</ul>
<h3 id="background-简写属性"><a href="#background-简写属性" class="headerlink" title="background 简写属性"></a>background 简写属性</h3><ul>
<li>没有顺序要求，也没有哪个属性是必须写的</li>
<li>background-size 必须写在 background-position 的后边，并且使用&#x2F;隔开</li>
<li>background-origin background-clip 两个样式 ，orgin 要在 clip 的前边</li>
</ul>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><ul>
<li>渐变是图片，需要通过 background-image 来设置</li>
</ul>
<h3 id="linear-gradient-：线性渐变，颜色沿着一条直线发生变化"><a href="#linear-gradient-：线性渐变，颜色沿着一条直线发生变化" class="headerlink" title="linear-gradient()：线性渐变，颜色沿着一条直线发生变化"></a>linear-gradient()：线性渐变，颜色沿着一条直线发生变化</h3><ul>
<li>线性渐变的开头，我们可以指定一个渐变的方向<ul>
<li>to left</li>
<li>to right</li>
<li>to bottom</li>
<li>to top</li>
<li>deg deg 表示度数</li>
<li>turn 表示圈</li>
</ul>
</li>
<li>渐变可以同时指定多个颜色，多个颜色默认情况下平均分布，也可以手动指定渐变的分布情况</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, red,orange,yellow,green,indigo,violet);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="repeating-linear-gradient-可以平铺的线性渐变"><a href="#repeating-linear-gradient-可以平铺的线性渐变" class="headerlink" title="repeating-linear-gradient() 可以平铺的线性渐变"></a>repeating-linear-gradient() 可以平铺的线性渐变</h3><h3 id="radial-gradient-径向渐变-放射性的效果"><a href="#radial-gradient-径向渐变-放射性的效果" class="headerlink" title="radial-gradient() 径向渐变(放射性的效果)"></a>radial-gradient() 径向渐变(放射性的效果)</h3><ul>
<li>默认情况下径向渐变的形状根据元素的形状来计算的<ul>
<li>正方形 –&gt; 圆形</li>
<li>长方形 –&gt; 椭圆形</li>
</ul>
</li>
<li>语法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">radial-gradient(大小 at 位置, 颜色 位置 ,颜色 位置 ,颜色 位置)</span><br></pre></td></tr></table></figure></li>
<li>大小：<ul>
<li>circle 圆形</li>
<li>ellipse 椭圆</li>
<li>closest-side 近边</li>
<li>closest-corner 近角</li>
<li>farthest-side 远边</li>
</ul>
</li>
<li>位置：top right left center bottom</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(farthest-corner at <span class="number">100px</span> <span class="number">100px</span>, red , <span class="number">#bfa</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>文本</tag>
        <tag>背景</tag>
        <tag>渐变</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-渐变篇</title>
    <url>/2025/03/06/HTMLCSS/css-%E6%B8%90%E5%8F%98/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul>
<li>属于background的背景方式之一</li>
<li>语法：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: 渐变函数;</span><br></pre></td></tr></table></figure></li>
<li>渐变可以使用关键字作为起始位置，但在小程序中关键字无效</li>
</ul>
<p><img src="/../../img/visualization/gradient.jpg" alt="渐变"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="线性渐变linear-gradient"><a href="#线性渐变linear-gradient" class="headerlink" title="线性渐变linear-gradient()"></a>线性渐变linear-gradient()</h2><ul>
<li>场景：条纹背景</li>
<li>语法：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">linear-gradient(角度，起始颜色， 终止颜色)</span><br></pre></td></tr></table></figure></li>
<li>多个渐变,可以用百分比，确定每个颜色从那个位置开始过渡<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">linear-gradient(red <span class="number">0%</span>, orange <span class="number">25%</span>, blue <span class="number">50%</span>, black <span class="number">90%</span>);</span><br></pre></td></tr></table></figure></li>
<li>如果每个颜色都有起始和结束，则形成条纹(色块分明)，起始0%和结束100%可以忽略不写<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">linear-gradient(<span class="selector-tag">to</span> <span class="attribute">right</span>, red <span class="number">20%</span>, orange <span class="number">20%</span> <span class="number">40%</span>, yellow <span class="number">40%</span> <span class="number">60%</span>, green <span class="number">60%</span> <span class="number">80%</span>, blue <span class="number">80%</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="重复线性渐变repeating-linear-gradient"><a href="#重复线性渐变repeating-linear-gradient" class="headerlink" title="重复线性渐变repeating-linear-gradient()"></a>重复线性渐变repeating-linear-gradient()</h3><ul>
<li>语法跟linear-gradient()一样，但是最后一个颜色要给一个长度，如果没有长度，默认长度0-100%，不会重复渐变。</li>
<li>只要末尾有长度，就会无限循环直到容器被填满</li>
<li>只有末尾有值：<span class="key_words">『(0%-最后一个颜色的值)』</span>的重复渐变<ul>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">repeating-linear-gradient(<span class="number">45deg</span>, white, grey <span class="number">25%</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>每个颜色都带值: <span class="key_words">『(第一个颜色的值-最后一个颜色的值)』</span>的重复渐变<ul>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">repeating-linear-gradient(<span class="number">45deg</span>, white <span class="number">10%</span>, red <span class="number">15%</span>, grey <span class="number">20%</span>); // 代表每<span class="number">10</span>-<span class="number">20%</span>是一个渐变轮回</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>每个颜色都带区间值，条纹：<span class="key_words">『(第一个颜色的最小区间值-最后一个颜色的最大区间值)』</span>的重复渐变<ul>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">repeating-linear-gradient(<span class="number">45deg</span>, grey -<span class="number">10%</span> <span class="number">0%</span>, white <span class="number">0%</span> <span class="number">5%</span>, green <span class="number">5%</span> <span class="number">10%</span>);</span><br><span class="line">// 代表每-<span class="number">10%</span>-<span class="number">10%</span>是一个渐变轮回,且色块分明，没有渐变过渡效果 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="径向渐变radial-gradient-由原点一圈一圈往外形成"><a href="#径向渐变radial-gradient-由原点一圈一圈往外形成" class="headerlink" title="径向渐变radial-gradient() - 由原点一圈一圈往外形成"></a>径向渐变radial-gradient() - 由原点一圈一圈往外形成</h2><ul>
<li>语法：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">radial-gradient(渐变位置, 渐变结束位置, 中间的颜色, 结束的颜色)</span><br></pre></td></tr></table></figure></li>
<li>渐变位置：有circle 和 ellipse两种形状<ul>
<li>关键字：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">radial-gradient(<span class="selector-tag">circle</span> at center, red, blue)</span><br></pre></td></tr></table></figure></li>
<li>不写，默认：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">center：radial-gradient(<span class="selector-tag">circle</span>, red, blue)</span><br></pre></td></tr></table></figure></li>
<li>关键字+范围：限制第一个颜色的大小(包括渐变)<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">radial-gradient(<span class="selector-tag">circle</span> <span class="number">50px</span> at center, red, blue); // 代表中间红色只有<span class="number">50px</span></span><br></pre></td></tr></table></figure></li>
<li>椭圆比圆多一个范围值，其他写法一样：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">radial-gradient(<span class="selector-tag">ellipse</span> <span class="number">50px</span> <span class="number">20px</span> at center, red, blue)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>渐变结束形状： <ul>
<li>farthest-corner: 默认,最远角</li>
<li>farthest-side: 与容器距离渐变中心点最远的一边或最远的垂直和水平边相切</li>
<li>closest-side: 与容器距离渐变中心点最近的一边(圆)或最近的垂直和水平边(椭圆)相切。</li>
<li>closest-corner: 最近角</li>
</ul>
</li>
<li>颜色带一个值的，渐变范围在值间，0%和100%默认可以忽略不写<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">radial-gradient(cyan, transparent <span class="number">20%</span>, salmon <span class="number">40%</span>);</span><br><span class="line">// 从中间开始三种颜色<span class="number">0</span>-<span class="number">20</span>是cyan，<span class="number">20</span>-<span class="number">40</span>是transparent，<span class="number">40</span>-<span class="number">100</span>是salmon</span><br></pre></td></tr></table></figure></li>
<li>每个值固定的区间范围，色块分明<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">radial-gradient(cyan <span class="number">0%</span> <span class="number">10%</span>, transparent <span class="number">20%</span> <span class="number">40%</span>, salmon <span class="number">40%</span> <span class="number">80%</span>, blue);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="重复径向渐变repeating-radial-gradient"><a href="#重复径向渐变repeating-radial-gradient" class="headerlink" title="重复径向渐变repeating-radial-gradient()"></a>重复径向渐变repeating-radial-gradient()</h3><ul>
<li>语法与径向渐变一样，但一定要有范围，不管是在位置上还是在跟着颜色在末尾处，只选取其中的最大值重复渐变</li>
<li>不加位置，只使用颜色，渐变相交<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">repeating-radial-gradient(black, white <span class="number">10px</span>);</span><br></pre></td></tr></table></figure></li>
<li>加了位置，和每个颜色带范围，从位置开始0%-最大值一轮回<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">repeating-radial-gradient(<span class="selector-tag">ellipse</span> farthest-corner at <span class="number">20%</span> <span class="number">20%</span>, red, black <span class="number">5%</span>, blue <span class="number">5%</span>, green <span class="number">10%</span>);</span><br></pre></td></tr></table></figure></li>
<li>区间范围,色块分明<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">repeating-radial-gradient</span>(ellipse farthest-corner at <span class="number">20%</span> <span class="number">20%</span>, red <span class="number">0</span> <span class="number">5%</span>, green <span class="number">5%</span> <span class="number">10%</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="圆锥渐变conic-gradient-–-从中间向外放射直线所形成的面"><a href="#圆锥渐变conic-gradient-–-从中间向外放射直线所形成的面" class="headerlink" title="圆锥渐变conic-gradient() – 从中间向外放射直线所形成的面"></a>圆锥渐变conic-gradient() – 从中间向外放射直线所形成的面</h2><ul>
<li>场景：用来创建环形，扇形,充电等形状的渐变</li>
<li>语法：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">conic-gradient(&lt;起始角度&gt;, &lt;颜色值<span class="number">1</span>&gt; &lt;起始位置&gt;, &lt;颜色值<span class="number">2</span>&gt; &lt;结束位置&gt;,...);</span><br></pre></td></tr></table></figure></li>
<li>普遍应用<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">conic-gradient(color1, color2, color3)</span><br></pre></td></tr></table></figure></li>
<li>颜色分明，带区间范围<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">conic-gradient(color1 <span class="number">0%</span> <span class="number">30%</span>, color2 <span class="number">30%</span> <span class="number">60%</span>)</span><br><span class="line">conic-gradient(color1 <span class="number">30%</span>, color2 <span class="number">30%</span> <span class="number">100%</span>)</span><br></pre></td></tr></table></figure></li>
<li>带一个值，在值附近会有过渡渐变<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">conic-gradient(color1 <span class="number">30%</span>, color2 <span class="number">70%</span>)</span><br></pre></td></tr></table></figure></li>
<li>动态效果：360旋转这个图形</li>
<li>想要实现动态充电效果百分比，最主要是动态修改区间范围颜色值的第一个范围</li>
</ul>
<h3 id="重复圆锥渐变repeating-conic-gradient"><a href="#重复圆锥渐变repeating-conic-gradient" class="headerlink" title="重复圆锥渐变repeating-conic-gradient()"></a>重复圆锥渐变repeating-conic-gradient()</h3><ul>
<li>语法与圆锥渐变一样，重复直到把容器填满</li>
<li>重复渐变使用区间范围的第二中写法不会重复，因为容器默认0%-100%</li>
</ul>
<h3 id="用重复圆锥渐变实现一个充电环形底"><a href="#用重复圆锥渐变实现一个充电环形底" class="headerlink" title="用重复圆锥渐变实现一个充电环形底"></a>用重复圆锥渐变实现一个充电环形底</h3><ul>
<li>底部的条纹：使用重复圆锥渐变</li>
<li>中间白色部分：用绝对定位叠加</li>
<li>进度条：定位一个跟条纹圆形一样大小的圆，置于中间，然后定时改变圆锥渐变的变量<br><img src="/../../img/visualization/charge1-conic.png" alt="条纹充电效果图"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.<span class="property">bottom</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 200px;</span><br><span class="line">  border-<span class="attr">radius</span>: 200px;</span><br><span class="line">  <span class="attr">background</span>: repeating-conic-<span class="title function_">gradient</span>(#fff <span class="number">0</span> 3deg, #<span class="number">000</span> 3deg 6deg);</span><br><span class="line">  z-<span class="attr">index</span>:<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">center</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: absolute;</span><br><span class="line">  <span class="attr">top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attr">left</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 200px;</span><br><span class="line">  border-<span class="attr">radius</span>: 200px;</span><br><span class="line">  z-<span class="attr">index</span>:<span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">top</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: absolute;</span><br><span class="line">  <span class="attr">top</span>:10px;</span><br><span class="line">  <span class="attr">left</span>: 10px;</span><br><span class="line">  <span class="attr">width</span>:180px;</span><br><span class="line">  <span class="attr">height</span>:180px;</span><br><span class="line">  border-<span class="attr">radius</span>: 180px;</span><br><span class="line">  <span class="attr">background</span>: white;</span><br><span class="line">  z-<span class="attr">index</span>: <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span> <span class="attr">id</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> cnt = <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> center = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;center&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (center &gt; <span class="number">100</span>) <span class="built_in">clearInterval</span>(timer)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      center.<span class="property">style</span>.<span class="property">background</span> = <span class="string">`conic-gradient(green <span class="subst">$&#123;cnt&#125;</span>%, transparent <span class="subst">$&#123;cnt&#125;</span>% 100%)`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      cnt++</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;, <span class="number">100</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>渐变</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-滤镜篇</title>
    <url>/2024/10/30/HTMLCSS/css-%E6%BB%A4%E9%95%9C%E7%AF%87/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>blur(): 模糊图像</li>
<li>brightness(): 调整亮度</li>
<li>saturate(): 调整饱和度</li>
<li>contrast(): 调整对比度</li>
<li>grayscale(): 改变图像灰度</li>
<li>drop-shadow(): 阴影,为半透明图片、伪元素等添加阴影效果,给任何非透明部分加阴影</li>
<li>hue-rotate(): 改变图整体色调</li>
<li>invert(): 反转图像颜色</li>
<li>opacity(): 改变图像透明度</li>
<li>sepla(): 将图像转为棕褐色</li>
</ul>
<h3 id="不规则投影"><a href="#不规则投影" class="headerlink" title="不规则投影"></a>不规则投影</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">filter</span>: <span class="built_in">drop-shadow</span>(<span class="number">3px</span> <span class="number">3px</span> <span class="number">3px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>));</span><br></pre></td></tr></table></figure>

<h3 id="染色"><a href="#染色" class="headerlink" title="染色"></a>染色</h3><ul>
<li>使用 sepia(1)降低饱和度的橙黄色效果，几乎所有的像素都收敛至 35-40.</li>
<li>使用 saturate(200%)滤镜来提高像素的饱和度。</li>
<li>使用 hut-rotate(295)滤镜改变主色调，比如想要主色调是 hsl(335, 100%, 50%),40 改变为 335,色相偏移 295 度，即 hue-rotate(295)</li>
</ul>
<h3 id="毛玻璃"><a href="#毛玻璃" class="headerlink" title="毛玻璃"></a>毛玻璃</h3><ul>
<li>对元素的伪元素进行处理，将其定位到元素的下层，将伪元素的背景与容器背景无缝重合，对伪元素进行模糊处理</li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-画多边形</title>
    <url>/2024/10/30/HTMLCSS/css-%E7%94%BB%E5%A4%9A%E8%BE%B9%E5%BD%A2/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="知识篇"><a href="#知识篇" class="headerlink" title="知识篇"></a>知识篇</h2><h3 id="clip-path-—-直接裁出图形，无需拼接元素实现图形"><a href="#clip-path-—-直接裁出图形，无需拼接元素实现图形" class="headerlink" title="clip-path — 直接裁出图形，无需拼接元素实现图形"></a>clip-path — 直接裁出图形，无需拼接元素实现图形</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>inset()</td>
<td>裁剪出一个矩形</td>
</tr>
<tr>
<td>circle()</td>
<td>裁剪出一个圆形</td>
</tr>
<tr>
<td>ellipse()</td>
<td>裁剪出一个椭圆</td>
</tr>
<tr>
<td>polygon()</td>
<td>裁剪出一个多边形</td>
</tr>
<tr>
<td>path</td>
<td>裁剪出一个任意形状</br>(使用 SVG 填充规则和一个 SVG 路径定义)</td>
</tr>
</tbody></table>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">			<span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span></span></span><br><span class="line"><span class="tag">		/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>多边形案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.line</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">164</span>, <span class="number">192</span>, <span class="number">245</span>);</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.leaf</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">152px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">10px</span> round <span class="number">152px</span> <span class="number">5px</span>);</span></span><br><span class="line"><span class="language-css">				<span class="attribute">line-height</span>: <span class="number">152px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: cadetblue;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.shanbei</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">152px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">10px</span> round <span class="number">20px</span> <span class="number">10px</span> <span class="number">150px</span>);</span></span><br><span class="line"><span class="language-css">				<span class="attribute">line-height</span>: <span class="number">152px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: cadetblue;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.roundjuxing</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">152px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">10px</span> <span class="number">20px</span> <span class="number">10px</span> <span class="number">30px</span> round <span class="number">20px</span>);</span></span><br><span class="line"><span class="language-css">				<span class="attribute">line-height</span>: <span class="number">152px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: cadetblue;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.circle1</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: <span class="number">#ffb700</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">margin-right</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">circle</span>(<span class="number">6rem</span> at right center);</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.circle2</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: <span class="number">#ffb700</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">margin-right</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">circle</span>(<span class="number">10%</span> at <span class="number">2rem</span> <span class="number">90%</span>);</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.circle3</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: <span class="number">#ffb700</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">margin-right</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">circle</span>(closest-side at <span class="number">50%</span> <span class="number">50%</span>);</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.circle4</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: <span class="number">#ffb700</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">margin-right</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">circle</span>(farthest-side at <span class="number">50%</span> <span class="number">50%</span>);</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.ellipse1</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: steelblue;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">ellipse</span>(<span class="number">4rem</span> <span class="number">50%</span> at right center);</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.ellipse2</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: steelblue;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">ellipse</span>(closest-side closest-side at <span class="number">50%</span> <span class="number">68%</span>);</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.ellipse3</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: steelblue;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">ellipse</span>(farthest-side farthest-side at <span class="number">50%</span> <span class="number">68%</span>);</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.polygon1</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">243</span>, <span class="number">117</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(</span></span><br><span class="line"><span class="language-css">					<span class="number">0%</span> <span class="number">0%</span>,</span></span><br><span class="line"><span class="language-css">					<span class="number">100%</span> <span class="number">0%</span>,</span></span><br><span class="line"><span class="language-css">					<span class="number">100%</span> <span class="number">75%</span>,</span></span><br><span class="line"><span class="language-css">					<span class="number">75%</span> <span class="number">75%</span>,</span></span><br><span class="line"><span class="language-css">					<span class="number">75%</span> <span class="number">100%</span>,</span></span><br><span class="line"><span class="language-css">					<span class="number">50%</span> <span class="number">75%</span>,</span></span><br><span class="line"><span class="language-css">					<span class="number">0%</span> <span class="number">75%</span></span></span><br><span class="line"><span class="language-css">				);</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">			<span class="selector-class">.path1</span> &#123;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">				<span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">243</span>, <span class="number">117</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-css">				<span class="attribute">clip-path</span>: <span class="built_in">path</span>(</span></span><br><span class="line"><span class="language-css">					<span class="string">&#x27;M 150 0 L 184 112 L 300 112 L 207 175 L 241 288 L 150 225 L 59 288 L 93 175 L 0 112 L 116 112 Z&#x27;</span></span></span><br><span class="line"><span class="language-css">				);</span></span><br><span class="line"><span class="language-css">			&#125;</span></span><br><span class="line"><span class="language-css">		</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">span</span>&gt;</span>inset<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;leaf&quot;</span>&gt;</span>叶子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;shanbei&quot;</span>&gt;</span>扇贝<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;roundjuxing&quot;</span>&gt;</span>圆角矩形<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">span</span>&gt;</span>circle<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle1&quot;</span>&gt;</span>方向值偏移<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle2&quot;</span>&gt;</span>数值偏移<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle3&quot;</span>&gt;</span>closest-side<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle4&quot;</span>&gt;</span>farthest-side<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">span</span>&gt;</span>ellipse<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ellipse1&quot;</span>&gt;</span>方向值偏移<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ellipse2&quot;</span>&gt;</span>closest-side<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ellipse3&quot;</span>&gt;</span>farthest-side<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">span</span>&gt;</span>polygon<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;polygon1&quot;</span>&gt;</span>对话框<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">span</span>&gt;</span>path<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;path1&quot;</span>&gt;</span>五角星<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="inset"><a href="#inset" class="headerlink" title="inset()"></a>inset()</h3><ul>
<li>一个参：整体<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">30px</span>);</span><br></pre></td></tr></table></figure></li>
<li>两个参：上 下<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">30px</span> <span class="number">50px</span>);</span><br></pre></td></tr></table></figure></li>
<li>三个参：上 左右 下<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">100px</span> <span class="number">30px</span> <span class="number">50px</span>);</span><br></pre></td></tr></table></figure></li>
<li>四个参：上 右 下 左<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">20px</span> <span class="number">89px</span> <span class="number">50px</span> <span class="number">40px</span>);</span><br></pre></td></tr></table></figure></li>
<li>round(将角变成弧线):<ul>
<li>注意：<span class="key_words">『round不能在第一位，round后面必须跟值，使用round不能输入负值』</span></li>
<li>叶子：整体 round 左上右下角 右上左下角<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">10px</span> round <span class="number">152px</span> <span class="number">5px</span>);</span><br></pre></td></tr></table></figure></li>
<li>扇形：整体 round 左上角 右上左下角 右下角<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">10px</span> round <span class="number">20px</span> <span class="number">10px</span> <span class="number">150px</span>);</span><br></pre></td></tr></table></figure></li>
<li>圆角矩形：前面四个就是裁出矩形 round 四个角的弧线大小<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">10px</span> <span class="number">20px</span> <span class="number">10px</span> <span class="number">30px</span> round <span class="number">20px</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="circle"><a href="#circle" class="headerlink" title="circle()"></a>circle()</h3><ul>
<li>参数一：可以是数值，也可以是 closest-side 和 farthest-side</li>
<li>参数二：at 关键字，控制圆心位置，默认在中间，有 x 轴 y 轴 ，后面可以是数值也可以是方向值</li>
<li>closest-side 与 farthest-side 区别<ul>
<li>使用 closest-side 时，裁剪出的圆会尽量小，以确保它不会超出矩形的边界。</li>
<li>使用 farthest-side 时，裁剪出的圆会尽量大，以确保它能够覆盖到矩形的边界</li>
</ul>
</li>
</ul>
<h3 id="ellipse"><a href="#ellipse" class="headerlink" title="ellipse()"></a>ellipse()</h3><ul>
<li>参数一：左右</li>
<li>参数二：上下</li>
<li>其它参数： at 关键字 控制圆心位置，默认中心</li>
<li>closest-side 与 farthest-side 区别<ul>
<li>跟 circle 一样</li>
</ul>
</li>
</ul>
<h3 id="polygon"><a href="#polygon" class="headerlink" title="polygon()"></a>polygon()</h3><ul>
<li>以逗号分隔，格式 x1 y1 一组，最少三组，每一组都是以原物体的左上角为原点，按照顺序依次连接</li>
<li>借助 <a href="https://bennettfeely.com/clippy/">https://bennettfeely.com/clippy/</a> 来拖拽出想要的图形，然后按顺序把 x，y 写进去。</li>
</ul>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><ul>
<li>接收的 svg 路径，可以通过 Gpt 生成一段 svg 五角星的路径</li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>多边形</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS动画库-GSAP</title>
    <url>/2024/10/30/HTMLCSS/css%E5%8A%A8%E7%94%BB%E5%BA%93-GSAP/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>项目中使用 gsap 的插件<ul>
<li>安装 gsap：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> install gsap</span><br></pre></td></tr></table></figure></li>
<li>在页面中引入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;插件名&#125; <span class="keyword">from</span> <span class="string">&quot;gsap/all&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>在页面中注册：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gsap.<span class="title function_">registerPlugin</span>(插件名)</span><br></pre></td></tr></table></figure></li>
<li>具体按文档，不是插件可以直接调用</li>
</ul>
</li>
</ul>
<h2 id="Draggable"><a href="#Draggable" class="headerlink" title="Draggable"></a>Draggable</h2><h3 id="问题归纳"><a href="#问题归纳" class="headerlink" title="问题归纳"></a>问题归纳</h3><ul>
<li>Q1: 使用”-&#x3D;”时怎么控制到某一程度不在减少</li>
<li>A1: “-&#x3D;”, “+&#x3D;”用来控制变量缓慢增加和减少，遇到如缩放到一定程度不想继续缩小，可以定制一个变量，在回调中控制变量的大小</li>
<li>示例片段：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span> <span class="comment">// 空值缩小时到0.3后不再继续缩小</span></span><br><span class="line"><span class="title class_">Observer</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">	<span class="attr">target</span>: <span class="string">&#x27;.octangonal&#x27;</span>,</span><br><span class="line">	<span class="attr">type</span>: <span class="string">&#x27;wheel,pointer&#x27;</span>,</span><br><span class="line">	<span class="attr">wheelSpeed</span>: <span class="number">0.5</span>,</span><br><span class="line">	<span class="attr">onWheel</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (res.<span class="property">deltaY</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			gsap.<span class="title function_">from</span>(<span class="string">&#x27;.octangonal&#x27;</span>, &#123;</span><br><span class="line">				<span class="attr">scale</span>: num,</span><br><span class="line">				<span class="title function_">onStart</span>(<span class="params"></span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (num &gt;= <span class="number">0.3</span>) &#123;</span><br><span class="line">						num -= <span class="number">0.1</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			gsap.<span class="title function_">from</span>(<span class="string">&#x27;.octangonal&#x27;</span>, &#123;</span><br><span class="line">				<span class="attr">scale</span>: <span class="string">&#x27;+=0.1&#x27;</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>动画</tag>
        <tag>gsap</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS样式-基本图形篇 + 步骤条实现</title>
    <url>/2024/10/30/HTMLCSS/css%E6%A0%B7%E5%BC%8F-%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%AF%87/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="自定义组件篇-—-步骤条样式的实现"><a href="#自定义组件篇-—-步骤条样式的实现" class="headerlink" title="自定义组件篇 — 步骤条样式的实现"></a>自定义组件篇 — 步骤条样式的实现</h2><blockquote>
<p>该方法使用的是微信小程序，并且数据是动态改变的</p>
</blockquote>
<h3 id="垂直布局："><a href="#垂直布局：" class="headerlink" title="垂直布局："></a>垂直布局：</h3><ul>
<li>难点:icon 的中间线和层级问题：使用伪类和绝对定位</li>
</ul>
<ol>
<li>先完成基础布局</li>
<li>看 icon 所在位置，给 icon 的外层加一个容器，这个容器主要是用来定位的</li>
<li>给 icon 添加样式，固定宽高然后 overflow 设置为可见，并添加伪类，display 设置为 inline-block，给个宽高</li>
<li>然后此时页面中可以看到该条线条，调整居中</li>
<li>最后通过动态判断列表是不是最后一个元素来决定显示那一条 icon 或者通过:not(:last-child)::after 来设置中间线</li>
</ol>
<ul>
<li>方案一示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*wxml*/</span></span><br><span class="line">  &lt;view <span class="keyword">class</span>=<span class="string">&quot;plan-box-step&quot;</span> <span class="attr">wx</span>:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;servicePlanList&#125;&#125;&quot;</span> <span class="attr">wx</span>:key=<span class="string">&quot;index&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>/&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;plan-box-step-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;!item.isLast&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;plan-box-step-image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;item.icon&#125;&#125;&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;aspectFit&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">wx:else</span> <span class="attr">style</span>=<span class="string">&quot;width: 40rpx; height: 40rpx;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;item.icon&#125;&#125;&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;aspectFit&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>/&gt;</span></span></span><br><span class="line">  &lt;/view&gt;</span><br><span class="line"><span class="comment">/*wxss*/</span></span><br><span class="line">.<span class="property">plan</span>-box-step &#123;</span><br><span class="line">  padding-<span class="attr">right</span>: 40rpx;</span><br><span class="line">  <span class="attr">display</span>: flex;</span><br><span class="line">  <span class="attr">height</span>: 120rpx;</span><br><span class="line">  align-<span class="attr">items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">plan</span>-box-step-icon &#123;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line">  <span class="attr">display</span>: flex;</span><br><span class="line">  align-<span class="attr">items</span>: center;</span><br><span class="line">  <span class="attr">height</span>: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">plan</span>-box-step-image &#123;</span><br><span class="line">  <span class="attr">height</span>: 40rpx;</span><br><span class="line">  <span class="attr">width</span>: 40rpx;</span><br><span class="line">  <span class="attr">overflow</span>: visible !important;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">plan</span>-box-step-<span class="attr">image</span>::after &#123;</span><br><span class="line">  <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attr">display</span>: inline-block;</span><br><span class="line">  <span class="attr">width</span>: 4rpx;</span><br><span class="line">  <span class="attr">height</span>: 80rpx;</span><br><span class="line">  background-<span class="attr">color</span>: #<span class="variable constant_">F5F5F5</span>;</span><br><span class="line">  <span class="attr">position</span>: absolute;</span><br><span class="line">  <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">  <span class="attr">transform</span>: <span class="title function_">translateY</span>(<span class="number">0</span>%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方案二示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*wxml*/</span></span><br><span class="line">&lt;view <span class="attr">wx</span>:<span class="keyword">if</span>=<span class="string">&quot;&#123;&#123;horizon&#125;&#125;&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;step-1&quot;</span> <span class="attr">wx</span>:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> <span class="attr">wx</span>:key=<span class="string">&quot;index&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;item.icon&#125;&#125;&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;aspectFit&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&lt;/view&gt;</span><br><span class="line"><span class="comment">/*scss*/</span></span><br><span class="line"><span class="comment">// 缺点：需要手动调整中间线与y轴的距离</span></span><br><span class="line">  .<span class="property">step</span>-<span class="number">1</span> &#123;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    <span class="attr">height</span>: 120rpx;</span><br><span class="line">    align-<span class="attr">items</span>: center;</span><br><span class="line">    .<span class="property">icon</span> &#123;</span><br><span class="line">      <span class="attr">display</span>: flex;</span><br><span class="line">      align-<span class="attr">items</span>: center;</span><br><span class="line">      <span class="attr">height</span>: <span class="number">100</span>%;</span><br><span class="line">      .<span class="property">image</span> &#123;</span><br><span class="line">        <span class="attr">height</span>: 40rpx;</span><br><span class="line">        <span class="attr">width</span>: 40rpx;</span><br><span class="line">        <span class="attr">margin</span>:<span class="number">0</span> 10rpx;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  .<span class="property">step</span>-<span class="number">1</span>:<span class="title function_">not</span>(:last-child)::after &#123;</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attr">width</span>: 2rpx;</span><br><span class="line">    background-<span class="attr">color</span>: rebeccapurple;</span><br><span class="line">    <span class="attr">height</span>: 80rpx;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translate</span>(-30rpx,60rpx); <span class="comment">// 调整与X轴的距离</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="横向布局"><a href="#横向布局" class="headerlink" title="横向布局"></a>横向布局</h3><ul>
<li>难点：元素的伪类层级太高会遮住子元素</li>
</ul>
<ol>
<li>将文本和 icon 或中间的原点放在一个容器中，然后对这个公共的容器进行操作</li>
<li>通过:first-child 和:last-child 对容器前后的元素进行对其操作</li>
<li>设置公共容器的 position:relative;</li>
<li>给 icon 添加一个::after 伪类，绝对定位，宽度 100%</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*wxml*/</span></span><br><span class="line">&lt;view <span class="keyword">class</span>=<span class="string">&quot;step-2&quot;</span> <span class="attr">wx</span>:<span class="keyword">else</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;top&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;dot&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;item.icon&#125;&#125;&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;bottom&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br><span class="line">&lt;/view&gt;</span><br><span class="line"><span class="comment">/*scss*/</span></span><br><span class="line">.<span class="property">step</span>-<span class="number">2</span> &#123;</span><br><span class="line">  <span class="attr">display</span>: flex;</span><br><span class="line">  transform-<span class="attr">style</span>: preserve-3d;  <span class="comment">// 使伪元素的层级在子元素下方的关键点一</span></span><br><span class="line">  .<span class="property">box</span> &#123;</span><br><span class="line">    <span class="attr">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    flex-<span class="attr">direction</span>: column;</span><br><span class="line">    <span class="attr">position</span>: relative;</span><br><span class="line">    overflow-<span class="attr">x</span>: hidden;</span><br><span class="line">    .<span class="property">dot</span> &#123;</span><br><span class="line">      <span class="attr">width</span>: 40rpx;</span><br><span class="line">      <span class="attr">height</span>: 40rpx;</span><br><span class="line">      border-<span class="attr">radius</span>: 40rpx;</span><br><span class="line">      background-<span class="attr">color</span>: <span class="title function_">rgb</span>(<span class="number">207</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  .<span class="property">box</span>:<span class="title function_">not</span>(:last-child)::after &#123; <span class="comment">// 伪元素选择器：选择给除最后一个元素添加:after伪类</span></span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attr">border</span>: 2rpx dotted <span class="title function_">rgb</span>(<span class="number">43</span>, <span class="number">158</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>%;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translateZ</span>(-1px);  <span class="comment">//  使伪元素的层级在子元素下方的关键点二</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="checkbox-样式修改问题"><a href="#checkbox-样式修改问题" class="headerlink" title="checkbox 样式修改问题"></a>checkbox 样式修改问题</h2><blockquote>
<p>微信小程序 checkbox 组件的样式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*checkbox 选项框大小  */</span></span><br><span class="line">checkbox .<span class="property">wx</span>-checkbox-input &#123;</span><br><span class="line">  <span class="attr">width</span>: 0rpx;</span><br><span class="line">  <span class="attr">height</span>: 0rpx;</span><br><span class="line">  <span class="attr">background</span>:transparent;</span><br><span class="line">  <span class="attr">border</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*checkbox选中后样式  */</span></span><br><span class="line">checkbox .<span class="property">wx</span>-checkbox-input.<span class="property">wx</span>-checkbox-input-checked &#123;</span><br><span class="line">  <span class="attr">background</span>:transparent;</span><br><span class="line">  <span class="attr">border</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*checkbox选中后图标样式  */</span></span><br><span class="line">checkbox .<span class="property">wx</span>-checkbox-input.<span class="property">wx</span>-checkbox-input-<span class="attr">checked</span>::before &#123;</span><br><span class="line">  <span class="attr">width</span>: 0rpx;</span><br><span class="line">  <span class="attr">height</span>: 0rpx;</span><br><span class="line">  font-<span class="attr">size</span>: 0rpx;</span><br><span class="line">  <span class="attr">color</span>: transparent;</span><br><span class="line">  <span class="attr">background</span>: transparen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动画篇–字体图标"><a href="#动画篇–字体图标" class="headerlink" title="动画篇–字体图标"></a>动画篇–字体图标</h2><ol>
<li>首先在需要添加动画的地方添加以下属性<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation-duration</span> // 动画持续时间</span><br><span class="line"><span class="attribute">animation-name</span> // 动画名称</span><br><span class="line"><span class="attribute">animation-iteration-count</span> // 动画次数</span><br></pre></td></tr></table></figure></li>
<li>使用@keyframes 添加动画效果</li>
<li>字体图标如果想要缩放的话可以使用 transform: scale()来缩放大小</li>
<li>字体图标无法使用弹性布局的居中问题–关键在于 diaply:inline-block;<ul>
<li>可以考虑把 display 改为 block</li>
</ul>
</li>
</ol>
<h2 id="图形篇–四分之一圆"><a href="#图形篇–四分之一圆" class="headerlink" title="图形篇–四分之一圆"></a>图形篇–四分之一圆</h2><ol>
<li>需要给定宽高</li>
<li>使用 border-top-left-radius：250rpx;的方式来实现四分之一圆，可调整弧线位置</li>
<li>位置可以通过定位实现</li>
</ol>
<h2 id="图形篇–箭头"><a href="#图形篇–箭头" class="headerlink" title="图形篇–箭头"></a>图形篇–箭头</h2><blockquote>
<p>以 React+微信小程序的案例为模板</p>
</blockquote>
<ol>
<li>准备一个空的容器</li>
<li>给这个容器一个宽高(一个线条)</li>
<li>然后给这个容器添加伪元素::before</li>
<li>伪元素中宽高为 0，border 可以按照线条给出合适的宽高，然后整体设置透明</li>
<li>想要哪个方向的箭头就给哪个方向的 border 添加宽高和颜色即可</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*wxml*/</span></span><br><span class="line">&lt;<span class="title class_">View</span> className=<span class="string">&#x27;arrow&#x27;</span>/&gt;</span><br><span class="line"><span class="comment">/*scss*/</span></span><br><span class="line">.<span class="property">arrow</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: relative;</span><br><span class="line">  <span class="attr">width</span>: 50rpx;</span><br><span class="line">  <span class="attr">height</span>: 3rpx;</span><br><span class="line">  background-<span class="attr">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">arrow</span>::before &#123;</span><br><span class="line">  <span class="attr">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attr">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attr">position</span>: absolute;</span><br><span class="line">  <span class="attr">left</span>: 40rpx;</span><br><span class="line">  <span class="attr">top</span>:-10rpx;</span><br><span class="line">  <span class="attr">border</span>: 10rpx solid transparent;</span><br><span class="line">  border-<span class="attr">left</span>: 10rpx solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="图形篇-—-等腰三角形"><a href="#图形篇-—-等腰三角形" class="headerlink" title="图形篇 — 等腰三角形"></a>图形篇 — 等腰三角形</h2><ul>
<li>宽高为 0</li>
<li>正方形的哪条线占满，border 的哪边就填充颜色，并且它对应的左右两边设置透明</li>
<li>切忌一共只需要设置三边</li>
<li>如：正方形左边占满，则上下两边要设置透明，左边要有颜色，border 的长度保持一样，实体</li>
</ul>
<h2 id="图形篇-—-直角三角形"><a href="#图形篇-—-直角三角形" class="headerlink" title="图形篇 — 直角三角形"></a>图形篇 — 直角三角形</h2><ul>
<li>宽高为 0</li>
<li>观察想要的直角三角形在正方形的位置，垂直方向填充颜色，水平方向，相反位置设置透明</li>
<li>切忌一共只需要设置两边</li>
<li>如：直角三角形位于正方形的左下，则下边填充颜色，右边透明，border 长度一样，实体</li>
</ul>
<h2 id="图形篇-—-梯形"><a href="#图形篇-—-梯形" class="headerlink" title="图形篇 — 梯形"></a>图形篇 — 梯形</h2><ul>
<li>高为 0，宽固定</li>
<li>border 的底边与宽度一样，填充颜色，左右长度为宽的一半，设置透明</li>
</ul>
<h2 id="图形篇-—-平行四边形"><a href="#图形篇-—-平行四边形" class="headerlink" title="图形篇 — 平行四边形"></a>图形篇 — 平行四边形</h2><ul>
<li>矩形 + 倾斜</li>
<li>transform:skew(20deg)倾斜</li>
</ul>
<h2 id="图形篇-—-六角形"><a href="#图形篇-—-六角形" class="headerlink" title="图形篇 — 六角形"></a>图形篇 — 六角形</h2><ul>
<li>两个三角形叠加</li>
<li>用伪元素 + 定位实现</li>
</ul>
<h2 id="图形篇-—-五角星"><a href="#图形篇-—-五角星" class="headerlink" title="图形篇 — 五角星"></a>图形篇 — 五角星</h2><ul>
<li>三个一样大小的三角型旋转可得或者三个不一样的三角形叠加</li>
<li>用伪元素 + 定位实现 + transform:rotate()</li>
</ul>
<h2 id="图形篇-—-爱心"><a href="#图形篇-—-爱心" class="headerlink" title="图形篇 — 爱心"></a>图形篇 — 爱心</h2><ul>
<li>一个三角形+ 两个圆</li>
<li>用伪元素 + 定位实现</li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>案例</tag>
        <tag>步骤条</tag>
        <tag>checkbox样式修改</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS样式-特效集</title>
    <url>/2024/10/30/HTMLCSS/css%E6%A0%B7%E5%BC%8F-%E7%89%B9%E6%95%88%E9%9B%86/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="知识篇"><a href="#知识篇" class="headerlink" title="知识篇"></a>知识篇</h2><h3 id="滤镜的三种做法："><a href="#滤镜的三种做法：" class="headerlink" title="滤镜的三种做法："></a>滤镜的三种做法：</h3><ol>
<li>canvas</li>
<li>css 功能较弱</li>
<li>svg (<a href="https://yoksel.github.io/svg-filters/#/">SVG Filters 模板效果</a>)</li>
</ol>
<h2 id="特效篇"><a href="#特效篇" class="headerlink" title="特效篇"></a>特效篇</h2><h3 id="故障波纹动效："><a href="#故障波纹动效：" class="headerlink" title="故障波纹动效："></a>故障波纹动效：</h3><ul>
<li>使用 svg 滤镜中的两种滤镜<ul>
<li>湍流滤镜 — 用到 Perlin Noise 算法(<span class="desc">如连绵起伏的山峰，凹凸不平的地面，大理石的纹理，纸张的褶皱</span>)<ul>
<li>feTurbulence 关键参数<ul>
<li>type: turbulence(尖锐) | fractalNoise(柔和) — 此处选 turbulence</li>
<li>baseFrequency：横向 纵向 (0-1 值越小，噪声频率越小) — 此处 0 0.4</li>
</ul>
</li>
</ul>
</li>
<li>置换滤镜<ul>
<li>feDisplacementMap<ul>
<li>scale: 值越大，受噪声的影响越大 &#x2F;&#x2F; 40</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>使用上面的 svg filter 模板效果网站调整好后，复制生成的代码</li>
<li>回到页面中使用<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">defs</span>&gt;</span>黏贴代码<span class="tag">&lt;/<span class="name">defs</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>本质只是借用 svg 效果，所以隐藏不显示，使用 filter 的 id，此 id 可以自定义</li>
</ul>
</li>
<li>在向要使用的元素或页面中的 class 添加 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">filter</span>: <span class="built_in">url</span>(<span class="string">#id</span>)</span><br></pre></td></tr></table></figure></li>
<li>动画效果，关键在baseFrequency值的改变，使用 GSAP 库来修改</li>
<li>主要使用 GSAP 的时间轴来实现，获取 feTurbulence 选择器，在 timeline 的回调函数中设置改变的 key 和 value</li>
<li>并定义一个初始值，通过调用 timeline 来控制值的变化和过渡时间</li>
<li>timeline 中先暂停动画，然后获取图片的选择器，</li>
<li>判断图片是否完成加载 complete，加载完就调用 play 否则就监听 load 事件，等待完成播放</li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>filter</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS预处理器-less语法</title>
    <url>/2024/10/30/HTMLCSS/css%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-less/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>css 的预处理语言</li>
<li>css 的增强版</li>
<li>新特性：对变量的支持、对 mixin 的支持等</li>
<li>语法大体上和 css 一致，但是增添了许多对 css 的扩展</li>
<li>less 转 css 才能在浏览器上执行</li>
<li>单行注释的内容不会被解析到 css 中</li>
<li>&amp;：表示外层的父元素</li>
<li>:extend(): 对当前选择器扩展指定选择器的样式（选择器分组）</li>
<li>mixin 混合: 在<span class="key_words">『类选择器后边添加()，实际上就创建了一个mixins』</span></li>
<li>@import：用来引入到其它 less 文件到当前 less 文件<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;syntax2.less&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><span class="key_words">『所有的数值都可以直接进行运算』</span><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">100px</span> + <span class="number">100px</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>定义：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">$变量名：<span class="selector-tag">xxx</span>;</span><br></pre></td></tr></table></figure></li>
<li>使用：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">$变量名</span><br></pre></td></tr></table></figure>
<ul>
<li>作为类名，或者一部分值使用时必须以<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">$&#123;变量名&#125;</span><br></pre></td></tr></table></figure></li>
<li>示例：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">.$&#123;<span class="selector-tag">c</span>&#125;&#123; <span class="attribute">background-image</span>: url(<span class="string">&quot;$&#123;c&#125;/1.png&quot;</span>);&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>发生<span class="key_words">『重名时，会优先使用近的』</span></li>
<li><span class="key_words">『声明前可以使用』</span></li>
<li>旧版语法：@变量名</li>
</ul>
<h3 id="混合函数-相当于形参实参混合"><a href="#混合函数-相当于形参实参混合" class="headerlink" title="混合函数 相当于形参实参混合"></a>混合函数 相当于形参实参混合</h3><ul>
<li>在混合函数中可以直接设置变量</li>
<li>调用混合函数，按顺序传递参数</li>
<li>示例：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.test</span>(<span class="variable">@w</span>:<span class="number">100px</span>,<span class="variable">@h</span>:<span class="number">200px</span>,<span class="variable">@bg-color</span>:red)&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="variable">@w</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="variable">@h</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">@bg-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="selector-class">.test</span>(<span class="number">200px</span>,<span class="number">300px</span>,<span class="number">#bfa</span>); <span class="comment">// 调用</span></span><br><span class="line">	<span class="selector-class">.test</span>(<span class="number">300px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数工具"><a href="#函数工具" class="headerlink" title="函数工具"></a><a href="https://lesscss.org/functions/#functions-overview">函数工具</a></h2><h3 id="逻辑函数"><a href="#逻辑函数" class="headerlink" title="逻辑函数"></a>逻辑函数</h3><h4 id="if-根据条件返回两个值之一"><a href="#if-根据条件返回两个值之一" class="headerlink" title="if: 根据条件返回两个值之一"></a>if: 根据条件返回两个值之一</h4><ul>
<li>相关布尔表达式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and === &amp;&amp;</span><br><span class="line">or === ||</span><br><span class="line">not === !</span><br></pre></td></tr></table></figure></li>
<li>参数<ul>
<li>condition：布尔表达式, less3.6 之前要加()</li>
<li>value1：为 true，返回</li>
<li>value2：为 false，返回</li>
</ul>
</li>
<li>示例：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@some:</span> foo</span><br><span class="line">div &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="built_in">if</span>((<span class="number">2</span>&gt;<span class="number">1</span>), <span class="number">0</span>,<span class="number">3px</span>) <span class="comment">// 假设为真，0</span></span><br><span class="line">	<span class="attribute">color</span>: <span class="built_in">if</span>((<span class="built_in">iscolor</span>(<span class="variable">@some</span>)), <span class="variable">@some</span>,black) <span class="comment">// 假设为假， black</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="boolean-计算结果为-true-或-false-一般与-if-搭配使用"><a href="#boolean-计算结果为-true-或-false-一般与-if-搭配使用" class="headerlink" title="boolean: 计算结果为 true 或 false, 一般与 if 搭配使用"></a>boolean: 计算结果为 true 或 false, 一般与 if 搭配使用</h4><ul>
<li>参数：<ul>
<li>condition — 布尔表达式</li>
</ul>
</li>
<li>示例<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@bg:</span> black</span><br><span class="line"><span class="variable">@bg-light</span>: <span class="built_in">boolean</span>(<span class="built_in">luma</span>(<span class="variable">@bg</span>) &gt; <span class="number">50%</span>)</span><br><span class="line">div &#123;</span><br><span class="line">	<span class="attribute">background</span>: <span class="variable">@bg</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="built_in">if</span>(<span class="variable">@bg-light</span>, black, white)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul>
<li>escape(<span class="desc">将 URL 编码应用于在输入字符串中找到的特殊字符</span>)<ul>
<li>最常见的编码字符：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\&lt;space\&gt;、#、^、( 、)、&#123; 、&#125;、|、:、&gt;、&lt;、;、[、]、=</span><br></pre></td></tr></table></figure></li>
<li>未编码的字符：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">,、/、?、@、&amp;、+、&#x27;、~、!、$</span><br></pre></td></tr></table></figure></li>
<li>参数：要转义的字符串</li>
<li>返回：不带引号的转义内容</li>
<li>示例: <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">escape</span>(<span class="string">&#x27;a=1&#x27;</span>) <span class="comment">// a%3D1, 将 = 转义为 URL 编码,非字符串输出 undefined</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>e(<span class="desc">字符串转义</span>)<ul>
<li>参数：要转义的字符串</li>
<li>返回：不带引号的转义的字符串</li>
<li>示例：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@mscode:</span> <span class="string">&quot;ms:alwaysHasItsOwnSyntax.For.Stuff()&quot;</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">e</span>(<span class="variable">@mscode</span>);</span><br><span class="line">输出： ms:alwaysHasItsOwnSyntax.For.Stuff()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>%(<span class="desc">设置字符串格式</span>)<ul>
<li>参数：<ul>
<li>带有占位符的字符串</li>
<li>用于替换占位符的值</li>
</ul>
</li>
<li>返回值：格式化的字符串</li>
<li>占位值：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%s、 %S、 %d、 %D、 %a、%A、 %%</span><br></pre></td></tr></table></figure>
<ul>
<li>d, D, a, A — 可以替换为任何类型的参数，与字符串结合，则将使用整个字符串包括其引号，不会转义</li>
<li>s, S — 可以替换为任何表达式，<code>与字符串结合</code>，则使用字符串值，<code>省略引号</code></li>
<li>注：小写占位符保留特殊字符，大写会转义特殊字符，除<code>()&#39;~!空格</code>编码为<code>%20</code></li>
</ul>
</li>
</ul>
</li>
<li>replace(<span class="desc">替换字符串中的文本</span>)<ul>
<li>参数：<ul>
<li>string：要搜索和替换的字符串</li>
<li>pattern： 要搜索的字符串或正则表达式模式</li>
<li>replacement：要用来替换匹配模式的字符串</li>
<li>flags：（可选）正则表达式标志</li>
</ul>
</li>
<li>返回：带有替换值的字符串</li>
<li>示例：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">replace</span>(<span class="string">&#x27;Hello, Mars?&#x27;</span>, <span class="string">&#x27;Mars?&#x27;</span>, <span class="string">&#x27;Earth!&#x27;</span>) <span class="comment">// Hello, Earth!</span></span><br><span class="line"><span class="selector-tag">replace</span>(<span class="string">&#x27;One + one = 4&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;gi&#x27;</span>) <span class="comment">// 全局匹配忽略大小写，2 + 2 = 4</span></span><br><span class="line"><span class="selector-tag">replace</span>(<span class="string">&#x27;This is a string.&#x27;</span>, <span class="string">&#x27;(string).$&#x27;</span>, <span class="string">&#x27;new $1.&#x27;</span>) <span class="comment">// 匹配在第一个匹配模式的字符串前添加new &#x27;This is a new string.&#x27;;</span></span><br><span class="line"><span class="selector-tag">replace</span>(<span class="string">~&#x27;bar-1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>) <span class="comment">// bar-2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a>列表函数</h3><ul>
<li>length: 返回列表的长度<ul>
<li>参数：list：逗号或空格分割的值列表</li>
</ul>
</li>
<li>extract: 返回列表中指定位置的值<ul>
<li>参数：<ul>
<li>list：逗号或空格分割的值列表</li>
<li>index：number，指定要返回的列表元素的位置，从 1 开始数</li>
</ul>
</li>
</ul>
</li>
<li>range: 生成一系列值的列表<ul>
<li>参数：<ul>
<li>start：可选，起始值，默认 1</li>
<li>end：结束值</li>
<li>step：可选，要递增的间隔</li>
</ul>
</li>
</ul>
</li>
<li>each: 将列表中的元素绑定给规则及中的每一项<ul>
<li>参数：<ul>
<li>list：逗号或空格分割的值列表</li>
<li>rules：匿名规则集&#x2F;混合</li>
</ul>
</li>
<li>示例：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@list:</span> apple, pear, conconut, orange</span><br><span class="line"><span class="variable">@selectors</span>: blue,green,red; <span class="comment">// 如果是结构化的对象还有@&#123;key&#125;,@&#123;index&#125;</span></span><br><span class="line">n: length(@list) // 4</span><br><span class="line">length(1px solid pink) // 3</span><br><span class="line">value: extract(@list, 3) // cocunt</span><br><span class="line">value1：range(4) // value1: 1,2,3,4</span><br><span class="line">each(@selectors,&#123;</span><br><span class="line">	.sel-@&#123;value&#125; &#123;</span><br><span class="line">		a:b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"># 在<span class="selector-tag">each</span>()中设置变量名称</span><br><span class="line"><span class="selector-class">.set-2</span>() &#123;</span><br><span class="line">	one:blue</span><br><span class="line">	two:green</span><br><span class="line">	three:red</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.set-2</span> &#123;</span><br><span class="line">	<span class="selector-tag">each</span>(.<span class="built_in">set-2</span>(), .(<span class="variable">@v</span>,<span class="variable">@k</span>,<span class="variable">@i</span>)&#123;</span><br><span class="line">		<span class="variable">@&#123;k&#125;</span><span class="selector-tag">-</span><span class="variable">@&#123;i&#125;</span>:@<span class="selector-tag">v</span> <span class="comment">// each将.set-2()里面的值按顺序赋值绑定给@v,@k,@i</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 将<span class="selector-tag">each</span>与<span class="selector-tag">range</span>结合使用创建循环</span><br><span class="line"><span class="selector-tag">each</span>(<span class="built_in">range</span>(<span class="number">4</span>), &#123;</span><br><span class="line">	<span class="selector-class">.col-</span><span class="variable">@&#123;value&#125;</span> &#123;</span><br><span class="line">		<span class="attribute">height</span>: (<span class="variable">@value</span> * <span class="number">50px</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul>
<li>ceil: 向上取整</li>
<li>floor: 向下取整</li>
<li>percentage: 将浮点数转换为百分比字符串</li>
<li>round: 四舍五入<ul>
<li>参数：<ul>
<li>number：浮点数</li>
<li>decimalPlaces：可选，要舍入到的小数位数，默认值 0</li>
</ul>
</li>
<li>返回：number</li>
<li>示例：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">round</span>(<span class="number">1.67</span>,<span class="number">1</span>) <span class="comment">// 1.7</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>sqrt: 计算数字平方根，单位不变</li>
<li>abs: 计算数值的绝对值，单位不变</li>
<li>pi: 返回 Π</li>
<li>pow: 返回参数的幂，幂为第二参数</li>
<li>min: 返回一个或多个值中的最小值</li>
<li>max: 返回一个或多个值中的最大值</li>
</ul>
<h3 id="类型函数"><a href="#类型函数" class="headerlink" title="类型函数"></a>类型函数</h3><ul>
<li>isnumber: 判断数值是否为数字，返回 true or false</li>
<li>isstring: 判断数值是否为字符串，返回 true or false</li>
<li>iscolor: 判断数值是否为颜色值，返回 true or false</li>
<li>iskeyword: 判断值是否为 keyword，返回 true or false</li>
<li>isurl: 判断值是否为 url()，返回 true or false</li>
<li>isunit: 判断值是否为指定单位的数字，返回 true or false<ul>
<li>参数：<ul>
<li>value：要评估的值</li>
<li>unit：要测试的单位标识符（可选）</li>
</ul>
</li>
<li>示例：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">isunit</span>(<span class="number">7.8%</span>, px) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="杂项函数"><a href="#杂项函数" class="headerlink" title="杂项函数"></a>杂项函数</h3><ul>
<li>image-size<ul>
<li>从文件中获取图像大小,目前仅在节点环境中可用。</li>
<li>示例：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">image</span><span class="selector-tag">-size</span>(<span class="string">&quot;file.png&quot;</span>) <span class="comment">// 10px 10px</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>image-width<ul>
<li>从文件中获取图像宽度,目前仅在节点环境中可用。</li>
</ul>
</li>
<li>image-height<ul>
<li>从文件中获取图像高度,目前仅在节点环境中可用。</li>
</ul>
</li>
<li>convert<ul>
<li>转换单位,只转换兼容的单位，单位不兼容返回第一个参数</li>
<li>参数：<ul>
<li>带单位的数字</li>
<li>单位</li>
</ul>
</li>
<li>示例：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">convert</span>(<span class="number">9s</span>,<span class="string">&#x27;ms&#x27;</span>) <span class="comment">// 9000</span></span><br></pre></td></tr></table></figure></li>
<li>兼容的设备组：<ul>
<li>长度：m、cm、mm、in、pt、pc</li>
<li>时间：s、ms</li>
<li>角度：rad、deg、grad、turn</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="色彩操作功能"><a href="#色彩操作功能" class="headerlink" title="色彩操作功能"></a>色彩操作功能</h3><ul>
<li>fadein<ul>
<li>降低颜色的透明度（或增加不透明度），使其更加不透明</li>
</ul>
</li>
<li>fadeout<ul>
<li>增加颜色的透明度（或降低不透明度），使其不那么不透明。</li>
<li>参数：<ul>
<li>color：颜色对象</li>
<li>amount：百分比 0-100%</li>
<li>method：可选，设置为 relative 来调整相对于当前值</li>
</ul>
</li>
</ul>
</li>
<li>mix<ul>
<li>将不同比例的颜色混合在一起</li>
<li>参数<ul>
<li>color1：颜色对象</li>
<li>color2：颜色对象</li>
<li>weight：可选，两种颜色之间的百分比平衡点，默认为 50%</li>
</ul>
</li>
</ul>
</li>
<li>shade<ul>
<li>以可变比例将颜色与黑色混合</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>css预处理器</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title>Html-弹性布局（Flex）</title>
    <url>/2024/10/30/HTMLCSS/html-Flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>主轴：在弹性布局中，我们会通过属性规定水平&#x2F;垂直方向为主轴</li>
<li>交叉轴：与主轴垂直的另一方向，称为交叉轴</li>
</ul>
<h2 id="flex-direction：控制弹性布局中元素的方向"><a href="#flex-direction：控制弹性布局中元素的方向" class="headerlink" title="flex-direction：控制弹性布局中元素的方向"></a>flex-direction：控制弹性布局中元素的方向</h2><ul>
<li>row：行(默认)</li>
<li>row-reverse：行反转</li>
<li>column：列</li>
<li>column-reverse：列反转</li>
</ul>
<h2 id="flex-wrap：元素是否换行"><a href="#flex-wrap：元素是否换行" class="headerlink" title="flex-wrap：元素是否换行"></a>flex-wrap：元素是否换行</h2><ul>
<li>nowrap：不换行(默认)</li>
<li>wrap：换行</li>
</ul>
<h3 id="以上简写：flex-flow-flex-direction-flex-wrap"><a href="#以上简写：flex-flow-flex-direction-flex-wrap" class="headerlink" title="以上简写：flex-flow: flex-direction flex-wrap;"></a>以上简写：flex-flow: flex-direction flex-wrap;</h3><h2 id="元素间的对齐和空间分配"><a href="#元素间的对齐和空间分配" class="headerlink" title="元素间的对齐和空间分配"></a>元素间的对齐和空间分配</h2><h3 id="align-items-—-y-轴，垂直方向"><a href="#align-items-—-y-轴，垂直方向" class="headerlink" title="align-items — y 轴，垂直方向"></a>align-items — y 轴，垂直方向</h3><ul>
<li>stretch：填充垂直方向的空间（默认）</li>
<li>flex-start：贴着容器顶部</li>
<li>flex-end：贴着容器底部</li>
<li>center：上下居中</li>
</ul>
<h3 id="justify-content-—-x-轴，水平方向"><a href="#justify-content-—-x-轴，水平方向" class="headerlink" title="justify-content — x 轴，水平方向"></a>justify-content — x 轴，水平方向</h3><ul>
<li>stretch：默认靠边，有多少放多少</li>
<li>flex-start：贴着容器左边</li>
<li>flex-end：贴着容器右边</li>
<li>center：水平居中</li>
<li>space-around：四周所占的空白面积相等（每个 div）</li>
<li>space-between：贴边的两个一边不分配空间，其余与 space-around 相同</li>
</ul>
<h2 id="flex：flex-grow-flex-shrink-flex-basis"><a href="#flex：flex-grow-flex-shrink-flex-basis" class="headerlink" title="flex：flex-grow flex-shrink flex-basis"></a>flex：flex-grow flex-shrink flex-basis</h2><ul>
<li>flex-grow：正数：扩大所占空间(为 1:用宽度将剩余的空间占领;为 0:不扩大空间)</li>
<li>flex-shrink：正数：缩小所占空间，只有在元素总和超出主轴才生效(为 0 不缩小)</li>
<li>flex-basis：元素的空间大小，默认 auto</li>
</ul>
<h2 id="align-self：只能作用单个项目并对齐当前-flex-grid-行中的元素。"><a href="#align-self：只能作用单个项目并对齐当前-flex-grid-行中的元素。" class="headerlink" title="align-self：只能作用单个项目并对齐当前 flex | grid 行中的元素。"></a>align-self：只能作用单个项目并对齐当前 flex | grid 行中的元素。</h2><blockquote>
<p>注：align-self 属性不适用于块类型的盒模型和表格单元。如果任何 flexbox 元素的侧轴方向 margin：auto，则会忽略 align-self。</p>
</blockquote>
<ul>
<li>flex-end：flex 元素会对齐到交叉轴的尾端。(搭配选择器，可以实现奇偶交错排列)</li>
<li>flex-start：flex 元素会对齐到交叉轴的首端。</li>
<li>center：元素尺寸大于 flex 元素尺寸，在两个方向均等溢出</li>
<li>不常用不介绍</li>
</ul>
<h2 id="连续字段换行（看-mdn-文档）"><a href="#连续字段换行（看-mdn-文档）" class="headerlink" title="连续字段换行（看 mdn 文档）"></a>连续字段换行（看 mdn 文档）</h2><ul>
<li>word-break: break-all; ：出现连续的单词或字段时，使用可换行</li>
</ul>
<h2 id="处理最后一行和最后一列的样式"><a href="#处理最后一行和最后一列的样式" class="headerlink" title="处理最后一行和最后一列的样式"></a>处理最后一行和最后一列的样式</h2><ul>
<li>格子数不定时，怎么处理边距<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用选择器重置最后一行的格子下边距为0 */</span></span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>n+<span class="number">1</span>)<span class="selector-pseudo">:nth-last-child</span>(-n+<span class="number">3</span>),</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>n+<span class="number">1</span>)<span class="selector-pseudo">:nth-last-child</span>(-n+<span class="number">3</span>)~<span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>n)&#123; // 一行<span class="number">3</span>个，指每一行第三个</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 重置第一行格子的上边距为0 */</span></span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(-n+<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS预处理器-sass语法</title>
    <url>/2024/10/30/HTMLCSS/css%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-sass/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h1 id="SCSS-和-SASS"><a href="#SCSS-和-SASS" class="headerlink" title="SCSS 和 SASS"></a>SCSS 和 SASS</h1><blockquote>
<p>scss 与 sass 的区别：sass 没有大括号和分号，每当一行结束都算作一个分号结束</p>
</blockquote>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><ul>
<li>变量声明：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$变量名:表达式</span><br></pre></td></tr></table></figure></li>
<li>流量控制规则：如 @if 和 @each</li>
<li>@error、@warn 和 @debug 规则</li>
</ul>
<h3 id="CSS-语句"><a href="#CSS-语句" class="headerlink" title="CSS 语句"></a>CSS 语句</h3><ul>
<li>样式规则：如 h1{&#x2F;<em>…</em>&#x2F;}</li>
<li>css at 规则：如 @media</li>
<li>Minxin 规则：使用 @include</li>
<li>@at-root 规则</li>
<li>@extend 规则只能在样式规则中使用</li>
</ul>
<h3 id="样式规则的属性声明"><a href="#样式规则的属性声明" class="headerlink" title="样式规则的属性声明"></a>样式规则的属性声明</h3><ul>
<li>插值#{}：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">#&#123;<span class="variable">$var</span>&#125;:<span class="variable">$var</span></span><br></pre></td></tr></table></figure></li>
<li>隐藏声明：声明的值为 null 或空不带引号的字符串，sass 不会编译为 css</li>
<li>前缀相同相当于命名空间，示例<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.enlarge</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span></span><br><span class="line">  transition: &#123;</span><br><span class="line">    property: font-size; <span class="comment">// 相当于transition-property</span></span><br><span class="line">    duration:<span class="number">4s</span>; <span class="comment">// 相当于transition-duration</span></span><br><span class="line">    delay:<span class="number">2s</span>; <span class="comment">// 相当于transition-delay</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="占位符选择器"><a href="#占位符选择器" class="headerlink" title="占位符选择器%"></a>占位符选择器%</h3><ul>
<li>用来扩展,写完公共样式后,其它选择器用@extend 来使用，都会应用这个样式</li>
</ul>
<h3 id="高层声明：只能顶层使用"><a href="#高层声明：只能顶层使用" class="headerlink" title="高层声明：只能顶层使用"></a>高层声明：只能顶层使用</h3><ul>
<li>模块负载：使用 @use</li>
<li>导入：使用 @import</li>
<li>混合定义：使用 @mixin</li>
<li>函数定义：使用 @function</li>
</ul>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><ul>
<li>值列表：可以用空格或逗号分隔，并且可以用[]括起来,或者根本不加</li>
<li>映射：定义一组数据,通过变量与键来映射出具体值</li>
</ul>
<h3 id="其它表达方式"><a href="#其它表达方式" class="headerlink" title="其它表达方式"></a>其它表达方式</h3><ul>
<li>变量：$var</li>
<li>函数调用：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nth</span>($list,<span class="number">1</span>) or <span class="selector-tag">var</span>(--main-bg-color)</span><br></pre></td></tr></table></figure></li>
<li>特殊函数：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">calc</span>(<span class="number">1px</span>+<span class="number">100%</span>) </span><br><span class="line">or <span class="built_in">url</span>(路径)</span><br></pre></td></tr></table></figure></li>
<li>父选择器：&amp;</li>
<li>值!important：被解析为不带引号的字符串</li>
</ul>
<h3 id="父选择器"><a href="#父选择器" class="headerlink" title="父选择器&amp;"></a>父选择器&amp;</h3><ul>
<li>注意：由于父选择器可以被类型选择器(如 h1)替换，因此<span class="key_words">『仅允许在复合选择器的开头使用』</span></li>
<li>添加后缀:<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">&amp;__copy </span><br><span class="line">or &amp;<span class="attr">--copy</span></span><br></pre></td></tr></table></figure></li>
<li>使用场景:伪类或在父级前添加选择器:not(&amp;)</li>
<li>在样式规则外使用返回 null,可做判断如：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">#&#123;<span class="built_in">if</span>(&amp;, &#x27;&amp;.styleName&#x27;, &#x27;.styleName&#x27;)&#125;</span><br></pre></td></tr></table></figure></li>
<li>高级嵌套：匹配外部选择器和元素选择器，示例<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scss</span></span><br><span class="line"><span class="variable">@use</span> <span class="string">&quot;sass:selector&quot;</span></span><br><span class="line"><span class="variable">@mixin</span> <span class="built_in">unify-parent</span>($child)</span><br><span class="line">  <span class="variable">@at-root</span> #&#123;<span class="selector-tag">selector</span><span class="selector-class">.unify</span>(&amp;, $child)&#125;</span><br><span class="line">    @<span class="selector-tag">content</span></span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.field</span></span><br><span class="line">  @<span class="selector-tag">include</span> <span class="selector-tag">unify-parent</span>(<span class="string">&quot;input&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">  @<span class="selector-tag">include</span> <span class="selector-tag">unify-parent</span>(<span class="string">&quot;select&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// css</span></span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-tag">input</span><span class="selector-class">.field</span> &#123;...&#125;</span><br><span class="line">.wrapper select.field &#123;...&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="在-scss-中"><a href="#在-scss-中" class="headerlink" title="在 scss 中"></a>在 scss 中</h3><ul>
<li><span class="key_words">『&#x2F;&#x2F;』</span>：单行注释，也叫<span class="key_words">『无声注释』</span>，不生成 css</li>
<li><span class="key_words">『&#x2F;**&#x2F;』</span>：多行注释，也被叫做<span class="key_words">『大声注释』</span>，压缩模式下多行注释会被删除，但是以<span class="key_words">『&#x2F;*！开头则不会被删除』</span></li>
</ul>
<h3 id="在-scss-中-1"><a href="#在-scss-中-1" class="headerlink" title="在 scss 中"></a>在 scss 中</h3><ul>
<li><span class="key_words">『&#x2F;&#x2F;』</span>：&#x2F;&#x2F;下一行的内容<span class="key_words">『缩进』</span>也会被注释</li>
</ul>
<h3 id="文档注释-无声注释"><a href="#文档注释-无声注释" class="headerlink" title="文档注释(无声注释)"></a>文档注释(无声注释)</h3><ul>
<li><span class="key_words">『&#x2F;&#x2F;&#x2F;』</span>：会解析成 markdown</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>默认值：<span class="key_words">『!default』</span>, 仅当该变量未定义或其值为 null 时，才会为该变量赋值</li>
<li>内置变量：无法修改</li>
<li>存在块作用域</li>
<li>全局标识：<span class="key_words">『!global』</span> 只能用于设置已在文件顶层声明的变量。它不能用于声明新变量。</li>
<li>成为全局变量：在顶层书写，或者在块作用域内使用!global</li>
<li>流程控制范围：使用@if，作用域内的变量可以分配给外部变量但在分配前该变量已经声明</li>
</ul>
<h2 id="规则"><a href="#规则" class="headerlink" title="@规则"></a>@规则</h2><ul>
<li>@mixin和@include: 可以轻松重用样式块。<ul>
<li><a href="https://sass.nodejs.cn/documentation/at-rules/mixin/">@mixin 参数</a></li>
</ul>
</li>
<li>@function: 定义了可在 SassScript 表达式中使用的自定义函数。</li>
<li>@extend: 允许选择器相互继承样式。</li>
<li>@at-root: 将样式放在 CSS 文档的根目录下。:将外部选择器添加为内部选择器</li>
<li>@error: 会导致编译失败并显示错误消息。</li>
<li>@warn: 在不完全停止编译的情况下打印警告。</li>
<li>@debug: 打印一条消息以进行调试。</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li>@if,@else，@else if：true 和 false 返回执行的部分</li>
<li>@each：遍历列表的每一项，格式<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$i</span> in <span class="variable">$items</span></span><br></pre></td></tr></table></figure></li>
<li>@for：使用 to，则排除最终数字，使用 through，则包含在内，格式<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">0</span> through <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>@while：表达式为真，一直执行，格式<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@while</span> <span class="variable">$var</span> &gt; <span class="variable">$var2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="来自-CSS"><a href="#来自-CSS" class="headerlink" title="来自 CSS"></a>来自 CSS</h2><ul>
<li>@media：作媒体查询，也可作特性查询<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span>(<span class="attribute">hover</span>:<span class="attribute">hover</span>) <span class="keyword">or</span> <span class="keyword">@media</span>(<span class="attribute">max-width</span>:<span class="number">1200px</span>)</span><br></pre></td></tr></table></figure></li>
<li>@supports：声明多个同样属性样式</li>
<li>@keyframes：子规则必须是关键帧规则(from 或 to，20%)</li>
</ul>
<h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><h3 id="数字"><a href="#数字" class="headerlink" title="数字:"></a>数字:</h3><ul>
<li>不区分整数和小数，也可以有单位</li>
<li>相乘时单位相乘,相除时,从第一个数字获取分子单位,第二个获取分母单位</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串:"></a>字符串:</h3><ul>
<li>string.unquote(): 将带引号的字符串转为不带引号的字符串</li>
<li>string.quote(): 将不带引号的字符串转为带引号的字符串</li>
<li>转义：在字符前添加\</li>
<li>不带引号的转义返回字符串，没有转义</li>
<li>带引号的字符串转义：unicode 中代表什么就等于什么</li>
<li>string.index(“原字符串”,”要索引的字符”): 返回索引的位置(从 1 开始算)</li>
<li>string.slice(“原字符串”,切割的长度)</li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表:"></a>列表:</h3><ul>
<li>索引：从 1 开始，负数索引为倒数</li>
<li>访问元素：获取列表中给定索引的元素<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">list<span class="selector-class">.nth</span>($list, $n)</span><br></pre></td></tr></table></figure></li>
<li>遍历元素：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$i</span> in <span class="variable">$lists</span></span><br></pre></td></tr></table></figure></li>
<li>添加到列表：添加元素在末尾不会破坏原来列表.<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">list<span class="selector-class">.append</span>($list,$val)</span><br></pre></td></tr></table></figure></li>
<li>在列表中查找元素：不存在返回 null，可与@if 一起检查<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">list<span class="selector-class">.index</span>($list,$value)</span><br></pre></td></tr></table></figure></li>
<li>列表的不可变性：返回新列表，不会修改原列表</li>
<li>任意参数 的 mixin 或函数时和 meta.keywords() 函数<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sass</span></span><br><span class="line"><span class="keyword">@use</span> <span class="string">&quot;sass:meta&quot;</span>;</span><br><span class="line"><span class="keyword">@mixin</span> syntax-colors(<span class="variable">$args</span>...) &#123;</span><br><span class="line">  <span class="keyword">@debug</span> meta.keywords(<span class="variable">$args</span>);</span><br><span class="line">  <span class="comment">// (string: #080, comment: #800, variable: #60b)</span></span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$name</span>, <span class="variable">$color</span> in meta.keywords(<span class="variable">$args</span>) &#123;</span><br><span class="line">    pre <span class="selector-tag">span</span><span class="selector-class">.stx-</span>#&#123;<span class="variable">$name</span>&#125; &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="variable">$color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@include</span> syntax-colors(</span><br><span class="line">  <span class="variable">$string</span>: <span class="number">#080</span>,</span><br><span class="line">  <span class="variable">$comment</span>: <span class="number">#800</span>,</span><br><span class="line">  <span class="variable">$variable</span>: <span class="number">#60b</span>,</span><br><span class="line">)</span><br><span class="line">// css</span><br><span class="line">pre span.stx-string &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#080</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre <span class="selector-tag">span</span><span class="selector-class">.stx-comment</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#800</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre <span class="selector-tag">span</span><span class="selector-class">.stx-variable</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#60b</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map:"></a>映射 map:</h3><ul>
<li>添加映射：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">map<span class="selector-class">.set</span>($map,$key,$value)</span><br></pre></td></tr></table></figure></li>
<li>合并两个现有映射：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">map<span class="selector-class">.merge</span>()</span><br></pre></td></tr></table></figure></li>
<li>查找一个值：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">map<span class="selector-class">.get</span>($map, $key)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean:"></a>Boolean:</h3><ul>
<li>@if $var {…}：结果为 true 返回</li>
<li>if(true,10px,20px)：true 返回第二个参数,false,返回第三个参数</li>
<li>false 和 null 为 false</li>
</ul>
<h3 id="null"><a href="#null" class="headerlink" title="null:"></a>null:</h3><ul>
<li>包含 null,省略</li>
</ul>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><ul>
<li>meta.get-function(): 将函数名称作为值获取</li>
<li>meta.call()：调用该函数</li>
</ul>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><ul>
<li>计算：calc()</li>
<li>比较功能：min()、max()、clamp()</li>
<li>阶梯值函数：round()、mod()、rem()</li>
<li>三角函数：sin()、cos()、tan()、asin()、acos()、atan()、atan2()</li>
<li>指数函数：pow()、sqrt()、hypot()、log()、exp()</li>
<li>符号相关函数：abs()、sign()</li>
</ul>
<h3 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h3><ul>
<li><a href="https://sass.nodejs.cn/documentation/modules/">内置模块</a></li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>css预处理器</tag>
        <tag>sass</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>Html-格子布局(Grid)</title>
    <url>/2024/10/30/HTMLCSS/html-Grid/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>前情提要： 只写了关键代码</li>
<li>示例布局： <a href="https://gitee.com/ovouu/study-notes/blob/master/html5%20&%20css/html/GTA5%E5%B0%81%E9%9D%A2.html">html&#x2F;GTA5 封面.html</a></li>
</ul>
<h3 id="划分行列"><a href="#划分行列" class="headerlink" title="划分行列"></a>划分行列</h3><ol>
<li><p>grid-template-columns 划分列数</p>
<ul>
<li>划几个就写几个值，每个值代表该列的宽</li>
</ul>
</li>
<li><p>grid-template-rows 划分行数</p>
<ul>
<li>划几个就写几个值，每个值代表该行的高</li>
</ul>
</li>
<li><p>repeat() 重复设置</p>
<ul>
<li>参数一：重复的数量</li>
<li>参数二：重复的值,这个值可以有多个，用空格连接<ul>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>:<span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">50px</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>自动填充 auto-fit</p>
<ul>
<li>根据容器尺寸，自动设置元素尺寸</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fit,<span class="number">100px</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>比例划分</p>
<ul>
<li>单位组合<ul>
<li>使用 fr 单位设置元素在空间中所占的比例</li>
</ul>
</li>
<li>重复定义<ul>
<li>结合 repeat</li>
</ul>
</li>
</ul>
</li>
<li><p>自动空间 auto</p>
<ul>
<li>在值中使用 auto，则将获取剩余空间</li>
</ul>
</li>
<li><p>组合定义</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template</span>: grid-template-rows / grid-template-columns</span><br><span class="line">eg：grid-template: <span class="number">50px</span> <span class="number">100px</span> <span class="number">50px</span> / <span class="number">150px</span> <span class="number">150px</span></span><br><span class="line">grid-template: grid-template-areas</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*点代表占位符*/</span></span><br><span class="line"><span class="attribute">grid-template</span>:</span><br><span class="line">  <span class="string">&#x27;header header .&#x27;</span><span class="number">100px</span></span><br><span class="line">  <span class="string">&#x27;. main main&#x27;</span><span class="number">200px</span></span><br><span class="line">  <span class="string">&#x27;footer . .&#x27;</span> <span class="number">300px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: header</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: main</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>最大最下值 minmax()</p>
<ul>
<li>取值范围在最小到最大之间取值，左边最小，右边最大</li>
<li>示例: <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>,<span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="间距定义"><a href="#间距定义" class="headerlink" title="间距定义"></a>间距定义</h3><ol>
<li>行间距：row-gap</li>
<li>列间距：column-gap</li>
<li>组合定义：gap<ul>
<li>一个值：行列统一</li>
<li>两个值：行 列</li>
</ul>
</li>
</ol>
<h3 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h3><ol>
<li>grid-row-start: 行开始网格线，起到命名的作用</li>
<li>grid-row-end: 行结束网格线</li>
<li>grid-column-start：列开始网格线</li>
<li>grid-column-end：列结束网格线</li>
</ol>
<ul>
<li>以上共有属性：<ul>
<li>Line: 网格络</li>
<li>span数值： 网格包含的网格数量</li>
<li>span 区域名称： 网格包含到指定的区域名称</li>
<li>auto： 自动设置，默认为一个网格宽高</li>
</ul>
</li>
</ul>
<ol start="5">
<li><p>根据网格线</p>
<ul>
<li>通过设置具体的第几条网格线来设置区域位置，设置的数值可以是正数和负数</li>
</ul>
</li>
<li><p>根据偏移量 span</p>
<ul>
<li>使用 span 可以设置包含网格的数量或包含到的区域名称。</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-row-start</span>: span <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>根据网格命名：看下面的网格命名小节</p>
</li>
<li><p>简写模式</p>
<ul>
<li>使用 grid-row 设置行开始网格线</li>
<li>使用设置 grid-column 列结束网格线</li>
</ul>
</li>
<li><p>更简洁的组合写法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-area</span>: grid-row/start/grid-column-start/grid-row-end/grid-column-end</span><br></pre></td></tr></table></figure></li>
<li><p>实现类似于 bootstrap 的布局</p>
</li>
</ol>
<h3 id="网格命名"><a href="#网格命名" class="headerlink" title="网格命名"></a>网格命名</h3><ul>
<li><p>独立命名</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*2. 然后在定义行列宽时也添加进去*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [c1-start] <span class="number">100px</span> [c1-end c2-start] <span class="number">100px</span> [c3-end];</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [r1-start] <span class="number">100px</span> [r1-end r2-start] <span class="number">100px</span> [r3-end];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*1.给一个网格中的每个线单独命名*/</span></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: r2-start;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: r2-end;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: c3-start;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: c3-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动命名</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*2. 然后在定义行列宽时也添加进去*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>,[c-start] <span class="number">100px</span> [c-end]);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">3</span>,[r-start] <span class="number">100px</span> [r-end]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*1.给一个网格中的每个线单独命名*/</span></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: r-start <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: r-end <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: c-start <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: c-end <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="区域换位"><a href="#区域换位" class="headerlink" title="区域换位"></a>区域换位</h3><ol>
<li><p>编号定位</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*2. 然后在定义行列宽时也添加进去*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">100px</span>);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*1.给一个网格中的每个线单独命名*/</span></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>:<span class="number">2</span>/<span class="number">2</span>/<span class="number">3</span>/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名定位</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*2. 然后在定义行列宽时也添加进去*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, [c] <span class="number">100px</span>);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(auto-fill, [r] <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*1.给一个网格中的每个线单独命名*/</span></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>:r <span class="number">2</span> / c <span class="number">2</span> / r <span class="number">3</span> / c <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="区域声明"><a href="#区域声明" class="headerlink" title="区域声明"></a>区域声明</h3><ul>
<li>以布局移动端页面结构为列</li>
</ul>
<ol>
<li><p>区域布局</p>
<ul>
<li>每个子元素添加对应的 grid-area： 子元素的命名;</li>
<li>在父元素中使用<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">80px</span> <span class="number">1</span>fr <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">1</span>fr <span class="number">50px</span> <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>:</span><br><span class="line">      <span class="string">&quot;ddd ddd ddd ddd&quot;</span></span><br><span class="line">      <span class="string">&quot;aaa bbb bbb ccc&quot;</span></span><br><span class="line">      <span class="string">&quot;eee eee eee eee&quot;</span>;</span><br><span class="line">其中每个aaa，bbb,ccc,ddd,eee,代表了子元素的命名，命名放在哪里就代表子元素占用的位置</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>简写形式</p>
<ul>
<li>每个子元素添加对应的 grid-area： 栅格名称;</li>
<li>在父元素中使用<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template</span>:</span><br><span class="line">  <span class="string">&#x27;栅格名称 栅格名称 栅格名称 栅格名称&#x27;</span> 行高</span><br><span class="line">  <span class="string">&#x27;栅格名称 栅格名称 栅格名称 栅格名称&#x27;</span> 行高</span><br><span class="line">  <span class="string">&#x27;栅格名称 栅格名称 栅格名称 栅格名称&#x27;</span> 行高/列宽 列宽 列宽 列宽;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>区域命名(系统自动命名)</p>
<ul>
<li>只要子元素命名了网格线的区域，栅格名字自定生成<ul>
<li>示例:<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-area</span>: header1-start/header1-start/main-end/mian-end</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>区域占位</p>
<ul>
<li>使用一个或多个.来占位，一个.,代表一个位置</li>
</ul>
</li>
</ol>
<h3 id="网格流动"><a href="#网格流动" class="headerlink" title="网格流动"></a>网格流动</h3><ol>
<li><p>grid-auto-flow 改变单元格排列方式</p>
<ul>
<li>column： 按列排序</li>
<li>row： 按行排序</li>
<li>dense： 元素使用前面空余栅格(想当与 margin)</li>
</ul>
</li>
<li><p>在父元素使用</p>
</li>
<li><p>强制填充</p>
<ul>
<li>当元素在栅格中放不下时，将会发生换行产生留白，使用grid-auto-flow: row dense;可以执行填充空白区域操作</li>
</ul>
</li>
</ol>
<h3 id="对齐管理"><a href="#对齐管理" class="headerlink" title="对齐管理"></a>对齐管理</h3><ul>
<li>justify-content: <span class="key_words">『所有栅格在容器中的水平对齐』</span>方式，容器有额外空间时</li>
<li>align-content：<span class="key_words">『所有栅格在容器中的垂直对齐』</span>方式，容器有额外空间时</li>
<li>align-items: <span class="key_words">『栅格内所有元素的垂直排列方』</span>式</li>
<li>justify-items: <span class="key_words">『栅格内所有元素的横向排列』</span>方式</li>
<li>align-self: <span class="key_words">『元素在栅格中垂直』</span>对齐方式</li>
<li>justify-self: <span class="key_words">『元素在栅格中水平』</span>对齐方式</li>
</ul>
<ol>
<li>网格对齐<ul>
<li>justify-content 属性的值如下</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>容器左边</td>
</tr>
<tr>
<td>end</td>
<td>容器右边</td>
</tr>
<tr>
<td>center</td>
<td>容器中间</td>
</tr>
<tr>
<td>stretch</td>
<td>撑满容器</td>
</tr>
<tr>
<td>space-between</td>
<td>第一个栅格靠左边，最后一个栅格靠右边，余下元素平均分配空间</td>
</tr>
<tr>
<td>space-around</td>
<td>每个元素两侧的间隔相等。所以，栅格之间的间隔比栅格与容器边距的间隔大一倍 space-evenly 栅格间距离完全平均分配</td>
</tr>
</tbody></table>
<ul>
<li>align-content 属性的值如下</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>容器顶边</td>
</tr>
<tr>
<td>end</td>
<td>容器底边</td>
</tr>
<tr>
<td>center</td>
<td>容器垂直中间</td>
</tr>
<tr>
<td>stretch</td>
<td>撑满容器</td>
</tr>
<tr>
<td>space-between</td>
<td>第一个栅格靠左边，最后一个栅格靠右边，余下元素平均分配空间</td>
</tr>
<tr>
<td>space-around</td>
<td>每个元素两侧的间隔相等。所以，栅格之间的间隔比栅格与容器边距的间隔大一倍</td>
</tr>
<tr>
<td>space-evenly</td>
<td>栅格间距离完全平均分配</td>
</tr>
</tbody></table>
<ol start="2">
<li>元素对齐<ul>
<li>justify-items 用于控制元素的水平对齐方式，可用的属性值如下</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>元素对齐栅格的左边</td>
</tr>
<tr>
<td>end</td>
<td>元素对齐栅格的右边</td>
</tr>
<tr>
<td>center</td>
<td>元素对齐栅格的中间</td>
</tr>
<tr>
<td>stretch</td>
<td>水平撑满栅格</td>
</tr>
</tbody></table>
<ul>
<li>align-items 用于控制元素的垂直对齐方式，可用的属性值如下</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>元素对齐栅格的顶边</td>
</tr>
<tr>
<td>end</td>
<td>元素对齐栅格的底边</td>
</tr>
<tr>
<td>center</td>
<td>元素对齐栅格的垂直中间</td>
</tr>
<tr>
<td>stretch</td>
<td>垂直撑满栅格</td>
</tr>
</tbody></table>
<ol start="3">
<li>简写<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;</span><br><span class="line">place-items: &lt;align-items&gt; &lt;justify-items&gt;</span><br><span class="line">place-self: &lt;align-self&gt; &lt;justify-self&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="自动排列"><a href="#自动排列" class="headerlink" title="自动排列"></a>自动排列</h3><ul>
<li>属性说明<ul>
<li>grid-auto-rows: 控制自动增加的栅格行的尺寸，grid-auto-flow:row; 为默认</li>
<li>grid-auto-columns: 控制自动增加的栅格列的尺寸，grid-auto-flow: column;</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Html-浮动布局(Float)</title>
    <url>/2024/10/30/HTMLCSS/html-float%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h2><ul>
<li>概念：可以使一个元素向其父元素的左侧或右侧移动</li>
<li>使用 float 属性来设置于元素的浮动<ul>
<li>可选值：<ul>
<li>none: 默认值 ，元素不浮动</li>
<li>left: 元素向左浮动</li>
<li>right: 元素向右浮动</li>
</ul>
</li>
</ul>
</li>
<li>元素设置浮动以后，水平布局的等式便不需要强制成立</li>
<li>元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，</li>
<li>元素下边的还在文档流中的元素会自动向上移动</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>设置浮动以后元素会向父元素的左侧或右侧移动，</li>
<li>浮动元素默认不会从父元素中移出</li>
<li>浮动元素向左或向右移动时，不会超过它前边的其他浮动元素</li>
<li>如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移</li>
<li>浮动元素不会超过它上边的浮动的兄弟元素，最多最多就是和它一样高</li>
<li>浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以可以利用浮动来设置文字环绕图片的效果</li>
<li>浮动元素会完全脱离文档流，从文档流中脱离后，元素的一些特点也会发生变化<ul>
<li>脱离文档流的特点：<ul>
<li>块元素：<ul>
<li>1、块元素不在独占页面的一行</li>
<li>2、脱离文档流以后，块元素的宽度和高度默认都被内容撑开</li>
</ul>
</li>
<li>行内元素：<ul>
<li>行内元素脱离文档流以后会变成块元素，特点和块元素一样</li>
</ul>
</li>
<li>脱离文档流以后，不需要再区分块和行内了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="简单总结："><a href="#简单总结：" class="headerlink" title="简单总结："></a>简单总结：</h3><ul>
<li>目前的主要作用就是让页面中的元素可以水平排列</li>
<li>通过浮动可以制作一些水平方向的布局</li>
</ul>
<h3 id="清除浮动-clear"><a href="#清除浮动-clear" class="headerlink" title="清除浮动 clear"></a>清除浮动 clear</h3><ul>
<li>期望：不希望某个元素因为其他元素浮动的影响而改变位置</li>
<li>作用：清除浮动元素对当前元素所产生的影响</li>
<li>可选值：<ul>
<li>left: 清除左侧浮动元素对当前元素的影响</li>
<li>right: 清除右侧浮动元素对当前元素的影响</li>
<li>both: 清除两侧中最大影响的那侧</li>
</ul>
</li>
<li>原理：设置清除浮动以后，浏览器会自动为元素添加一个上外边距，以使其位置不受其他元素的影响</li>
</ul>
<h2 id="BFC-Block-Formatting-Context-块级格式化环境"><a href="#BFC-Block-Formatting-Context-块级格式化环境" class="headerlink" title="BFC(Block Formatting Context) 块级格式化环境"></a>BFC(Block Formatting Context) 块级格式化环境</h2><ul>
<li>BFC 是一个 CSS 中的一个隐含的属性，可以为一个元素开启 BFC</li>
<li>开启 BFC 该元素会变成一个独立的布局区域</li>
<li>元素开启 BFC 后的特点：<ol>
<li>开启 BFC 的元素不会被浮动元素所覆盖</li>
<li>开启 BFC 的元素子元素和父元素外边距不会重叠</li>
<li>开启 BFC 的元素可以包含浮动的子元素</li>
</ol>
</li>
<li>可以通过一些特殊方式来开启元素的 BFC：<ul>
<li>设置元素的浮动（不推荐）<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">float</span>: left;</span><br></pre></td></tr></table></figure></li>
<li>将元素设置为行内块元素（不推荐）<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: inline-block;</span><br></pre></td></tr></table></figure></li>
<li>将元素的 overflow 设置为一个非 visible 的值<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>:hidden;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="高度塌陷-—-浮动布局常见问题"><a href="#高度塌陷-—-浮动布局常见问题" class="headerlink" title="高度塌陷 — 浮动布局常见问题"></a>高度塌陷 — 浮动布局常见问题</h2><ul>
<li>在浮动布局中，父元素的高度默认是被子元素撑开的，</li>
<li>当子元素浮动后，其会完全脱离文档流，</li>
<li><span class="key_words">『子元素从文档流中脱离将会无法撑起父元素的高度，导致父元素的高度丢失』</span></li>
<li>父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱</li>
<li>简单概括：div 中有一个 div1，但是 div1 设置为 float 离开 div，而 div 本身没有高度，就坍塌。页面就乱了</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>方案一：给父元素设置伪类</p>
<ul>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">.父元素的类选择器的值<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;<span class="comment">/*通过设置：after伪元素解决坍陷*/</span></span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方案二：clearfix</p>
<ul>
<li>可以同时解决高度塌陷和外边距重叠的问题</li>
<li>示例<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table; <span class="comment">/*解决外边距重叠的问题*/</span></span><br><span class="line">    <span class="attribute">clear</span>: both; <span class="comment">/*解决高度塌陷的问题*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="点击查看，浮动的网页布局示例代码"><a href="#点击查看，浮动的网页布局示例代码" class="headerlink" title="点击查看，浮动的网页布局示例代码"></a><a href="https://gitee.com/ovouu/study-notes/blob/master/html5%20&%20css/html/%E7%BD%91%E9%A1%B5%E7%9A%84%E5%B8%83%E5%B1%80.html">点击查看，浮动的网页布局示例代码</a></h3>]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Html-元素布局篇</title>
    <url>/2024/10/30/HTMLCSS/html-%E5%85%83%E7%B4%A0%E5%B8%83%E5%B1%80%E7%AF%87/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="注意：有用到-float-的，记得在父容器添加-clearfix"><a href="#注意：有用到-float-的，记得在父容器添加-clearfix" class="headerlink" title="注意：有用到 float 的，记得在父容器添加 clearfix"></a>注意：有用到 float 的，记得在父容器添加 clearfix</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="使用-text-align-属性"><a href="#使用-text-align-属性" class="headerlink" title="使用 text-align 属性"></a>使用 text-align 属性</h3><ul>
<li>当<span class="children">子元素</span>为行内块元素，即 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: inline-block;</span><br></pre></td></tr></table></figure></li>
<li><span class="parent">父元素</span>设置 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-align</span>: center;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定宽块级元素水平居中-—-方式一"><a href="#定宽块级元素水平居中-—-方式一" class="headerlink" title="定宽块级元素水平居中 — 方式一"></a>定宽块级元素水平居中 — 方式一</h3><ul>
<li><span class="children">子元素</span>使用 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>：<span class="number">0</span> auto;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定宽块级元素水平居中-—-方式二"><a href="#定宽块级元素水平居中-—-方式二" class="headerlink" title="定宽块级元素水平居中 — 方式二"></a>定宽块级元素水平居中 — 方式二</h3><ul>
<li><span class="children">子元素</span>使用 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="built_in">-</span>(子元素width/<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定宽块级元素水平居中-—-方式三"><a href="#定宽块级元素水平居中-—-方式三" class="headerlink" title="定宽块级元素水平居中 — 方式三"></a>定宽块级元素水平居中 — 方式三</h3><ul>
<li><span class="parent">父元素</span>使用 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">height</span>: 子元素height;</span><br></pre></td></tr></table></figure></li>
<li><span class="children">子元素</span>使用 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">width</span>: 子元素原宽度;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定宽块级元素水平居中-—-方式四"><a href="#定宽块级元素水平居中-—-方式四" class="headerlink" title="定宽块级元素水平居中 — 方式四"></a>定宽块级元素水平居中 — 方式四</h3><ul>
<li><span class="parent">父元素</span>使用: relative</li>
<li><span class="children">子元素</span>使用 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><ul>
<li><span class="parent">父元素</span>使用<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">height</span>: 子元素高度;</span><br><span class="line">diaplay: flex;</span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br></pre></td></tr></table></figure></li>
<li><span class="children">子元素</span>使用<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>:auto;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><ul>
<li>除了把 flex 改为 grid，其它跟 6 一样</li>
</ul>
<h2 id="垂直布局"><a href="#垂直布局" class="headerlink" title="垂直布局"></a>垂直布局</h2><h3 id="行内块级元素垂直居中"><a href="#行内块级元素垂直居中" class="headerlink" title="行内块级元素垂直居中"></a>行内块级元素垂直居中</h3><ul>
<li><span class="parent">父元素</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">line-height</span>: 父元素高度;</span><br></pre></td></tr></table></figure></li>
<li><span class="children">子元素</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>:inline-block; </span><br><span class="line"><span class="attribute">vertical-align</span>:middle;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定位方式-—-方式一"><a href="#定位方式-—-方式一" class="headerlink" title="定位方式 — 方式一"></a>定位方式 — 方式一</h3><ul>
<li><span class="parent">父元素</span>设置: relative</li>
<li><span class="children">子元素</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="built_in">-</span>(子元素高度 / <span class="number">2</span>)px;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定位方式-—-方式二"><a href="#定位方式-—-方式二" class="headerlink" title="定位方式 — 方式二"></a>定位方式 — 方式二</h3><ul>
<li><span class="parent">父元素</span>设置: relative</li>
<li><span class="children">子元素</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br><span class="line"><span class="attribute">height</span>: 子元素高度;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定位方式-—-方式三"><a href="#定位方式-—-方式三" class="headerlink" title="定位方式 — 方式三"></a>定位方式 — 方式三</h3><ul>
<li><span class="parent">父元素</span>设置: relative</li>
<li><span class="children">子元素</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);`</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h3><ul>
<li><span class="parent">父元素</span>设置: display:flex;<ul>
<li>方法一：align-items:center;</li>
</ul>
</li>
<li><span class="children">子元素</span>设置<ul>
<li>方法二：margin:auto;</li>
</ul>
</li>
</ul>
<h3 id="Grid-1"><a href="#Grid-1" class="headerlink" title="Grid"></a>Grid</h3><ul>
<li><span class="parent">父元素</span>设置: display:grid;<ul>
<li>方法一：align-items:center;</li>
</ul>
</li>
<li><span class="children">子元素</span>设置<ul>
<li>方法二：margin:auto;</li>
<li>方法三：align-self:center;</li>
</ul>
</li>
</ul>
<h2 id="水平垂直居中-➕"><a href="#水平垂直居中-➕" class="headerlink" title="水平垂直居中 ➕"></a>水平垂直居中 ➕</h2><h3 id="行内块级"><a href="#行内块级" class="headerlink" title="行内块级"></a>行内块级</h3><ul>
<li><span class="parent">父元素</span>设置 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">line-height</span>: 父元素高度;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br></pre></td></tr></table></figure></li>
<li><span class="children">子元素</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定位-—-方式一"><a href="#定位-—-方式一" class="headerlink" title="定位 — 方式一"></a>定位 — 方式一</h3><ul>
<li><span class="parent">父元素</span>设置: relative</li>
<li><span class="children">子元素</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span><span class="built_in">-</span>(子元素宽度/<span class="number">2</span>)px);</span><br><span class="line"><span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - (子元素高度/<span class="number">2</span>)px);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定位-—-方式二"><a href="#定位-—-方式二" class="headerlink" title="定位 — 方式二"></a>定位 — 方式二</h3><ul>
<li><span class="parent">父元素</span>设置: relative</li>
<li><span class="children">子元素</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="built_in">-</span>(子元素宽度 / <span class="number">2</span>)px;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="built_in">-</span>(子元素高度/<span class="number">2</span>)px;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定位-—-方式三"><a href="#定位-—-方式三" class="headerlink" title="定位 — 方式三"></a>定位 — 方式三</h3><ul>
<li><span class="parent">父元素</span>设置: relative</li>
<li><span class="children">子元素</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定位-—-方式四"><a href="#定位-—-方式四" class="headerlink" title="定位 — 方式四"></a>定位 — 方式四</h3><ul>
<li><span class="parent">父元素</span>设置: relative</li>
<li><span class="children">子元素</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Flex-1"><a href="#Flex-1" class="headerlink" title="Flex"></a>Flex</h3><ul>
<li><span class="parent">父元素</span>设置: display:flex;<ul>
<li>方法一：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">align-items</span>: center;</span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><span class="children">子元素</span>设置<ul>
<li>方法二：margin: auto;</li>
</ul>
</li>
</ul>
<h3 id="Grid-2"><a href="#Grid-2" class="headerlink" title="Grid"></a>Grid</h3><ul>
<li><span class="parent">父元素</span>设置: display:grid;<ul>
<li>方法一：place-items: center;</li>
<li>方法二: place-content: center;</li>
</ul>
</li>
<li><span class="children">子元素</span>设置<ul>
<li>方法三：margin: auto;</li>
<li>方法四：place-self: center;</li>
</ul>
</li>
</ul>
<h2 id="两列布局"><a href="#两列布局" class="headerlink" title="两列布局"></a>两列布局</h2><blockquote>
<p>两列布局: 一列定宽(也有可能由子元素决定宽度)，一列自适应的布局。(以左列定宽，右列自适应为例，高度一样)</p>
</blockquote>
<h3 id="float-calc-–-左容器宽度不可以由子元素撑起"><a href="#float-calc-–-左容器宽度不可以由子元素撑起" class="headerlink" title="float + calc() – 左容器宽度不可以由子元素撑起"></a>float + calc() – 左容器宽度不可以由子元素撑起</h3><ul>
<li><span class="children">左容器</span>设置: float: left;</li>
<li><span class="parent">右容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">float</span>: left; </span><br><span class="line"><span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - 左容器的宽度);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="float-margin-left-–-左容器宽度不可以由子元素撑起"><a href="#float-margin-left-–-左容器宽度不可以由子元素撑起" class="headerlink" title="float + margin-left – 左容器宽度不可以由子元素撑起"></a>float + margin-left – 左容器宽度不可以由子元素撑起</h3><ul>
<li><span class="children">左容器</span>设置: float: left;</li>
<li><span class="parent">右容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>: 左容器的宽度;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="absolute-margin-left-–-左容器宽度不可以由子元素撑起"><a href="#absolute-margin-left-–-左容器宽度不可以由子元素撑起" class="headerlink" title="absolute + margin-left – 左容器宽度不可以由子元素撑起"></a>absolute + margin-left – 左容器宽度不可以由子元素撑起</h3><ul>
<li><span class="children">左容器</span>设置: absolute</li>
<li><span class="parent">右容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>: 左容器的宽度;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="float-overflow-–-无限制"><a href="#float-overflow-–-无限制" class="headerlink" title="float + overflow – 无限制"></a>float + overflow – 无限制</h3><ul>
<li><span class="children">左容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">float</span>: left;</span><br></pre></td></tr></table></figure></li>
<li><span class="parent">右容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Flex-–-无限制"><a href="#Flex-–-无限制" class="headerlink" title="Flex – 无限制"></a>Flex – 无限制</h3><ul>
<li><span class="grandparent">左右父级容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>:flex;</span><br></pre></td></tr></table></figure></li>
<li><span class="parent">右容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Grid-–-无限制"><a href="#Grid-–-无限制" class="headerlink" title="Grid – 无限制"></a>Grid – 无限制</h3><ul>
<li><span class="grandparent">左右父级容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line"><span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三列布局"><a href="#三列布局" class="headerlink" title="三列布局"></a>三列布局</h2><h3 id="Float-—-方式一"><a href="#Float-—-方式一" class="headerlink" title="Float — 方式一"></a>Float — 方式一</h3><ul>
<li><span class="children">左容器</span>设置: float:left;</li>
<li><span class="parent">右容器</span>设置：float: right;</li>
<li><span class="grandparent">中间</span>设置：overflow: hidden;</li>
</ul>
<h3 id="Float-—-方式二"><a href="#Float-—-方式二" class="headerlink" title="Float — 方式二"></a>Float — 方式二</h3><ul>
<li><span class="children">左容器</span>设置: float:left;</li>
<li><span class="parent">右容器</span>设置：float: right;</li>
<li><span class="grandparent">中间</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>：calc(<span class="number">100%</span> -左右宽度之和);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h3><ul>
<li><span class="children">左容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><span class="parent">右容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><span class="grandparent">中间</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>：calc(<span class="number">100%</span> -左右宽度之和); </span><br><span class="line"><span class="attribute">margin-left</span>: 左容器宽度;  </span><br><span class="line"><span class="attribute">margin-right</span>: 有容器宽度;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Flex-2"><a href="#Flex-2" class="headerlink" title="Flex"></a>Flex</h3><ul>
<li><span class="parent">父容器</span>设置: display:flex;</li>
<li><span class="parent">右容器</span>设置：flex:1;</li>
</ul>
<h3 id="Grid-3"><a href="#Grid-3" class="headerlink" title="Grid"></a>Grid</h3><ul>
<li><span class="parent">父容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: grid; </span><br><span class="line"><span class="attribute">grid-template-columns</span>: auto ifr auto;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="等分布局"><a href="#等分布局" class="headerlink" title="等分布局"></a>等分布局</h2><h3 id="浮动-百分比"><a href="#浮动-百分比" class="headerlink" title="浮动 + 百分比"></a>浮动 + 百分比</h3><ul>
<li><span class="children">子元素共有类</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">25%</span>; </span><br><span class="line"><span class="attribute">float</span>: left;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="行内块级-百分比"><a href="#行内块级-百分比" class="headerlink" title="行内块级 + 百分比"></a>行内块级 + 百分比</h3><ul>
<li><span class="children">子元素共有类</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">24.5%</span>; </span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Flex-3"><a href="#Flex-3" class="headerlink" title="Flex"></a>Flex</h3><ul>
<li><span style="color: red">父容器</span>设置: display:flex;</li>
<li><span class="children">子元素共有类</span>设置: flex:1;</li>
</ul>
<h3 id="Grid-4"><a href="#Grid-4" class="headerlink" title="Grid"></a>Grid</h3><ul>
<li><span style="color: red">父容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line"><span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">4</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Sticky-Footer-布局"><a href="#Sticky-Footer-布局" class="headerlink" title="Sticky Footer 布局"></a>Sticky Footer 布局</h2><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><ul>
<li><span class="grandparent">html,body</span>设置: height: 100%</li>
<li><span class="parent">父级容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: relative; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br></pre></td></tr></table></figure></li>
<li><span class="parent">中间容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">padding-bottom</span>: 底部的高度;</span><br></pre></td></tr></table></figure></li>
<li><span class="children">底部</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">bottom</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="calc"><a href="#calc" class="headerlink" title="calc()"></a>calc()</h3><ul>
<li><span class="parent">中间容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">min-height</span>: <span class="built_in">calc</span>(<span class="number">100vh</span>- 底部高度);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Flex-4"><a href="#Flex-4" class="headerlink" title="Flex"></a>Flex</h3><ul>
<li><span class="parent">父级容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex; </span><br><span class="line"><span class="attribute">flex-flow</span>: column; </span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br></pre></td></tr></table></figure></li>
<li><span class="parent">中间容器</span>设置: flex:1;</li>
</ul>
<h3 id="Grid-5"><a href="#Grid-5" class="headerlink" title="Grid"></a>Grid</h3><ul>
<li><span class="parent">父级容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: grid; </span><br><span class="line"><span class="attribute">grid-template-rows</span>: auto <span class="number">1</span>fr auto; </span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="全屏布局"><a href="#全屏布局" class="headerlink" title="全屏布局"></a>全屏布局</h2><h3 id="calc-1"><a href="#calc-1" class="headerlink" title="calc()"></a>calc()</h3><ul>
<li><span class="parent">中间父容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden; </span><br><span class="line"><span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100vh</span> - 底部高度);</span><br></pre></td></tr></table></figure></li>
<li><span class="children">中间左</span>设置: height: 100%;</li>
<li><span class="parent">中间右</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: auto;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br></pre></td></tr></table></figure></li>
<li><span class="grandparent">中间右内容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">height</span>: 任意高度;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Flex-5"><a href="#Flex-5" class="headerlink" title="Flex"></a>Flex</h3><ul>
<li><span class="parent">父容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-flow</span>: column;</span><br></pre></td></tr></table></figure></li>
<li><span class="parent">中间父容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: auto;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><span class="grandparent">中间右内容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">height</span>: 任意高度;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Grid-6"><a href="#Grid-6" class="headerlink" title="Grid"></a>Grid</h3><ul>
<li><span class="parent">父容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line"><span class="attribute">grid-template-rows</span>: auto <span class="number">1</span>fr auto;</span><br></pre></td></tr></table></figure></li>
<li><span class="parent">中间父容器</span>设置: overflow:auto;</li>
<li><span class="grandparent">中间右内容器</span>设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">height</span>: 任意高度;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Html-基础</title>
    <url>/2024/10/30/HTMLCSS/html-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><blockquote>
<p>全称是 HyperText Markup Language，即超文本标记语言，它不是编程语言，而是一种用来告知浏览器如何组织页面的标记语言，用来描述网页的表现，展示效果或功能及行为。</p>
</blockquote>
<ul>
<li>超文本(hypertext) 是指连接单个网站或多个网站网页的链接</li>
<li>HTML 使用标记(markup) 来注明文本、图片和其它内容</li>
<li>HTML 通过标签(tag)标记元素，标签由在&lt;和&gt;中包裹的元素名组成</li>
<li>HTML 标签里的元素名不区分大小写</li>
</ul>
<h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><blockquote>
<p>需要在网页中书写特殊的符号，则需要使用 html 中的实体（转义字符）</p>
</blockquote>
<ul>
<li>实体的语法：&amp;实体的名字;</li>
<li>常见的实体：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;nbsp;: 空格</span><br><span class="line">&amp;gt;: &gt;</span><br><span class="line">&amp;lt;: &lt;</span><br><span class="line">&amp;copy;: 版权符号</span><br><span class="line">&amp;quot;: &quot;</span><br><span class="line">&amp;apos;: &#x27;</span><br><span class="line">&amp;amp;: &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h2><ul>
<li>告诉浏览器当前网页的版本</li>
<li>html5 的文档声明: <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!Doctype <span class="keyword">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><h3 id="十进制（日常使用）"><a href="#十进制（日常使用）" class="headerlink" title="十进制（日常使用）"></a>十进制（日常使用）</h3><ul>
<li>特点：满 10 进 1</li>
<li>单位数字：10个 （0-9）</li>
</ul>
<h3 id="二进制（计算机底层的进制）"><a href="#二进制（计算机底层的进制）" class="headerlink" title="二进制（计算机底层的进制）"></a>二进制（计算机底层的进制）</h3><ul>
<li>特点：满 2 进 1</li>
<li>计数：0 1 10 11 100 101 110 111</li>
<li>单位数字：2个 （0-1）</li>
<li>扩展：<ul>
<li>所有数据在计算机底层都会以二进制的形式保存</li>
<li>将内存想象为一个有多个小格子组成的容器，每个小格子中存储一个 1 或一个 0,这个小格子在内存中被称为 1 位（bit）</li>
<li>换算：<ul>
<li>8bit &#x3D; 1byte(字节)</li>
<li>1024byte &#x3D; 1kb(千字节)</li>
<li>1024kb &#x3D; 1mb(兆字节)</li>
<li>1024mb &#x3D; 1gb(吉字节)</li>
<li>1024gb &#x3D; 1tb(特字节)</li>
<li>1024tp &#x3D; 1pb</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h3><ul>
<li>特点：满 8 进 1</li>
<li>单位数字：8 个 （0-7）</li>
</ul>
<h3 id="十六进制-一般显示一个二进制数字时，都会转换为十六进制"><a href="#十六进制-一般显示一个二进制数字时，都会转换为十六进制" class="headerlink" title="十六进制(一般显示一个二进制数字时，都会转换为十六进制)"></a>十六进制(一般显示一个二进制数字时，都会转换为十六进制)</h3><ul>
<li>特点：满 16 进 1</li>
<li>计数：0 1 2 … 9 a b c d e f 10 11 12 …19 1a 1b 1c 1d 1e 1f 20</li>
<li>单位数字：16 个（0-f）</li>
</ul>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><ul>
<li>所有数据在计算机中存储时都是以二进制形式存储的，文字也不例外。</li>
<li>而计算机会将编码转换为字符，供我们阅读</li>
</ul>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul>
<li>将<span class="key_words">『字符』</span>转换为<span class="key_words">『二进制』</span>码的过程</li>
</ul>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><ul>
<li>将<span class="key_words">『二进制』</span>码转换为<span class="key_words">『字符』</span>的过程</li>
</ul>
<h3 id="字符集（charset）"><a href="#字符集（charset）" class="headerlink" title="字符集（charset）"></a>字符集（charset）</h3><ul>
<li>编码和解码所采用的规则</li>
</ul>
<h3 id="乱码问题："><a href="#乱码问题：" class="headerlink" title="乱码问题："></a>乱码问题：</h3><ul>
<li>如果编码和解码所采用的字符集不同就会出现乱码问题</li>
</ul>
<h3 id="常见的字符集："><a href="#常见的字符集：" class="headerlink" title="常见的字符集："></a>常见的字符集：</h3><ul>
<li>ASCII</li>
<li>ISO88591</li>
<li>GB2312</li>
<li>GBK</li>
<li>UTF-8，在开发时我们使用的字符集都是 UTF-8</li>
</ul>
<h2 id="head-的内容"><a href="#head-的内容" class="headerlink" title="head 的内容"></a>head 的内容</h2><h3 id="元数据：元素"><a href="#元数据：元素" class="headerlink" title="元数据：元素"></a>元数据：<meta>元素</h3><ul>
<li>meta: 可提供有关某个 HTML 元素的元信息，比如描述、针对搜索引擎的关键词以及刷新频率</li>
<li>charset：指定网页的字符集<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><a href="https://www.runoob.com/jsref/prop-meta-name.html">name</a>：指定 meta 元素的类型，说明该元素包含的信息。<ul>
<li>keywords：表网站的<span class="key_words">『关键字』</span>，可以同时指定多个关键字，使用,隔开，<span class="desc">SEO相关</span></li>
<li>description：规定页面的<span class="key_words">『描述』</span>。搜索引擎会把这个描述显示在搜索结果中，<span class="desc">SEO相关</span></li>
<li>application-name：规定页面所代表的 Web 应用程序的名称。</li>
<li>author：规定文档的作者的名字。</li>
</ul>
</li>
<li>content：指定的实际的数据内容</li>
<li><a href="https://www.runoob.com/jsref/dom-obj-meter.html">http-equiv</a>：设置或者返回 content 属性中 HTTP 头部信息<ul>
<li>content-type：返回内容的 MIME 类型，通常用于字符集的设置。</li>
<li>refresh：定义间隔多久后刷新页面</li>
</ul>
</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML5,前端,CSS3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;300&quot;</span>&gt;</span> // 定义间隔多久后刷新页面。</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;3;url=https://www.mozilla.org&quot;</span>&gt;</span> // 重定向火狐</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="title-标签"><a href="#title-标签" class="headerlink" title="title 标签"></a>title 标签</h3><ul>
<li>内容会作为搜索结果的超链接上的文字显示</li>
</ul>
<h2 id="表象元素"><a href="#表象元素" class="headerlink" title="表象元素"></a>表象元素</h2><ul>
<li>概念：仅仅影响表象而且没有语义的元素</li>
<li>i标签：被用来传达传统上用斜体表达的意义：外国文字，分类名称，技术术语，一种思想……</li>
<li>b标签：被用来传达传统上用粗体表达的意义：关键字，产品名称，引导句……</li>
<li>u标签：被用来传达传统上用下划线表达的意义：专有名词，拼写错误……</li>
</ul>
<h2 id="标签的属性"><a href="#标签的属性" class="headerlink" title="标签的属性"></a>标签的属性</h2><ul>
<li>在标签中（开始标签或自结束标签）还可以设置属性</li>
<li>属性是一个名值对（x&#x3D;y）</li>
<li>属性用来设置标签中的内容如何显示</li>
<li>属性和标签名或其他属性应该使用空格隔开</li>
<li>如果有属性值，属性值应该使用引号引起来</li>
</ul>
<h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><ul>
<li>语义对无障碍、SEO（搜索引擎优化）等非常重要</li>
</ul>
<h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><ul>
<li>h1 ~ h6标签<ul>
<li>代表分别从一级标题到六级标题</li>
<li>从 h1~h6 重要性递减，h1 最重要，h6 最不重要</li>
<li>h1 在网页中的重要性仅次于 title 标签，一般情况下一个页面中只会有一个 h1</li>
<li>一般情况下标题标签只会使用到 h1 ~ h3，h4 ~ h6 很少用</li>
<li>标题标签都是块元素</li>
</ul>
</li>
<li>hgroup标签<ul>
<li>为标题分组，可以将一组相关的标题同时放入到 hgroup</li>
</ul>
</li>
<li>p标签<ul>
<li>表示页面中的一个段落</li>
<li>p 标签也是一个块元素</li>
</ul>
</li>
<li>em标签(倾斜): 用于表示语音语调的一个加重</li>
<li>strong标签(加粗): 表示强调，重要内容！</li>
<li>blockquote标签: 表示一个长引用</li>
<li>q标签: 表示一个短引用</li>
<li>br标签: 表示页面中的换行</li>
</ul>
<h3 id="块元素-和-行内元素"><a href="#块元素-和-行内元素" class="headerlink" title="块元素 和 行内元素"></a>块元素 和 行内元素</h3><ul>
<li><span class="key_words">『块元素』</span>(block element)：在页面中独占一行的元素<ul>
<li>在网页中一般通过块元素来对页面进行布局</li>
</ul>
</li>
<li><span class="key_words">『行内元素』</span>(inline element)：在页面中不会独占一行的元素<ul>
<li>行内元素主要用来包裹文字</li>
</ul>
</li>
<li>注：<ul>
<li>一般情况下会在块元素中放行内元素，而不会在行内元素中放块元素</li>
<li>块元素中基本上什么都能放</li>
<li>p 元素中不能放任何的块元素</li>
<li>浏览器在解析网页时，会自动对网页中不符合规范的内容进行修正</li>
</ul>
</li>
</ul>
<h3 id="布局标签（结构化语义标签）"><a href="#布局标签（结构化语义标签）" class="headerlink" title="布局标签（结构化语义标签）"></a>布局标签（结构化语义标签）</h3><ul>
<li>header标签：表示网页的头部</li>
<li>main标签：表示网页的主体部分(一个页面中仅一个)</li>
<li>footer标签：表示网页的底部</li>
<li>nav标签：表示网页中的导航</li>
<li>aside标签：和主体相关的其他内容（侧边栏）</li>
<li>article标签：表示一个独立的文章</li>
<li>section标签：表示一个独立的区块，上边的标签都不能表示时使用 section</li>
<li>div标签：无语义，表示一个盒子，主要的布局元素</li>
<li>span标签：行内元素，无语义，用于在网页中选中文字</li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>在 html 中也可以创建列表，html 列表一共有三种：<ol>
<li>有序列表<ul>
<li>使用ol标签来创建有序，带编号列表</li>
<li>使用 li 表示列表项</li>
</ul>
</li>
<li>无序列表<ul>
<li>使用ul标签来创建无序列表</li>
<li>使用 li 表示列表项</li>
</ul>
</li>
<li>定义列表<ul>
<li>使用 dl 标签来创建一个定义列表</li>
<li>使用 dt 来表示定义的内容</li>
</ul>
</li>
</ol>
<ul>
<li>使用 dd 来对内容进行解释说明</li>
</ul>
</li>
<li>列表之间可以互相嵌套</li>
</ul>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><blockquote>
<p>可以让我们从一个页面跳转到其他页面，或者是当前页面的其他的位置</p>
</blockquote>
<ul>
<li>使用 a 标签来定义超链接</li>
<li>属性：<ul>
<li>href 属性<ul>
<li>作用：指定跳转的目标路径</li>
<li>值<ul>
<li>当值为<span class="key_words">『javascript:;』</span>,点击这个超链接什么也不会发生</li>
<li>当值为<span class="key_words">『#』</span>,可以跳到当前页面的顶部的位置</li>
<li>当值为<span class="key_words">『#目标元素的id属性值』</span>,可以跳转到页面的指定位置</li>
</ul>
</li>
</ul>
</li>
<li>target 属性<ul>
<li>作用：用来指定超链接打开的位置</li>
<li>可选值：<ul>
<li>_self：默认值，在当前页面中打开超链接</li>
<li>_blank：在一个新的页面中打开超链接</li>
</ul>
</li>
</ul>
</li>
<li>id 属性（唯一不重复的）<ul>
<li>每一个标签都可以添加一个 id 属性</li>
<li>id 属性就是元素的唯一标识，同一个页面中不能出现重复的 id 属性</li>
</ul>
</li>
</ul>
</li>
<li>行内元素，在 a 标签中可以嵌套除它自身外的任何元素</li>
</ul>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><ul>
<li>跳转一个服务器内部的页面时，一般使用相对路径</li>
<li>相对路径都会<span class="key_words">『使用.&#x2F;或..&#x2F;开头』</span></li>
<li><span class="key_words">『.&#x2F;』</span>：表示<span class="key_words">『当前文件所在的目录』</span>,可以省略不写</li>
<li><span class="key_words">『..&#x2F;』</span>：表示<span class="key_words">『当前文件所在目录的上一级目录』</span></li>
</ul>
<h3 id="常用的例子"><a href="#常用的例子" class="headerlink" title="常用的例子"></a>常用的例子</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 绝对URL</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;07.列表.html&quot;</span>&gt;</span>超链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// 相对URL</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./target.html&quot;</span>&gt;</span>超链接1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;../07.列表.html&quot;</span>&gt;</span>超链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// 值为javascript:;，点击无效果</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>这是一个新的超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// 点击在标签中打开新的页面</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;07.列表.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// 跳到页面容器id为#bottom的位置</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#bottom&quot;</span>&gt;</span>去底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// #回到顶部</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;bottom&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><ul>
<li>作用：向当前页面中引入一个外部图片</li>
<li>使用 img 标签来引入外部图片，img 标签是一个自结束标签</li>
<li>img 这种元素属于替换元素（块和行内元素之间，具有两种元素的特点）</li>
</ul>
<h3 id="img-的属性："><a href="#img-的属性：" class="headerlink" title="img 的属性："></a>img 的属性：</h3><ul>
<li>src：属性指定的是外部图片的路径（路径规则和超链接是一样的）</li>
<li>alt：图片的描述，这个描述默认情况下不会显示，有些浏览器会图片无法加载时显示<br>搜索引擎会根据 alt 中的内容来识别图片，如果不写 alt 属性则图片不会被搜索引擎所收录</li>
<li>width：图片的宽度 (单位是像素)</li>
<li>height：图片的高度 (单位是像素)<ul>
<li>宽度和高度中如果只修改了一个，则另一个会等比例缩放</li>
</ul>
</li>
<li>loading：指定浏览器是应立即加载图像还是延迟加载图像。<ul>
<li>eager：立即加载</li>
<li>lazy：延迟加载</li>
</ul>
</li>
<li>注意：<ul>
<li>一般情况在 pc 端，不建议修改图片的大小，需要多大的图片就裁多大</li>
<li>但是在移动端，经常需要对图片进行缩放（大图缩小）</li>
</ul>
</li>
</ul>
<h3 id="图片的格式："><a href="#图片的格式：" class="headerlink" title="图片的格式："></a>图片的格式：</h3><ul>
<li>jpeg(jpg) – 有损压缩，最流行<ul>
<li>支持的颜色比较丰富，不支持透明效果，不支持动图</li>
<li>一般用来显示照片</li>
</ul>
</li>
<li>gif<ul>
<li>支持的颜色比较少，支持简单透明，支持动图</li>
<li>颜色单一的图片，动图</li>
</ul>
</li>
<li>png  – 无损静态图像首选<ul>
<li>支持的颜色丰富，支持复杂透明，不支持动图</li>
<li>颜色丰富，复杂透明图片（专为网页而生）</li>
</ul>
</li>
<li>webp<ul>
<li>这种格式是谷歌新推出的专门用来表示网页中的图片的一种格式</li>
<li>它具备其他图片格式的所有优点，而且文件还特别的小</li>
</ul>
</li>
<li>apng<ul>
<li>动态可移植网络图形</li>
<li>是无损动画序列的良好选择（GIF 性能较差）。AVIF 和 WebP 性能更好，但浏览器支持较少</li>
</ul>
</li>
<li>avif<ul>
<li>AV1 图像档案格式</li>
<li>性能高，且无需版税。支持静态图像，与 PNG 或 JPEG 相比，它的压缩效果更好。</li>
<li>请注意，在使用 AVIF 时，应包含浏览器支持更好的回退格式（即要使用 picture标签 元素）</li>
</ul>
</li>
<li>svg<ul>
<li>可缩放矢量图形</li>
<li>适用于用户界面元素、图标、图表等</li>
</ul>
</li>
<li>base64<ul>
<li>将图片使用 base64 编码，这样可以将图片转换为字符，通过字符的形式来引入图片</li>
<li>一般都是一些需要和网页一起加载的图片才会使用 base64</li>
</ul>
</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/1.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;松鼠&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h2><h3 id="audio-标签"><a href="#audio-标签" class="headerlink" title="audio 标签"></a>audio 标签</h3><ul>
<li>支持 ie9 以上</li>
<li>用来向页面中引入一个外部的音频文件的</li>
<li>音视频文件引入时，默认情况下不允许用户自己控制播放停止</li>
<li>属性：<ul>
<li>controls: 是否允许用户控制播放</li>
<li>autoplay: 音频文件是否自动播放<ul>
<li>如果设置了 autoplay 则音乐在打开页面时会自动播放</li>
<li>但是目前来讲大部分浏览器都不会自动对音乐进行播放</li>
</ul>
</li>
<li>loop: 音乐是否循环播放</li>
</ul>
</li>
<li>除了通过 src 来指定外部文件的路径以外，还可以通过 source 来指定文件的路径,使用 source 最好指定源是什么 type</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 对不起，您的浏览器不支持播放音频！请升级浏览器！ --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.mp3&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.ogg&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;./source/audio.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mp3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="video-标签"><a href="#video-标签" class="headerlink" title="video 标签"></a>video 标签</h3><ul>
<li>支持 ie9 以上</li>
<li>向网页中引入一个视频</li>
<li>属性:<ul>
<li>controls: 是否允许用户控制播放</li>
<li>autoplay: 音频文件是否自动播放<ul>
<li>如果设置了 autoplay 则音乐在打开页面时会自动播放</li>
<li>但是目前来讲大部分浏览器都不会自动对音乐进行播放</li>
</ul>
</li>
<li>loop: 音乐是否循环播放</li>
<li>width | height: 播放器宽高</li>
<li>poster: “url”: 加载等待的画面图片</li>
<li>muted: 静音播放</li>
</ul>
</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span> <span class="attr">controls</span> <span class="attr">loop</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/flower.webm&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./source/flower.mp4&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;./source/flower.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>知识</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>Html-媒体查询布局</title>
    <url>/2024/10/30/HTMLCSS/html-%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li>通过@media 媒体查询，给不同屏幕的大小编写不同的样式来实现响应式的布局</li>
<li>缺点：工作量大，效率低，代码累赘，以及加载事件过长</li>
<li>语法：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">only</span> (media feature) &#123; css-<span class="selector-tag">code</span> &#125;</span><br></pre></td></tr></table></figure></li>
<li>用法：<ul>
<li>head 标签中引入(限定对应宽度使用对应 css 文件)：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (min-width: 481px) and (max-width: 600px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;small.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>css 中引入：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">1200px</span>) &#123; <span class="selector-tag">body</span> &#123; <span class="attribute">background</span>: red; &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>width | height: 视口的宽高</li>
<li>min-width: 视口的最小宽度（视口大于指定宽度时生效）</li>
<li>max-width: 视口的最大宽度（视口小于指定宽度时生效）</li>
<li>@media: 是关键字</li>
</ul>
<h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><ul>
<li>样式切换的分界点，我们称其为断点，也就是网页的样式会在这个点时发生变化</li>
</ul>
<table>
<thead>
<tr>
<th>常用的断点</th>
<th>代表的尺寸</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>&lt;576px</td>
<td>Extra small</td>
<td>max-width&#x3D;576px</td>
</tr>
<tr>
<td>&gt;&#x3D;576px</td>
<td>Small — sm</td>
<td>min-width&#x3D;769px</td>
</tr>
<tr>
<td>&gt;&#x3D;769px</td>
<td>Medium — md</td>
<td>min-width&#x3D;769px</td>
</tr>
<tr>
<td>&gt;&#x3D;992px</td>
<td>Large — lg</td>
<td>min-width&#x3D;992px</td>
</tr>
<tr>
<td>&gt;&#x3D;1200px</td>
<td>X-Large — xl</td>
<td>min-width&#x3D;1200px</td>
</tr>
<tr>
<td>&gt;&#x3D;1400px</td>
<td>XX-Large — xxl</td>
<td>min-width&#x3D;1400px</td>
</tr>
</tbody></table>
<h3 id="常用的媒体类型-mediatype"><a href="#常用的媒体类型-mediatype" class="headerlink" title="常用的媒体类型(mediatype)"></a>常用的媒体类型(mediatype)</h3><table>
<thead>
<tr>
<th>媒体类型</th>
<th>备注</th>
<th>常用</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>匹配所有设备</td>
<td>是</td>
</tr>
<tr>
<td>print</td>
<td>打印模式</td>
<td>是</td>
</tr>
<tr>
<td>screen</td>
<td>电脑屏幕</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li>not: <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> screen <span class="keyword">and</span> (<span class="attribute">width</span>:<span class="number">888px</span>)&#123;&#125; // 对除了 screen 类型之外的所有设备类型生效。</span><br></pre></td></tr></table></figure></li>
<li>only: <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">width</span>:<span class="number">888px</span>)&#123;&#125; // 只对 screen 类型有效</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="可查询属性（media-feature）"><a href="#可查询属性（media-feature）" class="headerlink" title="可查询属性（media feature）"></a>可查询属性（media feature）</h3><table>
<thead>
<tr>
<th>可查询属性</th>
<th>属性值类型</th>
<th>是否可用前缀</th>
<th>描述</th>
<th>常用</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>整数</td>
<td>是</td>
<td>每一组输出设备的彩色原件个数。不是彩色设备，则等于 0</td>
<td>否</td>
</tr>
<tr>
<td>color-index</td>
<td>整数</td>
<td>是</td>
<td>在输出设备的彩色查询表中的条目数。没有使用彩色查询表，则为 0</td>
<td>否</td>
</tr>
<tr>
<td>width</td>
<td>长度</td>
<td>是</td>
<td>输出设备中的页面可见区域宽度</td>
<td>是</td>
</tr>
<tr>
<td>height</td>
<td>长度</td>
<td>是</td>
<td>输出设备中的页面可见区域高度</td>
<td>是</td>
</tr>
<tr>
<td>device-width</td>
<td>长度</td>
<td>是</td>
<td>输出设备的屏幕可见宽度(设备本身的宽度)</td>
<td>是</td>
</tr>
<tr>
<td>device-height</td>
<td>长度</td>
<td>是</td>
<td>输出设备的屏幕可见高度(设备本身的高度)</td>
<td>是</td>
</tr>
<tr>
<td>grid</td>
<td>整数</td>
<td>否</td>
<td>查询输出设备是否使用栅格或点阵。值：1 代表是，0 代表否</td>
<td>否</td>
</tr>
<tr>
<td>resolution</td>
<td>dpi&#x2F;dpcm</td>
<td>是</td>
<td>设备的分辨率</td>
<td>否</td>
</tr>
<tr>
<td>orientation</td>
<td>portrait&#x2F;landscape</td>
<td>否</td>
<td>height 是否大于或等于 width。portrait(竖屏),landscape(横屏)</td>
<td>是</td>
</tr>
<tr>
<td>aspect-ratio</td>
<td>整数&#x2F;整数</td>
<td>是</td>
<td>width 与 height 的比率(宽高比)</td>
<td>是</td>
</tr>
<tr>
<td>device-aspect-ratio</td>
<td>整数&#x2F;整数</td>
<td>是</td>
<td>(设备的宽高比),常见的显示器比率：4&#x2F;3, 16&#x2F;9, 16&#x2F;10</td>
<td>是</td>
</tr>
<tr>
<td>scan</td>
<td>progressive&#x2F;interlaced</td>
<td>否</td>
<td>电视类设备的扫描工序</td>
<td>否</td>
</tr>
<tr>
<td>monochrome</td>
<td>整数</td>
<td>是</td>
<td>在单色框架缓冲区中每像素包含的单色原件个数。不是单色设备，则为 0</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="移动端常见宽高"><a href="#移动端常见宽高" class="headerlink" title="移动端常见宽高"></a>移动端常见宽高</h3><ul>
<li>竖屏常用宽高比：1:2, 2:3, 3:4, 3:5, 5:8, 9:16</li>
<li>横屏常用宽高比：4:3, 5:3</li>
</ul>
<table>
<thead>
<tr>
<th>宽高</th>
<th>比例</th>
</tr>
</thead>
<tbody><tr>
<td>320×480</td>
<td>2:3</td>
</tr>
<tr>
<td>480×854</td>
<td>约 9:16</td>
</tr>
<tr>
<td>480×800</td>
<td>3:5</td>
</tr>
<tr>
<td>480×640</td>
<td>3:4</td>
</tr>
<tr>
<td>540×960</td>
<td>9:16</td>
</tr>
<tr>
<td>600×1200</td>
<td>1:2</td>
</tr>
<tr>
<td>600×1024</td>
<td>约 9:16</td>
</tr>
<tr>
<td>640×960</td>
<td>2:3</td>
</tr>
<tr>
<td>640×1136</td>
<td>约 9:16</td>
</tr>
<tr>
<td>720×1280</td>
<td>9:16</td>
</tr>
<tr>
<td>768×1024</td>
<td>3:4</td>
</tr>
<tr>
<td>800×480</td>
<td>5:3</td>
</tr>
<tr>
<td>800×1280</td>
<td>5:8</td>
</tr>
<tr>
<td>1080×1920</td>
<td>9:16</td>
</tr>
<tr>
<td>1536×2048</td>
<td>4:3</td>
</tr>
<tr>
<td>1600×2560</td>
<td>5:8</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Html-盒子布局</title>
    <url>/2024/10/30/HTMLCSS/html-%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="文档流-normal-flow"><a href="#文档流-normal-flow" class="headerlink" title="文档流(normal flow)"></a>文档流(normal flow)</h2><blockquote>
<p>网页是一个多层的结构，用户只能看到最顶上一层,最底下的一层称为文档流，文档流是网页的基础</p>
</blockquote>
<ul>
<li>CSS 可以分别为每一层来设置样式</li>
<li>元素默认都是在文档流中进行排列</li>
<li>元素主要有两个状态: 在文档流中 &#x2F; 脱离文档流</li>
<li>元素在文档流的特点：<ul>
<li>块元素：<ul>
<li>在页面中独占一行(自上向下垂直排列)</li>
<li>默认宽度是父元素的全部，默认高度是被内容撑开</li>
</ul>
</li>
<li>行内元素：<ul>
<li>不会独占页面的一行，只占自身的大小(从左向右水平排列，会换行)</li>
<li>行内元素的默认宽度和高度都是被内容撑开</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="盒模型-box-model"><a href="#盒模型-box-model" class="headerlink" title="盒模型(box model)"></a>盒模型(box model)</h2><ul>
<li>一个盒子的大小由以下几个部分组成：<ul>
<li>内容区(content) + 内边距(padding) + 边框(border) + 外边距(margin)</li>
</ul>
</li>
<li>浏览器默认使用标准盒模型</li>
</ul>
<ol>
<li><span class="key_words">『标准盒模型(W3C盒模型)』</span>中 width 和 height 指的是内容区域 content 的宽高<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: content-box;</span><br></pre></td></tr></table></figure></li>
<li><span class="key_words">『怪异盒模型(IE盒模型)』</span>中的 width 和 height 指的是 content + border + padding 的宽高<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为 content 已经包含 border 和 padding，所以这两项不会撑开盒子</li>
</ul>
</li>
</ol>
<h3 id="内容区-content"><a href="#内容区-content" class="headerlink" title="内容区(content)"></a>内容区(content)</h3><ul>
<li>元素中的所有的子元素和文本内容都在内容区中排列</li>
<li>内容区的大小由 width 和 height 两个属性来设置</li>
</ul>
<h3 id="边框-border"><a href="#边框-border" class="headerlink" title="边框(border)"></a>边框(border)</h3><ul>
<li>要设置边框，需要至少设置三个样式：</li>
<li>border-[top | right | bottom | left]简写属性(没有顺序要求):<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: border-width border-style border-color;</span><br></pre></td></tr></table></figure>
<ul>
<li>边框的宽度：border-[top | right | bottom | left]-width<ul>
<li>默认值为 3px</li>
<li>值的情况<ul>
<li>四个值：上 右 下 左</li>
<li>三个值：上 左右 下</li>
<li>两个值：上下 左右</li>
<li>一个值：上下左右</li>
</ul>
</li>
</ul>
</li>
<li>边框的颜色：border-color<ul>
<li>值的情况与 border-width 一样</li>
</ul>
</li>
<li>边框的样式：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-style</span>: none | <span class="built_in">solid</span>(实) | <span class="built_in">dotted</span>(点) | <span class="built_in">dashed</span>(虚) | <span class="built_in">double</span>(双)</span><br></pre></td></tr></table></figure></li>
<li>圆角半径：border-[top | bottom]-[left | right]-radius<ul>
<li>值情况：<ul>
<li>两个值：左上&#x2F;右下 右上&#x2F;左下</li>
<li>三个值：左上 右上&#x2F;左下 右下</li>
<li>四个值：左上 右上 右下 左下</li>
</ul>
</li>
</ul>
</li>
<li>元素的阴影：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: 水平偏移量(正值向右,负值向左) 垂直偏移量(正值向下,负值向上) 模糊半径 颜色</span><br></pre></td></tr></table></figure>
<ul>
<li>不会影响页面布局</li>
</ul>
</li>
<li>轮廓：outline：常用来设置 hover 效果。与 border 一样，但轮廓不会占用空间和影响元素位置大小</li>
</ul>
</li>
</ul>
<h3 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距(padding)"></a>内边距(padding)</h3><ul>
<li>padding-[top | right | bottom | left]</li>
<li>背景颜色会延伸到内边距上</li>
</ul>
<h3 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距(margin)"></a>外边距(margin)</h3><ul>
<li>margin-[top | right | bottom | left]</li>
<li>元素在页面中是按照自左向右的顺序排列的，所以默认情况下设置左、上会移动元素自身,而设置下、右会移动其他元素</li>
</ul>
<h2 id="盒子的布局"><a href="#盒子的布局" class="headerlink" title="盒子的布局"></a>盒子的布局</h2><h3 id="水平布局-—-width-xxx-margin-0-auto"><a href="#水平布局-—-width-xxx-margin-0-auto" class="headerlink" title="水平布局 — width:xxx; margin:0 auto;"></a>水平布局 — width:xxx; margin:0 auto;</h3><ul>
<li>一个元素在其父元素中，水平布局必须要满足以下的等式，如果相加结果使等式不成立，则称为过度约束，则等式会自动调整<ul>
<li>margin-left+border-left+padding-left+width+padding-right+border-right+margin-right &#x3D; 其父元素内容区的宽度</li>
</ul>
</li>
<li>调整的情况：<ul>
<li>如果这七个值中<span class="key_words">『没有为 auto』</span>的情况，则浏览器会<span class="key_words">『自动调整margin-right』</span>值以使等式满足</li>
<li>这七个值中有三个值和设置为 auto<ul>
<li>width</li>
<li>margin-left</li>
<li>maring-right</li>
</ul>
</li>
<li><span class="key_words">『某个值为auto，则会自动调整为auto的那个值』</span></li>
<li><span class="key_words">『宽度和一个外边距设置为auto，则宽度会调整到最大，设置为 auto 的外边距会自动为0』</span></li>
<li><span class="key_words">『三个值都设置为auto，则外边距都是0，宽度最大』</span></li>
<li><span class="key_words">『两个外边距设置为auto，宽度固定值，则会将外边距设置为相同的值』</span></li>
</ul>
</li>
<li><span class="key_words">『开启了绝对定位』</span>后:<ul>
<li>水平方向的布局等式就需要添加 left 和 right 两个值</li>
<li>当发生过度约束：<ul>
<li>如果 9 个值中没有 auto 则自动调整 right 值以使等式满足</li>
<li>如果有 auto，则自动调整 auto 的值以使等式满足</li>
<li>可设置 auto 的值：margin、width、left、right</li>
<li>因为 left 和 right 的值默认是 auto，所以如果不指定 left 和 right 则等式不满足时，会自动调整这两个值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="垂直布局"><a href="#垂直布局" class="headerlink" title="垂直布局"></a>垂直布局</h3><ul>
<li>默认情况下父元素的高度被内容撑开</li>
<li>子元素是在父元素的内容区中排列的，如果子元素大小超过父元素，则子元素会从父元素中溢出</li>
<li>使用 overflow 属性来设置父元素如何处理溢出的子元素<ul>
<li>可选值：<ul>
<li>visible：默认值 子元素会从父元素中溢出，在父元素外部的位置显示</li>
<li>hidden：溢出内容将会被裁剪不会显示</li>
<li>scroll：生成两个滚动条，通过滚动条来查看完整的内容</li>
<li>auto：根据需要生成滚动条</li>
<li>还可以单独对 x 和 y 方向的内容做溢出处理<ul>
<li>overflow-x，overflow-y</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><span class="key_words">『开启了绝对定位』</span>后:<ul>
<li>垂直方向布局的等式的也必须要满足<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top + margin-top/bottom + padding-top/bottom + border-top/bottom + height = 包含块的高度</span><br></pre></td></tr></table></figure></li>
<li>用 margin-left,margin-right 的话必须设置 left:0,right:0</li>
</ul>
</li>
</ul>
<h3 id="垂直外边距的重叠（折叠）"><a href="#垂直外边距的重叠（折叠）" class="headerlink" title="垂直外边距的重叠（折叠）"></a>垂直外边距的重叠（折叠）</h3><ul>
<li>相邻的垂直方向外边距会发生重叠现象</li>
<li>兄弟元素(<span class="desc">对开发有利，不需要处理</span>)<ul>
<li>兄弟元素间的相邻垂直外边距，则取两者之间<span class="key_words">『绝对值较大的』</span></li>
<li>特殊情况：如果相邻的外边距<span class="key_words">『一正一负』</span>，则取两者的<span class="key_words">『和』</span></li>
</ul>
</li>
<li>父子元素(<span class="desc">影响布局，必须处理</span>)<ul>
<li>父子元素间的相邻垂直外边距，子元素的会传递给父元素（上外边距）</li>
</ul>
</li>
</ul>
<h2 id="行内元素的盒模型"><a href="#行内元素的盒模型" class="headerlink" title="行内元素的盒模型"></a>行内元素的盒模型</h2><ul>
<li>行内元素不支持设置宽高</li>
<li>行内元素可以设置 padding、margin、border，但是垂直方向都不会影响页面的布局</li>
</ul>
<h3 id="display：用来设置元素显示的类型"><a href="#display：用来设置元素显示的类型" class="headerlink" title="display：用来设置元素显示的类型"></a>display：用来设置元素显示的类型</h3><ul>
<li>inline：将元素设置为行内元素</li>
<li>block：将元素设置为块元素</li>
<li>inline-block：将元素设置为行内块元素，即可以设置宽度和高又不会独占一行</li>
<li>table：将元素设置为一个表格</li>
<li>none：元素不在页面中显示</li>
</ul>
<h3 id="visibility：用来设置元素的显示状态"><a href="#visibility：用来设置元素的显示状态" class="headerlink" title="visibility：用来设置元素的显示状态"></a>visibility：用来设置元素的显示状态</h3><ul>
<li>visible：默认值，元素在页面中正常显示</li>
<li>hidden：元素在页面中<span class="key_words">『隐藏不显示，但是依然占据页面的位置』</span></li>
</ul>
<h2 id="默认样式和重置样式表"><a href="#默认样式和重置样式表" class="headerlink" title="默认样式和重置样式表"></a>默认样式和重置样式表</h2><h3 id="默认样式："><a href="#默认样式：" class="headerlink" title="默认样式："></a>默认样式：</h3><ul>
<li>浏览器为元素设置的样式，这写样式会影响到页面布局，通常情况下要去除</li>
</ul>
<h3 id="重置样式表"><a href="#重置样式表" class="headerlink" title="重置样式表"></a>重置样式表</h3><ul>
<li>专门用来对浏览器的样式进行重置的</li>
<li>reset.css：直接去除了浏览器的默认样式</li>
<li>normalize.css：对默认样式进行了统一</li>
</ul>
<h2 id="像素与视口"><a href="#像素与视口" class="headerlink" title="像素与视口"></a>像素与视口</h2><h3 id="像素："><a href="#像素：" class="headerlink" title="像素："></a>像素：</h3><ul>
<li>屏幕是由一个一个的点构成，这一个个的点就是像素</li>
<li>分辨率：1920 x 1080 说的就是屏幕中点的数量</li>
<li>在前端开发中像素要分成两种情况讨论：CSS像素 和 物理像素<ul>
<li>物理像素，上述所说的点就属于物理像素</li>
<li>CSS 像素，编写网页时，所用像素都是 CSS 像素</li>
</ul>
</li>
<li>浏览器在显示网页时，需要将 CSS 像素转换为物理像素然后再呈现<ul>
<li>一个 css 像素最终由几个物理像素显示，由浏览器决定</li>
<li>默认情况下在 pc 端，<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个 css 像素 = 一个物理像素</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="视口-viewport"><a href="#视口-viewport" class="headerlink" title="视口(viewport)"></a>视口(viewport)</h3><ul>
<li>视口就是屏幕中用来显示网页的区域</li>
<li>默认情况下：css 像素和物理像素的比是 1:1</li>
<li>放大两倍的情况：<ul>
<li>视口宽度：960px（CSS 像素）、1920px（物理像素）</li>
<li><ul>
<li>此时，css 像素和物理像素的比是 1:2</li>
</ul>
</li>
</ul>
</li>
<li>通过改变视口的大小，可以改变 CSS 像素和物理像素的比值</li>
</ul>
<h3 id="移动端网页"><a href="#移动端网页" class="headerlink" title="移动端网页"></a>移动端网页</h3><ul>
<li>在不同的屏幕，单位像素的大小是不同的，像素越小屏幕会越清晰</li>
<li>智能手机的像素点 远远小于 计算机的像素点</li>
<li>移动端默认的视口大小是 980px(css 像素)，</li>
<li>默认情况下，移动端的像素比就是 980&#x2F;移动端宽度</li>
<li>可以通过 meta 标签来设置视口大小</li>
<li>将网页的视口设置为完美视口 (<span class="desc">移动端网页必备</span>)<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>不同的设备完美视口的大小是不一样的，所以在移动端开发时，就不能再使用 px 来进行布局了</li>
<li>使用 vw 来表示的是视口的宽度（viewport width）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100vw = 一个视口的宽度</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Html-表格表单篇</title>
    <url>/2024/10/30/HTMLCSS/html-%E8%A1%A8%E5%8D%95%E8%A1%A8%E6%A0%BC%E7%AF%87/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><ul>
<li>table标签：创建一个表格</li>
<li>tr标签：在 table标签 中使用表示表格中的一行，有几个 tr 就有几行</li>
<li>th标签：在 tr标签 中使用表示表头中的单元格,也可以当作是加粗的 td</li>
<li>td标签：在 tr标签 中使用表示一个单元格，有几个 td 就有几个单元格</li>
<li>在 td标签 中使用的属性：<ul>
<li>rowspan&#x3D;”number”：纵向的合并单元格<ul>
<li>注意：<span class="desc">rowspan&#x3D;”0”,告知浏览器使单元格横跨到表格组件中的最后一个行(thead、tbody 或 tfoot)</span></li>
</ul>
</li>
<li>colspan&#x3D;”number”：横向的合并单元格<ul>
<li>注意：colspan&#x3D;”0”,告知浏览器使单元格横跨到列组 (colgroup) 的最后一列。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="长表格"><a href="#长表格" class="headerlink" title="长表格"></a>长表格</h3><ul>
<li>thead标签：表格的头部，在 table标签 中使用，包裹 tr标签 的代码&#96;</li>
<li>tbody标签：表格的主体，在 table标签 中使用，包裹 tr标签 的代码&#96;</li>
<li>tfoot标签：表格的底部，在 table标签 中使用，包裹 tr标签 的代码&#96;</li>
<li>注意：<span class="desc">如果没有用到以上标签，浏览器会自动向 table 中添加一个 tbody<br>并将所有的 tr 都放到 tbody 中，<span class="key_words">『tr是tbody的子元素，不是table的子元素』</span></li>
<li>使用这三个标签创建的表格，在打印时，会在<span class="key_words">『每页都打印表格的头部和底部』</span></li>
<li>无论编写到什么位置，thead 中的内容，<span class="key_words">『永远都会显示在表格的头部』</span></li>
<li>而 tfoot 中的内容，<span class="key_words">『永远都会显示在表格的底部』</span></li>
<li>caption标签: 表格标题，在表格外底部显示</li>
</ul>
<h3 id="表格样式"><a href="#表格样式" class="headerlink" title="表格样式"></a>表格样式</h3><ul>
<li>可以设置宽高</li>
<li>可以设置边框 border</li>
<li>border-spacing：设置表格边框之间的距离</li>
<li>border-collapse：设置表格的边框的合并<ul>
<li>如果将值设置 collapse，则 table 和 td 的边框将会自动合并为一个</li>
<li>当设置了边框合并以后，border-spacing 将自动失效</li>
</ul>
</li>
<li>默认情况下元素在 td 中是垂直居中的 可以通过 vertical-align 来修改</li>
<li>display: table-cell;：将元素设置为单元格 td</li>
</ul>
<h3 id="表格嵌套"><a href="#表格嵌套" class="headerlink" title="表格嵌套"></a>表格嵌套</h3><ul>
<li>在一个表格中也可以嵌套其他的表格</li>
<li>表格布局，布局简单，但是维护麻烦，所以现在已经很少有人用</li>
<li>表格的列数由 td 最多的那个 tr 来决定</li>
<li>总结：table 嵌套 table</li>
</ul>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="form标签：创建一个表单"><a href="#form标签：创建一个表单" class="headerlink" title="form标签：创建一个表单"></a>form标签：创建一个表单</h3><ul>
<li>属性：<ul>
<li>action&#x3D;””：<span class="key_words">『form的必须的属性』</span>，需要一个服务器的地址，提交表单时表单中的内容将会被提交到该地址</li>
<li>autocomplete&#x3D;”off”：关闭自动补全</li>
</ul>
</li>
</ul>
<h3 id="input标签-创建一个表单项"><a href="#input标签-创建一个表单项" class="headerlink" title="input标签: 创建一个表单项"></a>input标签: 创建一个表单项</h3><ul>
<li>默认用户添加的内容将会以<span class="key_words">『查询字符串(url地址?后边的内容)』</span>的形式发送给服务器</li>
<li>查询字符实际上就是键值对结构，多个键值对之间使用&amp;隔开：<ul>
<li>键：表单项指定的 name 属性值</li>
<li>值：用户填写的内容</li>
</ul>
</li>
<li>属性：<ul>
<li>name&#x3D;””：用户填写的名字，服务器根据这个来获取用户填写内容</li>
<li>value&#x3D;””：为文本框指定一个默认值</li>
<li>checked：选项按钮的默认选中状态</li>
<li>readonly：将表单项设置为只读，数据会提交</li>
<li>disabled：将表单项设置为禁用，数据不会提交</li>
<li>autofocus：设置表单项自动获取焦点</li>
<li>type：指定表单项类型</li>
<li>required: 必填</li>
<li>placeholder&#x3D;””: 文本提示，value 有值则不显示</li>
<li>multiple: 多选文件提交</li>
</ul>
</li>
<li>示例 和 type 类型：<table>
<tr>
  <th>属性值</th>
  <th>示例</th>
</tr>
<tr>
  <td>button</td>
  <td>按钮: <input type="button" value="按钮"></td>
</tr>
<tr>
  <td>checkbox</td>
  <td>复选框：<input type="checkbox"></td>
</tr>
<tr>
  <td>radio</td>
  <td>单选：<input type="radio"><br />
通过name属性来分组的，相同的name属于一组</td>
</tr>
<tr>
  <td>email</td>
  <td>邮箱：<input type="email"></td>
</tr>
<tr>
  <td>url</td>
  <td>网址：<input type="url"></td>
</tr>
<tr>
<td>password</td>
<td>密码框：<input type="password"></td>
</tr>
<tr>
<td>text</td>
<td>默认文本框：<input type="text"></td>
</tr>
<tr>
  <td>number</td>
  <td>步进器：<input type="number"></td>
</tr>
<tr>
  <td>tel</td>
  <td>手机号码：<input type="tel"></td>
</tr>
<tr>
  <td>search</td>
  <td>搜索框：<input type="search"></td>
</tr>
<tr>
  <td>datetime-local</td>
  <td>日期时间： <input type="datetime-local"></td>
</tr>
<tr>
  <td>date</td>
  <td>日历-日期：<input type="date"></td>
</tr>
<tr>
  <td>time</td>
  <td>时间：<input type="time"></td>
</tr>
<tr>
  <td>month</td>
  <td>日历-年月：<input type="month"></td>
</tr>
<tr>
  <td>week</td>
  <td>日历-周：<input type="week"></td>
</tr>
<tr>
  <td>color</td>
  <td>颜色块：<input type="color"></td>
</tr>
<tr>
  <td>file</td>
  <td>文件：<input type="file"></td>
</tr>
<tr>
  <td>hidden</td>
  <td>隐形控件：<input hidden></td>
</tr>
<tr>
  <td>image</td>
  <td><input type="image" src="" alt="链接失效"></td>
</tr>
<tr>
<td>range</td>
<td>范围控件：<input type="range"></td>
</tr>
<tr>
<td>reset</td>
<td>重置：<input type="reset"></td>
</tr>
<tr>
  <td>submit</td>
  <td>form中做提交：<input type="submit"></td>
</tr>
</table></li>
</ul>
<h3 id="button-标签"><a href="#button-标签" class="headerlink" title="button 标签"></a>button 标签</h3><ul>
<li>创建按钮，和 input 创建的按钮功能一致，但比它灵活</li>
<li>属性也一致<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>单纯的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h3><ul>
<li>使用 select 来创建一个下拉列表</li>
<li>使用 option 标签来创建下拉列表中的选项</li>
<li>下拉列表的 name 属性需要指定给 select 标签，value 属性需要指定给 option<ul>
<li>selected：option 默认选中</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&#x27;star&#x27;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&#x27;ym&#x27;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span></span></span><br><span class="line"><span class="tag">		<span class="attr">value</span>=<span class="string">&#x27;wyb&#x27;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">selected</span></span></span><br><span class="line"><span class="tag">	&gt;</span></span><br><span class="line">		wyb</span><br><span class="line">	<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&#x27;xxx&#x27;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>表单表格</tag>
      </tags>
  </entry>
  <entry>
    <title>Html-页面布局技术篇</title>
    <url>/2024/10/30/HTMLCSS/html-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E6%8A%80%E6%9C%AF%E7%AF%87/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="布局类型"><a href="#布局类型" class="headerlink" title="布局类型"></a>布局类型</h2><ul>
<li>💚 自适应布局<ul>
<li>百分比布局</li>
<li><a href="/2024/10/30/HTMLCSS/html-Flex%E5%B8%83%E5%B1%80/" title="Html-弹性布局（Flex）">弹性布局(Flex)</a></li>
<li>rem 布局</li>
<li>vw、vh 布局</li>
</ul>
</li>
<li>💚 响应式布局<ul>
<li><a href="/2024/10/30/HTMLCSS/html-%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%B8%83%E5%B1%80/" title="Html-媒体查询布局">媒体查询</a></li>
</ul>
</li>
<li>静态布局(固定布局)</li>
<li>流式布局(Flow) - <span class="desc">默认网页模型, CSS 盒布局模型</span><ul>
<li>块级元素自上而下垂直分布，默认状态下，块级元素的宽度为 100%，占整行</li>
<li>内联元素会在所处的最近父级容器元素内从左到右水平分布</li>
</ul>
</li>
<li><a href="/2024/10/30/HTMLCSS/html-float%E5%B8%83%E5%B1%80/" title="Html-浮动布局(Float)">浮动布局(Float)</a> - <span class="desc">CSS 盒布局模型</span></li>
<li>Layer 布局(定位) - <span class="desc">CSS 盒布局模型</span></li>
</ul>
<hr>
<h2 id="自适应和响应式"><a href="#自适应和响应式" class="headerlink" title="自适应和响应式"></a>自适应和响应式</h2><h3 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h3><ul>
<li>特点：不管屏幕大小(分辨率)怎么变化，页面的元素的位置会变化而大小不会变化。</li>
<li>方法：<ul>
<li>使用 flex 布局</li>
<li>使用百分比</li>
<li>避免写死宽高</li>
<li>使用 rem</li>
</ul>
</li>
</ul>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><ul>
<li>特点：在同一套项目中做兼容(设计多个方案和不同方案对应的样式)</li>
<li>方法：使用 @media 媒体查询 和网格系统 (Grid System) 配合相对布局单位进行布局</li>
<li>优点：面对不同的分辨率设备灵活性强，适合中小型网站</li>
<li>缺点：如果浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐</li>
</ul>
<h3 id="自适应与响应式的区别"><a href="#自适应与响应式的区别" class="headerlink" title="自适应与响应式的区别"></a>自适应与响应式的区别</h3><ul>
<li>响应式是先@media 确定设备，再有需要的地方，css 用上%或者 vw，vh 等</li>
<li>自适应是属于 pc、手机等设备都做一套设计</li>
</ul>
<h2 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h2><ul>
<li>视窗变化时，height、width、padding、margin、border 都是依托父组件的宽高，并且单位为%</li>
<li>子元素的 margin、padding 为百分比参照父级容器的宽度</li>
<li>border-radius 为百分比，则是相对于自身的宽度</li>
<li>子元素的 top、bottom|(right、left)为百分比则相对于非 static 定位的父元素的高度|(宽度)。</li>
<li>缺点：计算困难</li>
</ul>
<h2 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h2><ul>
<li>本质是<span class="key_words">『等比缩放，依赖于整体的html根标签』</span>，通常用来适配<span class="key_words">『移动端』</span>布局，字体，图片高度</li>
<li>缺点：<ul>
<li>数据量大：所有图片，盒子都需要给一个准确的值，才能保证不同机型的适配</li>
<li>在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小，即 css 样式和 js 代码有一定的耦合性，且必须将改变 font-size 的代码放在 css 样式之前</li>
</ul>
</li>
<li>解决：使用 flexible.js 插件</li>
</ul>
<h2 id="vw、vh-布局"><a href="#vw、vh-布局" class="headerlink" title="vw、vh 布局"></a>vw、vh 布局</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1vw(vh) = (视窗宽度(高度) / 100)px</span><br></pre></td></tr></table></figure>

<h2 id="静态布局-—-定宽"><a href="#静态布局-—-定宽" class="headerlink" title="静态布局 — 定宽"></a>静态布局 — 定宽</h2><ul>
<li>特点：常规 pc 网站都是静态布局，即就是设置了 min-width,小于宽度出滚动条，大于内容居中加背景。</li>
<li>方法：<ul>
<li>PC：居中布局，所有样式使用绝对宽度&#x2F;高度(px)，设计一个 Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；</li>
<li>移动设备：另外建立移动网站，单独设计一个布局，使用不同的域名如 wap.或 m.。</li>
</ul>
</li>
<li>在移动端开发中采用静态布局的两种方式：(来自：流布局与响应式网页设计有什么区别？)<ul>
<li>在 viewport meta 标签上设置 width&#x3D;320，页面的各个元素也采用 px 作为单位。通过用 JS 动态修改标签的 initial-scale 使得页面等比缩放，从而刚好占满整个屏幕。</li>
<li>在 viewport meta 标签上设置 content&#x3D;”width&#x3D;640,user-scalable&#x3D;no”，页面的各个元素也采用 px 作为单位。由于 640px 超出了手机宽度，浏览器会自动缩小页面至刚好全屏。</li>
</ul>
</li>
<li>缺点：不能根据用户的屏幕尺寸做出不同的表现。</li>
</ul>
<h2 id="定位（Layer-布局-—-层级布局模型）"><a href="#定位（Layer-布局-—-层级布局模型）" class="headerlink" title="定位（Layer 布局 — 层级布局模型）"></a>定位（Layer 布局 — 层级布局模型）</h2><h3 id="相对定位（relative）"><a href="#相对定位（relative）" class="headerlink" title="相对定位（relative）"></a>相对定位（relative）</h3><ul>
<li>该属性本身不做任何事，但可以用 top、left 来操作它的位置</li>
</ul>
<ol>
<li>相对于元素自身在文档流中的位置进行定位</li>
<li>相对定位的元素<span class="key_words">『不会脱离文档流』</span>&gt;，定位元素的性质不会改变，块还是块，内联还是内联</li>
<li>如果不设置偏移量，元素不会发生任何的变化</li>
<li>会提升元素的层级</li>
</ol>
<h3 id="绝对定位（absolute）"><a href="#绝对定位（absolute）" class="headerlink" title="绝对定位（absolute）"></a>绝对定位（absolute）</h3><ul>
<li>将元素移除正常布局，屏幕滚动时也会跟着滚动。</li>
</ul>
<ol>
<li>开启绝对定位后，如果不设置偏移量元素的位置不会发生变化</li>
<li>开启绝对定位后，<span class="key_words">『元素脱离文档流中』</span></li>
<li>绝对定位会改变元素的性质，行内变成块，块的宽高被内容撑开</li>
<li>绝对定位会使元素提升一个层级</li>
<li>绝对定位元素是相对于包含块进行定位的，使用 left、right、top、bottom 操作</li>
</ol>
<ul>
<li>包含块(containing block)<ul>
<li>正常情况下，包含块就是离当前元素最近的祖先块元素</li>
<li>绝对定位的包含块:<ul>
<li>包含块就是离它最近的开启了定位的祖先元素，</li>
</ul>
</li>
<li>如果所有的祖先元素都没有开启定位则根元素就是它的包含块<ul>
<li>html（根元素、初始包含块）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="固定定位（fixed）"><a href="#固定定位（fixed）" class="headerlink" title="固定定位（fixed）"></a>固定定位（fixed）</h3><ul>
<li>固定定位也是一种绝对定位，和绝对定位是大致相同的</li>
<li>不同的是：<ul>
<li>fixed 永远相对于浏览器窗口进行定位</li>
<li>fixed 会固定在浏览器的指定的位置，不会随页面一起滚动</li>
</ul>
</li>
</ul>
<h3 id="粘滞定位（sticky）"><a href="#粘滞定位（sticky）" class="headerlink" title="粘滞定位（sticky）"></a>粘滞定位（sticky）</h3><ul>
<li>粘滞定位和相对定位的特点基本一致</li>
<li>不同的是粘滞定位可以在元素到达某个位置时将其固定</li>
<li>理解：在页面中的某个位置设置后，当滚动到顶部时，层级最高,固定在顶部，滚回来后回到原来的位置</li>
</ul>
<h3 id="偏移量（offset）"><a href="#偏移量（offset）" class="headerlink" title="偏移量（offset）"></a>偏移量（offset）</h3><ul>
<li>当元素开启了定位以后，可以通过偏移量来设置元素的位置<ul>
<li>top：相对于定位位置的顶部的偏移量</li>
<li>bottom：相对于定位位置的底部的偏移量</li>
<li>定位元素垂直方向的位置由 top 和 bottom 两个属性来控制</li>
<li>left：相对于定位位置的左侧的偏移量</li>
<li>right：相对于定位位置的右侧的偏移量</li>
<li>定位元素水平方向的位置由 left 和 right 两个属性来控制</li>
<li>一般只需要使用两个值即可给元素进行定位<ul>
<li>top left</li>
<li>top right</li>
<li>bottom left</li>
<li>bottom right</li>
</ul>
</li>
<li>偏移量也可以指定一个负值，如果是负值则元素会向相反的方向移动</li>
</ul>
</li>
</ul>
<h3 id="层级（z-index-number-）"><a href="#层级（z-index-number-）" class="headerlink" title="层级（z-index: number;）"></a>层级（z-index: number;）</h3><ul>
<li>需要一个正整数作为参数，值越大层级越高，层级越高越优先显示</li>
<li>如果层级一样，则后边的会盖住前边的，父元素永远都不会盖住子元素。</li>
<li><span class="key_words">『文档流 &lt; 浮动 &lt; 定位』</span></li>
</ul>
<h3 id="元素的透明"><a href="#元素的透明" class="headerlink" title="元素的透明"></a>元素的透明</h3><ul>
<li>使用 opacity 来设置元素的透明度<ul>
<li>需要一个 0-1 之间的值</li>
<li>0 表示完全透明</li>
<li>1 表示完全不透明</li>
</ul>
</li>
<li>IE8 及以下的浏览器不支持该样式，需要使用如下方式来设置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=透明度);</span><br></pre></td></tr></table></figure>
<ul>
<li>需要一个 0-100 之间的值</li>
<li>0 表示完全透明</li>
<li>100 表示完全不透明</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Html-html5和CSS3新特性</title>
    <url>/2024/10/30/HTMLCSS/html5%E5%92%8CCSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>概念： HTML5 的语义化指的是<span class="key_words">『合理正确的使用语义化的标签』</span>来创建页面结构</p>
</blockquote>
<h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><ul>
<li>语义化标签</li>
<li>多媒体标签(audio,video) <a href="html%E5%9F%BA%E7%A1%80.md">点击，页面最底部</a></li>
<li>input 属性值</li>
<li>表单属性 — <a href="html%20-%20%E8%A1%A8%E5%8D%95%E8%A1%A8%E6%A0%BC%E7%AF%87.md">点击，查看更多详情</a></li>
<li>canvas &#x2F; webGL</li>
<li>拖拽释放 API</li>
<li>history API</li>
<li>requestAnimationFrame</li>
<li>地理位置 API</li>
<li>webSocket</li>
<li>web 存储：localStorange、SessionStorage — <a href="/2024/10/31/JS/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" title="浏览器缓存">点击，查看并阅读浏览器缓存</a></li>
<li>css3 特性<ul>
<li>属性选择器</li>
<li>伪类选择器</li>
<li>伪元素选择器 — <a href="/2024/10/30/HTMLCSS/html-%E8%A1%A8%E5%8D%95%E8%A1%A8%E6%A0%BC%E7%AF%87/" title="Html-表格表单篇">点击，查看更多选择器知识</a></li>
<li>盒子模型 —<a href="/2024/10/30/HTMLCSS/html-%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80/" title="Html-盒子布局">点击，查看更多盒子知识</a></li>
<li>模糊滤镜 filter —</li>
<li>calc 函数： 声明属性值时执行简单计算<ul>
<li>如：width：calc(100%-80px) 表示子盒永远比父盒小 80 像素</li>
</ul>
</li>
<li>过度效果 transtion: 变化的属性 花费时间 运动曲线 何时开始;</li>
</ul>
</li>
</ul>
<h3 id="语义化标签："><a href="#语义化标签：" class="headerlink" title="语义化标签："></a>语义化标签：</h3><ul>
<li><p>header: 头部标签</p>
</li>
<li><p>nav：导航栏标签</p>
</li>
<li><p>main: 创建网页的主体</p>
</li>
<li><p>article：内容标签</p>
</li>
<li><p>section：定义文档某个区域</p>
</li>
<li><p>aside：侧边栏标签</p>
</li>
<li><p>footer：底部标签</p>
</li>
<li><p>优点：</p>
<ul>
<li>代码结构清晰</li>
<li>利于开发和维护</li>
<li>有利于搜索引擎优化(SEO)</li>
<li>在没有 CSS 样式的情况下，页面整体也会呈现很好的结构效果</li>
</ul>
</li>
</ul>
<h3 id="input-属性值-type"><a href="#input-属性值-type" class="headerlink" title="input 属性值 type"></a>input 属性值 type</h3><table>
<tr>
    <th>属性值</th>
    <th>说明</th>
    <th>示例</th>
</tr>
<tr>
    <td>email</td>
    <td>限制用户输入必须为 Email 类型</td>
    <td>邮箱：<input type="email"></td>
</tr>
<tr>
    <td>url</td>
    <td>限制用户输入必须为 URL 类型</td>
    <td>网址：<input type="url"></td>
</tr>
<tr>
    <td>date</td>
    <td>限制用户输入必须为 日期 类型</td>
    <td>日历-日期：<input type="date"></td>
</tr>
<tr>
    <td>time</td>
    <td>限制用户输入必须为 时间 类型</td>
    <td>时间：<input type="time"></td>
</tr>
<tr>
    <td>month</td>
    <td>限制用户输入必须为 月份 类型</td>
    <td>日历-年月：<input type="month"></td>
</tr>
<tr>
    <td>week</td>
    <td>限制用户输入必须为 周 类型</td>
    <td>日历-周：<input type="week"></td>
</tr>
<tr>
    <td>number</td>
    <td>限制用户输入必须为 Number 类型</td>
    <td>步进器：<input type="number"></td>
</tr>
<tr>
    <td>tel</td>
    <td>手机号码</td>
    <td>手机号码：<input type="tel"></td>
</tr>
<tr>
    <td>search</td>
    <td>搜索框</td>
    <td>搜索框：<input type="search"></td>
</tr>
<tr>
    <td>color</td>
    <td>生成一个颜色表单</td>
    <td>颜色块：<input type="color"></td>
</tr>
<tr>
    <td>submit</td>
    <td>提交按钮</td>
    <td>form中做提交：<input type="submit"></td>
</tr>
</table>

<h3 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h3><table>
<tr>
    <th>属性值</th>
    <th>说明</th>
    <th>示例</th>
</tr>
<tr>
    <td>required</td>
    <td>必填</td>
</tr>
<tr>
    <td>autofocus</td>
    <td>页面加载完自动聚焦指定表单</td>
</tr>
<tr>
    <td>autocomplete: on/off</td>
    <td>浏览器基于之前键入的值，默认显示已填写的选项，只有name+成功提交才算键入过</td>
</tr>
<tr>
    <td>placeholder:""</td>
    <td>文本提示，value有值则不显示</td>
    <td><input type="search" name="sea" id="" requird placeholder="请填写" autofocus autocomplete="off"></td>
</tr>
<tr>
    <td>multiple</td>
    <td>多选文件提交</td>
    <td><input type="file" name="" id="" multiple></td>
</tr>
</table>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>案例-光影特效</title>
    <url>/2024/10/30/HTMLCSS/%E6%A1%88%E4%BE%8B%20-%20%E5%85%89%E5%BD%B1%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="彩色投影"><a href="#彩色投影" class="headerlink" title="彩色投影"></a>彩色投影</h2><ul>
<li>方式一：<ul>
<li>给父元素添加 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">background</span>: <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>给子元素添加 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">background</span>:inherit; </span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">10px</span>) <span class="built_in">brightness</span>(<span class="number">80%</span>) <span class="built_in">opacity</span>(<span class="number">0.8</span>); </span><br><span class="line"><span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>方式二：使用 box-shadow, 父元素直接使用<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">3px</span> <span class="number">12px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">173</span>, <span class="number">181</span>, <span class="number">0.8</span>);</span><br></pre></td></tr></table></figure></li>
<li>方式一示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#bfa</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.children</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background</span>: inherit;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">10px</span>) <span class="built_in">brightness</span>(<span class="number">80%</span>) <span class="built_in">opacity</span>(<span class="number">0.8</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;father&quot;&gt;</span><br><span class="line">	&lt;<span class="selector-tag">div</span> class=&quot;children&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="倒影"><a href="#倒影" class="headerlink" title="倒影"></a>倒影</h2><ul>
<li>方式一：使用-webkit-box-reflect 属性(除 IE 和火狐都可用)</li>
<li>方式二：用伪元素将父元素复制一份在 transform 倒转一下位置</li>
<li>示例：基于方式一<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">140px</span>;</span><br><span class="line">	<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> <span class="number">#fff</span>;</span><br><span class="line">	<span class="attribute">transform-origin</span>: center;</span><br><span class="line">	-webkit-box-reflect: below <span class="number">10px</span> <span class="built_in">linear-gradient</span>(transparent, transparent, <span class="number">#0005</span>); // 倒影渐变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="玻璃的反光效果"><a href="#玻璃的反光效果" class="headerlink" title="玻璃的反光效果"></a>玻璃的反光效果</h2><ul>
<li>解析：<ul>
<li>首先先放一张图在最底层，并设置相对定位</li>
<li>创建一个空的容器并定位到与图片的位置大小一致</li>
<li>给这个空容器添加伪类，创建出一个 45deg 的半透明条状，并执行动画</li>
</ul>
</li>
<li>示例：以下写法基于 react + sass + tailwindcss<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.scss&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Permissions</span> = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span>&lt; div&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;asset/image/bg-3.jpg&quot;</span> <span class="attr">className</span>=<span class="string">&quot;relative w-[900px] h-[600px]&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;a cat&quot;</span>/&gt;</span></span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;pili&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">.<span class="property">pili</span> &#123;</span><br><span class="line">  <span class="attr">overflow</span>: hidden;</span><br><span class="line">  transition-<span class="attr">duration</span>: .5s;</span><br><span class="line">  <span class="attr">width</span>: 900px;</span><br><span class="line">  <span class="attr">height</span>: 600px;</span><br><span class="line">  <span class="attr">position</span>:absolute;</span><br><span class="line">  <span class="attr">top</span>: 24px;</span><br><span class="line">  <span class="attr">left</span>:24px;</span><br><span class="line"></span><br><span class="line">  &amp;::before &#123;</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">width</span>: 1200px;</span><br><span class="line">    <span class="attr">height</span>: 15px;</span><br><span class="line">    background-<span class="attr">color</span>: <span class="title function_">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">.7</span>);</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">rotate</span>(-45deg);</span><br><span class="line">    -webkit-<span class="attr">transform</span>: <span class="title function_">rotate</span>(-45deg);</span><br><span class="line">    -moz-<span class="attr">transform</span>: <span class="title function_">rotate</span>(-45deg);</span><br><span class="line">		-ms-<span class="attr">transform</span>: <span class="title function_">rotate</span>(-45deg);</span><br><span class="line">    -webkit-<span class="attr">animation</span>: searchLights 3s ease-<span class="keyword">in</span> 3s infinite;</span><br><span class="line">    <span class="attr">animation</span>: searchLights 3s ease-<span class="keyword">in</span> 3s infinite;</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes searchLights &#123;</span><br><span class="line">    <span class="number">0</span>% &#123;</span><br><span class="line">      <span class="attr">left</span>: -300px;</span><br><span class="line">      <span class="attr">top</span>:-150px;</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">      <span class="attr">left</span>:400px;</span><br><span class="line">      <span class="attr">top</span>:1600px</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="毛玻璃"><a href="#毛玻璃" class="headerlink" title="毛玻璃"></a>毛玻璃</h2><blockquote>
<p>关键：使用 backdro-filter: blur(5px); 数值越大越模糊</p>
</blockquote>
<ul>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.maoboli</span> &#123;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">	<span class="attribute">transition-duration</span>: <span class="number">0.5s</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">900px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">	backdrop-<span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>Git在项目中遇到的问题(实战)</title>
    <url>/2024/10/30/Engineering/Git%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><blockquote>
<p>当前公司业务是用 rebase 合并代码，则需要修改 git 拉取的默认配置</p>
</blockquote>
<ul>
<li>全局修改 pull 的默认配置 rebase：git config –global –add pull.rebase true</li>
<li>查看修改成功与否：git config –global -l,找到 pull.rebase&#x3D;true 则为成功</li>
</ul>
<h2 id="分析-studydemo-文件夹的树状图"><a href="#分析-studydemo-文件夹的树状图" class="headerlink" title="分析 studydemo 文件夹的树状图"></a>分析 studydemo 文件夹的树状图</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- .<span class="property">git</span></span><br><span class="line">- wxproject		 --- commit master</span><br><span class="line">- pachong			 --- commit feature4</span><br><span class="line">- maindian	   --- commit feature5</span><br><span class="line">- h5project		 --- commit feature5</span><br><span class="line">- first-demo	 --- commit feature2</span><br><span class="line">- <span class="title class_">FAProject</span>		 --- commit feature1</span><br><span class="line">- background-<span class="number">1</span> --- commit feature5</span><br><span class="line">- .<span class="property">hintrc</span></span><br><span class="line">- <span class="variable constant_">README</span>.<span class="property">md</span></span><br><span class="line">- 备注.<span class="property">txt</span></span><br></pre></td></tr></table></figure>

<h2 id="解决合并分支的问题-—-feature5-合并-feature4"><a href="#解决合并分支的问题-—-feature5-合并-feature4" class="headerlink" title="解决合并分支的问题 — feature5 合并 feature4"></a>解决合并分支的问题 — feature5 合并 feature4</h2><h3 id="时间线乱序"><a href="#时间线乱序" class="headerlink" title="时间线乱序"></a>时间线乱序</h3><ul>
<li>方法一(命令行操作)：<ol>
<li>先撤回已提交记录：git reset HEAD^ &#x2F;&#x2F; 这个只能撤回一条最新记录</li>
<li>贮藏未提交的记录：git stash</li>
<li>拉取当前分支的最新记录：git pull</li>
<li>弹出贮藏：git pop stash</li>
<li>重新提交: git commit -m “msg”</li>
<li>推送到远程：git push -f</li>
</ol>
</li>
<li>方法二(命令行+tortoiseGit)：<ol>
<li>撤回已提交记录: git reset HEAD^</li>
<li>重新提交合并上一次提交，推送强制覆盖已知</li>
</ol>
</li>
<li>方法三：<ul>
<li>如果没有什么删除分支之类的，合完，合并记录</li>
<li>获取需要合并记录的 commit id：git log</li>
<li>进入交互式的 rebase 模式: git rebase -i commitID</li>
<li>输入 i 进入可编辑模式</li>
<li>将需要合并的提交记录从pick改为squash或者fixup<ul>
<li>squash：将当前提交记录与上一提交记录合并，同时将提交信息合并为一个</li>
<li>fixup：将当前提交记录与上一提交记录合并，但不保留当前提交记录</li>
</ul>
</li>
<li>按 esc 输入:wq 退出</li>
<li>修改合并后的 commit message: git commit –amend</li>
<li>强制推送修改后的记录: git push –force</li>
</ul>
</li>
</ul>
<h3 id="切分支一直提示：The-following-untracked-working-tree-files-would-be-overwritten-by-checkout…"><a href="#切分支一直提示：The-following-untracked-working-tree-files-would-be-overwritten-by-checkout…" class="headerlink" title="切分支一直提示：The following untracked working tree files would be overwritten by checkout…"></a>切分支一直提示：The following untracked working tree files would be overwritten by checkout…</h3><ul>
<li>方法一： 保留未追踪的文件<ul>
<li>git add .</li>
<li>git stash</li>
<li>执行本来想执行的命令</li>
</ul>
</li>
<li>方法二：不想要这些文件，直接覆盖<ul>
<li>git checkout -f targetFeatureName</li>
</ul>
</li>
</ul>
<h3 id="遇到-index-lock-文件直接去当前目录的-git-下删除-index-lock"><a href="#遇到-index-lock-文件直接去当前目录的-git-下删除-index-lock" class="headerlink" title="遇到 index.lock 文件直接去当前目录的.git 下删除 index.lock"></a>遇到 index.lock 文件直接去当前目录的.git 下删除 index.lock</h3><h2 id="直接拉取远程的其它分支-—-feature5拉取feature1"><a href="#直接拉取远程的其它分支-—-feature5拉取feature1" class="headerlink" title="直接拉取远程的其它分支 — feature5拉取feature1"></a>直接拉取远程的其它分支 — feature5拉取feature1</h2><ul>
<li>提示 (no branch, rebasing feature1)</li>
<li><a href="https://blog.csdn.net/lanxing_huangyao/article/details/120242089">解决方案，点击跳转</a></li>
</ul>
<h2 id="当主干分支有改变，但当前分支拉取的时候主干没变的情况"><a href="#当主干分支有改变，但当前分支拉取的时候主干没变的情况" class="headerlink" title="当主干分支有改变，但当前分支拉取的时候主干没变的情况"></a>当主干分支有改变，但当前分支拉取的时候主干没变的情况</h2><blockquote>
<p>这里用 merge 时间先会乱所以用 rebase，本质就是合并主干代码到分支</p>
</blockquote>
<ul>
<li>贮藏一下当前分支未提交的代码：git stash</li>
<li>确认当前所在分支: git branch</li>
<li>切换分支到主干: git checkout master</li>
<li>拉取远程的主干: git pull origin master</li>
<li>切换到要合并的分支: git checkout featureName</li>
<li>开始变基：git rebase master(当前分支变基主干，变基后的内容在当前分支中更新)</li>
<li>如果变基有冲突，看提示那个文件，或者看 vscode 那个文件标红了<ul>
<li>解决标红后 git add .</li>
<li>然后 git rebase –continue</li>
</ul>
</li>
<li>查看日志: git log –pretty&#x3D;oneline –graph(确认是否变基成功)</li>
<li>尝试推送到远程分支，发现果然不行：git push -u origin originFeatureName(rebase 变基后，本地和远程的记录不同，所以推送不成功)</li>
<li>强推到远程分支：git push -f origin originFeatureName</li>
<li>弹出贮藏：git pop</li>
</ul>
<h3 id="各个分支已经推送到远程后，把分支合并到-master"><a href="#各个分支已经推送到远程后，把分支合并到-master" class="headerlink" title="各个分支已经推送到远程后，把分支合并到 master"></a>各个分支已经推送到远程后，把分支合并到 master</h3><ul>
<li>切换到 master 分支：git checkout master</li>
<li>确保 master 分支，是最新记录：git pull origin master</li>
<li>合并分支：git merge 要合并到master的分支</li>
<li>查看日志: git log –pretty&#x3D;oneline –graph(确认是否合并成功)</li>
<li>推送分支到 master：git push origin master</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>案例-时间轴特效</title>
    <url>/2024/10/30/HTMLCSS/%E6%A1%88%E4%BE%8B%20-%20%E6%97%B6%E9%97%B4%E8%BD%B4%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="滚动时间轴特效"><a href="#滚动时间轴特效" class="headerlink" title="滚动时间轴特效"></a>滚动时间轴特效</h2><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>中间线的定位</li>
<li>item 左右交错分布</li>
<li>遮罩 mask</li>
<li>使 item 层级高过遮罩</li>
<li>鼠标上下滚动的样式</li>
</ul>
<h3 id="中间线的定位"><a href="#中间线的定位" class="headerlink" title="中间线的定位"></a>中间线的定位</h3><ul>
<li>容器要有一个固定宽度</li>
<li>使容器在视图居中</li>
<li>给容器的伪元素设置绝对定位，高度百分百，在 y 轴溢出设置为滚动，左为百分之五十，在设置下宽度，背景，层级既可</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.timeline</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: white;</span><br><span class="line">	<span class="attribute">background-repeat</span>: no-repeat <span class="meta">!important</span>;</span><br><span class="line">	<span class="comment">/* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */</span></span><br><span class="line">	<span class="attribute">background-attachment</span>: fixed <span class="meta">!important</span>;</span><br><span class="line">	<span class="comment">/* 让背景图基于容器大小伸缩 */</span></span><br><span class="line">	<span class="attribute">background-size</span>: cover <span class="meta">!important</span>;</span><br><span class="line">	<span class="attribute">z-index</span>: <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="item-左右交错分布"><a href="#item-左右交错分布" class="headerlink" title="item 左右交错分布"></a>item 左右交错分布</h3><ol>
<li>要考虑好如何布局，因为使布局交错分布的属性 align-self<sup><a href="#ref1">1</a></sup>有限制</li>
<li>存在该属性的类要作用在偶数的项中，并使 align-self: flex-end;</li>
</ol>
<ul>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(even) &#123;</span><br><span class="line">	<span class="attribute">align-self</span>: flex-end; // 这个是使item 交错垂直布局</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-direction</span>: row-reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(even)<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">	<span class="attribute">translate</span>: -<span class="number">100px</span> <span class="number">50px</span>;</span><br><span class="line">	<span class="attribute">z-index</span>: <span class="number">60</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="遮罩-mask"><a href="#遮罩-mask" class="headerlink" title="遮罩 mask"></a>遮罩 mask</h3><ol>
<li>给容器添加相对定位</li>
<li>在容器中添加 div，并设置为绝对定位，宽高百分百，背景只要半透明就行</li>
</ol>
<ul>
<li>示例:<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mask</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">	<span class="attribute">color</span>: black;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使-item-层级高过遮罩"><a href="#使-item-层级高过遮罩" class="headerlink" title="使 item 层级高过遮罩"></a>使 item 层级高过遮罩</h3><ol>
<li>准备好一个样式 transform:translateZ(0);<sup><a href="#ref2">2</a></sup></li>
<li>然后通过滚动等条件来判断给哪一个 item 添加</li>
</ol>
<h3 id="鼠标上下滚动的样式"><a href="#鼠标上下滚动的样式" class="headerlink" title="鼠标上下滚动的样式"></a>鼠标上下滚动的样式</h3><ol>
<li>获取容器的 dom 和给容器添加一个鼠标滚动事件(onWheel)</li>
<li>通过鼠标事件的 event 获取 e.nativeEvent.deltaY<sup><a href="#ref3">3</a></sup></li>
<li>如果向上滚则判断 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dom.<span class="property">scrollTop</span> &lt;= <span class="number">0</span> </span><br><span class="line">	? 当前数组的索引 &lt; <span class="number">0</span> ? <span class="keyword">return</span> : 当前数组索引 = 当前数组索引-<span class="number">1</span></span><br><span class="line">	: dom.<span class="property">scrollTop</span>+dom.<span class="property">clientHeight</span> &gt;= dom.<span class="property">scrollHeight</span> </span><br><span class="line">		? (当前数组索引 &gt; 数组的长度-<span class="number">1</span> ? <span class="keyword">return</span> : <span class="literal">null</span>) </span><br><span class="line">		: 当前数组索引 = 当前数组索引+<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>遍历数组，判断<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(当前索引 &gt; 数组长度-<span class="number">1</span>) 当前索引 = 数组长度-<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(当前索引 ==== 当前数组索引) &#123;</span><br><span class="line">	<span class="attr">transform</span>:<span class="title function_">translateZ</span>(<span class="number">0</span>)</span><br><span class="line">	改变背景的变量 = 当前背景</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h4><p id="ref1">[1] align-self：只能作用单个项目并对齐当前 flex 行中的元素。align-self使用的条件是存在三层的div，这三个div是祖>父>子关系，该属性使用在父布局，则祖布局只能有一个布局就是父布局，然后其它内容只能写在子布局中，而祖布局有多少个兄弟元素都没关系。</p>
<p id="ref2">[2] transform:translateZ(0);：在3D变化中,元素的Z轴是指元素在初始情况下,从元素背面穿过元素指向元素正面的方向,初始状态下元素的Z轴值为0,沿着Z轴往下移动,Z轴值为负值,反之则为正值。</p>
<p id="ref3">[3] e.nativeEvent.deltaY：在 React 中，e.nativeEvent 才是原生 DOM 事件的那个 event,可以阻止监听同一事件的其他事件监听器被调用。detaltaY:向下滚动回返回正值，向上滚动回返回负值，否则返回0。</p>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>案例-电子表指针转动Date</title>
    <url>/2024/10/30/HTMLCSS/%E6%A1%88%E4%BE%8B%20-%20%E7%94%B5%E5%AD%90%E8%A1%A8%E6%8C%87%E9%92%88%E8%BD%AC%E5%8A%A8Date/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ul>
<li>读秒：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">let</span> seconds = now.<span class="title function_">getSeconds</span>()</span><br><span class="line"><span class="keyword">let</span> minutes = now.<span class="title function_">getMinutes</span>()</span><br><span class="line"><span class="keyword">let</span> hours = now.<span class="title function_">getHours</span>()</span><br></pre></td></tr></table></figure></li>
<li>计算指针旋转的度数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> secondsDeg = ((seconds /<span class="number">60</span>) * <span class="number">360</span>) + <span class="number">90</span> <span class="comment">// 这是秒针</span></span><br><span class="line"><span class="keyword">let</span> minutesDeg = ((minutes / <span class="number">60</span>) * <span class="number">360</span>) + (seconds / <span class="number">3600</span>) + <span class="number">90</span> <span class="comment">// 这是分针</span></span><br><span class="line"><span class="keyword">let</span> hoursDeg = ((hours / <span class="number">12</span>) * <span class="number">360</span>) + (seconds/<span class="number">43200</span>)*<span class="number">360</span>+(mins/<span class="number">720</span>)*<span class="number">360</span> + <span class="number">90</span> <span class="comment">// 这是时针</span></span><br></pre></td></tr></table></figure></li>
<li>设置指针角度<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dom.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;secondsDeg&#125;</span>deg)`</span> <span class="comment">// 秒针的dom旋转的角度</span></span><br><span class="line">dom.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;minutesDeg&#125;</span>deg)`</span> <span class="comment">// 分针的dom旋转的角度</span></span><br><span class="line">dom.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;hoursDeg&#125;</span>deg)`</span>   <span class="comment">// 时针的dom旋转的角度</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>案例-对齐文本</title>
    <url>/2024/10/30/HTMLCSS/%E6%A1%88%E4%BE%8B%20-%20%E5%AF%B9%E9%BD%90%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="对齐文本方式一"><a href="#对齐文本方式一" class="headerlink" title="对齐文本方式一"></a>对齐文本方式一</h2><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p><img src="/../../img/textAlignStyle1.png" alt="示例"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>外层使用 flex flex-col</li>
<li>内层最好不用使用 flex 将文本内容包裹起来，会失效</li>
<li>内层只有文本会更准确点</li>
<li>text-align 和 text-align-last 要结合使用，并且值为 justify</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.text_space &#123;</span><br><span class="line">	text-align: justify;</span><br><span class="line">	text-align-last: justify;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-col text_space&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>模糊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>亮度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>灰度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>透明度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>对比度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="对齐文本方式二"><a href="#对齐文本方式二" class="headerlink" title="对齐文本方式二"></a>对齐文本方式二</h2><h3 id="样式-1"><a href="#样式-1" class="headerlink" title="样式"></a>样式</h3><ul>
<li>文字左对齐，然后文字后面的样式按照最长文字的距离来</li>
<li>本质就是固定前面的文本的长度</li>
</ul>
<h3 id="示例：-使用-tailwind-语法"><a href="#示例：-使用-tailwind-语法" class="headerlink" title="示例：(使用 tailwind 语法)"></a>示例：(使用 tailwind 语法)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;flex flex-col&#x27;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;flex items-center&#x27;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;w-[60px]&#x27;</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>oppo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;flex items-center&#x27;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;w-[60px]&#x27;</span>&gt;</span>banane<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;flex items-center&#x27;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;w-[60px]&#x27;</span>&gt;</span>gray<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS&amp;HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用的命令</title>
    <url>/2024/10/30/Engineering/Git%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul>
<li>切分支：git checkout featureName</li>
<li>查看当前分支：git branch</li>
<li>删除本地分支：git branch -d featureName</li>
<li>删除远程分支: git push origin -d originFeatureName</li>
<li>回退本地分支版本：git reset –hard HEAD^ (退一个版本)</li>
<li>回退本地分支版本：git reset –hard version (退多个版本)</li>
<li>回退远程分支版本：git push -f origin featureName(通过回退本地分支版本后强制推送)</li>
<li>贮藏代码：git stash</li>
<li>应用最近一次后删除stash该条记录：git stash pop</li>
</ul>
<h3 id="更新分支存在信息"><a href="#更新分支存在信息" class="headerlink" title="更新分支存在信息"></a>更新分支存在信息</h3><ul>
<li>查看本地分支和追踪情况：git remote show origin</li>
<li>同步删除已经删除的远程分支：git remote prune origin</li>
<li>查看本地分支和远程分支情况：git branch -a</li>
</ul>
<h3 id="命令行切换新分支，本地没有对应的分支的情况下"><a href="#命令行切换新分支，本地没有对应的分支的情况下" class="headerlink" title="命令行切换新分支，本地没有对应的分支的情况下"></a>命令行切换新分支，本地没有对应的分支的情况下</h3><ul>
<li>刷新远程分支: git fetch</li>
<li>创建并切换到新分支: git checkout -b featureName</li>
<li>远程跟踪分支: git branch -u remote&#x2F;featureName</li>
<li>拉取远程代码: git pull origin featureName</li>
<li>查看日志: git log</li>
</ul>
<h3 id="命令行提交文件"><a href="#命令行提交文件" class="headerlink" title="命令行提交文件"></a>命令行提交文件</h3><ul>
<li>将所有文件提交到暂存区：git add .</li>
<li>将暂存区的内容提交到本地仓库：git commit -m “msg”</li>
<li>将本地仓库的内容提交到远程仓库上: git push -u origin featureName</li>
<li>记得随时查看日志确认是否有问题</li>
</ul>
<h3 id="命令行合并分支-—-W-分支合并到-master"><a href="#命令行合并分支-—-W-分支合并到-master" class="headerlink" title="命令行合并分支 — W 分支合并到 master"></a>命令行合并分支 — W 分支合并到 master</h3><ul>
<li>确保 W 分支是最新内容后</li>
<li>切换回 master: git checkout master</li>
<li>保证当前的 master 是最新记录: git pull</li>
<li>把 W 分支合并到 master 中: git rebase W</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Next --- React 开发框架</title>
    <url>/2024/11/01/Engineering/Next/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>直观的、<span class="key_words">『基于页面』</span>的路由系统（<span class="desc">并支持动态路由</span>）</li>
<li><span class="key_words">『预渲染』</span>。支持在页面级的静态生成(SSG) 和服务器端渲染(SSR)</li>
<li>自动代码拆分，提升页面加载速度</li>
<li>具有经过优化的预取功能的<span class="key_words">『客户端路由』</span></li>
<li>内置 CSS 和 Sass 的支持，并支持任何CSS-in-JS库</li>
<li>开发环境支持快速刷新</li>
<li>利用 Serverless Functions 及 API 路由 构建 API 功能</li>
<li>完全可扩展</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>前提：node 版本需要12.22.0 及更高</li>
<li>创建：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx create-next-app@latest --typescript</span><br></pre></td></tr></table></figure></li>
<li>运行：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run dev&lt;/span&gt;</span><br></pre></td></tr></table></figure></li>
<li>启动服务器，访问<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:3000</span><br></pre></td></tr></table></figure></li>
<li>安装：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install next react react-dom</span><br></pre></td></tr></table></figure></li>
<li>配置：在package.json文件添加scripts配置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;next dev&quot;</span>, <span class="comment">// 开发模式启动</span></span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;next build&quot;</span>, <span class="comment">// 构建生产环境</span></span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;next start&quot;</span>, <span class="comment">// 启动生产环境服务器</span></span><br><span class="line">  <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;next lint&quot;</span> <span class="comment">// 设置内置ESLint配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="页面-Pages"><a href="#页面-Pages" class="headerlink" title="页面(Pages)"></a>页面(Pages)</h2><ul>
<li>在next.js中，page就是React组件，文件存放在pages目录下，每个page都使用其文件名作为路由，通过<span class="key_words">『&#x2F;文件名』</span>访问<ul>
<li>支持有<span class="key_words">『动态路由的pages』</span>，如<span class="desc">文件名为pages&#x2F;posts&#x2F;[id].js,通过posts&#x2F;1访问</span></li>
</ul>
</li>
</ul>
<h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><ul>
<li>默认情况下将预渲染每个page，即预先为每个page生成HTML文件</li>
<li><span class="key_words">『水合』</span>：<ul>
<li>当浏览器加载一个page时，其Javascript代码将运行并使页面完全具有交互性的过程。</li>
</ul>
</li>
<li>两种形式的预渲染：<ul>
<li><span class="key_words">『静态生成』</span>(推荐)：HTML在<span class="key_words">『构建时』</span>生成，并在每次页面请求时重用</li>
<li><span class="key_words">『服务端渲染』</span>：在<span class="key_words">『每次页面请求时』</span>重新生成HTML</li>
</ul>
</li>
<li>允许每个页面选择渲染方式，CDN可以在没有额外配置的情况下缓存静态生成的页面提高性能</li>
</ul>
<h3 id="静态生成-—-生成带有或不带有数据的页面"><a href="#静态生成-—-生成带有或不带有数据的页面" class="headerlink" title="静态生成 — 生成带有或不带有数据的页面"></a>静态生成 — 生成带有或不带有数据的页面</h3><ul>
<li><span class="key_words">『生成不带有数据的静态页面』</span>：不涉及获取外部数据，只需构建时为页面生成HTML文件</li>
<li><span class="key_words">『生成带有数据的页面』</span>:<ul>
<li>页面<span class="key_words">『内容』</span>取决于外部数据: 使用getStaticProps</li>
<li>页面『paths』取决于外部数据：使用getStaticPaths + getStaticProps</li>
</ul>
</li>
<li>尽可能使用静态生成如：营销页面，博客文章、简历、产品列表、帮助文档</li>
<li>静态生成不满足使用的解决方案：静态生成+客户端渲染，服务端渲染</li>
</ul>
<h3 id="服务端渲染-—-也被称为SSR或动态渲染"><a href="#服务端渲染-—-也被称为SSR或动态渲染" class="headerlink" title="服务端渲染 — 也被称为SSR或动态渲染"></a>服务端渲染 — 也被称为SSR或动态渲染</h3><ul>
<li>使用：getServerSideProps</li>
</ul>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><ul>
<li>getStaticProps（静态生成）：仅在<span class="key_words">『构建时』</span>获取数据。</li>
<li>getStaticPaths（静态生成）：根据数据指定预渲染页面的动态路由。</li>
<li>getServerSideProps（服务器端渲染）：获取每个请求的数据。</li>
</ul>
<h3 id="getStaticProps"><a href="#getStaticProps" class="headerlink" title="getStaticProps"></a>getStaticProps</h3><ul>
<li>返回一个对象</li>
<li>context 包含:<ul>
<li>params: 使用动态路由页面的路由参数     </li>
<li>preview：是否处于预览模式。true&#x2F;undefined     </li>
<li>previewData：setPreviewData设置的预览数据集</li>
<li>locale：活动区域设置(<span class="desc">前提：启用国际路由</span>)</li>
<li>locales：所有支持的区域设置(<span class="desc">前提：启用国际路由</span>)</li>
<li>defaultLocale：配置的默认区域设置(<span class="desc">前提：启用国际路由</span>)</li>
</ul>
</li>
<li>props：可选对象，包含页面组件将接受的props</li>
<li>revalidate：可选的次数，单位秒，默认false，具体看<a href="#ref1">增量静态生成</a></li>
<li>notFound：可选的布尔值，允许页面返回404和页面</li>
<li>redirect：可选的重定向值，允许重定向到内部和外部资源，构建时不允许重定向<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GetStaticProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getStaticProps</span>: <span class="title class_">GetStaticProps</span> = <span class="title function_">async</span> (context) =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="增量静态再生-ISR-基于每个页面使用静态生成，而无需重新构建整个站点。"><a href="#增量静态再生-ISR-基于每个页面使用静态生成，而无需重新构建整个站点。" class="headerlink" title="增量静态再生(ISR)(基于每个页面使用静态生成，而无需重新构建整个站点。)"></a><p id="ref1">增量静态再生(ISR)</p>(<span class="desc">基于每个页面使用静态生成，而无需重新构建整个站点。</span>)</h3><ul>
<li>使用revalidate：number启用，当对在生成时预呈现的页面发出请求时，它最初将显示缓存的页面。过程如下：<ul>
<li>初始请求之后和10秒之前对页面的任何请求也会被缓存并即时缓存</li>
<li>number秒窗口之后，下一个请求仍将显示缓存(过时)页面</li>
<li>next会在后台触发页面重新生成</li>
<li>生成成功后，next使缓存失效并显示更新的产品页面；失败则页面保持不变</li>
</ul>
</li>
</ul>
<h3 id="读取文件：process-cwd"><a href="#读取文件：process-cwd" class="headerlink" title="读取文件：process.cwd()"></a>读取文件：process.cwd()</h3><ul>
<li>文件可以直接从getStaticProps中的文件系统中读取。即必须获取文件的完整路径</li>
<li>next将代码编译到一个单独的目录中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> postsDirectory = path.<span class="title function_">join</span>(process.<span class="title function_">cwd</span>(),<span class="string">&#x27;posts&#x27;</span>) </span><br><span class="line">  <span class="comment">// 使用 fs.readdir(postsDirectory)来读取这个目录</span></span><br><span class="line">  <span class="keyword">const</span> filenames = <span class="keyword">await</span> fs.<span class="title function_">readdir</span>(postsDirectory)</span><br><span class="line">  <span class="keyword">const</span> posts = filenames.<span class="title function_">map</span>(<span class="title function_">async</span> (filename) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> filePath = path.<span class="title function_">join</span>(postsDirectory, filename)</span><br><span class="line">    <span class="keyword">const</span> fileContents = <span class="keyword">await</span> fs.<span class="title function_">readFile</span>(filePath, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      filename,</span><br><span class="line">      <span class="attr">content</span>: fileContents,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">posts</span>: <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(posts),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="getStaticPaths"><a href="#getStaticPaths" class="headerlink" title="getStaticPaths"></a>getStaticPaths</h3><ul>
<li>静态预呈现使用动态路由的页面时使用</li>
<li>paths键(必选)<ul>
<li>如果页面使用可选的捕获所有路由，使用null、[]、undefined或 false来呈现最根路径，如果在page&#x2F;[[…slug]],使用slug:false,则静态生成页面”&#x2F;“</li>
</ul>
</li>
<li>fallback键(必选)<ul>
<li>fallback：false: <ul>
<li>则任何<span class="key_words">『未返回的路径都将导致404』</span>，不经常添加新页面可用</li>
</ul>
</li>
<li>fallback: true: <ul>
<li>返回的路径将在构建时由getStaticProps呈现为HTML，在生成时<span class="key_words">『未生成的路径不会生成404』</span>,提供<a href="#ref2">回退版本</a>,从用户角度看，页面将从回退页面交换到整个页面。有大量依赖于数据的静态页面可用。</li>
</ul>
</li>
<li>fallback:blocking: <ul>
<li>阻塞原因，每条路径只发生一次。构建时尚未生成的路径不会导致404。相反Next将对第一个请求进行SSR，并返回生成的HTML。完成后，浏览器将接收生成路径的 HTML。Next将此路径添加到预呈现页面的列表中。</li>
</ul>
</li>
</ul>
</li>
<li><span id="ref2">回退页面</span><ul>
<li>页面的props将为空。使用router.isFallback可以检测是否正在渲染回退，如果只为true的话<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticPaths</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">paths</span>: [</span><br><span class="line">      &#123; <span class="attr">params</span>: &#123; ... &#125;&#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">fallback</span>: <span class="literal">true</span>,<span class="literal">false</span>,or <span class="string">&#x27;blocking&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GetStaticPaths</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getStaticPaths</span>: <span class="title class_">GetStaticPaths</span> = <span class="title function_">async</span> () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="getServerSideProps"><a href="#getServerSideProps" class="headerlink" title="getServerSideProps"></a>getServerSideProps</h3><ul>
<li>仅当需要预呈现其数据必须在请求时提取的页面时，才应使用。getStaticProps到第一个字节的时间（TTFB）将比慢，因为服务器必须计算每个请求的结果，并且如果没有额外的配置，CDN就无法缓存结果。</li>
<li>返回一个对象</li>
<li>context包含:<ul>
<li>params: 使用动态路由页面的路由参数</li>
<li>req: http 传入信息对象，以及其它内置的解析助手</li>
<li>res: http返回对象</li>
<li>query: 查询字符串的对象</li>
<li>preview：是否处于预览模式。true&#x2F;undefined     </li>
<li>previewData：setPreviewData设置的预览数据集</li>
<li>resolvedUrl: 请求URL的规范化版本，去掉客户端转换的前缀并包括原始查询值</li>
<li>locale：活动区域设置(前提：启用国际路由)</li>
<li>locales：所有支持的区域设置(前提：启用国际路由)</li>
<li>defaultLocale：配置的默认区域设置(前提：启用国际路由)</li>
</ul>
</li>
<li>props：可选对象，包含页面组件将接受的props</li>
<li>notFound：可选的布尔值，允许页面返回404和页面</li>
<li>redirect：可选的重定向值，允许重定向到内部和外部资源，构建时不允许重定向</li>
<li>在getServerSideProps中提供req中间件: req<ul>
<li>req.cookies: 一个包含请求发送的cookie的对象。默认为｛｝<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GetServerSideProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getServerSideProps</span>: <span class="title class_">GetServerSideProps</span> = <span class="title function_">async</span> (context) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="在客户端获取数据"><a href="#在客户端获取数据" class="headerlink" title="在客户端获取数据"></a>在客户端获取数据</h3><ul>
<li>使用场景：如果页面包含频繁更新的数据，并且不需要预呈现数据。用户面板页面。</li>
<li>首先，立即显示没有数据的页面。页面的部分内容可以使用静态生成进行预渲染。您可以显示丢失数据的加载状态。然后，在客户端获取数据，并在准备好后显示。</li>
</ul>
<h3 id="SWR"><a href="#SWR" class="headerlink" title="SWR"></a>SWR</h3><ul>
<li>next团队创建的React数据获取挂钩</li>
<li>处理缓存、重新验证、焦点跟踪、间隔重新蚀刻等<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useSWR <span class="keyword">from</span> <span class="string">&#x27;swr&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetcher</span> = (<span class="params">url</span>) =&gt; <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Profile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useSWR</span>(<span class="string">&#x27;/api/user&#x27;</span>, fetcher)</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>failed to load<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">if</span> (!data) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello &#123;data.name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内置对-CSS-的支持"><a href="#内置对-CSS-的支持" class="headerlink" title="内置对 CSS 的支持"></a>内置对 CSS 的支持</h2><ul>
<li>允许在js文件import css文件</li>
</ul>
<h3 id="添加全局样式表"><a href="#添加全局样式表" class="headerlink" title="添加全局样式表"></a>添加全局样式表</h3><ul>
<li>创建一个pages&#x2F;_app.js文件，然后import css文件</li>
</ul>
<h3 id="从node-modules目录import样式"><a href="#从node-modules目录import样式" class="headerlink" title="从node_modules目录import样式"></a>从node_modules目录import样式</h3><ul>
<li>可以在应用程序的任何位置导入</li>
<li>全局样式表还是要在pages&#x2F;_app.js导入</li>
<li>其它的对应组件页面导入</li>
</ul>
<h3 id="添加组件级CSS"><a href="#添加组件级CSS" class="headerlink" title="添加组件级CSS"></a>添加组件级CSS</h3><ul>
<li>CSS模块支持的文件命名格式：[name].module.css</li>
<li>CSS模块时一项可选功能，仅对带有.module.css扩展名的文件启用</li>
</ul>
<h3 id="对Sass的支持"><a href="#对Sass的支持" class="headerlink" title="对Sass的支持"></a>对Sass的支持</h3><ul>
<li>文件后缀必须为：.module.scss或.module.sass</li>
<li>记得安装sass：npm i sass</li>
<li>自定义Sass参数：使用next.config.js文件中的sassOptions属性进行配置</li>
<li>Sass变量<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xxx.module.scss</span></span><br><span class="line">$primary-<span class="attr">color</span>: #64FF00</span><br><span class="line">:<span class="keyword">export</span> &#123;</span><br><span class="line">  <span class="attr">primaryColor</span>: $primary-color</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pages/_app.js</span></span><br><span class="line"><span class="keyword">import</span> variables <span class="keyword">from</span> <span class="string">&quot;../xxx.module.scss&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MyApp</span>(<span class="params">&#123;Component, pageProps&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">color</span>=<span class="string">&#123;variables.primaryColor&#125;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>CSS-in-JS<ul>
<li>内联样式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p style=&#123;&#123; color: &#x27;red&#x27; &#125;&#125;&gt;内联&lt;/p&gt;</span><br></pre></td></tr></table></figure></li>
<li>引入<a href="https://github.com/vercel/styled-jsx">styled-jsx</a>以支持作用于隔离的css，支持类似于Web组件的shadow css单不支持服务端渲染且仅支持js</li>
</ul>
</li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="自定义单个共享布局：自己封装想要的布局组件然后应用在全局中"><a href="#自定义单个共享布局：自己封装想要的布局组件然后应用在全局中" class="headerlink" title="自定义单个共享布局：自己封装想要的布局组件然后应用在全局中"></a>自定义单个共享布局：自己封装想要的布局组件然后应用在全局中</h3><h3 id="多个布局-嵌套布局："><a href="#多个布局-嵌套布局：" class="headerlink" title="多个布局 | 嵌套布局："></a>多个布局 | 嵌套布局：</h3><ul>
<li>自己定义多个布局组件，然后使用getLayout实现,这种布局支持状态持久性，因为React组件书在页面转换之间保持，这个过程叫<span class="key_words">『协调』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Layout</span> <span class="keyword">from</span> <span class="string">&#x27;../component/layout&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NestedLayout</span> <span class="keyword">from</span> <span class="string">&#x27;../component/nested-layout&#x27;</span></span><br><span class="line"><span class="comment">// ts引入import type &#123; ReactElement &#125; from &#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts模式给page添加类型ReactElement </span></span><br><span class="line"><span class="title class_">Page</span>.<span class="property">getLayout</span> = <span class="keyword">function</span> <span class="title function_">getLayout</span>(<span class="params">page</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">Layout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">NestedLayout</span>&gt;</span>&#123;page&#125;<span class="tag">&lt;/<span class="name">NestedLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// page/_app.js</span></span><br><span class="line"><span class="comment">// ts模式下需要定义布局类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MyApp</span>(<span class="params">&#123;Component, pageProps&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> getLayout = <span class="title class_">Component</span>.<span class="property">getLayout</span> || (<span class="function"><span class="params">page</span> =&gt;</span> page)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getLayout</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><ul>
<li>Image组件next&#x2F;image是HTML元素img标签的扩展</li>
<li>使用图像组件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Image</span> <span class="keyword">from</span> <span class="string">&#x27;next/image&#x27;</span></span><br><span class="line">&lt;<span class="title class_">Image</span> src=&#123;&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="本地图像"><a href="#本地图像" class="headerlink" title="本地图像"></a>本地图像</h3><ul>
<li>要先引入，使用import，next将根据导入的文件自动确定图像的width和height</li>
</ul>
<h3 id="远程映像：需要提供src、width、height、alt"><a href="#远程映像：需要提供src、width、height、alt" class="headerlink" title="远程映像：需要提供src、width、height、alt"></a>远程映像：需要提供src、width、height、alt</h3><h3 id="域名："><a href="#域名：" class="headerlink" title="域名："></a>域名：</h3><ul>
<li>访问远程映像单仍使用内置的next Image Optimization API，则src保留为默认设置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">images</span>: &#123;</span><br><span class="line">    <span class="comment">// 这个地址是远程映像的图片的绝对地址</span></span><br><span class="line">    <span class="attr">domains</span>: [<span class="string">&#x27;examplae.com&#x27;</span>, <span class="string">&#x27;example2.com&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="优先权：’priority’添加到图像中，成为每个页面的最大内容绘制-LCP-元素"><a href="#优先权：’priority’添加到图像中，成为每个页面的最大内容绘制-LCP-元素" class="headerlink" title="优先权：’priority’添加到图像中，成为每个页面的最大内容绘制(LCP)元素"></a>优先权：’priority’添加到图像中，成为每个页面的最大内容绘制(LCP)元素</h3><ul>
<li>LCP 元素通常是页面视口中可见的最大图像或文本块</li>
</ul>
<h3 id="图像大小调整"><a href="#图像大小调整" class="headerlink" title="图像大小调整"></a>图像大小调整</h3><ul>
<li>自动： 使用静态导入</li>
<li>显式地：通过包含height和width</li>
<li>隐式地：通过使用 layout&#x3D;”fill”,使图像展开填充父元素</li>
<li><h3 id="不知道图像大小的情况下调整"><a href="#不知道图像大小的情况下调整" class="headerlink" title="不知道图像大小的情况下调整"></a>不知道图像大小的情况下调整</h3><ul>
<li>使用 layout&#x3D;”fill” ,使用fill、contain或cover的objectFit属性以及objectPosition属性来定义</li>
<li>规范化图像：自己做的图，自己规范图像大小</li>
<li>修改API调用</li>
<li>如果以上都不适用，则将按照 img标签 的标准在页面上运行</li>
</ul>
</li>
</ul>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul>
<li>建议对内部 img标签 设置样式的方法是将Image组件上的className设置为导入的CSS模块的值。className的值将自动应用于基础的 img标签。</li>
<li>当使用 layout&#x3D;’fill’ 时，父元素必须具有 position:relative(必要的)</li>
<li>当使用 layout&#x3D;’responsive’ 时，父元素必须具有 display:block(div的默认值，应另行指定)</li>
</ul>
<h2 id="字体优化"><a href="#字体优化" class="headerlink" title="字体优化"></a>字体优化</h2><ul>
<li>第一内容绘制（FCP）和最大内容绘制（LCP）</li>
<li>使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Head</span> <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>要添加web字体，使用 Head标签 包裹</li>
<li>如果不想要优化，在next.config.js中设置 optimizeFonts: false</li>
</ul>
<h2 id="脚本组件"><a href="#脚本组件" class="headerlink" title="脚本组件"></a>脚本组件</h2><ul>
<li>脚本组件 next&#x2F;script 是HTML元素 script标签 的扩展</li>
<li>使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Script</span> <span class="keyword">from</span> <span class="string">&#x27;next/script&#x27;</span></span><br><span class="line">&lt;<span class="title class_">Script</span> src=<span class="string">&quot;第三方路径&quot;</span> strategy=<span class="string">&quot;策略属性&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="strategy：决定何时加载第三方脚本"><a href="#strategy：决定何时加载第三方脚本" class="headerlink" title="strategy：决定何时加载第三方脚本"></a>strategy：决定何时加载第三方脚本</h3><ul>
<li>beforeInteractive: 在页面交互之前加载<ul>
<li>从服务器注入到初始HTML中，并在执行自绑定JavaScript之前运行。</li>
<li>此策略应用于在<span class="key_words">『页面交互之前需要获取和执行的任何关键脚本』</spna></li>
</ul>
</li>
<li>afterInteractive（默认）：在页面变成交互式后立即加载<ul>
<li>被注入客户端，并将在Next.js对页面进行水合后运行。</li>
<li>这种策略应该用于<span class="key_words">『不需要尽快加载的脚本，并且可以在页面交互后立即获取和执行』</span>。</li>
</ul>
</li>
<li>lazyOnload: 在空闲时间加载<ul>
<li>在获取所有资源后以及空闲时间内加载较晚。</li>
<li>此策略应用于<span class="key_words">『后台或低优先级脚本』</span>，这些脚本不需要在页面交互之前或之后立即加载。</li>
</ul>
</li>
</ul>
<h3 id="内联脚本"><a href="#内联脚本" class="headerlink" title="内联脚本"></a>内联脚本</h3><ul>
<li>使用：将javascript放在{}中编写 或者在标签上使用dangerouslySetInnerHTML属性，但必须定义id属性</li>
<li>只能策略属性<span class="key_words">『不为beforeInteractive』</span>时才能使用</li>
</ul>
<h3 id="加载后执行代码-onLoad"><a href="#加载后执行代码-onLoad" class="headerlink" title="加载后执行代码(onLoad)"></a>加载后执行代码(onLoad)</h3><ul>
<li>策略属性<span class="key_words">『不为lazyOnload』</span>,都可以在加载后在标签上使用onLoad属性来执行代码</li>
</ul>
<h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><h3 id="静态文件服务"><a href="#静态文件服务" class="headerlink" title="静态文件服务"></a>静态文件服务</h3><ul>
<li>将静态文件存放到根目录下的public目录中，并对外提供访问。public目录下的存放的静态文件对外访问路径以<span class="key_words">『&#x2F;为起始路径』</span>，如”&#x2F;xxx.png”</li>
<li>要确保pages&#x2F;下的文件于静态文件无重名</li>
</ul>
<h3 id="快速刷新"><a href="#快速刷新" class="headerlink" title="快速刷新"></a>快速刷新</h3><ul>
<li>尝试在两次编辑之间保留零部件的状态。只要不更改参数或Hook调用的顺序，useState和useRef就会保留以前的值。</li>
<li>具有依赖关系的钩子将始终在快速刷新期间更新。在进行快速刷新时，依赖项列表将被忽略。</li>
<li>即使是空依赖项数组的useEffect，在快速刷新期间仍会重新运行一次。</li>
</ul>
<h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><ul>
<li>安装：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run lint</span><br></pre></td></tr></table></figure></li>
<li>然后配置</li>
</ul>
<h2 id="路由-next-version-13"><a href="#路由-next-version-13" class="headerlink" title="路由  next version 13+"></a>路由  next version 13+</h2><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><ul>
<li>App 路由<ul>
<li>app目录和pages目录一起工作，也兼容pages页面的路由，但主要在app页面的路由</li>
<li><span class="key_words">『App Router的优先级高于Pages Router。』</span></li>
<li>默认情况下， app内的组件是<a href="#ref4">React服务器组件</a>。性能优化之一</li>
</ul>
</li>
<li>路由片段<ul>
<li>路径的<span class="key_words">『每个文件夹代表一个路由片段』</span>。每个路线段都映射到网址路径中相应的片段。</li>
</ul>
</li>
<li>嵌套路由: <ul>
<li>就是文件夹相互嵌套</li>
</ul>
</li>
<li>主机托管<ul>
<li>app目录中可以放自己的文件和特殊文件等，因为只有page.js或route.js返回的内容是可公开寻址的</li>
<li>特殊文件：.js、.jsx、.tsx文件扩展名可用于特殊文件</li>
<li>私有文件：文件夹名：_folderName，表示该目录下的文件退出路由</li>
</ul>
</li>
<li>高级路由模式<ul>
<li><a href="#ref5">并行路由</a>：允许在同一视图中显示两个会多个可以独立导航的页面</li>
<li><a href="#ref6">拦截路由</a>：允许拦截一条路线并将其显示在另一条路线的上下文中。</li>
<li>布局更React差不多，template.js文件用来定义模板，layout.js用来定义布局， 嵌套要使用到children</li>
</ul>
</li>
<li>修改 head标签<ul>
<li>通过到处layout.js或page.js文件中的metadata对象或generateMetadata功能来定义元数据</li>
</ul>
</li>
</ul>
<h3 id="链接和导航"><a href="#链接和导航" class="headerlink" title="链接和导航"></a>链接和导航</h3><ul>
<li>导航的两种方式:<ul>
<li>使用 Link 组件, Link来自”next&#x2F;link”， 动态可以使用模板字符串语法<ul>
<li>相当于vue的声明式导航</li>
<li><a href="https://next.nodejs.cn/docs/app/api-reference/functions/use-pathname/">usePathname</a>:检查链接是否处于活动状态，用于className判断</li>
<li>滚动到id：在url链接添加#id</li>
<li>禁用滚动恢复：添加属性scroll&#x3D;{false}，默认滚动</li>
</ul>
</li>
<li>使用<a href="https://next.nodejs.cn/docs/app/api-reference/functions/use-router/">useRouter 钩子</a><ul>
<li>相当于vue的编程式导航,<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter, usePathname &#125; <span class="keyword">from</span> <span class="string">&quot;next/navigation&quot;</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line">router.<span class="title function_">push</span>(<span class="string">&#x27;/dashboard&#x27;</span>, &#123; <span class="attr">scroll</span>: <span class="literal">false</span> &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>工作原理<ul>
<li>预请求: 用户访问路由之前在后台预加载路由的方法<ul>
<li>Link组件：自动预取。静态<span class="key_words">『prefetch默认为true，动态』</span>prefetch默认自动，<span class="key_words">『只有共享布局向下直到为30s，预取并缓存第一个loading.js文件』</span>。可以显示即时加载状态。</li>
<li>router.prefetch(): useRouter钩子编程式预取路由</li>
<li>预取在开发中不启用，仅在生产中启用</li>
</ul>
</li>
<li>缓存：<ul>
<li>Next有一个内存中客户端缓存，称为<span class="key_words">『路由缓存』</span>。当用户在app中导航时，prefetched路线段和访问过的路线的React Server组件有效负载将存储在缓存中。</li>
</ul>
</li>
<li>部分渲染：<ul>
<li>仅在客户端上重新渲染导航时发生变化的路线段，并且保留所有共享段。<span class="desc">就是在同一文件夹下的不同文件不同路径，切换只渲染对应文件而不影响整体的文件</span></li>
</ul>
</li>
<li>软导航：<ul>
<li>仅渲染已更改的片段，同时保留 React 和浏览器状态，并且不会重新加载整个页面。<span class="desc">默认，浏览器执行硬导航</span></li>
</ul>
</li>
<li>后退和前进导航<ul>
<li>默认，将保持向后和向前导航的滚动位置，并重用路由缓存中的路线段。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul>
<li>在文件名称括上方括号（[folderName]）</li>
<li>动态端作为params属性将传递给layout、page、route和generateMetadata函数</li>
<li>生成静态参数<ul>
<li>generateStaticParams在构建时预动态路线段至静态生成路由结合起来</li>
<li>优点：智能检索数据</li>
</ul>
</li>
<li>捕获所有片段: 通过在方括号使用[…folderName]</li>
<li>可选的包罗万象的段：[[…folderName]],<ul>
<li>与捕获所有片段的区别：如果带可选参数，则不带参数的路由也会被匹配</li>
</ul>
</li>
</ul>
<h3 id="加载-UI-和流式传输"><a href="#加载-UI-和流式传输" class="headerlink" title="加载 UI 和流式传输"></a>加载 UI 和流式传输</h3><ul>
<li>即时加载状态(后备UI)<ul>
<li>在导航时立即显示</li>
<li>在文件加中创建loading.js，并嵌套在统一文件夹中的layout.js内。会自动将page.js文件和下面的所有子文件封装在 Suspense组件 边界中。</li>
<li>即使使用 以服务器为中心的路由，导航也是即时的。</li>
</ul>
</li>
<li>使用 Suspense 的流式: 自己看文档</li>
</ul>
<h3 id="错误处理error-js-文件"><a href="#错误处理error-js-文件" class="headerlink" title="错误处理error.js 文件"></a>错误处理error.js 文件</h3><ul>
<li>自动创建 React 误差边界、wraps 嵌套子段或 page.js 组件。</li>
<li>从 error.js 文件导出的 React 组件用作 fallback 组件。</li>
<li>如果在错误边界内抛出错误，则错误为 contained，回退组件为 rendered。</li>
<li>当回退错误组件处于活动状态时，布局 above 错误边界 maintain 其状态和 remain 交互，并且错误组件可以显示从错误中恢复的功能。</li>
<li>从错误中恢复<ul>
<li>重试</li>
<li>使用reset()函数</li>
</ul>
</li>
<li>处理布局中的错误<ul>
<li>error.js边界<span class="key_words">『不捕获同一段』</span>的layout.js或template.js组件中抛出的错误</li>
<li>处理特定布局或模板的错误：将error.js文件放置在布局的父段</li>
<li>处理根布局或模板的错误：使用global-error.js</li>
</ul>
</li>
<li>处理根布局中的错误<ul>
<li>根app&#x2F;error.js边界不捕获根app&#x2F;layout.js或app&#x2F;template.js组件中抛出的错误</li>
<li>处理：使用文娱根app目录中的global-error.js</li>
<li>global-error.js错误边界封装entire应用，并且其后被组件在活动时替换根布局</li>
<li>即使定义了global-error.js，仍建议定义一个根error.js其后背组件将渲染within根布局</li>
</ul>
</li>
</ul>
<h3 id="并行路由"><a href="#并行路由" class="headerlink" title="并行路由"></a><p id="ref5">并行路由</p></h3><ul>
<li>允许同时或有条件地在同一布局中渲染一个或多个页面。允许根据条件渲染插槽</li>
<li>插槽：使用slots创建并行路由，按照@folder约定定义的，并作为props传递到同一级别的布局</li>
<li>children属性是一个隐式插槽，不需要映射到文件夹。<span class="desc">即app&#x2F;page.js &#x3D;&#x3D;&#x3D; app&#x2F;@children&#x2F;page.js</span></li>
<li>未匹配的路由 default.js<ul>
<li>默认情况下槽内渲染的内容将于当前URL匹配</li>
<li>在插槽文件夹下在新建default.js作为后备渲染</li>
</ul>
</li>
<li>useSelectedLayoutSegment(s)<ul>
<li>都接收 parallelRoutesKey，它允许你读取该槽内的活动航路段。</li>
<li>当用户导航到 URL 栏中的 @auth&#x2F;login 或 &#x2F;login 时，loginSegments 将等于字符串 “login”</li>
</ul>
</li>
</ul>
<h3 id="拦截路由"><a href="#拦截路由" class="headerlink" title="拦截路由"></a><p id="ref6">拦截路由</p></h3><ul>
<li>允许从当前布局内应用的其他部分加载路由。</li>
<li>使用(…)来定义,在文件夹的名称哪里添加，类似于相对路径..&#x2F;,约定基于路由段<ul>
<li>(.): 匹配<span class="key_words">『同一水平』</span>上的段</li>
<li>(..): 匹配<span class="key_words">『高一级』</span>的段</li>
<li>(..)(..): 匹配<span class="key_words">『上面两级』</span>的段</li>
<li>(…): 匹配root app目录中的段</li>
</ul>
</li>
</ul>
<h3 id="路由处理程序"><a href="#路由处理程序" class="headerlink" title="路由处理程序"></a>路由处理程序</h3><ul>
<li>使用 Web 请求 和 响应 API 为给定路由创建自定义请求处理程序</li>
<li>仅在 app 目录中可用,相当于 pages 目录中的 API 路由，<br> 在app目录内的route.js|ts文件中定义<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> dynamic = <span class="string">&quot;force-dynamic&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">GET</span>(<span class="params">request: Request</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>支持的HTTP方法：GET、POST、PUT、PATCH、DELETE、HEAD 和 OPTIONS</li>
<li>扩展API：NextRequest 和 NextResponse</li>
<li>行为<ul>
<li>缓存<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">GET</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;searchParams&#125; = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>)<span class="comment">// 将Request对象与GET方法一起使用时存在</span></span><br><span class="line">  <span class="keyword">const</span> id = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;id&#x27;</span>) <span class="comment">// 将Request对象与GET方法一起使用时存在</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://data.mogodb.api.com/product/<span class="subst">$&#123;id&#125;</span>`</span> &#123;</span><br><span class="line">    <span class="attr">methods</span>: <span class="string">&#x27;POST&#x27;</span> <span class="comment">// post方法的情况存在</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;API-Key&#x27;</span>: process.<span class="property">env</span>.<span class="property">DATA_API_KEY</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Data</span>().<span class="title function_">toISOString</span>() &#125;) <span class="comment">// post方法的情况存在</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>(</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Response</span>.<span class="title function_">json</span>(&#123;data&#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>选择退出缓存<ul>
<li>将Request对象与GET方法一起使用</li>
<li>使用任何其它HTTP方法</li>
<li>像使用cookies和headers一样使用动态函数</li>
<li>片段配置选项手动指定动态模式</li>
</ul>
</li>
</ul>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul>
<li>在缓存内容和路由匹配之前运行</li>
<li>使用项目根目录中的文件middleware.ts|js来定义中间件</li>
</ul>
<h2 id="数据获取-1"><a href="#数据获取-1" class="headerlink" title="数据获取"></a>数据获取</h2><h3 id="数据获取-2"><a href="#数据获取-2" class="headerlink" title="数据获取"></a>数据获取</h3><ul>
<li>四种方式获取数据<ul>
<li>在服务器上，使用fetch</li>
<li>在服务器上，带有第三方库</li>
<li>在客户端上，通过路由处理程序</li>
<li>在客户端，使用第三方库</li>
</ul>
</li>
<li>在服务器上，使用fetch<ul>
<li>可以在服务器组件、路由处理程序 和 服务器操作 中将 fetch 与 async&#x2F;await 一起使用</li>
<li>在路由处理程序中，fetch 请求不会被记忆，因为路由处理程序不是 React 组件树的一部分。</li>
</ul>
</li>
</ul>
<h3 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h3><ul>
<li>默认情况下， 会自动将fetch的返回值缓存到服务器上的数据缓存</li>
<li>数据缓存是持久的HTTP缓存。根据你的平台，缓存可以自动扩展并达到跨多个区域共享</li>
</ul>
<h3 id="重新验证数据"><a href="#重新验证数据" class="headerlink" title="重新验证数据"></a>重新验证数据</h3><ul>
<li>是清除数据缓存并重新获取最新数据的过程。当数据变化时要确保显示最新数据时非常有用</li>
<li>方式一:<span class="key_words">『基于时间的重新验证』</span><ul>
<li>定时更新。用于不经常更改且不重要的数据</li>
<li>使用fetch的 next.revalidate 选项来设置资源的缓存生命周期<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;heeps://...&quot;</span>,&#123; <span class="attr">next</span>: &#123; <span class="attr">revalidate</span>: <span class="number">3600</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>方式二:<span class="key_words">『按需重新验证』</span><ul>
<li>根据时间手动重新验证数据。</li>
<li>数据可以通过路径(revalidatePath)或通过<span class="key_words">『服务器动作或路由处理程序』</span>内的缓存标签 (revalidateTag)按需重新验证</li>
<li>next 有一个缓存标记系统，用于使跨路由的fetch请求无效<ul>
<li>使用fetch时，可以选择使用一个或多个标签来标记缓存条目<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://...&#x27;</span>, &#123;<span class="attr">next</span>: &#123;<span class="attr">tags</span>: [<span class="string">&#x27;collection&#x27;</span>]&#125;&#125;)      </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>然后，调用revalidateTag来重新验证与改标签关联的条目<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; revalidateTag &#125; <span class="keyword">from</span> <span class="string">&#x27;next/cache&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">action</span>(<span class="params"></span>) &#123; <span class="title function_">revalidateTag</span>(<span class="string">&#x27;collection&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="选择退出数据缓存"><a href="#选择退出数据缓存" class="headerlink" title="选择退出数据缓存"></a>选择退出数据缓存</h3><ul>
<li>满足以下条件，则 fetch 请求将被缓存 not</li>
<li>cache: ‘no-store’ 添加到 fetch 请求中。</li>
<li>revalidate: 0 选项添加到各个 fetch 请求中。</li>
<li>fetch 请求位于使用 POST 方法的路由处理程序内部。</li>
<li>fetch 请求在使用 headers 或 cookies 之后出现。</li>
<li>使用 const dynamic &#x3D; ‘force-dynamic’ 航路段选项。</li>
<li>fetchCache 路由段选项默认配置为跳过缓存。</li>
<li>fetch 请求使用 Authorization 或 Cookie 标头，并且组件树中其上方有一个未缓存的请求。</li>
</ul>
<h3 id="数据获取模式"><a href="#数据获取模式" class="headerlink" title="数据获取模式"></a>数据获取模式</h3><ol>
<li>在服务器上获取数据</li>
<li>在需要的地方获取数据： 在在数据组件使用fetch或react cache。因为fetch会自动记忆</li>
<li>流式(Streaming)和 悬念(Suspense)：逐步渲染UI并将其增量流式传输到客户端</li>
<li>并行和顺序数据获取<ul>
<li>使用<span class="key_words">『顺序数据获取』</span>: 路由中的请求相互依赖，因此会创建瀑布。当因为一次提取取决于另一次提取的结果，或者希望在下一次提取之前满足某个条件以节省资源的情况使用。类似于react从布局中单独拎其中一个布局渲染完在回到原布局。</li>
<li>使用<span class="key_words">『并行数据获取』</span>: 路由中的请求会立即发起，同时加载数据。就是两个函数同时请求完然后布局在调用</li>
</ul>
</li>
<li>预加载数据<ul>
<li>创建preload函数。不必将Promise作为props传递下去。preload函数是一种模式，名字可自定义<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">preload</span>= (<span class="params">id: string</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">getItem</span>(id) <span class="comment">// 预加载的函数API </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后在正常请求这个API(getItem)，最后页面函数直接调用preload即可</li>
</ul>
</li>
<li>使用 React cache、server-only 和预加载模式<ul>
<li>通过这种方法，可以与获取数据，缓存响应，并保证此数据获取只发生在服务器上<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; cache &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;server-only&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">preload</span> = (<span class="params">id: string</span>) =&gt; &#123; <span class="keyword">void</span> <span class="title function_">getItem</span>(id) &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getItem = <span class="title function_">cache</span>(<span class="title function_">async</span>(<span class="attr">id</span>: string) =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="形式和突变"><a href="#形式和突变" class="headerlink" title="形式和突变"></a>形式和突变</h3><ul>
<li>仅服务器表单<ul>
<li>在函数顶部使用”use server”</li>
</ul>
</li>
<li>重新验证数据<ul>
<li>使用revalidatePath(‘&#x2F;‘)使整个路线段失效或使用revalidateTag()使带有缓存标记的特定数据失效</li>
</ul>
</li>
<li>重定向<ul>
<li>使用redirect(url)</li>
</ul>
</li>
<li>表单验证<ul>
<li>使用required和type&#x3D;”email”等HTML验证进行基本表单验证</li>
</ul>
</li>
<li>显示加载状态<ul>
<li>当表单在服务器上提交时，使用useFormStatus()显示加载状态，只能用作服务器操作的form元素的子元素</li>
</ul>
</li>
<li>错误处理<ul>
<li>请求时一起返回</li>
</ul>
</li>
<li>乐观的更新<ul>
<li>使用后在服务器操作完成之前乐观地更新 UI<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useOptimistic</span>(messages,</span><br><span class="line">  <span class="function">(<span class="params">state,newMessage</span>) =&gt;</span> [...state, &#123;<span class="attr">message</span>:newMessage&#125;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>设置cookie<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookies().set(key,val)</span><br></pre></td></tr></table></figure></li>
<li>读取cookie<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookies().get(key)?.value</span><br></pre></td></tr></table></figure></li>
<li>删除cookie<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookies().delete(key)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h3 id="服务器组件"><a href="#服务器组件" class="headerlink" title="服务器组件"></a><p id="ref4">服务器组件</p></h3><ul>
<li>三种不同的服务器渲染策略<ul>
<li>静态渲染</li>
<li>动态渲染</li>
<li>流式</li>
</ul>
</li>
<li>优点<ul>
<li>数据获取：减少渲染所用时间及客户端发出的请求量 </li>
<li>安全</li>
<li>缓存：可以重用</li>
<li>打包尺寸：对网速慢或设备差的用户有益</li>
<li>初始页面加载和首次内容绘制FCP：可以生成用户立即查看的页面</li>
<li>搜索引擎优化和社交网络共享性</li>
<li>流式：渲染分多块，按块渲染</li>
</ul>
</li>
</ul>
<h3 id="服务器组件是如何渲染的？"><a href="#服务器组件是如何渲染的？" class="headerlink" title="服务器组件是如何渲染的？"></a>服务器组件是如何渲染的？</h3><ul>
<li>渲染工作被分成几个块：<span class="key_words">『按个别路线段和悬念边界』</span>，每个块都分两步渲染：</li>
<li>React将服务器组件渲染为一种称为<span class="key_words">『React服务器组件有效负载』</span>(RSC 有效负载)的特殊数据格式。</li>
<li>Next.js 使用 RSC 有效负载和客户端组件 JavaScript 指令在服务器上呈现 HTML。</li>
<li>然后，在客户端：<ul>
<li>HTML用于立即显示路线的快速非交互式预览</li>
<li>React服务器组件有效负载用于协调客户端和服务器组件树，并更新DOM</li>
<li>JavaScript指令用于hydrate客户端组件并使应用具有交互性</li>
</ul>
</li>
<li>静态渲染(默认)<ul>
<li>路线在构建时间渲染或在数据重新验证之后在后台验证。结果被缓存并可以推送到内容分发网络CDN</li>
<li>适用：已知内容</li>
</ul>
</li>
<li>动态渲染<ul>
<li>在请求时间处为每个用户渲染路线</li>
<li>适用：个性化数据和仅在请求时才能直到的信息</li>
</ul>
</li>
</ul>
<h3 id="客户端组件"><a href="#客户端组件" class="headerlink" title="客户端组件"></a>客户端组件</h3><ul>
<li>在请求时在客户端上渲染交互式UI</li>
<li>优点：<ul>
<li>互动性: 客户端组件可以适用状态、效果和事件监听器，意味着可以向用户踢狗即时反馈并更新UI</li>
<li>浏览器API：客户端组件可以访问浏览器API</li>
</ul>
</li>
<li>使用： 在文件顶部添加”use client”,声明服务器和客户端组件模块之间的boundary</li>
<li>客户端组件时如何渲染的？<ul>
<li>整页加载<ul>
<li>在服务器上：<ol>
<li>React 将服务器组件渲染为一种称为 React 服务器组件有效负载（RSC 有效负载） 的特殊数据格式，其中包括对客户端组件的引用。</li>
<li>Next.js 使用 RSC 有效负载和客户端组件 JavaScript 指令在服务器上呈现路由的 HTML。</li>
</ol>
</li>
<li>然后，在客户端：<ol>
<li>HTML 用于立即显示路线的快速非交互式初始预览。</li>
<li>React 服务器组件有效负载用于协调客户端和服务器组件树，并更新 DOM。</li>
<li>JavaScript 指令用于 hydrate 客户端组件并使其 UI 具有交互性。</li>
</ol>
</li>
</ul>
</li>
<li>后续导航<ul>
<li>在后续导航中，客户端组件完全在客户端上渲染，而不需要服务器渲染的 HTML。</li>
</ul>
</li>
</ul>
</li>
<li>这意味着客户端组件 JavaScript 包已下载并解析。 一旦包准备好，React 将使用 RSC Payload 来协调客户端和服务器组件树，并更新 DOM。</li>
</ul>
<h3 id="服务器和客户端组合模式"><a href="#服务器和客户端组合模式" class="headerlink" title="服务器和客户端组合模式"></a>服务器和客户端组合模式</h3><ul>
<li>服务器组件模式<ul>
<li>组件之间共享数据</li>
<li>将仅服务器代码排除在客户端环境之外</li>
<li>使用第三方软件包和提供商</li>
</ul>
</li>
<li>客户端组件<ul>
<li>将客户端组件移至树下</li>
<li>将属性从服务器传递到客户端组件（序列化）</li>
</ul>
</li>
<li>交错服务器和客户端组件<ul>
<li>不支持的模式：将服务器组件导入客户端组件</li>
<li>支持的模式：将服务器组件作为 Props 传递给客户端组件<ul>
<li>使用 React children 属性在客户端组件中创建 “slot”。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Edge-和-Node-js-运行时"><a href="#Edge-和-Node-js-运行时" class="headerlink" title="Edge 和 Node.js 运行时"></a><a href="https://next.nodejs.cn/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes">Edge 和 Node.js 运行时</a></h3><ul>
<li>Node.js 运行时（默认）可以访问生态系统中的所有 Node.js API 和兼容包。</li>
<li>Edge 运行时 是基于 网络 API 的。</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Git知识</title>
    <url>/2024/10/30/Engineering/Git%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ul>
<li><h3 id="集中式-svn"><a href="#集中式-svn" class="headerlink" title="集中式(svn)"></a>集中式(svn)</h3><ul>
<li>svn 因为每次存的都是差异，需要的硬盘空间会相对的小一点，但回滚的速度会很慢</li>
<li>优点: 代码存放在单一的服务器上 便于项目的管理</li>
<li>缺点: 服务器宕机，数据就存在丢失的风险</li>
</ul>
</li>
<li><h3 id="分布式-git"><a href="#分布式-git" class="headerlink" title="分布式(git)"></a>分布式(git)</h3><ul>
<li>git 每次存的都是项目的完整快照，需要的硬盘空间会相对大一点<br>(<span class="desc">Git 团队对代码做了极致的压缩，最终需要的实际空间比 svn 多一点，但回滚速度极快</span>)</li>
<li>优点: 完全的分布式</li>
<li>缺点: 学习起来比 SVN 陡峭</li>
</ul>
</li>
</ul>
<h2 id="底层命令"><a href="#底层命令" class="headerlink" title="底层命令"></a>底层命令</h2><h3 id="git-对象"><a href="#git-对象" class="headerlink" title="git 对象"></a>git 对象</h3><ul>
<li>生成一个 hash 值:压缩后的文件内容的键值对存到.git&#x2F;objects：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git hash-object -w fileUrl</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="tree-对象"><a href="#tree-对象" class="headerlink" title="tree 对象"></a>tree 对象</h3><ul>
<li>往暂存区添加一条记录(让 git 对象对应上文件名)存到.git&#x2F;index：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git update-index --add --cacheinfo 100644 hash test.txt</span><br></pre></td></tr></table></figure></li>
<li>生成树对象存到.git&#x2F;objects: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git write-tree</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="commit-对象"><a href="#commit-对象" class="headerlink" title="commit 对象"></a>commit 对象</h3><ul>
<li>生成一个提交对象存到.git&#x2F;objects: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;first commit&#x27; | git commit-tree treehash</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="初始化配置和文件的-UDR-命令"><a href="#初始化配置和文件的-UDR-命令" class="headerlink" title="初始化配置和文件的 UDR 命令"></a>初始化配置和文件的 UDR 命令</h2><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><ul>
<li>配置用户名：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;name&quot;</span><br></pre></td></tr></table></figure></li>
<li>配置邮箱：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.email name@example.com</span><br></pre></td></tr></table></figure></li>
<li>获取设置配置列表：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li>
<li>初始化仓库: git init</li>
</ul>
<h3 id="U-修改提交操作"><a href="#U-修改提交操作" class="headerlink" title="U(修改提交操作)"></a>U(修改提交操作)</h3><ul>
<li>将单个文件从工作区添加到暂存区: git add file</li>
<li>将所有文件添加到暂存区: git add .</li>
<li>将暂存区的文件提交到本地仓库: git commit -m “msg”</li>
</ul>
<h3 id="D-删除-重命名"><a href="#D-删除-重命名" class="headerlink" title="D(删除 &amp; 重命名)"></a>D(删除 &amp; 重命名)</h3><ul>
<li>删除：git rm deleteFileName</li>
<li>重命名：git mv oldFileName newFileName</li>
</ul>
<h3 id="R-查询操作"><a href="#R-查询操作" class="headerlink" title="R(查询操作)"></a>R(查询操作)</h3><ul>
<li>查看工作目录中文件的状态: git status(已跟踪(已提交 已暂存 已修改) 未跟踪)</li>
<li>查看未暂存的修改,比较文件不同，即暂存区和工作区的差异: git diff</li>
<li>查看未提交的暂存: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --cache</span><br></pre></td></tr></table></figure></li>
<li>查看提交记录: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><blockquote>
<p>分支的本质其实就是一个提交对象!!!</p>
</blockquote>
<ul>
<li>HEAD:<ul>
<li>一个指针，它默认指向 master 分支，切换分支时其实就是让 HEAD 指向不同的分支</li>
<li>每次有新的提交时 HEAD 都会带着当前指向的分支，一起往前移动</li>
</ul>
</li>
</ul>
<h3 id="git-分支命令"><a href="#git-分支命令" class="headerlink" title="git 分支命令"></a>git 分支命令</h3><ul>
<li>查看整个项目的分支图: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log [--oneline | --decorate | --graph | --all]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><ul>
<li>查看分支列表: git branch</li>
<li>查看所有分支: git branch -a</li>
<li>查看分支指向的最新的提交: git branch -v</li>
<li>查看合并到当前分支的分支列表: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch --merged // 一旦出现在这个列表中就应该考虑删除已合并的分支</span><br></pre></td></tr></table></figure></li>
<li>查看没有合并到当前分支的分支列表: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch --no-merged // 一旦出现在这个列表中就应该观察一下是否需要合并</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><ul>
<li>⭐ 创建分支: git branch createName</li>
<li>在指定的提交对象上创建新的分支: git branch createName commithash — 版本穿梭(时光机)</li>
</ul>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><ul>
<li>⭐ 删除本地分支: git branch -d deleteFeatureName</li>
<li>强制删除分支: git branch -D deleteFeatureName</li>
<li>⭐ 删除远程分支: git push origin -d deleteOriginFeatureName</li>
</ul>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><ul>
<li>⭐ 切换分支: git checkout featureName</li>
<li>创建并切换到新分支: git checkout -b featureName</li>
</ul>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul>
<li>合并某个分支到当前分支，默认 fast forward: git merge featureName<ul>
<li>快进合并 –&gt; 不会产生冲突</li>
<li>典型合并 –&gt; 有机会产生冲突</li>
<li>解决冲突 –&gt; 打开冲突的文件 进行修改 add commit</li>
</ul>
</li>
</ul>
<h3 id="git-分支的注意点"><a href="#git-分支的注意点" class="headerlink" title="git 分支的注意点"></a>git 分支的注意点</h3><ul>
<li>在切换的时候 一定要保证当前分支是干净的!!!</li>
<li><span class="key_words">『允许』</span>切换分支:<ul>
<li>分支上所有的内容处于<span class="key_words">『已提交状态』</span></li>
<li>(避免)分支上的内容是初始化创建 处于未跟踪状态</li>
<li>(避免)分支上的内容是初始化创建 第一次处于已暂存状态</li>
</ul>
</li>
<li><span class="key_words">『不允许』</span>切分支:<ul>
<li>分支上所有的内容处于<span class="key_words">『已修改状态』</span>或第二次以后的<span class="key_words">『已暂存状态』</span></li>
</ul>
</li>
<li>在分支上的工作做到一半时 如果有切换分支的需求, 我们应该将现有的工作<span class="key_words">『贮藏』</span>起来</li>
</ul>
<h3 id="贮藏"><a href="#贮藏" class="headerlink" title="贮藏"></a>贮藏</h3><ul>
<li>⭐ 将当前工作区改过的文件贮藏到栈中，贮藏后当前库是上一个已提交的状态: git stash</li>
<li>⭐ 查看当前贮藏列表的文件：git stash list</li>
<li>将栈顶的工作内容恢复，但不让任何内容出栈：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash apply &lt;name&gt;</span><br><span class="line">例： git stash apply stash@&#123;1&#125;</span><br></pre></td></tr></table></figure></li>
<li>取出栈顶的工作内容后就应该将其删除(出栈): git stash drop</li>
<li>⭐ 恢复贮藏起来的文件并把列表中对应文件删除，是 apply+drop 操作：git stash pop fileName</li>
<li>删除所有stash记录：git stash clear</li>
<li>保存当前未commit代码并添加备注：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash save &quot;备注的内容&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="撤销与回退操作-后悔药"><a href="#撤销与回退操作-后悔药" class="headerlink" title="撤销与回退操作(后悔药)"></a>撤销与回退操作(后悔药)</h2><h3 id="撤销：当修改了工作区-暂存区的文件，想要撤销之前的操作"><a href="#撤销：当修改了工作区-暂存区的文件，想要撤销之前的操作" class="headerlink" title="撤销：当修改了工作区&#x2F;暂存区的文件，想要撤销之前的操作"></a>撤销：当修改了工作区&#x2F;暂存区的文件，想要撤销之前的操作</h3><ul>
<li><p>场景 1：(撤销工作目录的修改)当改乱了工作区某个文件的内容，但还未 add 到暂存区</p>
<ul>
<li>撤销指定文件的修改：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- fileName // -- 表示是文件名不是分支名，不混淆可不用</span><br></pre></td></tr></table></figure></li>
<li>撤销所有工作区的修改：git checkout .</li>
<li>撤销工作区和暂存区的所有修改：git checkout -f</li>
</ul>
</li>
<li><p>场景 2：(撤销暂存区的修改)当乱改了工作区某个文件的内容，并且 git add 到了暂存区</p>
<ol>
<li>将暂存区的文件修改撤销掉：git reset HEAD fileName</li>
<li>将工作区的文件修改撤销掉：git checkout fileName</li>
</ol>
</li>
<li><p>场景 3：乱改了很多文件，想回到最新一次提交时的状态</p>
<ul>
<li>撤销工作区中所有未提交文件的修改内容：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>场景 4：(撤销提交)在当前最后一次提交的 commit 信息，还没有 push 到远程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="回退：当已经进行了-commit-操作，需要回退到之前的版本："><a href="#回退：当已经进行了-commit-操作，需要回退到之前的版本：" class="headerlink" title="回退：当已经进行了 commit 操作，需要回退到之前的版本："></a>回退：当已经进行了 commit 操作，需要回退到之前的版本：</h3><ul>
<li>查看每一步操作的记录: git reflog (谨慎！！！每次改变都会记录)</li>
<li>设置为某一 id 的记录: git reset id</li>
<li>设置为对应 id 记录: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard id</span><br></pre></td></tr></table></figure></li>
<li>回退到上次提交的状态: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li>
<li>回退到 n 个版本前的状态: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD~n</span><br></pre></td></tr></table></figure></li>
<li>回退到某一个 commitid 的状态及内容，只改变 HEAD：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD commitid（会把commitid之后的记录放到暂存区）</span><br></pre></td></tr></table></figure></li>
<li>回退到某一个 commitid 的状态，并保留工作区的内容：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --mixed(默认) HEAD commitid</span><br></pre></td></tr></table></figure></li>
<li>回退到某一个 commitid 的状态及内容，并重置暂存区和工作目录：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD commitid</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h3><ul>
<li>回滚操作：适用于reset命令后发现误操作了其他记录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看历史记录: git reflog // 把错误提交的commitHash记住</span><br><span class="line">回滚错误: git reset --hard commitHash </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="checkout-深入"><a href="#checkout-深入" class="headerlink" title="checkout 深入"></a>checkout 深入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout brancname 跟 git reset --hard commithash 特别像</span><br></pre></td></tr></table></figure>
<h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ul>
<li>都需要重置 HEAD 暂存区 工作目录</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>checkout 对工作目录是安全的 <code>reset --hard</code> 是强制覆盖</li>
<li>checkout 动 HEAD 时不会带着分支走而是切换分支</li>
<li><code>reset --hard</code> 时是带着分支走</li>
</ul>
<h3 id="checkout-路径"><a href="#checkout-路径" class="headerlink" title="checkout + 路径"></a>checkout + 路径</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout commithash filename</span><br></pre></td></tr></table></figure>
<ul>
<li>重置暂存区</li>
<li>重置工作目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure>
<ul>
<li>重置工作目录</li>
</ul>
<h2 id="远程协作"><a href="#远程协作" class="headerlink" title="远程协作"></a>远程协作</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li><p>项目经理初始化远程仓库</p>
<ul>
<li>一定要初始化一个空的仓库; 在 github 上操作</li>
</ul>
</li>
<li><p>项目经理创建本地仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote 别名 仓库地址(https)</span><br><span class="line">git init 将源码复制进来</span><br><span class="line">修改用户名 修改邮箱</span><br><span class="line">git add</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目经理推送本地仓库到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push 别名 分支 // 输入用户名密码;推完之后会附带生成远程跟踪分支</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目邀请成员 &amp; 成员接受邀请</p>
<ul>
<li>在 github 上操作</li>
</ul>
</li>
<li><p>成员克隆远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 仓库地址 // 在本地生成.git 文件 默认为远程仓库配了别名 orgin</span><br></pre></td></tr></table></figure>
<ul>
<li>只有在克隆的时候 本地分支 master 和 远程跟踪分支别名&#x2F;master 是有同步关系的</li>
</ul>
</li>
<li><p>成员做出贡献</p>
<ul>
<li>修改源码文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line">git push 别名 分支 // 输入用户名 密码;推完之后会附带生成远程跟踪分支</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>项目经理更新修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch 别名 // 将修改同步到远程跟踪分支上</span><br><span class="line">git merge 远程跟踪分支</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="做远程跟踪"><a href="#做远程跟踪" class="headerlink" title="做远程跟踪"></a>做远程跟踪</h3><ul>
<li>克隆仓库时会自动为 master 做跟踪</li>
<li>本地没有分支: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout --track remote/featureName</span><br></pre></td></tr></table></figure></li>
<li>本地已经创建了分支: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -u remote/featureName</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><ul>
<li>刷新远程分支信息: git fetch</li>
<li>将本地 master 分支推送到远程对应分支: git push origin master</li>
<li>下载远程代码并合并: git pull</li>
<li>拉取远程最新代码并合并，不会产生 Merge: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure></li>
<li>推送本地代码到远程分支上: git push</li>
<li>将远程仓库和本地仓库关联起来: git remote add origin url</li>
<li>查看远程库信息: git remote -v</li>
</ul>
<h2 id="rebase-和-merge"><a href="#rebase-和-merge" class="headerlink" title="rebase 和 merge"></a>rebase 和 merge</h2><h3 id="rebase-把分叉的提交历史“整理”成一条直线，看上去更直观"><a href="#rebase-把分叉的提交历史“整理”成一条直线，看上去更直观" class="headerlink" title="rebase: 把分叉的提交历史“整理”成一条直线，看上去更直观"></a>rebase: 把分叉的提交历史“整理”成一条直线，看上去更直观</h3><ul>
<li>变基：git rebase</li>
<li>将当前分支移植到指定分支或者 commit 之上：git rebase -i commit</li>
<li>从远程回退到未提交状态：git reset HEAD^</li>
</ul>
<h3 id="merge：-每次操作都会产生一条-merge-记录，从日志上看的，会产生分叉，日志看起来杂乱"><a href="#merge：-每次操作都会产生一条-merge-记录，从日志上看的，会产生分叉，日志看起来杂乱" class="headerlink" title="merge： 每次操作都会产生一条 merge 记录，从日志上看的，会产生分叉，日志看起来杂乱"></a>merge： 每次操作都会产生一条 merge 记录，从日志上看的，会产生分叉，日志看起来杂乱</h3><h2 id="git-修改默认-pull-的参数"><a href="#git-修改默认-pull-的参数" class="headerlink" title="git 修改默认 pull 的参数"></a>git 修改默认 pull 的参数</h2><ul>
<li>git pull &#x3D; git fetch + git merge</li>
<li>全局修改 pull 的命令: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --add pull.rebase true</span><br></pre></td></tr></table></figure></li>
<li>查看命令是否修改成功：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global -l</span><br></pre></td></tr></table></figure></li>
<li>如果之前向全局配置文件修改过 pull 的配置项，但修改错了，使用<code>--unset</code></li>
<li>使用–unset 后，发现提示有多个值，则使用<code>--replace-all</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --replace-all pull.rebase true</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="修改全局配置项"><a href="#修改全局配置项" class="headerlink" title="修改全局配置项"></a>修改全局配置项</h2><h3 id="新增一个配置项：-add"><a href="#新增一个配置项：-add" class="headerlink" title="新增一个配置项：--add"></a>新增一个配置项：<code>--add</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：git config --local/--global/--system --add section.key value</span><br><span class="line">示例: git config --global --add pull.rebase true</span><br></pre></td></tr></table></figure>
<h3 id="获取一个配置项：-get"><a href="#获取一个配置项：-get" class="headerlink" title="获取一个配置项：--get"></a>获取一个配置项：<code>--get</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：git config --local/--global/--system --get section.key</span><br></pre></td></tr></table></figure>
<h3 id="删除一个配置项：-unset"><a href="#删除一个配置项：-unset" class="headerlink" title="删除一个配置项：--unset"></a>删除一个配置项：<code>--unset</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：git config --local/--global/--system --unset section.key</span><br><span class="line">示例：git config --global --unset pull.rebase</span><br></pre></td></tr></table></figure>
<h3 id="查看配置文件：-list-l"><a href="#查看配置文件：-list-l" class="headerlink" title="查看配置文件：--list/-l"></a>查看配置文件：<code>--list/-l</code></h3><ul>
<li>查看仓库级的 config：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --local -l</span><br></pre></td></tr></table></figure></li>
<li>查看全局级的 config：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global -l</span><br></pre></td></tr></table></figure></li>
<li>查看系统级的 config：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --system -l</span><br></pre></td></tr></table></figure></li>
<li>查看当前生效的配置：git config -l</li>
</ul>
<h3 id="编辑配置文件：-edit-e"><a href="#编辑配置文件：-edit-e" class="headerlink" title="编辑配置文件：--edit/-e"></a>编辑配置文件：<code>--edit/-e</code></h3><ul>
<li>编辑仓库级的 config: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --local -e</span><br></pre></td></tr></table></figure></li>
<li>编辑全局级的 config：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global -e</span><br></pre></td></tr></table></figure></li>
<li>编辑系统级的 config: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --system -e</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><span class="key_words">本地仓库</span>：<ul>
<li>存放所有相关的文件，具体分为工作区、暂存区和仓库区，<span class="key_words">『暂存区和仓库区则在.git文件夹下』</span></li>
</ul>
</li>
<li><span class="key_words">工作区</span>：<ul>
<li>即我们工作的文件夹(<span class="desc">不包含.git文件夹</span>)，在里面进行文件的增删改操作</li>
</ul>
</li>
<li><span class="key_words">暂存区</span>：<ul>
<li>临时保存工作区的改动，通过git add操作将工作区的修改同步到暂存区</li>
</ul>
</li>
<li><span class="key_words">仓库区</span>：<ul>
<li>当执行git commit操作时，将暂存区上的所有变动同步到<span class="key_words">『本地仓库』</span></li>
</ul>
</li>
<li><span class="key_words">远程仓库</span>：<ul>
<li>GitHub&#x2F;GitLab 上保存的仓库，通过 git push 将本地仓库同步到远程仓库，也可以通过 git fetch&#x2F;pull 将远程仓库同步到本地仓库</li>
</ul>
</li>
<li><span class="key_words">快照</span>：<ul>
<li>git 将顶级目录中的文件和文件夹称作集合，并通过一系列快照来管理历史记录。在 git 的术语中，</li>
<li><span class="key_words">『文件被称为blob对象(数据对象)』</span>，也就是一组数据。</li>
<li><span class="key_words">『目录则被称为tree(树)』</span>,目录可以包含文件和子目录。</li>
<li><span class="key_words">『快照统称“commit”』</span>，每个快照都有一系列的父辈。<span class="key_words">『每次commit都是创建一个全新的记录』</span></li>
</ul>
</li>
<li>master 引用通常会指向<span class="key_words">『主分支最新一次 commit』</span>.在 Git 中，<span class="key_words">『当前的位置』</span>有一个特殊的索引，它就是“HEAD”。</li>
</ul>
<h3 id="checkout-可以用于切换分支，可以从历史提交或暂存区中拷贝文件到工作目录"><a href="#checkout-可以用于切换分支，可以从历史提交或暂存区中拷贝文件到工作目录" class="headerlink" title="checkout 可以用于切换分支，可以从历史提交或暂存区中拷贝文件到工作目录"></a>checkout 可以用于切换分支，可以从历史提交或暂存区中拷贝文件到工作目录</h3><ul>
<li>当给定某个文件名时，git 会从指定的提交中拷贝文件到暂存区域和工作目录。</li>
</ul>
<h3 id="HEAD-标识处于分离状态的提交操作"><a href="#HEAD-标识处于分离状态的提交操作" class="headerlink" title="HEAD 标识处于分离状态的提交操作"></a>HEAD 标识处于分离状态的提交操作</h3><ul>
<li>可以正常提交，但不会更新任何命名分支，一旦切换到别的分支，这个提交节点再也不会被引用就会被丢弃</li>
<li>如果想保存这个状态，可以用 git checkout -b name 来创建一个新的分支</li>
</ul>
<h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><ul>
<li>也用来从仓库中复制文件到索引，而不动工作目录</li>
<li>当前分支默认指向到那个提交。用<code>--hard</code>，工作目录也更新，用<code>--soft</code> ，都不变</li>
<li>没有给出提交点的版本号，默认用 HEAD。分支执行不变，但是索引会回滚到最后一次提交。用<code>--hard</code>，工作目录也同样</li>
</ul>
<h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><ul>
<li>将现有的提交还原，恢复提交的内容，并生成一条还原记录。</li>
<li>git revert commitHash</li>
</ul>
<h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><ul>
<li>将已经提交的 commit，复制出新的 commit 应用到分支里</li>
<li>应用场景： 比如全部都在master上开发，突然当前a开发没开发完或先不上，要先开发b，那么a不需要需要移到其他分支，避免污染代码记录</li>
<li>获取commitHash：git log</li>
<li>复制单个: 先复制对应记录的commitHash，然后切到其他分支：git cherry-pick commitHash</li>
<li>复制多个：git cherry-pick commitHash1 commitHash2</li>
<li>复制多个连续的commit：git cherry-pick commit1^..commit2</li>
<li>遇到冲突：先解决冲突，在执行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick [--continue/放弃 --abort(回到之前)/退出 --quit(保留操作成功的)]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><ul>
<li>merge 命令把不同分支合并起来。<span class="key_words">『合并前，索引必须和当前提交相同。』</span></li>
<li>cherry-pick 复制一个提交节点并在当前分支做一次完全一样的新提交</li>
</ul>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><ul>
<li>合并分支。本质上，是线性化的自动的 cherry-pick</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/../../img/Engineering/git%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE.webp" alt="git工作原理图"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">	工作区==git add files==&gt;暂存区/索引</span><br><span class="line">	暂存区/索引==git checkout -- files==&gt;工作区</span><br><span class="line">	暂存区/索引==git commit==&gt;仓库区</span><br><span class="line">	仓库区==git reset -- files==&gt;暂存区/索引</span><br><span class="line">  仓库区==git checkout HEAD -- files==&gt;工作区</span><br><span class="line">  工作区==git commit files==&gt;仓库区</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="工作区-–-暂存区-–-仓库区-–-就走完本地仓库-–-推送到远程仓库"><a href="#工作区-–-暂存区-–-仓库区-–-就走完本地仓库-–-推送到远程仓库" class="headerlink" title="工作区 –&gt; 暂存区 –&gt; 仓库区 –&gt; 就走完本地仓库 –&gt; 推送到远程仓库"></a>工作区 –&gt; 暂存区 –&gt; 仓库区 –&gt; 就走完本地仓库 –&gt; 推送到远程仓库</h3></li>
<li>.git</li>
</ul>
<p><img src="/../../img/Engineering/git%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.webp" alt=".git目录结构"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>查看每个 SHA-1 的类型: git cat-file -t</li>
<li>查看每个对象的内容和简单的数据结构: git cat-file -p</li>
<li>把当前文件放入暂存区: git add files</li>
<li>把暂存区生成快照并提交本地仓库: git commit</li>
<li>⭐ 用来<span class="en">撤销暂存区</span>的某一文件, git reset 撤销所有暂存区的文件: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset -- files</span><br></pre></td></tr></table></figure></li>
<li>把文件从暂存区复制到仓库区，用来丢弃本地修改: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- files</span><br></pre></td></tr></table></figure></li>
<li>回滚到复制最后一次提交: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout HEAD -- files</span><br></pre></td></tr></table></figure></li>
<li>相当于运行 git add 把工作区的所有文件加入暂存区再提交到仓库区: git commit -a</li>
<li>进行最后一次提交+工作目录中文件快照的提交，并且文件被添加到暂存区：git commit files</li>
<li>比较两次提交记录的差异：git diff commitId commitId</li>
<li>比较跟远程分支的差异: git diff HEAD</li>
<li>比较跟暂存区的记录的差异: git diff</li>
<li>比较跟某一分支记录的差异: git diff featureName</li>
<li>使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/142289703">点击跳转，去了解更多 git 底层原理</a></p>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Mobx库</title>
    <url>/2024/11/01/Engineering/mobx%E5%BA%93/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>自动获取源自应用state的数据</li>
<li>机制：事件调用actions，使用actions来修改state，然后自动更新，更新的值会触发对应的值变化</li>
<li>安装：<a href="https://cn.mobx.js.org/">mobx的介绍</a></li>
<li>搭档：React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而MobX提供机制来存储和更新应用状态供 React 使用。</li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><a href="#ref1">Observable state(可观察的状态)</a></li>
<li><a href="#ref2">Computed values(计算值)</a></li>
<li><a href="#ref3">React组件-@observer</a></li>
<li><a href="#ref4">Reactions(反应)</a></li>
<li><a href="#ref5">Actions(动作)</a></li>
<li>自定义reactions<ul>
<li>使用<a href="#ref6">autorun</a>、<a href="#ref7">reaction</a>和<a href="#ref8">when</a>来创建</li>
</ul>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>简单，可扩展</li>
<li>保证参照完整性</li>
<li>高效</li>
</ul>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>将应用变成响应式的三个步骤<ul>
<li>定义状态并使其可观察<ul>
<li>使用observable</li>
</ul>
</li>
<li>创建视图以响应状态的变化<ul>
<li>使用@observer</li>
</ul>
</li>
<li>更改状态</li>
</ul>
</li>
</ul>
<h2 id="observable"><a href="#observable" class="headerlink" title="observable"></a><span id="ref1">observable</span></h2><ul>
<li>定义：使用@observable装饰器给现有的数据结构添加<span class="key_words">『可观察功能』</span></li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">observable</span>(value)</span><br><span class="line">@observable classProperty = value</span><br></pre></td></tr></table></figure>
<h3 id="value-的类型"><a href="#value-的类型" class="headerlink" title="value 的类型"></a>value 的类型</h3><ul>
<li>Map: 会返回一个新的Observable Map<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = observable.<span class="title function_">map</span>(&#123; <span class="attr">key</span>: <span class="string">&quot;value&quot;</span>&#125;);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;new value&quot;</span>); </span><br></pre></td></tr></table></figure></li>
<li>数组：会返回一个Observable Array<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="title function_">observable</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) </span><br></pre></td></tr></table></figure></li>
<li>没有原型的对象：会被克隆并且所有属性都会被转换成可观察的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title function_">observable</span>(&#123;</span><br><span class="line">	<span class="comment">// 观察的属性</span></span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="string">&#x27;23&#x27;</span>,</span><br><span class="line">	<span class="attr">show</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="comment">// 计算属性</span></span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">labelText</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">show</span> ? <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> age: <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span> : <span class="variable language_">this</span>.<span class="property">name</span> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 动作</span></span><br><span class="line">	<span class="title function_">setAge</span>(<span class="params">age</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">	<span class="attr">setAge</span>: action</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">autorun</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">labelTExt</span>))</span><br></pre></td></tr></table></figure></li>
<li>有原型的对象(原值类型值和引用类型值)：会返回一个Boxed Observable。在构造函数中使用extendObservable 或在类中使用@observable<ul>
<li>获取当前值: .get()</li>
<li>更新值: .set()</li>
<li>监听值的更改: antorun(()&#x3D;&gt;{})<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eg：<span class="keyword">const</span> temperature = observable.<span class="title function_">box</span>(<span class="number">20</span>);</span><br><span class="line">temperature.<span class="title function_">set</span>(<span class="number">25</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="decorators"><a href="#decorators" class="headerlink" title="decorators"></a>decorators</h3><ul>
<li>不使用observable，然后单独使用decorate来另外定义<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	name = <span class="string">&quot;John&quot;</span></span><br><span class="line">	age = <span class="number">42</span></span><br><span class="line">	showAge = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">labelText</span>() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">showAge</span> ? <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> (age: <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>)`</span> : <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">setAge</span>(<span class="params">age</span>) &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 decorate 时，所有字段都应该指定</span></span><br><span class="line"><span class="title function_">decorate</span>(<span class="title class_">Person</span>, &#123;</span><br><span class="line">	<span class="attr">name</span>: observable,</span><br><span class="line">	<span class="attr">age</span>: observable,</span><br><span class="line">	<span class="attr">showAge</span>: observable,</span><br><span class="line">	<span class="attr">labelText</span>: computed,</span><br><span class="line">	<span class="attr">setAge</span>: action</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="computed"><a href="#computed" class="headerlink" title="(@)computed"></a><span id="ref2">(@)computed</span></h2><ul>
<li>定义：使用@computed装饰器或(extend)Observable时调用的getter&#x2F;setter函数来<span class="key_words">『定义』</span>数据发生变化时<span class="key_words">『自动更新的值』</span></li>
</ul>
<h3 id="computed-与-autorun-的区别"><a href="#computed-与-autorun-的区别" class="headerlink" title="@computed 与 autorun 的区别"></a>@computed 与 autorun 的区别</h3><ul>
<li>@computed：响应式调用的表达式，响应式的产生一个可以被其它observer使用的值</li>
<li>autorun：响应式调用的表达式，与@computed区别，不产生新值，只想要效果</li>
</ul>
<h3 id="getter-与-setter"><a href="#getter-与-setter" class="headerlink" title="getter 与 setter"></a>getter 与 setter</h3><ul>
<li>正常情况下的示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@computed </span><br><span class="line"><span class="keyword">get</span> <span class="title function_">total</span>()&#123; </span><br><span class="line">	retuan <span class="variable language_">this</span>.<span class="property">price</span> * <span class="variable language_">this</span>.<span class="property">amount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>正常情况下setter也不需要注解，因为是一个自动的动作</li>
<li>setter不能用来直接改变计算属性的值，但是可以用来逆向衍生</li>
<li><span class="key_words">『永远在getter之后定义setter』</span></li>
<li>observable.object 和 extendObservable 都会自动将 getter 属性推导成计算属性,所以这两种情况不用添加装饰器<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> orderLine = observable.<span class="title function_">object</span>(&#123;</span><br><span class="line">	<span class="attr">price</span>:<span class="number">0</span>，</span><br><span class="line">	<span class="attr">amount</span>:<span class="number">1</span>,</span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">total</span>() &#123;</span><br><span class="line">		retuan <span class="variable language_">this</span>.<span class="property">price</span> * <span class="variable language_">this</span>.<span class="property">amount</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">set</span> <span class="title function_">total</span>(<span class="params">total</span>) &#123; </span><br><span class="line">		<span class="comment">// 从total中推导出price</span></span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">price</span> = total / <span class="variable language_">this</span>.<span class="property">amount</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="computed-expression-函数-不常用"><a href="#computed-expression-函数-不常用" class="headerlink" title="computed(expression) 函数(不常用)"></a>computed(expression) 函数(<span class="desc">不常用</span>)</h3><ul>
<li>使用场合：传递一个“在observable.box”中的计算值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable, computed&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> name = observable.<span class="title function_">box</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> upperCaseName = <span class="title function_">computed</span>(<span class="function">() =&gt;</span></span><br><span class="line">    name.<span class="title function_">get</span>().<span class="title function_">toUpperCase</span>()</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> disposer = upperCaseName.<span class="title function_">observe</span>(<span class="function"><span class="params">change</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(change.<span class="property">newValue</span>));</span><br><span class="line">name.<span class="title function_">set</span>(<span class="string">&quot;Dave&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第二参数对象的可选参"><a href="#第二参数对象的可选参" class="headerlink" title="第二参数对象的可选参"></a>第二参数对象的可选参</h3><ul>
<li>name：字符串, 在 spy 和 MobX 开发者工具中使用的调试名称</li>
<li>context：在提供的表达式中使用的 this</li>
<li>set：要使用的setter函数。</li>
<li>equals：比较前一个值和后一个值的函数，相等不评估</li>
<li>requiresReaction：推荐为true</li>
<li>keepAlive：慎用，会造成内存泄露</li>
</ul>
<h3 id="内置比较器"><a href="#内置比较器" class="headerlink" title="内置比较器"></a>内置比较器</h3><ul>
<li>comparer.identity: 使用恒等 (&#x3D;&#x3D;&#x3D;) 运算符来判定两个值是否相同。</li>
<li>comparer.default: 等同于 comparer.identity，但还认为 NaN 等于 NaN</li>
<li>comparer.structural: 执行深层结构比较以确定两个值是否相同。</li>
</ul>
<h2 id="Autorun-自定义reactions"><a href="#Autorun-自定义reactions" class="headerlink" title="Autorun(自定义reactions)"></a><span id="ref6">Autorun(自定义reactions)</span></h2><h3 id="第二参数对象的可选参-1"><a href="#第二参数对象的可选参-1" class="headerlink" title="第二参数对象的可选参"></a>第二参数对象的可选参</h3><ul>
<li>delay：对reaction函数去抖动的数字，默认为0不抖动，以毫秒为单位</li>
<li>name：字符串，用于在例如spy事件中用作reaction的名称</li>
<li>onError：处理reaction的错误</li>
<li>scheduler：设置自定义调度器已决定如何调度autorun函数的重新运行</li>
</ul>
<h2 id="When-自定义reactions"><a href="#When-自定义reactions" class="headerlink" title="When(自定义reactions)"></a><span id="ref8">When(自定义reactions)</span></h2><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">when</span>(</span><br><span class="line">	<span class="attr">predicate</span>: <span class="function">() =&gt;</span> boolean, </span><br><span class="line">	effect?: <span class="function">() =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">	options?</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>when 观察并运行给定的 predicate，直到返回true。 一旦返回 true，effect 就会被执行，然后 autorunner(<span class="desc">自动运行程序</span>) 会被清理。该函数返回一个清理器以提前取消autorunner。</li>
</ul>
<h3 id="when-promise"><a href="#when-promise" class="headerlink" title="when-promise"></a>when-promise</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不提供effect返回一个promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">await</span> <span class="title function_">when</span>(<span class="function">() =&gt;</span> that.<span class="property">isVisible</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reaction-自定义reactions"><a href="#Reaction-自定义reactions" class="headerlink" title="Reaction(自定义reactions)"></a><span id="ref7">Reaction(自定义reactions)</span></h2><ul>
<li>antorun的变种，与anturun的区别，<span class="key_words">『创建时』</span>reaction函数<span class="key_words">『不会直接运行』</span>，只有在数据表达式<span class="key_words">『首次返回一个新值后才会运行』</span>。在执行时访问任何observable都不会被追踪。</li>
<li>用法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">reaction</span>(</span><br><span class="line">	<span class="function">() =&gt;</span> data, </span><br><span class="line">	<span class="function">(<span class="params">data, reaction</span>) =&gt;</span> &#123; sideEffect &#125;, </span><br><span class="line">	options?</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>简单理解：reaction是下面语句的语法糖<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">computed</span>(expression).<span class="title function_">observe</span>(<span class="title function_">action</span>(sideEffect))</span><br><span class="line">或 <span class="title function_">autorun</span>(<span class="function">() =&gt;</span> <span class="title function_">action</span>(sideEffect)(expression))</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="用法解析"><a href="#用法解析" class="headerlink" title="用法解析"></a>用法解析</h3><ul>
<li>参数1为data函数，用来追踪并返回数据作为第二个函数的输入。</li>
<li>参数2为effect函数，接收的两个参数分别为<span class="key_words">『data函数返回的值』</span>和<span class="key_words">『当前的reaction』</span>,当前的reaction用来在执行期间清理reaction。<span class="key_words">『effect函数仅对data函数中访问的数据作出反应』</span></li>
<li>返回一个清理函数</li>
</ul>
<h3 id="options可选参"><a href="#options可选参" class="headerlink" title="options可选参"></a>options可选参</h3><ul>
<li>fireImmediately: 布尔值，用来标识效果函数是否在数据函数第一次运行后立即触发。默认值是 false</li>
<li>其他的同autorun一样</li>
</ul>
<h2 id="observer"><a href="#observer" class="headerlink" title="@observer"></a><span id="ref3">@observer</span></h2><ul>
<li>用来将 React 组件转变成响应式组件，observer由mobx-react包提供<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@observer <span class="keyword">class</span> <span class="title class_">Timer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.component</span> &#123;</span><br><span class="line">	<span class="title function_">render</span> (</span><br><span class="line">		<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>seconds:&#123;this.props.timerData.second&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当observer需要组合其它装饰器或高阶组件时，请确保<span class="key_words">『observer是最深处(第一个应用)的装饰器』</span>，否则不起效</li>
<li>使用<span class="key_words">『@observer装饰器』</span> 与 <span class="key_words">『observer(class Timer … {})』</span>效果一样</li>
<li>陷阱：使用以下方式初始化，组件不会有反应。<span class="key_words">『值需要通过引用来传递而不是通过字面量值来传递』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">render</span>(</span><br><span class="line">	<span class="string">`&lt;Timer timerData=&#123;timerData.secondsPassed&#125; /&gt;`</span>, </span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>无状态函数组件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Timer</span> = <span class="title function_">observer</span>(</span><br><span class="line">	<span class="function">(<span class="params">&#123;timerData&#125;</span>) =&gt;</span> </span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>seconds:&#123;timerData.second&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>可观察的局部组件状态：<ul>
<li>在使用@observer的类中使用@observable来观察属性。响应式状态会被render调用，也会调用componentWillUpdate 和 componentDidUpdate</li>
</ul>
</li>
</ul>
<h3 id="使用-inject-将组件连接到提供的-stores"><a href="#使用-inject-将组件连接到提供的-stores" class="headerlink" title="使用 inject 将组件连接到提供的 stores"></a>使用 inject 将组件连接到提供的 stores</h3><ul>
<li>用法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">inject</span>(stores)(component) </span><br><span class="line">或 @<span class="title function_">inject</span>(stores) <span class="keyword">class</span> <span class="title class_">Component</span>...</span><br></pre></td></tr></table></figure></li>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = <span class="title function_">observable</span>(&#123;</span><br><span class="line">   <span class="attr">foreground</span>: <span class="string">&#x27;#000&#x27;</span>,</span><br><span class="line">   <span class="attr">background</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">colors</span>=<span class="string">&#123;colors&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">app</span> <span class="attr">stuff...</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = <span class="title function_">inject</span>(<span class="string">&quot;colors&quot;</span>)(<span class="title function_">observer</span>(<span class="function">(<span class="params">&#123; colors, label, onClick &#125;</span>) =&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">color:</span> <span class="attr">colors.foreground</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">backgroundColor:</span> <span class="attr">colors.background</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span>&#123;label&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">));</span><br><span class="line"><span class="comment">// 稍后..</span></span><br><span class="line">colors.<span class="property">foreground</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="comment">// 所有button都会更新</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="componentWillReact-生命周期钩子"><a href="#componentWillReact-生命周期钩子" class="headerlink" title="componentWillReact(生命周期钩子)"></a>componentWillReact(生命周期钩子)</h3><ul>
<li>当组件因为它观察的数据发生了改变，它会重新渲染，这时componentWillReact会被触发，方便组件追溯并找到导致渲染的操作</li>
</ul>
<h2 id="MobX-会对什么作出反应？"><a href="#MobX-会对什么作出反应？" class="headerlink" title="MobX 会对什么作出反应？"></a><span id="ref4">MobX 会对什么作出反应？</span></h2><ul>
<li>MobX 会对在<span class="key_words">『执行跟踪函数期间读取的任何现有的可观察属性做出反应。』</span><ul>
<li>追踪函数：是computed表达式、observer组件的render()和when、reaction 和anturun的第一个入参函数</li>
<li>过程：只追踪哪些在函数执行时被读取的observable</li>
<li>读取：对象属性的间接引用，可用. 或 [] 形式完成</li>
</ul>
</li>
<li><span class="key_words">『只追踪同步』</span>地访问数据</li>
<li>MobX 只会为<span class="key_words">『直接通过 render 存取的 observer 组件』</span>的数据进行数据<span class="key_words">『追踪』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不接受参数，避免创建额外组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params">&#123; message &#125;</span>) =&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">SomeContainer</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">title</span> = <span class="string">&#123;()</span> =&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">Observer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">					&#123;() =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;message.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;/<span class="name">Observer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		&#125;</span></span><br><span class="line"><span class="language-xml">	/&gt;</span></span><br><span class="line">message.<span class="property">title</span> = <span class="string">&quot;Bar&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>避免在本地字段中缓存 observable</li>
<li>不会有反应的<ul>
<li>从observable获取的值，但是在追踪函数之外</li>
<li>在异步调用的代码块中读取的observable</li>
</ul>
</li>
</ul>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a><span id="ref5">Action</span></h2><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">action</span>(fn)</span><br><span class="line"><span class="title function_">action</span>(name, fn)</span><br><span class="line">@action <span class="title function_">classMethod</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">@<span class="title function_">action</span>(name) <span class="title function_">classMethod</span> () &#123;&#125;</span><br><span class="line">@action boundClassMethod = <span class="function">(<span class="params">args</span>) =&gt;</span> &#123; body &#125;</span><br><span class="line">@<span class="title function_">action</span>(name) boundClassMethod = <span class="function">(<span class="params">args</span>) =&gt;</span> &#123; body &#125;</span><br><span class="line">@action.<span class="property">bound</span> <span class="title function_">classMethod</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">action.<span class="property">bound</span> 不要和箭头函数一起使用；箭头函数已经是绑定过的并且不能重新绑定</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<ul>
<li>永远只对<span class="key_words">『修改』</span>状态的函数使用动作。只执行查找，过滤器等函数<span class="key_words">『不』</span>应该被标记为动作</li>
</ul>
</li>
</ul>
<h3 id="编写异步-Actions"><a href="#编写异步-Actions" class="headerlink" title="编写异步 Actions"></a>编写异步 Actions</h3><ul>
<li><p>@action </p>
<ul>
<li><span class="key_words">『只对当前运行的函数作出反应』</span>，而不会对当前运行函数所调用的<span class="key_words">『函数(不包含在当前函数之内)』</span>作出反应</li>
</ul>
</li>
<li><p>runInAction(name?, thunk)</p>
<ul>
<li>接收代码块并在异步动作中执行。对于即时创建和执行动作非常有用</li>
</ul>
</li>
<li><p>promise：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mobx.<span class="title function_">configure</span>(&#123; <span class="attr">enforceActions</span>: <span class="literal">true</span> &#125;) <span class="comment">// 不允许在动作之外进行状态修改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">	@observable githubProjects = []</span><br><span class="line">	@observable state = <span class="string">&quot;pending&quot;</span></span><br><span class="line">	@action</span><br><span class="line">	<span class="title function_">fetchProjects</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">githubProjects</span> = []</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;pending&quot;</span></span><br><span class="line">		<span class="title function_">fetchGithubProjectsSomehow</span>().<span class="title function_">then</span>(<span class="variable language_">this</span>.<span class="property">fetchSuccess</span>, <span class="variable language_">this</span>.<span class="property">fetchError</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 内联方法，缺点不能进行类型推导</span></span><br><span class="line">	<span class="title function_">action</span>(<span class="string">&quot;fetchSuccess&quot;</span>, <span class="function"><span class="params">projects</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> filteredProjects = <span class="title function_">somePreprocessing</span>(projects)</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">githubProjects</span> = filteredProjects</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;done&quot;</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="title function_">action</span>(<span class="string">&quot;fetchError&quot;</span>,<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;error&quot;</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>async&#x2F;await</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mobx.<span class="title function_">configure</span>(&#123; <span class="attr">enforceActions</span>: <span class="literal">true</span> &#125;) <span class="comment">// 不允许在动作之外进行状态修改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">	@observable githubProjects = []</span><br><span class="line">	@observable state = <span class="string">&quot;pending&quot;</span></span><br><span class="line">	@action</span><br><span class="line">	<span class="keyword">async</span> <span class="title function_">fetchProjects</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">githubProjects</span> = []</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;pending&quot;</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> projects = <span class="keyword">await</span> <span class="title function_">fetchGithubProjectsSomehow</span>()</span><br><span class="line">			<span class="keyword">const</span> filteredProjects = <span class="title function_">somePreprocessing</span>(projects)</span><br><span class="line">			<span class="comment">// await 之后，再次修改状态需要动作:</span></span><br><span class="line">			<span class="title function_">runInAction</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">					<span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;done&quot;</span></span><br><span class="line">					<span class="variable language_">this</span>.<span class="property">githubProjects</span> = filteredProjects</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">			<span class="title function_">runInAction</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">					<span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;error&quot;</span></span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>flows</p>
</li>
<li><p>使用 function * 来代替 async，使用 yield 代替 await</p>
</li>
<li><p>其它与async&#x2F;await差不多，只能作为函数使用，不能作为装饰器</p>
</li>
</ul>
<h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><h3 id="toJS-value-options"><a href="#toJS-value-options" class="headerlink" title="toJS(value, options?)"></a>toJS(value, options?)</h3><ul>
<li>作用：递归地将一个observable对象转换成javascript解构。支持observable数组、对象、映射和原始类型</li>
<li>options：<ul>
<li>exportMapsAsObjects 是否将observable映射序列化为对象(true) 或JavaScript Map对象(false).默认true</li>
<li>detectCycles 如果监测到循环，则重现使用已经序列化的对象。可以防止无限递归。默认true</li>
</ul>
</li>
</ul>
<h3 id="extendObservable-target-properties-decorators-options"><a href="#extendObservable-target-properties-decorators-options" class="headerlink" title="extendObservable(target, properties, decorators?, options?)"></a>extendObservable(target, properties, decorators?, options?)</h3><ul>
<li>作用：用来向已存在的目标对象添加observable属性。属性映射中的所有键对都会导致目标上的新的observable属性被初始化为给定值。属性映射中的任意getters都会转化成计算属性。</li>
<li>使用deep:false使得新的属性变成浅的。即阻止它们的值自动转换成observables。</li>
<li>observable.object(object) 实际上是 extendObservable({}, object) 的别名</li>
</ul>
<h3 id="创建observable数据结构和reactions"><a href="#创建observable数据结构和reactions" class="headerlink" title="创建observable数据结构和reactions"></a>创建observable数据结构和reactions</h3><ul>
<li>Atoms可以用来通知MobX某些observable数据源被观察或发生了改变。当数据源被使用或不再使用时，MobX会通知atom</li>
<li>多数场景下，可以通过创建普通的observable并使用工具onBecomeObserved 或 onBecomeUnobserved在Mobx开始追踪observable时接收通知来避免创建atom</li>
</ul>
<h3 id="Intercept-Observe"><a href="#Intercept-Observe" class="headerlink" title="Intercept &amp; Observe"></a>Intercept &amp; Observe</h3><ul>
<li>作用：<ul>
<li>用来监测单个observable的变化。 intercept可以在变化作用域observable之前监测和修改变化。observe允许在observable变化之后拦截改变。</li>
</ul>
</li>
</ul>
<h3 id="intercept-target-propertyName-interceptor"><a href="#intercept-target-propertyName-interceptor" class="headerlink" title="intercept(target,propertyName?, interceptor)"></a>intercept(target,propertyName?, interceptor)</h3><ul>
<li>target: 监测的observable </li>
<li>propertyName: <ul>
<li>可选参数，用来指定某个属性进来拦截。注意，intercept(user.name, interceptor) 和 intercept(user, “name”, interceptor) 根本是完全不同的。前者尝试给 user.name(或许根本不是一个 observable) 里面的当前值添加一个拦截器，而后者拦截 user 的 name 属性的变化。</li>
</ul>
</li>
<li>interceptor: <ul>
<li>在每次变化作用于 observable 后调用的回调函数。接收一个用来描述变化的对象。</li>
</ul>
</li>
</ul>
<h3 id="Observe-target-propertyName-listener-invokeImmediately"><a href="#Observe-target-propertyName-listener-invokeImmediately" class="headerlink" title="Observe(target, propertyName?, listener, invokeImmediately?)"></a>Observe(target, propertyName?, listener, invokeImmediately?)</h3><ul>
<li>target: 观察的 observable</li>
<li>propertyName: <ul>
<li>可选参数，用来指定某个属性进行观察。注意，observe(user.name, listener) 和 observe(user, “name”, listener) 根本是完全不同的。前者观察 user.name(或许根本不是一个 observable) 里面的当前值，而后者观察 user 的 name 属性。</li>
</ul>
</li>
<li>listener: <ul>
<li>在<span class="key_words">『每次』</span>变化作用于 observable 后调用的回调函数。接收一个用来描述变化的对象，除了装箱的 observable，它<span class="key_words">『调用listener 的两个参数: newValue、oldValue』</span>。</li>
</ul>
</li>
<li>invokeImmediately: <ul>
<li>默认是 false。如果想直接使用 observable 的状态(而不是等待第一次变化)调用 listener 的话，把它设置为 true。不是所有类型的 observable 都支持。</li>
</ul>
</li>
<li>该函数返回一个disposer函数，当调用时取消观察者。</li>
<li>observe 会响应对应的变动，而像是 autorun 或 reaction 则会对新值做出响应</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>Mobx库</tag>
      </tags>
  </entry>
  <entry>
    <title>Vite --- 新一代前端构建工具</title>
    <url>/2024/11/01/Engineering/vite/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>一个基于原生 ESM 的前端开发和构建工具，提供极速的服务启动、热重载、按需编译、类型支持和插件系统。</p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>服务器启动速度快：通过将应用中的模块区分为依赖和源码两类</p>
<ul>
<li>依赖：大多为在开发时不会变动的纯 JS<ul>
<li>使用 esbuild 预构建依赖</li>
<li>esbuild 使用 Go 编写，并且比以 JS 编写的打包器预构建依赖快 10-100 倍</li>
</ul>
</li>
<li>源码：包含一些非.js文件（<span class="desc">例如 JSX，CSS 或者 组件</span>）<ul>
<li>并不是所有的源码都需要同时被加载（<span class="desc">例如基于路由拆分的代码模块</span>）</li>
<li>以原生 ESM 方式提供源码。实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码</li>
</ul>
</li>
</ul>
</li>
<li><p>快速更新</p>
<ul>
<li>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，精确地使已编辑的模块与其最近的 HMR 边界之间的链失活。</li>
<li>同时利用 HTTP 头来加速整个页面的重新加载<ul>
<li>源码模块的请求会根据 304 Not Modified 进行协商缓存</li>
<li>依赖模块请求则会通过 Cache-Control: max-age&#x3D;31536000,immutable 进行强缓存，一旦被缓存将不需要再次请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><ol>
<li>一个开发服务器，基于原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的模块热更新（HMR）。</li>
<li>一套构建指令，使用 Rollup 打包代码，并且是预配置的，可输出用于生产环境的高度优化过的静态资源。</li>
</ol>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><ul>
<li>支持原生 ESM语法的script标签</li>
<li>原生 ESM动态导入</li>
<li>import.meta的浏览器</li>
<li>传统浏览器可以通过插件@vitejs&#x2F;plugin-legacy支持</li>
</ul>
<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><ul>
<li>提示：node版本要16+，14.18+</li>
<li>安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm create vite@latest 文件名 --template react-ts</span><br></pre></td></tr></table></figure></li>
<li>注意：如果出现vite不是内部命令，<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li>
<li>create-vite 是一个快速生成主流框架基础模板的工具。</li>
<li>可以用如 degit 之类的工具，使用社区模版来搭建项目。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx degit user/project my-project</span><br><span class="line">npx degit user/project#main my-project <span class="comment">// 使用 main 作为默认分支</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="index-html与项目根目录"><a href="#index-html与项目根目录" class="headerlink" title="index.html与项目根目录"></a>index.html与项目根目录</h2><ul>
<li>index.html<ul>
<li>是项目的入口文件。</li>
<li>Vite 将index.html视为源码和模块图的一部分。标签指向源码，url能自动转换</li>
</ul>
</li>
<li>根目录：即服务文件的位置，以 <code>&lt;root&gt;</code> 代称。<ul>
<li>源码中的绝对 URL 路径将以项目的 “根” 作为基础来解析。</li>
<li>能够处理依赖关系，解析处于根目录外的文件位置。</li>
<li>Vite 也支持多个 .html 作入口点的 多页面应用模式。</li>
</ul>
</li>
<li>指定替代根目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vite serve some/sub/dir</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="npm依赖解析和预构建"><a href="#npm依赖解析和预构建" class="headerlink" title="npm依赖解析和预构建"></a>npm依赖解析和预构建</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; someMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;my-dep&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将会检测到所有被加载源文件中的此类裸模块导入，并执行以下操作:</li>
</ul>
<ol>
<li>预构建,提高页面加载速度，并将 CommonJS&#x2F;UMD 转换为 ESM 格式。预构建由 esbuild 执行，这使冷启动时间快。</li>
<li>重写导入为合法的 URL以便浏览器能够正确导入。</li>
<li>依赖是强缓存的,通过 HTTP 头来缓存请求得到的依赖。</li>
</ol>
<h3 id="模块热替换-create-vite-创建应用程序时已有"><a href="#模块热替换-create-vite-创建应用程序时已有" class="headerlink" title="模块热替换(create-vite 创建应用程序时已有)"></a>模块热替换(create-vite 创建应用程序时已有)</h3><ul>
<li>具有 HMR 功能的框架可以利用该 API 提供即时、准确的更新，而无需重新加载页面或清除应用程序状态。</li>
</ul>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><ul>
<li>仅执行 .ts 文件的转译工作，不执行任何类型检查（<span class="desc">构建命令之外运行 tsc –noEmit 或 单独的进程中运行 tsc –noEmit –watch 或 使用 vite-plugin-checker插件</span>）</li>
<li>使用 esbuild 将 ts 转译到 js，约是 tsc 速度的20~30倍，HMR 更新反映到浏览器的时间小于 50ms。</li>
<li>使用仅含类型的导入和导出形式的语法可以避免 “仅含类型的导入被不正确打包” 的问题</li>
<li>TypeScript编译器选项<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;isolatedModules&quot;</span>:<span class="literal">true</span> <span class="comment">// 支持转译功能</span></span><br><span class="line"><span class="string">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span> <span class="comment">// 在一些库（如：vue）不支持isolatedModules时用</span></span><br><span class="line"><span class="string">&quot;useDefineForClassFields&quot;</span>: <span class="literal">true</span> <span class="comment">// ts的target是ES或更高，默认。</span></span><br></pre></td></tr></table></figure></li>
<li>代码库难迁移，可以用rollup-plugin-friendly-type-imports</li>
</ul>
<h3 id="客户端类型"><a href="#客户端类型" class="headerlink" title="客户端类型"></a>客户端类型</h3><ul>
<li>默认类型定义是写给它的 Node.js API,要补充到Vite 应用的客户端代码环境中，</li>
<li>添加一个 d.ts 声明文件：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;vite/client&quot; /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>或者将 vite&#x2F;client 添加到 tsconfig.json 中的 compilerOptions.types 下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;types&quot;</span>: [<span class="string">&quot;vite/client&quot;</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这将会提供以下类型定义补充：<ul>
<li>资源导入 (例如：导入一个 .svg 文件)</li>
<li>import.meta.env 上 Vite 注入的环境变量的类型定义</li>
<li>import.meta.hot 上的 HMR API 类型定义</li>
<li>TIP：要覆盖默认的类型定义，请在三斜线注释前添加定义。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例如，要为 <span class="title class_">React</span> 组件中的 *.<span class="property">svg</span> 文件定义类型：</span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.svg&#x27;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="attr">content</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">React</span>.<span class="property">SVGProps</span>&lt;<span class="title class_">SVGElement</span>&gt;&gt;</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">default</span> content</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;vite/client&quot; /&gt; </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ul>
<li>第一优先级支持</li>
<li>Vue3 单文件组件支持：@vitejs&#x2F;plugin-vue</li>
<li>Vue3 JSX 支持：@vitejs&#x2F;plugin-vue-jsx</li>
<li>Vue2.7 SFC支持：@vitejs&#x2F;plugin-vue2</li>
<li>Vue2.7 JSX支持：underfin&#x2F;plugin-vue2-jsx</li>
</ul>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><ul>
<li>不在 React 或 Vue 中使用 JSX，自定义的 jsxFactory 和 jsxFragment 也可以使用 esbuild选项进行配置。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">如<span class="title class_">Preact</span>：</span><br><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">esbuild</span>: &#123;</span><br><span class="line">    <span class="attr">jsxFactory</span>: <span class="string">&#x27;h&#x27;</span>,</span><br><span class="line">    <span class="attr">jsxFragment</span>: <span class="string">&#x27;Fragment&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">使用 jsxInject为 <span class="variable constant_">JSX</span> 注入 helper，以避免手动导入：</span><br><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">esbuild</span>: &#123;</span><br><span class="line">    <span class="attr">jsxInject</span>: <span class="string">`import React from &#x27;react&#x27;`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul>
<li><p>导入 .css 文件将会把内容插入到 style 标签中，同时也带有 HMR 支持。也能够以字符串的形式检索处理后的、作为其模块默认导出的 CSS。</p>
</li>
<li><p>@import 内联和变基</p>
<ul>
<li>通过 postcss-import 预配置支持了 CSS @import 内联，Vite 的路径别名也遵从 CSS @import。</li>
<li>Sass 和 Less 文件也支持 @import 别名和 URL 变基。</li>
</ul>
</li>
<li><p>PostCSS</p>
<ul>
<li>如果项目包含有效的 PostCSS 配置 (<span class="desc">例如 postcss.config.js</span>)，将会自动应用于所有已导入的 CSS。</li>
</ul>
</li>
<li><p>CSS Modules</p>
<ul>
<li>任何以 .module.css 为后缀名的文件都被认为是CSS modules 文件。导入会返回相应的模块对象</li>
</ul>
</li>
<li><p>CSS modules 行为可以通过 css.modules 选项 进行配置。</p>
</li>
<li><p>css.modules.localsConvention 开启了 camelCase 格式变量名转换，可以使用按名导入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* example.module.css */</span></span><br><span class="line">.<span class="property">red</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*.js*/</span></span><br><span class="line"><span class="keyword">import</span> classes <span class="keyword">from</span> <span class="string">&#x27;./example.module.css&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">className</span> = classes.<span class="property">red</span></span><br><span class="line"><span class="comment">// .apply-color -&gt; applyColor</span></span><br><span class="line"><span class="keyword">import</span> &#123; applyColor &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.module.css&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">className</span> = applyColor   </span><br></pre></td></tr></table></figure></li>
<li><p>CSS 预处理器：要安装依赖</p>
<ul>
<li>.scss and .sass：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm add -D sass</span><br></pre></td></tr></table></figure></li>
<li>.less：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm add -D less</span><br></pre></td></tr></table></figure></li>
<li>.styl and .stylus：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm add -D stylus</span><br></pre></td></tr></table></figure></li>
<li>Sass 和 Less，保证 Vite 别名也能被使用。</li>
<li>@import 别名和 URL 变基不支持 Stylus。</li>
<li>url() 中的相对路径引用的，与根文件不同目录中的 Sass&#x2F;Less 文件会自动变基。</li>
<li>单文件组件，可以通过以下形式自动开启。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style lang=<span class="string">&quot;sass&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li>在文件扩展名前加上 .module 来结合使用 CSS modules 和预处理器。</li>
</ul>
</li>
<li><p>禁用CSS注入页面</p>
<ul>
<li>自动注入 CSS 内容的行为可以通过 <span class="key_words">『?inline』</span> 参数来关闭。</li>
<li>在关闭时，被处理过的 CSS 字符串将会作为该模块的默认导出，但样式并没有被注入到页面中。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./foo.css&#x27;</span> <span class="comment">// 样式将会注入页面</span></span><br><span class="line"><span class="keyword">import</span> otherStyles <span class="keyword">from</span> <span class="string">&#x27;./bar.css?inline&#x27;</span> <span class="comment">// 样式不会注入页面</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><ul>
<li>导入一个静态资源会返回解析后的 URL：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> imgUrl <span class="keyword">from</span> <span class="string">&#x27;./img.png&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hero-img&#x27;</span>).<span class="property">src</span> = imgUrl</span><br></pre></td></tr></table></figure></li>
<li>添加一些特殊的查询参数可以更改资源被引入的方式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式加载资源为一个 URL</span></span><br><span class="line"><span class="keyword">import</span> assetAsURL <span class="keyword">from</span> <span class="string">&#x27;./asset.js?url&#x27;</span></span><br><span class="line"><span class="comment">// 以字符串形式加载资源</span></span><br><span class="line"><span class="keyword">import</span> assetAsString <span class="keyword">from</span> <span class="string">&#x27;./shader.glsl?raw&#x27;</span></span><br><span class="line"><span class="comment">// 加载为 Web Worker</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Worker</span> <span class="keyword">from</span> <span class="string">&#x27;./worker.js?worker&#x27;</span></span><br><span class="line"><span class="comment">// 在构建时 Web Worker 内联为 base64 字符串</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">InlineWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./worker.js?worker&amp;inline&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul>
<li>可以被直接导入,支持具名导入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json <span class="keyword">from</span> <span class="string">&#x27;./example.json&#x27;</span> <span class="comment">// 导入整个对象</span></span><br><span class="line"><span class="keyword">import</span> &#123; field &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.json&#x27;</span> <span class="comment">// 对一个根字段使用具名导入 —— 有效帮助 treeshaking！</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Glob导入"><a href="#Glob导入" class="headerlink" title="Glob导入"></a>Glob导入</h3><ul>
<li>支持使用特殊的 import.meta.glob 函数从文件系统导入多个模块：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将dir文件夹下的所有js文件导入</span></span><br><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;./dir/*.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 然后通过遍历modules的key来访问相应的模块</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> path <span class="keyword">in</span> modules) &#123;</span><br><span class="line">  modules[path]().<span class="title function_">then</span>(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(path, mod)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配到的文件默认是懒加载的，通过动态导入实现，并会在构建时分离为独立的 chunk。</span></span><br><span class="line"><span class="comment">// 直接引入所有的模块，可以传入&#123;eager:true&#125;,作为第二参数</span></span><br><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;./dir/*.js&#x27;</span>, &#123; <span class="attr">eager</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure></li>
<li>Glob 导入形式<ul>
<li>支持以字符串形式导入文件。</li>
<li>使用了 Import Reflection 语法对导入进行断言：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;./dir/*.js&#x27;</span>, &#123; <span class="attr">as</span>: <span class="string">&#x27;raw&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>多个匹配模式<ul>
<li>第一个参数是一个 glob 数组，例如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>([<span class="string">&#x27;./dir/*.js&#x27;</span>, <span class="string">&#x27;./another/*.js&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>反面匹配模式(以 ! 作为前缀):排除匹配<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>([<span class="string">&#x27;./dir/*.js&#x27;</span>, <span class="string">&#x27;!**/bar.js&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
<li>具名导入（部分导入）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;./dir/*.js&#x27;</span>, &#123; <span class="attr">import</span>: <span class="string">&#x27;setup&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure></li>
<li>tree-shaking：移除 JavaScript 上下文中的未引用代码</li>
<li>与 eager 在一起时，可以对这些模块进行 tree-shaking<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">import</span>: <span class="string">&#x27;setup&#x27;</span>, <span class="attr">eager</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure></li>
<li>设置 import 为 default 可以加载默认导出<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">import</span>: <span class="string">&#x27;default&#x27;</span>,<span class="attr">eager</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>自定义查询&lt;：使用 query 选项<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">query</span>: &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>动态导入<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`./dir/<span class="subst">$&#123;file&#125;</span>.js`</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><ul>
<li>预编译的 .wasm 文件可以通过 ?init 来导入。默认导出一个初始化函数，返回值为所导出 wasm 实例对象的 Promise<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> init <span class="keyword">from</span> <span class="string">&#x27;./example.wasm?init&#x27;</span></span><br><span class="line"><span class="title function_">init</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">instance</span>) =&gt;</span> &#123;</span><br><span class="line">  instance.<span class="property">exports</span>.<span class="title function_">test</span>()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 还可以将传递给 WebAssembly.instantiate 的导入对象作为其第二个参数：</span></span><br><span class="line"><span class="title function_">init</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: &#123;</span><br><span class="line">    <span class="attr">someFunc</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125;&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>在生产构建当中，体积小于 assetInlineLimit 的 .wasm 文件将会被内联为 base64 字符串。否则，它们将作为资源复制到 dist 目录中，并按需获取。</li>
</ul>
<h3 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h3><ul>
<li>通过构造器导入<ul>
<li>Web Worker 可以使用 new Worker() 和 new SharedWorker() 导入。</li>
<li>type: ‘module’可以创建模块</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./worker.js&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>), &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>带有查询后缀的导入<ul>
<li>在导入请求上添加 <span class="key_words">『?worker 或 ?sharedworker』</span> 查询参数来直接导入一个 web worker 脚本。</li>
</ul>
</li>
<li>默认导出会是一个自定义 worker 的构造函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./worker?worker&#x27;</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">MyWorker</span>()</span><br></pre></td></tr></table></figure></li>
<li>如果想将 worker 内联为 base64 字符串，添加 <span class="key_words">『inline』</span> 查询参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./worker?worker&amp;inline&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>如果想要以一个 URL 的形式读取该 worker，添加 <span class="key_words">『url』</span> 这个 query：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./worker?worker&amp;url&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="构建优化"><a href="#构建优化" class="headerlink" title="构建优化"></a>构建优化</h3><ul>
<li>CSS代码分割<ul>
<li>自动地将一个异步 chunk 模块中使用到的 CSS 代码抽取出来并为其生成一个单独的文件。这个 CSS 文件将在该异步 chunk 加载完成时自动通过一个 link 标签载入，该异步 chunk 会保证只在 CSS 加载完毕后再执行，避免发生 FOUC 。</li>
<li>禁用 CSS 代码分割：通过设置 build.cssCodeSplit:false</li>
</ul>
</li>
<li>预加载指令生成<ul>
<li>为入口 chunk 和它们在打包出的 HTML 中的直接引入自动生成 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;modulepreload&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>异步chunk加载优化<ul>
<li>将使用一个预加载步骤自动重写代码，来分割动态导入调用，以实现当 A 被请求时，C 也将 同时 被请求：Entry —&gt; (A + C)</li>
</ul>
</li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul>
<li>添加一个插件<ul>
<li>安装好插件，然后在vite.config.js 配置文件中的 plugins 数组中引入</li>
</ul>
</li>
</ul>
<h3 id="强制插件排序"><a href="#强制插件排序" class="headerlink" title="强制插件排序"></a>强制插件排序</h3><ul>
<li>使用 enforce 修饰符来强制插件的位置:<ul>
<li>pre：在 Vite 核心插件之前调用该插件</li>
<li>post：在 Vite 构建插件之后调用该插件</li>
<li>default：在 Vite 核心插件之后调用该插件</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...<span class="title function_">image</span>(),</span><br><span class="line">      <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="按需应用"><a href="#按需应用" class="headerlink" title="按需应用"></a>按需应用</h3><ul>
<li>如果插件在服务或构建期间按需使用，请使用 apply 属性指明它们仅在 ‘build’ 或 ‘serve’ 模式时调用：  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> typescript2 <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-typescript2&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...<span class="title function_">typescript2</span>(),</span><br><span class="line">      <span class="attr">apply</span>: <span class="string">&#x27;build&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="依赖预构建（仅会在开发模式下应用）"><a href="#依赖预构建（仅会在开发模式下应用）" class="headerlink" title="依赖预构建（仅会在开发模式下应用）"></a>依赖预构建（仅会在开发模式下应用）</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li>CommonJS和UMD兼容性: 将作为 CommonJS&#x2F;UMD 发布的依赖项转换为 ESM。</li>
<li>将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</li>
</ul>
<h3 id="自动依赖搜寻"><a href="#自动依赖搜寻" class="headerlink" title="自动依赖搜寻"></a>自动依赖搜寻</h3><ul>
<li>如果没有找到相应的缓存，将抓取源码，并自动寻找引入的依赖项，并将这些依赖项作为预构建包的入口点。</li>
<li>在服务器已经启动之后，如果遇到一个新的依赖关系导入，且不在缓存中，将重新运行依赖构建进程并重新加载页面。</li>
</ul>
<h3 id="Monorepo-和链接依赖"><a href="#Monorepo-和链接依赖" class="headerlink" title="Monorepo 和链接依赖"></a>Monorepo 和链接依赖</h3><ul>
<li>monorepo 启动，该仓库中的某个包可能会成为另一个包的依赖。</li>
<li>Vite 会自动侦测没有从 node_modules 解析的依赖项，并将链接的依赖视为源码。</li>
<li>会分析被链接依赖的依赖列表。但被链接的依赖导出要为 ESM 格式。如果不是，在配置里将此依赖添加到这两项中。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optimizeDeps.include</span><br><span class="line">build.commonjsOptions.include </span><br></pre></td></tr></table></figure></li>
<li>当这个被链接的依赖发生变更后，在重启开发服务器时在命令中带上 <code>--force</code> 选项让所有更改生效。</li>
<li>传递依赖项错误的去重，导致运行出错，使用npm pack 来修复<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="attr">include</span>: [<span class="string">&#x27;linked-dep&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">commonjsOptions</span>: &#123;</span><br><span class="line">      <span class="attr">include</span>: [<span class="regexp">/linked-dep/</span>, <span class="regexp">/node_modules/</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自定义行为"><a href="#自定义行为" class="headerlink" title="自定义行为"></a>自定义行为</h3><ul>
<li>optimizeDeps.include：明确包含依赖依赖项很大或者是 CommonJS</li>
<li>optimizeDeps.exclude：明确排除依赖项很小，并且已经是有效的 ESM</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>文件系统缓存<ul>
<li>Vite 会将预构建的依赖缓存到 node_modules&#x2F;.vite。它基于以下几个源来决定是否需要重新运行预构建步骤:<ol>
<li>补丁文件夹的修改时间</li>
<li>包管理器的 lockfile，<span class="desc">例如 package-lock.json, yarn.lock，或者 pnpm-lock.yaml或者 bun.lockb</span></li>
<li>vite.config.js 中的相关字段</li>
<li>NODE_ENV 的值</li>
</ol>
</li>
<li>只有在上述其中一项发生更改时，才需要重新运行预构建。</li>
<li>强制重新构建依赖，用 <code>--force</code> 命令行选项启动开发服务器，或者手动删除 node_modules&#x2F;.vite 目录。</li>
</ul>
</li>
<li>浏览器缓存<ul>
<li>已预构建的依赖请求使用 HTTP 头 max-age&#x3D;31536000,immutable 进行强缓存，一旦被缓存将不需要再次请求。</li>
</ul>
</li>
<li>如安装了不同的版本的依赖项，则会通过附加的版本查询自动失效。</li>
<li>如果想通过本地编辑来调试依赖项，则:<ol>
<li>通过浏览器调试工具的 Network 选项卡暂时禁用缓存；</li>
<li>重启 Vite 开发服务器指定 <code>--force</code> 选项，来重新构建依赖项</li>
<li>重新载入页面。</li>
</ol>
</li>
</ul>
<h2 id="静态资源处理-1"><a href="#静态资源处理-1" class="headerlink" title="静态资源处理"></a>静态资源处理</h2><h3 id="将资源引入为-URL"><a href="#将资源引入为-URL" class="headerlink" title="将资源引入为 URL"></a>将资源引入为 URL</h3><ul>
<li>服务时引入一个静态资源会返回解析后的公共路径：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> imgUrl <span class="keyword">from</span> <span class="string">&#x27;./img.png&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hero-img&#x27;</span>).<span class="property">src</span> = imgUrl</span><br></pre></td></tr></table></figure></li>
<li>行为类似于 Webpack 的 file-loader。区别在于导入既可以使用绝对公共路径，也可以使用相对路径。<ul>
<li>url() 在 CSS 中的引用也以同样的方式处理。</li>
<li>Vue插件，Vue SFC模板中的资源引用都将自动转换为导入。</li>
<li>常见的图像、媒体和字体文件类型被自动检测为资源。使用 assetsInclude 选项扩展内部列表。</li>
<li>引用的资源作为构建资源图的一部分包括在内，将生成散列文件名，并可以由插件进行处理以进行优化。</li>
<li>较小的资源体积小于 assetsInlineLimit 选项值则会被内联为 base64 data URL。</li>
<li>Git LFS 占位符会自动排除在内联之外。要获得内联，请确保在构建之前通过 Git LFS 下载文件内容。</li>
</ul>
</li>
<li>默认情况下，TS 不会将静态资源导入视为有效的模块。要解决这个问题，需要添加 vite&#x2F;client。</li>
</ul>
<h3 id="显示-URL-引入"><a href="#显示-URL-引入" class="headerlink" title="显示 URL 引入"></a>显示 URL 引入</h3><ul>
<li>未被包含在内部列表或 assetsInclude 中的资源，可以使用 <span class="key_words">『?url』</span> 后缀显式导入为一个 URL。</li>
</ul>
<h3 id="将资源引入为-字符串"><a href="#将资源引入为-字符串" class="headerlink" title="将资源引入为 字符串"></a>将资源引入为 字符串</h3><ul>
<li>资源可以使用 <span class="key_words">『?raw』</span> 后缀声明作为字符串引入。</li>
<li>import shaderString from ‘.&#x2F;shader.glsl?raw</li>
</ul>
<h3 id="导入脚本作为Worker"><a href="#导入脚本作为Worker" class="headerlink" title="导入脚本作为Worker"></a>导入脚本作为Worker</h3><ul>
<li>通过 <span class="key_words">『?worker 或 ?sharedworker』</span> 后缀导入为 web worker。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在生产构建中将会分离出 chunk</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Worker</span> <span class="keyword">from</span> <span class="string">&#x27;./shader.js?worker&#x27;</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>()</span><br><span class="line"><span class="comment">// sharedworker</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SharedWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./shader.js?sharedworker&#x27;</span></span><br><span class="line"><span class="keyword">const</span> sharedWorker = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>()</span><br><span class="line"><span class="comment">// 内联为 base64 字符串</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">InlineWorker</span> <span class="keyword">from</span> <span class="string">&#x27;./shader.js?worker&amp;inline&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="public-目录"><a href="#public-目录" class="headerlink" title="public 目录"></a>public 目录</h3><ul>
<li>存放不会被源码引用、必须保持原有文件名、不想引入，只想得到url</li>
<li>目录默认是 <span class="key_words">『<code>&lt;root&gt;</code>&#x2F;public』</span>，但可以通过 publicDir 选项 来配置</li>
<li>注意：该目录资源不应该被js文件引用，应该使用&#x2F;绝对路径</li>
</ul>
<h3 id="new-URL-url-import-meta-url"><a href="#new-URL-url-import-meta-url" class="headerlink" title="new URL(url, import.meta.url)"></a>new URL(url, import.meta.url)</h3><ul>
<li>功能：暴露当前模块的 URL。</li>
<li>将它与原生的 URL 构造器 组合使用，在一个 JS 模块中，通过相对路径我们就能得到一个被完整解析的静态资源 URL：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// URL字符串必须是静态的</span></span><br><span class="line"><span class="keyword">const</span> imgUrl = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./img.png&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>).<span class="property">href</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hero-img&#x27;</span>).<span class="property">src</span> = imgUrl</span><br><span class="line">字符串模板支持动态 <span class="variable constant_">URL</span>：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getImageUrl</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">`./dir/<span class="subst">$&#123;name&#125;</span>.png`</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>).<span class="property">href</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="构建生产版本-vite-build"><a href="#构建生产版本-vite-build" class="headerlink" title="构建生产版本: vite build"></a>构建生产版本: vite build</h2><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><ul>
<li>支持原生 ESM script 标签、支持原生 ESM 动态导入 和 import.meta 的浏览器</li>
<li>通过 build.target 配置项指定构建目标，最低支持 es2015。</li>
<li>默认情况下 Vite 只处理语法转译，且默认不包含任何 polyfill。</li>
<li>传统浏览器可以通过插件 @vitejs&#x2F;plugin-legacy 来支持。兼容版的 chunk 只会在不支持原生 ESM 的浏览器中进行按需加载。</li>
</ul>
<h3 id="公共基础路径"><a href="#公共基础路径" class="headerlink" title="公共基础路径"></a>公共基础路径</h3><ul>
<li>在嵌套的公共路径下部署项目，需指定 base 配置项，然后所有资源的路径都将据此配置重写</li>
<li>也可以通过命令行参数指定，<span class="desc">例如 vite build –base&#x3D;&#x2F;my&#x2F;public&#x2F;path&#x2F;。</span></li>
<li>当访问过程中需要使用动态连接的 url 时，可以使用全局注入的 import.meta.env.BASE_URL 变量，它的值为公共基础路径。</li>
<li>注意:这个变量在构建时会被静态替换，因此必须按 import.meta.env.BASE_URL 的原样出现</li>
</ul>
<h3 id="自定义构建"><a href="#自定义构建" class="headerlink" title="自定义构建"></a>自定义构建</h3><ul>
<li>通过 build.rollupOptions 直接调整底层的 Rollup 选项</li>
</ul>
<h3 id="产物分块策略"><a href="#产物分块策略" class="headerlink" title="产物分块策略"></a>产物分块策略</h3><ul>
<li>通过配置 build.rollupOptions.output.manualChunks 来自定义 chunk 分割策略.</li>
<li>默认的策略是将 chunk 分割为 index 和 vendor。可以通过在配置文件中添加 splitVendorChunkPlugin 来继续使用 “分割 Vendor Chunk” 策略</li>
<li>也可用工厂函数 splitVendorChunk({ cache: SplitVendorChunkCache }) 来提供该策略，cache.reset() 需要在 buildStart 阶段被调用。</li>
</ul>
<h3 id="文件变化时重新构建"><a href="#文件变化时重新构建" class="headerlink" title="文件变化时重新构建"></a>文件变化时重新构建</h3><ul>
<li>启用 rollup 的监听器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vite build --watch</span><br></pre></td></tr></table></figure></li>
<li>或直接通过 build.watch 调整底层的 WatcherOptions 选项。</li>
</ul>
<h3 id="多页面应用模式"><a href="#多页面应用模式" class="headerlink" title="多页面应用模式"></a>多页面应用模式</h3><ul>
<li>在构建过程中，只需指定多个 .html 文件作为入口点</li>
<li>如果指定了另一个根目录，在解析输入路径时，__dirname 的值将仍然是 vite.config.js 文件所在的目录。因此，需要把对应入口文件的 root 的路径添加到 resolve 的参数中。</li>
</ul>
<h3 id="库模式"><a href="#库模式" class="headerlink" title="库模式"></a>库模式</h3><ul>
<li>这个库要进行发布构建时，使用 build.rollupOptions.external 配置项确保将那些不想打包进库的依赖进行外部化处理</li>
<li>在 package.json 中使用如下格式。来暴露多个入口起点：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./dist/my-lib.mjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./dist/my-lib.cjs&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;./secondary&quot;</span>: &#123;<span class="comment">//暴露多个入口起点使用这种形式</span></span><br><span class="line">      <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./dist/secondary.mjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./dist/secondary.cjs&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol>
<li>如果 package.json 不包含 “type”: “module”，Vite 会生成不同的文件后缀名以兼容 Node.js。.js 会变为 .mjs 而 .cjs 会变为 .js 。</li>
<li>在库模式下，所有 import.meta.env.* 用法在构建生产时都会被静态替换。但是，process.env.* 的用法不会被替换。如果不允许这样做，使用 define: { ‘process.env.NODE_ENV’: ‘“production”‘ } 。</li>
</ol>
<h2 id="部署静态站点"><a href="#部署静态站点" class="headerlink" title="部署静态站点"></a>部署静态站点</h2><ul>
<li>构建应用：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li>
<li>本地测试应用：构建后运行npm run preview<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;preview&quot;</span>: <span class="string">&quot;vite preview --port 8080&quot;</span> <span class="comment">// 配置服务的运行端口</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h3><ol>
<li>在 vite.config.js 中设置正确的 base。</li>
</ol>
<ul>
<li>部署在 <code>https://&lt;USERNAME&gt;.github.io/</code> 上，省略 base 使其默认为 ‘&#x2F;‘</li>
<li>部署在 <code>https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;/</code> 上，设置 base 为 <code>&#39;/&lt;REPO&gt;/&#39;</code></li>
</ul>
<ol start="2">
<li>进入仓库 settings 页面的 GitHub Pages 配置，选择部署来源为“GitHub Actions”</li>
</ol>
<h3 id="GitLab-Pages-配合-GitLab-CI"><a href="#GitLab-Pages-配合-GitLab-CI" class="headerlink" title="GitLab Pages 配合 GitLab CI"></a>GitLab Pages 配合 GitLab CI</h3><ol>
<li>在 vite.config.js 中设置正确的 base。<ul>
<li>部署在 <code>https://&lt;USERNAME or GROUP&gt;.gitlab.io/</code> 上，省略 base 使其默认为 ‘&#x2F;‘。</li>
<li>部署在 <code>https://&lt;USERNAME or GROUP&gt;.gitlab.io/&lt;REPO&gt;/</code> 上，设置 base 为 <code>&#39;/&lt;REPO&gt;/&#39;</code>。</li>
</ul>
</li>
<li>在项目根目录创建一个 .gitlab-ci.yml 文件，并包含以下内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">image</span>: <span class="attr">node</span>:<span class="number">16.5</span><span class="number">.0</span></span><br><span class="line"><span class="attr">pages</span>:</span><br><span class="line">  <span class="attr">stage</span>: deploy</span><br><span class="line">  <span class="attr">cache</span>:</span><br><span class="line">    <span class="attr">key</span>:</span><br><span class="line">      <span class="attr">files</span>:</span><br><span class="line">        - package-lock.<span class="property">json</span></span><br><span class="line">      <span class="attr">prefix</span>: npm</span><br><span class="line">    <span class="attr">paths</span>:</span><br><span class="line">      - node_modules/</span><br><span class="line">  <span class="attr">script</span>:</span><br><span class="line">    - npm install</span><br><span class="line">    - npm run build</span><br><span class="line">    - cp -a dist/. public/</span><br><span class="line">  <span class="attr">artifacts</span>:</span><br><span class="line">    <span class="attr">paths</span>:</span><br><span class="line">      - public</span><br><span class="line">  <span class="attr">rules</span>:</span><br><span class="line">     - <span class="attr">if</span>: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="环境变量与模式"><a href="#环境变量与模式" class="headerlink" title="环境变量与模式"></a>环境变量与模式</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">MODE</span>: &#123;string&#125; <span class="comment">// 应用运行的模式。</span></span><br><span class="line"><span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>: &#123;string&#125; <span class="comment">// 部署应用时的基本 URL。他由base 配置项决定。</span></span><br><span class="line"><span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">PROD</span>: &#123;boolean&#125; <span class="comment">// 应用是否运行在生产环境。</span></span><br><span class="line"><span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">DEV</span>: &#123;boolean&#125; <span class="comment">// 应用是否运行在开发环境 (永远与 import.meta.env.PROD相反)。</span></span><br><span class="line"><span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">SSR</span>: &#123;boolean&#125; <span class="comment">// 应用是否运行在 server 上。   </span></span><br></pre></td></tr></table></figure>

<h3 id="生产环境替换"><a href="#生产环境替换" class="headerlink" title="生产环境替换"></a>生产环境替换</h3><ul>
<li>在生产环境中，在引用环境变量时请使用完全静态的字符串。</li>
<li>对于 JavaScript 字符串，可以使用 unicode 零宽度空格来分割这个字符串<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">eg</span>: <span class="string">&#x27;import.meta\u200b.env.MODE&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>对于 Vue 模板或其他编译到 JavaScript 字符串的 HTML，可以使用 wbr 标签<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eg：<span class="keyword">import</span>.<span class="property">meta</span>.&lt;wbr&gt;env.<span class="property">MODE</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="env文件"><a href="#env文件" class="headerlink" title=".env文件"></a>.env文件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">env</span>                <span class="comment">// 所有情况下都会加载</span></span><br><span class="line">.<span class="property">env</span>.<span class="property">local</span>          <span class="comment">// 所有情况下都会加载，但会被 git 忽略</span></span><br><span class="line">.<span class="property">env</span>.[mode]         <span class="comment">// 只在指定模式下加载</span></span><br><span class="line">.<span class="property">env</span>.[mode].<span class="property">local</span>   <span class="comment">// 只在指定模式下加载，但会被 git 忽略</span></span><br></pre></td></tr></table></figure>
<ul>
<li>环境加载优先级<ul>
<li>Vite 执行时已经存在的环境变量有最高的优先级，不会被覆盖。</li>
<li>一份用于指定模式的文件（例如 .env.production）会比通用形式的优先级更高（例如 .env）</li>
<li>.env 类文件会在 Vite 启动一开始时被加载，而改动会在重启服务器后生效。</li>
</ul>
</li>
<li>加载的环境变量也会通过 import.meta.env 以字符串形式暴露给客户端源码</li>
<li>为了防止意外地将一些环境变量泄漏到客户端，只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理的代码。</li>
</ul>
<h3 id="TypeScript-的智能提示"><a href="#TypeScript-的智能提示" class="headerlink" title="TypeScript 的智能提示"></a>TypeScript 的智能提示</h3><ul>
<li>获取以 VITE_ 为前缀的用户自定义环境变量的 TypeScript 智能提示：</li>
<li>在 src 目录下创建一个 env.d.ts 文件，接着按下面这样增加 ImportMetaEnv 的定义：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;vite/client&quot; /&gt;</span></span><br><span class="line">interface <span class="title class_">ImportMetaEnv</span> &#123;</span><br><span class="line">  readonly <span class="attr">VITE_APP_TITLE</span>: string</span><br><span class="line">  <span class="comment">// 更多环境变量...</span></span><br><span class="line">&#125;</span><br><span class="line">interface <span class="title class_">ImportMeta</span> &#123;</span><br><span class="line">  readonly <span class="attr">env</span>: <span class="title class_">ImportMetaEnv</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果代码依赖于浏览器环境的类型，比如 DOM 和 WebWorker，可以在 tsconfig.json 中修改 lib 字段来获取类型支持。</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;WebWorker&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul>
<li>默认情况下，开发服务器 (dev 命令) 运行在 development模式，而 build 命令则运行在 production 模式。</li>
<li>通过传递 <span class="key_words">『–mode』</span> 选项标志来覆盖命令使用的默认模式: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vite build --mode staging</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h2><ul>
<li>情景逻辑<ul>
<li>如果需要执行 SSR 和客户端间情景逻辑，可以使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">SSR</span>) &#123; <span class="comment">/* ... 仅在服务端执行的逻辑 */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="生产环境构建"><a href="#生产环境构建" class="headerlink" title="生产环境构建"></a>生产环境构建</h3><ol>
<li>正常生成一个客户端构建；</li>
<li>再生成一个 SSR 构建，使其通过 import() 直接加载，这样便无需再使用 Vite 的 ssrLoadModule</li>
</ol>
<ul>
<li>注意: 使用 <span class="key_words">『–ssr』</span> 标志表明这将会是一个 SSR 构建。同时需要指定 SSR 的入口。</li>
</ul>
<ol start="3">
<li>在 server.js 中，通过 process.env.NODE_ENV 条件分支，需要添加一些用于生产环境的特定逻辑：</li>
</ol>
<ul>
<li>使用 dist&#x2F;client&#x2F;index.html 作为模板，而不是根目录的 index.html，因为前者包含了到客户端构建的正确资源链接。</li>
<li>使用 import(‘.&#x2F;dist&#x2F;server&#x2F;entry-server.js’) </li>
<li>将 vite 开发服务器的创建和所有使用都移到 dev-only 条件分支后面，然后添加静态文件服务中间件来服务 dist&#x2F;client 中的文件。</li>
</ul>
<h3 id="生成预加载指令"><a href="#生成预加载指令" class="headerlink" title="生成预加载指令"></a>生成预加载指令</h3><ul>
<li>使用 <span class="key_words">『–ssrManifest』</span> 标志，这将会在构建输出目录中生成一份 ssr-manifest.json：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;build:client&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build --outDir dist/client --ssrManifest&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li>
<li>@vitejs&#x2F;plugin-vue 会自动注册使用的组件模块 ID 到相关的 Vue SSR 上下文</li>
</ul>
<h3 id="预渲染-SSG"><a href="#预渲染-SSG" class="headerlink" title="预渲染 &#x2F; SSG"></a>预渲染 &#x2F; SSG</h3><ul>
<li>预先知道某些路由所需的路由和数据，可以使用与生产环境 SSR 相同的逻辑将这些路由预先渲染到静态 HTML中。</li>
</ul>
<h3 id="SSR-外部化"><a href="#SSR-外部化" class="headerlink" title="SSR 外部化"></a>SSR 外部化</h3><ul>
<li>当运行 SSR 时依赖会由 Vite 的 SSR 转换模块系统作外部化。</li>
<li>如果依赖需要被 Vite 的管道转换,可以添加到 ssr.noExternal</li>
<li>对于采用链接的依赖，它们将默认不会被外部化</li>
</ul>
<h3 id="SSR-专有插件逻辑"><a href="#SSR-专有插件逻辑" class="headerlink" title="SSR 专有插件逻辑"></a>SSR 专有插件逻辑</h3><ul>
<li>一些框架，会根据客户端渲染和服务端渲染的区别，将组件编译成不同的格式。可以向以下的插件钩子中，给 Vite 传递额外的 options 对象，对象中包含 ssr 属性来支持根据情景转换：<ul>
<li>resolveId</li>
<li>load</li>
<li>transform</li>
</ul>
</li>
</ul>
<h3 id="SSR-构建目标"><a href="#SSR-构建目标" class="headerlink" title="SSR 构建目标"></a>SSR 构建目标</h3><ul>
<li>SSR 构建的默认目标为 node 环境，但也可以让服务运行在 Web Worker 上。可以将ssr.target 设置为 webworker，以将目标配置为 Web Worker。</li>
</ul>
<h3 id="SSR-构建产物"><a href="#SSR-构建产物" class="headerlink" title="SSR 构建产物"></a>SSR 构建产物</h3><ul>
<li>通过设置 ssr.noExternal 为 true 来将 SSR 打包成单个 JavaScript 文件。这将会做两件事：<ul>
<li>将所有依赖视为 noExternal（非外部化）</li>
<li>若任何 Node.js 内置内容被引入，将抛出一个错误</li>
</ul>
</li>
</ul>
<h3 id="Vite-CLI"><a href="#Vite-CLI" class="headerlink" title="Vite CLI"></a>Vite CLI</h3><ul>
<li>CLI 命令 $ vite dev 和 $ vite preview 也可以用于 SSR 应用：可以将SSR 中间件通过 configureServer 添加到开发服务器、以及通过 configurePreviewServer 添加到预览服务器。</li>
</ul>
<h3 id="SSR-格式"><a href="#SSR-格式" class="headerlink" title="SSR 格式"></a>SSR 格式</h3><ul>
<li>默认情况下，Vite 生成的 SSR 打包产物是 ESM 格式。</li>
<li>如果SSR 项目不能使用 ESM，可以通过 Vite v2 外部启发式方法设置生成 CJS 格式的产物<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">legacy.buildSsrCjsExternalHeuristics: true</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="后端集成-自定义"><a href="#后端集成-自定义" class="headerlink" title="后端集成(自定义)"></a>后端集成(自定义)</h2><ol>
<li>在的 Vite 配置中配置入口文件和启用创建 manifest：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="comment">// 在 outDir 中生成 manifest.json</span></span><br><span class="line">    <span class="attr">manifest</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">			<span class="comment">// 覆盖默认的 .html 入口</span></span><br><span class="line">			<span class="attr">input</span>: <span class="string">&#x27;/path/to/main.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果没有禁用 module preload 的 polyfill，还需在入口处添加此 polyfill：</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vite/modulepreload-polyfill&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>在开发环境中，在服务器的 HTML 模板中注入以下内容：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是在开发环境中</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;http://localhost:5173/@vite/client&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:5173/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>为了正确地提供资源，有两种选项：<ul>
<li>确保服务器被配置过，将会拦截代理资源请求给到 Vite 服务器</li>
<li>设置 server.origin 以求生成的资源链接将以服务器 URL 形式被解析而非一个相对路径</li>
</ul>
</li>
<li>正使用 @vitejs&#x2F;plugin-react 配合 React，还需要在上述脚本前添加以下脚本，因为插件不能修改正在服务的 HTML<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> <span class="title class_">RefreshRuntime</span> <span class="keyword">from</span> <span class="string">&#x27;http://localhost:5173/@react-refresh&#x27;</span></span><br><span class="line">  <span class="title class_">RefreshRuntime</span>.<span class="title function_">injectIntoGlobalHook</span>(<span class="variable language_">window</span>)</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">$RefreshReg$</span> = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">$RefreshSig$</span> = <span class="function">() =&gt;</span> <span class="function">(<span class="params">type</span>) =&gt;</span> type</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">__vite_plugin_react_preamble_installed__</span> = <span class="literal">true</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">// 如果是在生产环境中</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/assets/&#123;&#123; manifest[&#x27;main.js&#x27;].css &#125;&#125;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/assets/&#123;&#123; manifest[&#x27;main.js&#x27;].file &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>在生产环境中：在运行 vite build 之后，一个 manifest.json 文件将与静态资源文件一同生成。<ul>
<li>清单是一个 Record&lt;name, chunk&gt; 结构的对象。</li>
<li>对于 入口 或动态入口 chunk，键是相对于项目根目录的资源路径。</li>
<li>对于非入口 chunk，键是生成文件的名称并加上前缀 _。</li>
<li>Chunk 将信息包含在其静态和动态导入上(<span class="desc">两者都是映射到清单中相应 chunk 的键&lt;?span&gt;)，以及任何与之相关的 CSS 和资源文件。</li>
<li>可以使用这个文件来渲染链接或者用散列文件名预加载指令</li>
</ul>
</li>
</ol>
<h2 id="插件API"><a href="#插件API" class="headerlink" title="插件API"></a>插件API</h2><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><ul>
<li>如果插件不使用 Vite 特有的钩子，可以作为兼容 Rollup 的插件来实现：<ul>
<li>Rollup 插件应该有一个带 rollup-plugin- 前缀、语义清晰的名称。</li>
<li>在 package.json 中包含 rollup-plugin 和 vite-plugin 关键字</li>
</ul>
</li>
<li>对于 Vite 专属的插件：<ul>
<li>Vite 插件应该有一个带 vite-plugin- 前缀、语义清晰的名称。</li>
<li>在 package.json 中包含 vite-plugin 关键字。</li>
</ul>
</li>
<li>只适用于特定的框架的插件：<ul>
<li>vite-plugin-vue- 前缀作为 Vue 插件</li>
<li>vite-plugin-react- 前缀作为 React 插件</li>
<li>vite-plugin-svelte- 前缀作为 Svelte 插件</li>
</ul>
</li>
</ul>
<h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><ul>
<li>用户会将插件添加到项目的 devDependencies 中并使用数组形式的 plugins 选项配置它们。该数组将在内部被扁平化（flatten）。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> vitePlugin <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-feature&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rollupPlugin <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-feature&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vitePlugin</span>(), <span class="title function_">rollupPlugin</span>()] <span class="comment">// 可以接受将多个插件作为单个元素的预设</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>转换自定义文件类型<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fileRegex = <span class="regexp">/\.(my-file-ext)$/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">myPlugin</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;transform-file&#x27;</span>,</span><br><span class="line">    <span class="title function_">transform</span>(<span class="params">src, id</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fileRegex.<span class="title function_">test</span>(id)) &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">code</span>: <span class="title function_">compileFileToJS</span>(src),</span><br><span class="line">          <span class="attr">map</span>: <span class="literal">null</span> <span class="comment">// 如果可行将提供 source map</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="虚拟模块"><a href="#虚拟模块" class="headerlink" title="虚拟模块"></a>虚拟模块</h3><ul>
<li>一种很实用的模式，使可以对使用 ESM 语法的源文件传入一些编译时信息。然后在js文件中引入。</li>
<li>在 Vite（以及 Rollup）中都以 virtual: 为前缀。</li>
</ul>
<h3 id="通用钩子"><a href="#通用钩子" class="headerlink" title="通用钩子"></a>通用钩子</h3><ul>
<li>以下钩子在服务器启动时被调用：<ul>
<li>options</li>
<li>buildStart</li>
</ul>
</li>
<li>以下钩子会在每个传入模块请求时被调用：<ul>
<li>resolveId</li>
<li>load</li>
<li>transform</li>
</ul>
</li>
<li>以下钩子在服务器关闭时被调用：<ul>
<li>buildEnd</li>
<li>closeBundle</li>
</ul>
</li>
<li>注意 moduleParsed 钩子在开发中是不会被调用的。可以认为 Vite 的开发服务器只调用了 rollup.rollup() 而没有调用 bundle.generate()。</li>
</ul>
<h3 id="Vite-独有钩子"><a href="#Vite-独有钩子" class="headerlink" title="Vite 独有钩子"></a>Vite 独有钩子</h3><ul>
<li>config<ul>
<li>类型：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">(<span class="attr">config</span>: <span class="title class_">UserConfig</span>, <span class="attr">env</span>: &#123;<span class="attr">mode</span>: <span class="built_in">string</span>, <span class="attr">command</span>: <span class="built_in">string</span>&#125;) =&gt; <span class="title class_">UserConfig</span> | <span class="literal">null</span> | <span class="built_in">void</span></span><br></pre></td></tr></table></figure></li>
<li>种类：async, sequential</li>
<li><span class="key_words">『在解析 Vite 配置前调用。』</span>钩子接收原始用户配置和一个描述配置环境的变量，包含正在使用的 mode 和 command。它可以返回一个将被深度合并到现有配置中的部分配置对象，或者直接改变配置。</li>
</ul>
</li>
<li>configResolved<ul>
<li>类型：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">(<span class="attr">config</span>: <span class="title class_">ResolvedConfig</span>) =&gt; <span class="built_in">void</span> | <span class="string">`Promise&lt;void&gt;`</span></span><br></pre></td></tr></table></figure></li>
<li>种类：async, parallel</li>
<li><span class="key_words">『在解析 Vite 配置后调用。』</span>使用这个钩子读取和存储最终解析的配置。</li>
</ul>
</li>
<li>configureServer<ul>
<li>类型：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">(<span class="attr">server</span>: <span class="title class_">ViteDevServer</span>) =&gt; (<span class="function">() =&gt;</span> <span class="built_in">void</span>) | <span class="built_in">void</span> | <span class="title class_">Promise</span>&lt;(<span class="function">() =&gt;</span> <span class="built_in">void</span>) | <span class="built_in">void</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li>种类：async, sequential</li>
<li>注入后置中间件：<span class="key_words">『在内部中间件被安装前调用。』</span>如果想注入一个在内部中间件之后运行的中间件，可以从 configureServer 返回一个函数，将会在内部中间件安装后被调用</li>
<li>存储服务器访问</li>
</ul>
</li>
<li>configurePreviewServer<ul>
<li>类型：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">(<span class="attr">server</span>: &#123;<span class="attr">middlewares</span>: <span class="title class_">Connect</span>.<span class="property">Server</span>, <span class="attr">httpServer</span>: http.<span class="property">Server</span>&#125;) =&gt; (<span class="function">() =&gt;</span> <span class="built_in">void</span>) | <span class="built_in">void</span> | <span class="title class_">Promise</span>&lt;(<span class="function">() =&gt;</span> <span class="built_in">void</span>) | <span class="built_in">void</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li>种类：async, sequential</li>
<li><span class="key_words">『用于预览服务器,在其他中间件安装前被调用的。』</span>想要在其他中间件之后安装一个插件，可以从 configurePreviewServer返回一个函数，它将会在内部中间件被安装之后再调用</li>
</ul>
</li>
<li>transformIndexHtml：转换 index.html 的专用钩子<ul>
<li>类型：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">IndexHtmlTransformHook</span> | &#123; enforce?: <span class="string">&#x27;pre&#x27;</span> | <span class="string">&#x27;post&#x27;</span>, <span class="attr">transform</span>: <span class="title class_">IndexHtmlTransformHook</span> &#125;</span><br></pre></td></tr></table></figure></li>
<li>种类： async, sequential</li>
<li><span class="key_words">『接收当前的 HTML 字符串和转换上下文。』</span>上下文在开发期间暴露ViteDevServer实例，在构建期间暴露 Rollup 输出的包。</li>
<li>这个钩子可以是异步的，并且可以返回以下其中之一:<ul>
<li>经过转换的 HTML 字符串</li>
<li>注入到现有HTML中的标签描述符对象数组({tag, attrs, children})。每个标签也可以指定它应该被注入到哪里（默认是在 <code>&lt;head&gt;</code> 之前）</li>
<li>一个包含 { html, tags } 的对象</li>
</ul>
</li>
</ul>
</li>
<li>handleHotUpdate<ul>
<li>类型：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">(<span class="attr">ctx</span>: <span class="title class_">HmrContext</span>) =&gt; <span class="string">`Array&lt;ModuleNode&gt; | void | Promise&lt;Array&lt;ModuleNode&gt; | void&gt;`</span></span><br></pre></td></tr></table></figure></li>
<li><span class="key_words">『执行自定义 HMR 更新处理。』</span>钩子接收一个带有以下签名的上下文对象：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">HmrContext</span> &#123;</span><br><span class="line">  <span class="attr">file</span>: string</span><br><span class="line">  <span class="attr">timestamp</span>: number</span><br><span class="line">  <span class="attr">modules</span>: <span class="title class_">Array</span>&lt;<span class="title class_">ModuleNode</span>&gt; <span class="comment">//是受更改文件影响的模块数组。</span></span><br><span class="line">  <span class="attr">read</span>: <span class="function">() =&gt;</span> string | <span class="title class_">Promise</span>&lt;string&gt;  <span class="comment">//异步读函数，它返回文件的内容</span></span><br><span class="line">  <span class="attr">server</span>: <span class="title class_">ViteDevServer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="插件顺序"><a href="#插件顺序" class="headerlink" title="插件顺序"></a>插件顺序</h3><ul>
<li>一个 Vite 插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是pre 或 post。解析后的插件将按照以下顺序排列：<ul>
<li>Alias</li>
<li>带有 enforce: ‘pre’ 的用户插件</li>
<li>Vite 核心插件</li>
<li>没有 enforce 值的用户插件</li>
<li>Vite 构建用的插件</li>
<li>带有 enforce: ‘post’ 的用户插件</li>
<li>Vite 后置构建插件（最小化，manifest，报告</li>
</ul>
</li>
</ul>
<h3 id="Rollup-插件兼容性"><a href="#Rollup-插件兼容性" class="headerlink" title="Rollup 插件兼容性"></a>Rollup 插件兼容性</h3><ul>
<li>只要 Rollup 插件符合以下标准，它就应该像 Vite 插件一样工作：<ul>
<li>没有使用 moduleParsed 钩子。</li>
<li>它在打包钩子和输出钩子之间没有很强的耦合。</li>
</ul>
</li>
<li>如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。它的工作原理与 Vite 插件的 enforce: ‘post’ 和 apply: ‘build’ 相同。</li>
</ul>
<h3 id="路径规范化"><a href="#路径规范化" class="headerlink" title="路径规范化"></a>路径规范化</h3><ul>
<li>Vite在解析路径时使用 POSIX 分隔符（ &#x2F; ），同时保留了 Windows 中的卷名。</li>
<li>Rollup 在默认情况下保持解析的路径不变，因此解析的路径在 Windows 中会使用 win32 分隔符（ \ ）。</li>
</ul>
<h3 id="过滤与include-exclde模式"><a href="#过滤与include-exclde模式" class="headerlink" title="过滤与include&#x2F;exclde模式"></a>过滤与include&#x2F;exclde模式</h3><ul>
<li>暴露 @rollup&#x2F;pluginutils 的 createFilter 函数，以支持 Vite 独有插件和集成使用标准的 include&#x2F;exclude 过滤模式</li>
</ul>
<h3 id="客户端与服务端间通信"><a href="#客户端与服务端间通信" class="headerlink" title="客户端与服务端间通信"></a>客户端与服务端间通信</h3><ul>
<li>服务端到客户端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">在插件一侧，我们可以使用 server.<span class="property">ws</span>.<span class="property">send</span> 去给所有客户端广播事件：</span><br><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [&#123;</span><br><span class="line">    <span class="title function_">configureServer</span>(<span class="params">server</span>) &#123;</span><br><span class="line">      server.<span class="property">ws</span>.<span class="title function_">send</span>(<span class="string">&#x27;my:greetings&#x27;</span>, &#123; <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br><span class="line">在客户端侧，使用 hot.<span class="property">on</span> 去监听事件：</span><br><span class="line"><span class="comment">// client side</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">on</span>(<span class="string">&#x27;my:greetings&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">msg</span>) <span class="comment">// hello</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端到服务端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">为了从客户端向服务端发送事件，使用 hot.<span class="property">send</span>：</span><br><span class="line">  <span class="comment">// client side</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">    <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">send</span>(<span class="string">&#x27;my:from-client&#x27;</span>, &#123; <span class="attr">msg</span>: <span class="string">&#x27;Hey!&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">然后使用 server.<span class="property">ws</span>.<span class="property">on</span> 并在服务端监听这些事件：</span><br><span class="line">  <span class="comment">// vite.config.js</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [&#123;</span><br><span class="line">      <span class="title function_">configureServer</span>(<span class="params">server</span>) &#123;</span><br><span class="line">        server.<span class="property">ws</span>.<span class="title function_">on</span>(<span class="string">&#x27;my:from-client&#x27;</span>, <span class="function">(<span class="params">data, client</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message from client:&#x27;</span>, data.<span class="property">msg</span>) <span class="comment">// Hey!</span></span><br><span class="line">          <span class="comment">// reply only to the client (if needed)</span></span><br><span class="line">          client.<span class="title function_">send</span>(<span class="string">&#x27;my:ack&#x27;</span>, &#123; <span class="attr">msg</span>: <span class="string">&#x27;Hi! I got your message!&#x27;</span> &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
<li>自定义事件的 TypeScript 类型定义指南<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">可以通过扩展 <span class="title class_">CustomEventMap</span> 这个 interface 来为自定义事件标注类型：</span><br><span class="line"><span class="comment">// events.d.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vite/types/customEvent&#x27;</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;vite/types/customEvent&#x27;</span> &#123;</span><br><span class="line">  interface <span class="title class_">CustomEventMap</span> &#123;</span><br><span class="line">     <span class="string">&#x27;custom:foo&#x27;</span>: &#123; <span class="attr">msg</span>: string &#125;</span><br><span class="line">     <span class="comment">// &#x27;event-key&#x27;: payload</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="客户端-HMR-API：通过-import-meta-hot-对象暴露手动-HMR-API。"><a href="#客户端-HMR-API：通过-import-meta-hot-对象暴露手动-HMR-API。" class="headerlink" title="客户端 HMR API：通过 import.meta.hot 对象暴露手动 HMR API。"></a>客户端 HMR API：通过 import.meta.hot 对象暴露手动 HMR API。</h2><h3 id="必需的条件守卫"><a href="#必需的条件守卫" class="headerlink" title="必需的条件守卫"></a>必需的条件守卫</h3><ul>
<li>确保用一个条件语句守护所有 HMR API的使用<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>) &#123; <span class="comment">/* HMR 代码 */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="TypeScript-的智能提示-1"><a href="#TypeScript-的智能提示-1" class="headerlink" title="TypeScript 的智能提示"></a>TypeScript 的智能提示</h3><ul>
<li>在 src 目录中创建env.d.ts，以便 TypeScript 获取类型定义：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;reference types=&quot;vite/client&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="hot-accept-cb-：接收模块自身"><a href="#hot-accept-cb-：接收模块自身" class="headerlink" title="hot.accept(cb)：接收模块自身"></a>hot.accept(cb)：接收模块自身</h3><ul>
<li>参数: 接收已更新模块的回调函数：</li>
<li>“接受” 热更新的模块被认为是 HMR 边界。</li>
</ul>
<h3 id="hot-accept-deps-cb-：接受直接依赖项的更新，而无需重新加载自身"><a href="#hot-accept-deps-cb-：接受直接依赖项的更新，而无需重新加载自身" class="headerlink" title="hot.accept(deps, cb)：接受直接依赖项的更新，而无需重新加载自身"></a>hot.accept(deps, cb)：接受直接依赖项的更新，而无需重新加载自身</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupSideEffect</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title function_">setupSideEffect</span>()</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./foo.js&#x27;</span>, <span class="function">(<span class="params">newFoo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调函数接收到更新后的&#x27;./foo.js&#x27; 模块</span></span><br><span class="line">    newFoo?.<span class="title function_">foo</span>()</span><br><span class="line">		<span class="comment">// 你可以使用新的模块实例来决定是否使其失效。</span></span><br><span class="line">		  <span class="keyword">if</span> (<span class="title function_">cannotHandleUpdate</span>(<span class="variable language_">module</span>)) &#123;</span><br><span class="line">		    <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">invalidate</span>()</span><br><span class="line">		  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 也可以接受一个依赖模块的数组：</span></span><br><span class="line">  <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(</span><br><span class="line">    [<span class="string">&#x27;./foo.js&#x27;</span>, <span class="string">&#x27;./bar.js&#x27;</span>],</span><br><span class="line">    <span class="function">(<span class="params">[newFooModule, newBarModule]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 回调函数接收一个更新后模块的数组</span></span><br><span class="line">    &#125;</span><br><span class="line">   )</span><br><span class="line">	<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">hot</span>.<span class="title function_">dispose</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 清理副作用</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hot-dispose-cb-："><a href="#hot-dispose-cb-：" class="headerlink" title="hot.dispose(cb)："></a>hot.dispose(cb)：</h3><ul>
<li>一个接收自身的模块或一个期望被其他模块接收的模块可以使用 hot.dispose 来清除任何由新副本产生的持久副作用</li>
</ul>
<h3 id="hot-prune-cb"><a href="#hot-prune-cb" class="headerlink" title="hot.prune(cb):"></a>hot.prune(cb):</h3><ul>
<li>注册一个回调，当模块在页面上不再被导入时调用</li>
</ul>
<h3 id="hot-data："><a href="#hot-data：" class="headerlink" title="hot.data："></a>hot.data：</h3><ul>
<li>在同一个更新模块的不同实例之间持久化.将信息从模块的前一个版本传递到下一本</li>
</ul>
<h3 id="hot-decline-："><a href="#hot-decline-：" class="headerlink" title="hot.decline()："></a>hot.decline()：</h3><ul>
<li>目前是一个空操作并暂留用于向后兼容。</li>
</ul>
<h3 id="hot-invalidate"><a href="#hot-invalidate" class="headerlink" title="hot.invalidate():"></a>hot.invalidate():</h3><ul>
<li>指明某模块是不可热更新的,建议在 accept 回调中调用 invalidate</li>
</ul>
<h3 id="hot-on-event-cb-："><a href="#hot-on-event-cb-：" class="headerlink" title="hot.on(event, cb)："></a>hot.on(event, cb)：</h3><ul>
<li>监听自定义 HMR 事件。以下事件自动触发：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">vite</span>:beforeUpdate <span class="comment">// 当更新即将被应用时（例如，一个模块将被替换）</span></span><br><span class="line"><span class="attr">vite</span>:afterUpdate <span class="comment">// 当更新已经被应用时</span></span><br><span class="line"><span class="attr">vite</span>:beforeFullReload <span class="comment">// 当完整的重载即将发生时</span></span><br><span class="line"><span class="attr">vite</span>:beforePrune <span class="comment">// 当不再需要的模块即将被剔除时</span></span><br><span class="line"><span class="attr">vite</span>:invalidate <span class="comment">// 当使用import.meta.hot.invalidate()使一个模块失效时</span></span><br><span class="line"><span class="attr">vite</span>:error <span class="comment">// 当发生错误时（例如，语法错误）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="hot-send-event-data-："><a href="#hot-send-event-data-：" class="headerlink" title="hot.send(event, data)："></a>hot.send(event, data)：</h3><ul>
<li>发送自定义事件到 Vite 开发服务器。</li>
</ul>
<h2 id="Javascript-API-—-看手册"><a href="#Javascript-API-—-看手册" class="headerlink" title="Javascript API — 看手册"></a>Javascript API — 看手册</h2>]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>Vite</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack --- 第一篇</title>
    <url>/2024/11/01/Engineering/webpack--%E7%AC%AC%E4%B8%80%E7%AF%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>是JavaScript应用程序的静态模块打包器。当webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有模块打包成一个或多个bundle。</p>
</blockquote>
<h2 id="四个核心概念："><a href="#四个核心概念：" class="headerlink" title="四个核心概念："></a>四个核心概念：</h2><ul>
<li>入口(entry)</li>
<li>输出(output)</li>
<li>loader</li>
<li>插件(plugins)</li>
</ul>
<h2 id="webpack优点"><a href="#webpack优点" class="headerlink" title="webpack优点"></a>webpack优点</h2><ul>
<li>可以打包你的 JavaScript 应用程序（支持 ESM 和 CommonJS）</li>
<li>可以扩展为支持许多不同的静态资源</li>
<li>关心性能和加载时间</li>
<li>始终在改进或添加新功能</li>
<li>依赖自动收集：自动构建并基于你所引用或导出的内容推断出依赖的图谱</li>
</ul>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><blockquote>
<p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p>
</blockquote>
<h3 id="默认值：-src-index-js"><a href="#默认值：-src-index-js" class="headerlink" title="默认值：.&#x2F;src&#x2F;index.js"></a>默认值：.&#x2F;src&#x2F;index.js</h3><ul>
<li>也可在webpack.config.js中的module.exports里面配置entry,指定一个或多个不同的入口起点</li>
</ul>
<h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><ul>
<li>单个入口<ul>
<li>用法：entry: string | Array<string></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>对象语法：定义入口的最可扩展方式<ul>
<li>用法：entry: {[entryChunkName: string]: string | [string]&gt;}</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">  <span class="attr">app</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">  <span class="attr">adminApp</span>: <span class="string">&#x27;./src/adminApp.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="描述入口的对象"><a href="#描述入口的对象" class="headerlink" title="描述入口的对象"></a>描述入口的对象</h3><ul>
<li>dependOn: 当前入口所依赖的入口。必须在该入口被加载前被加载。</li>
<li>filename: 指定要输出的文件名称。</li>
<li>import: 启动时需加载的模块。</li>
<li>library: 指定 library 选项，为当前 entry 构建一个 library。</li>
<li>runtime: 运行时 chunk 的名字。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时 chunk。</li>
<li>publicPath: 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共 URL 地址。</li>
</ul>
<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><ul>
<li>分离应用程序(app)和第三方库(vendor)入口</li>
<li>多页面程序<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析：告诉webpack需要三个独立分离的依赖图</span></span><br><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">  <span class="attr">pageOne</span>: <span class="string">&#x27;./src/pageOne/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">pageTwo</span>: <span class="string">&#x27;./src/pageTwo/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">pageThree</span>: <span class="string">&#x27;./src/pageThree/index.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。只能有一个output</p>
</blockquote>
<h3 id="默认值-dist"><a href="#默认值-dist" class="headerlink" title="默认值: .&#x2F;dist"></a>默认值: .&#x2F;dist</h3><ul>
<li>也可在webpack.config.js中的module.exports里面配置output属性</li>
</ul>
<h3 id="配置方式："><a href="#配置方式：" class="headerlink" title="配置方式："></a>配置方式：</h3><ul>
<li>output最低要求是，将它的值设置为一个对象，然后给输出文件的文件名配置output.filename</li>
<li>多个入口起点：使用占位符(substitutions)来确保每个文件具有唯一的名称<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span>, <span class="comment">//写入到./dist/filename</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>高阶进阶<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/home/proj/cdn/assets/[fullhash]&#x27;</span>,</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;https://cdn.example.com/assets/[fullhash]/&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// publicPath: &#x27;&#x27; 时，在运行时通过入口起点文件中的 __webpack_public_path__ 动态设置</span></span><br><span class="line">__webpack_public_path__ = myRuntimePublicPath;  </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><blockquote>
<p>让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。</p>
</blockquote>
<h3 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h3><ul>
<li>test 属性，识别出哪些文件会被转换。</li>
<li>use 属性，表示进行转换时，应该使用哪个 loader。</li>
</ul>
<h3 id="安装对应的loader"><a href="#安装对应的loader" class="headerlink" title="安装对应的loader"></a>安装对应的loader</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save-dev css-loader ts-loader</span><br></pre></td></tr></table></figure>

<h3 id="配置方式：-1"><a href="#配置方式：-1" class="headerlink" title="配置方式："></a>配置方式：</h3><ul>
<li>在webpack.config.js中的config里的module.exports里面的module配置rules，指定loader</li>
<li>例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules</span>:[&#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,<span class="attr">use</span>:<span class="string">&#x27;css-loader&#x27;</span>&#125;,]</span><br></pre></td></tr></table></figure></li>
<li>loader执行顺序: 从右到左（或从上到下）地取值（evaluate）&#x2F;执行（execute）</li>
</ul>
<h3 id="使用loader"><a href="#使用loader" class="headerlink" title="使用loader"></a>使用loader</h3><ul>
<li>内联方式：在每个import语句中显式指定loader</li>
<li>使用!前缀，将禁用所有已配置的normal loader<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Styles</span> <span class="keyword">from</span> <span class="string">&#x27;!style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>使用!!前缀，将禁用所有已配置的loader(preLoader, loader, postLoader)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Styles</span> <span class="keyword">from</span> <span class="string">&#x27;!!style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>使用-!前缀，将禁用所有已配置的preLoader和loader，但是不禁用postLoaders<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Styles</span> <span class="keyword">from</span> <span class="string">&#x27;-!style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>选项可以传递查询参数(如: ?key&#x3D;value&amp;foo&#x3D;bar)，或者一个 JSON 对象(如: ?{“key”:”value”,”foo”:”bar”})</li>
</ul>
</li>
</ul>
<h3 id="loader-特性"><a href="#loader-特性" class="headerlink" title="loader 特性"></a>loader 特性</h3><ul>
<li>支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。</li>
<li>可以是同步的，也可以是异步的。</li>
<li>运行在 Node.js 中，并且能够执行任何操作。</li>
<li>除了通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。</li>
</ul>
<h3 id="解析loader"><a href="#解析loader" class="headerlink" title="解析loader"></a>解析loader</h3><ul>
<li>遵循标准模块解析规则。多数情况下，loader 将从模块路径加载（通常是从 npm install, node_modules 进行加载）</li>
<li>loader 模块会导出为一个函数，并且编写为 Node.js 兼容的 JavaScript。loader 通常被命名为 xxx-loader。</li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><blockquote>
<p>webpack的支柱功能，用于执行从打包优化和压缩，一直到重新定义环境中的变量的任务。具有apply方法的js对象。</p>
</blockquote>
<ul>
<li>注意：如果在插件中使用了 webpack-sources 的 package，为避免持久缓存的版本冲突,请使用 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>).<span class="property">sources</span> </span><br><span class="line">替代 </span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;webpack-sources&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式:"></a>配置方式:</h3><ul>
<li>在webpack.config.js中，首先需要require() 它，然后添加一个new实例到module.exports里的plugins数组<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 访问内置的插件</span></span><br><span class="line"><span class="attr">plugins</span>: [<span class="keyword">new</span> webpack.<span class="title class_">ProgressPlugin</span>(), <span class="comment">//用于自定义编译过程中的进度报告</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;<span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>&#125;)]</span><br></pre></td></tr></table></figure></li>
<li>Node API方式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 访问 webpack 运行时(runtime)</span></span><br><span class="line"><span class="keyword">const</span> configuration = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> compiler = <span class="title function_">webpack</span>(configuration);</span><br><span class="line"><span class="keyword">new</span> webpack.<span class="title class_">ProgressPlugin</span>().<span class="title function_">apply</span>(compiler);</span><br><span class="line">compiler.<span class="title function_">run</span>(<span class="keyword">function</span> (<span class="params">err, stats</span>) &#123;&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote>
<p>webpack 的配置文件是 JavaScript 文件，文件内导出了一个 webpack 配置的对象。</p>
</blockquote>
<h2 id="应避免操作"><a href="#应避免操作" class="headerlink" title="应避免操作"></a>应避免操作</h2><ul>
<li>当使用 webpack CLI 工具时，访问 CLI 参数（应编写自己的 CLI 工具替代，或者使用 –env）</li>
<li>导出不确定的结果（两次调用 webpack 应产生相同的输出文件）</li>
<li>编写超长的配置（应将配置文件拆分成多个）</li>
</ul>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./foo.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;foo.bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多个target: 可以将其导出为多个配置</li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><blockquote>
<p>在模块化编程中，开发者将程序分解为功能离散的chunk，并称为模块</p>
</blockquote>
<ul>
<li>支持的模块类型<ul>
<li>ECMAScript 模块</li>
<li>CommonJS 模块</li>
<li>AMD 模块</li>
<li>Assets</li>
<li>WebAssembly 模块</li>
</ul>
</li>
</ul>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><ul>
<li>通过选择development或production其中一个，来设置mode参数，启用相应模式下的 webpack 内置的优化</li>
<li>配置方式: 在webpack.config.js中的module.exports里mode：’production’</li>
<li>也可以分别配置development和production的配置文件，然后启动时调用对应的文件即可</li>
</ul>
<h2 id="浏览器兼容及环境"><a href="#浏览器兼容及环境" class="headerlink" title="浏览器兼容及环境"></a>浏览器兼容及环境</h2><ul>
<li>支持所有符合 ES5 标准 的浏览器（不支持 IE8 及以下版本）</li>
<li>import() 和 require.ensure() 需要 Promise</li>
<li>旧版本浏览器还需要提前加载 polyfill。</li>
<li>Webpack 5 运行于 Node.js v10.13.0+ 的版本</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack --- 第三篇Tapable</title>
    <url>/2024/11/01/Engineering/webpack--%E7%AC%AC%E4%B8%89%E7%AF%87%E4%BA%86%E8%A7%A3Tapable/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>了解webpack Plugin之前应该掌握Tapable<br>在 Webpack 的编译过程中，本质上通过 Tapable 实现了在编译过程中的一种<span class="key_words">『发布订阅者模式』</span>的插件 Plugin 机制。</p>
</blockquote>
<p>Tapable提供了一系列事件的发布订阅者API，通过Tapable使用者可以注册事件，从而在不同实际去触发注册的事件进行执行</p>
<h3 id="官方提供的九种钩子"><a href="#官方提供的九种钩子" class="headerlink" title="官方提供的九种钩子"></a>官方提供的九种钩子</h3><ul>
<li>SyncHook</li>
<li>SyncBailHook</li>
<li>SyncWaterfallHook</li>
<li>SyncLoopHook</li>
<li>AsyncParallelHook</li>
<li>AsyncParallelBaiHook</li>
<li>AsyncSeriesHook</li>
<li>AsyncSeriesBailHook</li>
<li>AsyncSeriesWaterfallHook</li>
</ul>
<h3 id="Tapable中所有注册的事件可以分为同步、异步两种执行方式"><a href="#Tapable中所有注册的事件可以分为同步、异步两种执行方式" class="headerlink" title="Tapable中所有注册的事件可以分为同步、异步两种执行方式"></a>Tapable中所有注册的事件可以分为同步、异步两种执行方式</h3><ul>
<li>同步(Sync前缀): 表示注册的事件函数会同步进行执行</li>
<li>异步(Async前缀): 表示注册的事件函数会异步进行执行</li>
<li>异步串行钩子(AsyncSeries)：可以被串联(<span class="desc">连续按照顺序调用</span>)执行的异步钩子函数</li>
<li>异步并行钩子(AsyncParalle)：可以被并联(<span class="desc">并发调用</span>)执行的异步钩子函数</li>
<li><span class="key_words">『同步钩子』</span>唯一的注册事件方法:『tap』，执行调用『call』方法</li>
<li><span class="key_words">『异步钩子』</span><ul>
<li>注册方法:『tap、tapAsync、tapPromise』</li>
<li>触发注册的方法:『call、callAsync、promise』<span class="desc">一一对应</span></li>
</ul>
</li>
</ul>
<h3 id="Tapable-按照执行机制分类"><a href="#Tapable-按照执行机制分类" class="headerlink" title="Tapable 按照执行机制分类"></a>Tapable 按照执行机制分类</h3><ul>
<li>Basic Hook：基本类型钩子，仅执行钩子注册的事件，不关心被调用事件的返回值</li>
<li>Waterfall：瀑布类型的钩子，会在注册事件执行时将事件函数执行非undefined的返回值传递给接下来的事件函数作为参数，其他的与基本类型钩子类似</li>
<li>Bail：保险类型钩子，在基础类型钩子上增加一个保险机制，<span class="key_words">『任意一个注册函数执行返回非undefined的值，整个钩子执行过程会立即中断』</span>，之后的注册事件就不会调用</li>
<li>Loop: 循环类型钩子，通过 call 调用时，<span class="key_words">『任意一个注册的事件返回值非 undefeind则立即重头开始重新执行所有的注册事件，直到所有被注册的事件函数都返回 undefined』</span>。</li>
<li>注册事件: 通过tap函数监听对应的事件，接受两个参数：参数一仅作标识, 参数二在调用时会执行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hook.tap(String|Object, 本次注册的函数)</span><br></pre></td></tr></table></figure></li>
<li>调用事件: 通过call方法传入对应的参数，调用注册在hook内部的事件函数执行，同时将call方法传入的参数传递给每一个注册的事件函数作为<span class="key_words">『实参』</span></li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">SyncHook</span>, <span class="title class_">SyncBailHook</span>, <span class="title class_">SyncWaterfallHook</span>,<span class="title class_">SyncWaterfallHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;tapable&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&#x27;arg1&#x27;</span>,<span class="string">&#x27;arg2&#x27;</span>,<span class="string">&#x27;arg3&#x27;</span>]) <span class="comment">// 这个就换钩子名，其他一样</span></span><br><span class="line"><span class="comment">// SyncHook注册与调用事件</span></span><br><span class="line"><span class="comment">// 初始化同步钩子</span></span><br><span class="line">重点：数组中对应的字符串个数</span><br><span class="line">hook.<span class="title function_">tap</span>(<span class="string">&#x27;flag1&#x27;</span>,<span class="function">(<span class="params">arg1,arg2,arg3</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">hook.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyncBailHook注册与调用事件</span></span><br><span class="line">hook.<span class="title function_">tap</span>(<span class="string">&#x27;flag1&#x27;</span>,<span class="function">(<span class="params">arg1,arg2,arg3</span>) =&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 存在返回值，阻断后面注册事件的调用</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">hook.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><a href="https://juejin.cn/post/7040982789650382855">参考:Tapable讲解</a></li>
</ul>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ul>
<li>Tapable 提供的所有 Hook 都支持注入 Interception ，可以通过拦截器对整个Tapable发布&#x2F;订阅流程进行监听<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hook.<span class="title function_">intercept</span>(&#123;</span><br><span class="line">  <span class="comment">// 每次通过 tap、tapAsync、tapPromise 方法注册事件函数时，会触发 register 拦截器。</span></span><br><span class="line">  <span class="comment">// 并且接受 tap 作为参数, 还可以对注册事件进行修改;</span></span><br><span class="line">  <span class="attr">register</span>: <span class="function">(<span class="params">tapInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;tapInfo.name&#125;</span> is doing its job`</span>);</span><br><span class="line">    <span class="keyword">return</span> tapInfo</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 通过hook实例对象上的call方法时候触发拦截器，接受的参数为调用 Hook 时传入的参数。</span></span><br><span class="line">  <span class="attr">call</span>: <span class="function">(<span class="params">arg1, arg2, arg3</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在调用被注册的每一个事件函数之前执行，接受参数为对应的 Tap 对象。</span></span><br><span class="line">  <span class="attr">tap</span>: <span class="function">(<span class="params">tap</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// loop类型钩子中 每次重新开始 loop 之前会执行该拦截器，拦截器函数接受的参数为调用时传入的参数。</span></span><br><span class="line">  <span class="attr">loop</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="Before-stage"><a href="#Before-stage" class="headerlink" title="Before &amp;&amp; stage"></a>Before &amp;&amp; stage</h4><ul>
<li>before 值类型为Array | String,值为注册事件对象时的名称，它可以<span class="key_words">让当前事件在对应标识事件前执行』</span></li>
<li>stage 值类型为Number，<span class="key_words">『数字越大事件回调执行的越晚』</span>，支持传入负数，默认为0 </li>
<li>使用：在注册事件函数，第一个参数为对象时，在这个对象添加stage和before来控制本次注册事件的执行时机</li>
<li>如果同时使用 before 和 stage 时，会优先处理 before ，在满足 before 的条件之后才会进行 stage 的判断。<span class="desc">不建议同时使用</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hook.<span class="title function_">tap</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;flag1&#x27;</span></span><br><span class="line">&#125;,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">hook.<span class="title function_">tap</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;flag2&#x27;</span>,</span><br><span class="line">	<span class="comment">// flag2 会在flag1前执行</span></span><br><span class="line">	<span class="attr">before</span>:<span class="string">&#x27;flag1&#x27;</span></span><br><span class="line">&#125;,<span class="function">()=&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="HookMap"><a href="#HookMap" class="headerlink" title="HookMap"></a>HookMap</h4><ul>
<li>辅助类，管理Hook <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建HookMap实例</span></span><br><span class="line"><span class="keyword">const</span> keyedHook = <span class="keyword">new</span> <span class="title class_">HookMap</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&#x27;arg&#x27;</span>]));</span><br><span class="line"><span class="comment">// 在keyedHook中创建一个name为key1的hook，同时为该hook通过tap注册事件 </span></span><br><span class="line">keyedHook.<span class="title function_">for</span>(<span class="string">&#x27;key1&#x27;</span>).<span class="title function_">tap</span>(<span class="string">&#x27;Plugin 1&#x27;</span>, <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Plugin 1&#x27;</span>, arg);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 从HookMap中拿到name为key1的hook</span></span><br><span class="line"><span class="keyword">const</span> hook = keyedHook.<span class="title function_">get</span>(<span class="string">&#x27;key1&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (hook) &#123;</span><br><span class="line">  <span class="comment">// 通过call方法触发Hook</span></span><br><span class="line">  hook.<span class="title function_">call</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack --- 第四篇</title>
    <url>/2024/11/01/Engineering/webpack--%E7%AC%AC%E5%9B%9B%E7%AF%87%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>entry：编译入口，webpack编译器点</li>
<li>compiler：编译管理器，webpack启动后会创建compiler对象，该对象一直存活直到结束退出</li>
<li>compilation：<span class="key_words">『单次』</span>编译过程的管理器(<span class="desc">比如watch &#x3D; true时，运行过程中只有一个compiler，但每次文件变更触发重新编译时，就会创建一个新的compilation</span>)</li>
<li>dependence: 依赖对象，webpack基于该类型记录模块间依赖关系</li>
<li>module：<ul>
<li>webpack<span class="key_words">『内部所有资源』</span>都会以”module”对象形式存在，所有关于<span class="key_words">『资源的操作、转译、合并都是以”module”为基本单位』</span>进行的</li>
</ul>
</li>
<li>chunk：<ul>
<li>编译完成准备输出时，webpack会将<span class="key_words">『module』</span>按特定的规则<span class="key_words">『组织成一个一个的chunk』</span>，这些chunk某种程度上<span class="key_words">『跟最终输出一一对应』</span></li>
</ul>
</li>
<li>loader：资源内容转换器，实现从内容A转换B的转换器</li>
<li>plugin：<ul>
<li><span class="key_words">『webpack构建过程』</span>中，会在特定的时机<span class="key_words">『广播』</span>对应的<span class="key_words">『事件』</span>，插件<span class="key_words">『监听』</span>这些<span class="key_words">『事件』</span>，在特定的时间点<span class="key_words">『介入』</span>编译<span class="key_words">『过程』</span></li>
</ul>
</li>
</ul>
<h2 id="webpack内部原理"><a href="#webpack内部原理" class="headerlink" title="webpack内部原理"></a>webpack内部原理</h2><h3 id="主要部分："><a href="#主要部分：" class="headerlink" title="主要部分："></a>主要部分：</h3><ul>
<li>项目中使用的每个文件都是一个模块，通过互相引用，这些模块会形成一个图数据结构。在打包过程中，模块会被合并成 chunk。 chunk 合并成 chunk 组，并形成一个通过模块互相连接的图。</li>
</ul>
<h3 id="chunk："><a href="#chunk：" class="headerlink" title="chunk："></a>chunk：</h3><ul>
<li>两种形式：<ul>
<li>initial(初始化) 是入口起点的 main chunk。此 chunk 包含为入口起点指定的所有模块及其依赖项。</li>
<li>non-initial 是可以延迟加载的块。可能会出现在使用 动态导入(dynamic imports) 或者 SplitChunksPlugin 时。</li>
</ul>
</li>
<li>每个 chunk 都有对应的 asset(资源)。</li>
</ul>
<h3 id="output-："><a href="#output-：" class="headerlink" title="output ："></a>output ：</h3><ul>
<li>输出文件的名称会受配置中的两个字段的影响：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output.<span class="property">filename</span> <span class="comment">// 用于 initial chunk 文件</span></span><br><span class="line">output.<span class="property">chunkFilename</span> <span class="comment">// 用于 non-initial chunk 文件</span></span><br></pre></td></tr></table></figure></li>
<li>在某些情况下，使用 initial 和 non-initial 的 chunk 时，可以使用 output.filename。</li>
<li>常用占位符：</li>
</ul>
<ol>
<li>[id] - chunk id<span class="desc">（如 [id].js -&gt; 485.js）</span></li>
<li>[name] - chunk name<span class="desc">（如 [name].js -&gt; app.js）</span>。如果 chunk 没有名称，则会使用其 id 作为名称</li>
<li>[contenthash] - 输出文件内容的 md4-hash<span class="desc">（如 [contenthash].js -&gt; 4ea6ff1de66c537eb9b2.js）</span></li>
</ol>
<h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><h3 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h3><ul>
<li>负责整体编译流程的Compiler对象、负责编译Module的Complication对象。</li>
<li><span class="key_words">『最核心的功能』</span>：将各种类型的资源，转译、组合、拼接、生成 JS 格式的 bundler 文件。</li>
<li>这个过程核心完成了<span class="key_words">『内容转换 + 资源合并』</span>两种功能, 三个阶段</li>
</ul>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><ul>
<li>初始化参数：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li>
<li>创建编译器对象：用上一步得到的参数创建 Compiler 对象</li>
<li>初始化编译环境：注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等</li>
<li>开始编译：执行 compiler 对象的 run 方法</li>
<li>确定入口：根据配置中的 entry 找出所有的入口文件，调用compilition.addEntry 将入口文件转换为 dependence 对象</li>
</ul>
<h4 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h4><ul>
<li>编译模块make：根据entry对应的dependence<span class="key_words">『创建module对象，调用loader』</span>将模块<span class="key_words">『转译为标准js』</span>内容，<span class="key_words">『调用js解释器将内容转换为AST对象』</span>，从中找到该模块<span class="key_words">『依赖的模块』</span>，在递归。处理全部入口文件</li>
<li>完成模块编译：通过上一步，得到每个模块<span class="key_words">『被翻译后的内容』</span>以及它们之间的<span class="key_words">『依赖关系图』</span></li>
</ul>
<h4 id="生成阶段"><a href="#生成阶段" class="headerlink" title="生成阶段"></a>生成阶段</h4><ul>
<li>输出资源seal：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会<br>  - 写入文件系统emitAssets：根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>
<li>参考<ul>
<li><a href="https://juejin.cn/post/6949040393165996040">webpack核心原理</a></li>
<li><a href="https://gitmind.cn/app/docs/m1foeg1o?view=outline">webpack5知识体系</a></li>
</ul>
</li>
</ul>
<h2 id="PLugin解析"><a href="#PLugin解析" class="headerlink" title="PLugin解析"></a>PLugin解析</h2><h3 id="什么是插件？"><a href="#什么是插件？" class="headerlink" title="什么是插件？"></a>什么是插件？</h3><ul>
<li>从形态上看，插件通常是一个带有aplly函数的类 ，apply运行时会得到参数compiler，以此为起点调用hook</li>
</ul>
<h3 id="什么时候触发什么钩子？"><a href="#什么时候触发什么钩子？" class="headerlink" title="什么时候触发什么钩子？"></a>什么时候触发什么钩子？</h3><ul>
<li>compiler.hooks.compilation<ul>
<li>触发时机：启动编译创建出 compilation 对象后触发</li>
</ul>
<ul>
<li>传递参数：当前编译的 compilation 对象</li>
<li>示例：很多插件基于此事件获取 compilation 实例</li>
</ul>
</li>
</ul>
<ul>
<li>compiler.hooks.make<ul>
<li>触发时机：正式开始编译时触发</li>
<li>传递参数：同样是当前编译的 compilation 对象</li>
<li>示例：webpack 内置的 EntryPlugin 基于此钩子实现 entry 模块的初始化</li>
</ul>
</li>
<li>compilation.hooks.optimizeChunks<ul>
<li>触发时机：seal 函数中，chunk 集合构建完毕后触发</li>
<li>传递参数：chunks 集合与 chunkGroups 集合</li>
<li>示例：SplitChunksPlugin 插件基于此钩子实现 chunk 拆分优化</li>
</ul>
</li>
<li>compiler.hooks.done<ul>
<li>触发时机：编译完成后触发</li>
<li>传递参数：stats 对象，包含编译过程中的各类统计信息</li>
<li>示例：webpack-bundle-analyzer 插件基于此钩子实现打包分析</li>
</ul>
</li>
<li>compilation.seal函数内部有以下两个钩子<ul>
<li>optimizeModules： 优化已经编译出的modules</li>
<li>afterOptimizeModules：用于通知优化行为的结束</li>
</ul>
</li>
<li>apply从设计上只有输入，webpack不关心输出，所以在插件中只能调用类型实体的方法或更改实体的配置信息，来变更编译行为</li>
</ul>
<h3 id="如何让影响编译状态？"><a href="#如何让影响编译状态？" class="headerlink" title="如何让影响编译状态？"></a>如何让影响编译状态？</h3><ul>
<li>hooks回调内部通过修改状态、调用上下文api等方式对webpack产生side effect</li>
<li>webpack会将上下文信息以参数或this（compiler对象）形式传递给钩子回调，在回调中可以调用上下文对象的方法或者直接修改上下文对象属性的方式，对原定流程产生side effect</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-DOM和事件</title>
    <url>/2024/10/31/JS/JS-DOM%E5%92%8C%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h1 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM( Document Object Model)"></a>DOM( Document Object Model)</h1><blockquote>
<p>文档对象模型，通过 DOM 可以来任意来修改网页中各个内容</p>
</blockquote>
<ul>
<li>文档：<ul>
<li>指的是网页，一个网页就是一个文档</li>
</ul>
</li>
<li>对象：<ul>
<li>指将网页中的每一个节点都转换为对象，转换完后，以一种纯面向对象的形式来操作网页</li>
</ul>
</li>
<li>模型：<ul>
<li>用来表示节点和节点之间的关系，方便操作页面</li>
</ul>
</li>
<li>节点(Node)：<ul>
<li>构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点</li>
<li>常用的节点(每个节点的类型都不一样)<ul>
<li>文档节点(Document)，代表整个网页</li>
<li>元素节点(Element)，代表网页中的标签</li>
<li>属性节点(Attribute)，代表标签中的属性</li>
<li>文本节点(Text)，代表网页中的文本内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h2><ul>
<li>DOM 查询</li>
<li>在网页中浏览器已经为我们提供了 document 对象，</li>
<li>它代表的是整个网页，它是 window 对象的属性，可以在页面中直接使用。</li>
</ul>
<h3 id="document-查询方法："><a href="#document-查询方法：" class="headerlink" title="document 查询方法："></a>document 查询方法：</h3><ul>
<li>根据元素的 id 属性查询一个元素节点对象：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id属性值&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>根据元素的 name 属性值查询一组元素节点对象:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;name属性值&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>根据标签名来查询一组元素节点对象：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;标签名&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>获取页面中 html 根元素：document.documentElement</li>
<li>获取页面中的 body 元素：document.body</li>
<li>根据元素的 class 属性值查询一组元素节点对象：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>不支持 IE8 及以下的浏览器</li>
</ul>
</li>
<li>返回文档中与指定选择器或选择器组匹配的第一个 Element 对象：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>根据 CSS 选择器去页面中查询一个元素</li>
<li>IE8 使用 querySelector()代替</li>
<li>如果匹配到的元素有多个，那么它只会返回查询到的第一个元素</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.box1 div&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>返回与指定的选择器组匹配的文档中的元素列表：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>根据 CSS 选择器去页面中查询一组元素</li>
<li>会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个</li>
</ul>
</li>
</ul>
<h3 id="具体的元素节点查询"><a href="#具体的元素节点查询" class="headerlink" title="具体的元素节点查询"></a>具体的元素节点查询</h3><ul>
<li>通过标签名查询当前元素的指定后代元素<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">元素.<span class="title function_">getElementsByTagName</span>()</span><br></pre></td></tr></table></figure></li>
<li>获取当前元素的所有子节点，会获取到空白的文本子节点: ele.childNodes</li>
<li>获取当前元素的所有子元素: ele.children</li>
<li>获取当前元素的第一个子节点: ele.firstChild</li>
<li>获取当前元素的最后一个子节点: ele.lastChild</li>
<li>获取当前元素的父元素: ele.parentNode</li>
<li>获取当前元素的前一个兄弟节点: ele.previousSibling</li>
<li>获取当前元素的后一个兄弟节点: ele.nextSibling</li>
<li>innerHTML 和 innerText<ul>
<li>两个属性作用类似，都可以获取到标签内部的内容，</li>
<li>不同是<span class="key_words">『innerHTML会获取到html标签』</span>，而<span class="key_words">『innerText会自动去除标签』</span></li>
</ul>
</li>
<li>读取标签内部的文本内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">示例：&lt;h1&gt;h1中的文本内容&lt;/h1&gt;</span><br><span class="line">元素.<span class="property">firstChild</span>.<span class="property">nodeValue</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DOM-修改"><a href="#DOM-修改" class="headerlink" title="DOM 修改"></a>DOM 修改</h3><ul>
<li>可以根据标签名创建一个元素节点对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>()</span><br></pre></td></tr></table></figure></li>
<li>可以根据文本内容创建一个文本节点对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createTextNode</span>()</span><br></pre></td></tr></table></figure></li>
<li>向父节点中添加指定的子节点<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父节点.<span class="title function_">appendChild</span>(子节点)</span><br></pre></td></tr></table></figure></li>
<li>将一个新的节点插入到旧节点的前边<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父节点.<span class="title function_">insertBefore</span>(新节点,旧节点)</span><br></pre></td></tr></table></figure></li>
<li>使用一个新的节点去替换旧节点<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父节点.<span class="title function_">replaceChild</span>(新节点,旧节点)</span><br></pre></td></tr></table></figure></li>
<li>删除指定的子节点<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父节点.<span class="title function_">removeChild</span>(子节点)</span><br><span class="line">子节点.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(子节点)  <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="元素的属性"><a href="#元素的属性" class="headerlink" title="元素的属性"></a>元素的属性</h3><ul>
<li>读取元素的属性：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：元素.属性名</span><br></pre></td></tr></table></figure></li>
<li>修改元素的属性：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：元素.属性名 = 属性值</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用-DOM-操作-CSS"><a href="#使用-DOM-操作-CSS" class="headerlink" title="使用 DOM 操作 CSS"></a>使用 DOM 操作 CSS</h3><ul>
<li>修改元素的样式 — 内联样式<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">元素.<span class="property">style</span>.样式名 = 样式值</span><br></pre></td></tr></table></figure></li>
<li>注意：如果 CSS 的样式名中含有-，需要将这种样式名修改为驼峰命名法，aaBB</li>
<li>尽量不要为样式添加!important</li>
</ul>
</li>
<li>读取元素的样式 — 内联样式<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">元素.<span class="property">style</span>.样式名</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>读取元素的当前显示的样式<ul>
<li>正常浏览器: getComputedStyle()<ul>
<li>这个方法是 window 对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式</li>
<li>可以通过对象.样式名来读取样式，如果获取的样式没有设置，则会获取到真实的值，而不是默认值</li>
<li>参数：<ol>
<li>要获取样式的元素</li>
<li>可以传递一个伪元素，一般传 null</li>
</ol>
</li>
</ul>
</li>
<li>IE8<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">元素.<span class="property">currentStyle</span>.样式名 <span class="comment">// IE 浏览器支持</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以用来读取当前元素正在显示的样式，如果当前元素没有设置该样式，则获取它的默认值</li>
</ul>
</li>
</ul>
</li>
<li>定义一个函数，用来获取指定元素的当前的样式<ul>
<li>参数<ul>
<li>obj：要获取样式的元素</li>
<li>name：要获取的样式名</li>
</ul>
</li>
<li>例子：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getStyle</span>(<span class="params">obj, name</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">getComputedStyle</span></span><br><span class="line">		? <span class="title function_">getComputedStyle</span>(obj, <span class="literal">null</span>)[name]</span><br><span class="line">		: obj.<span class="property">currentStyle</span>[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>clientWidth | clientHeight<ul>
<li>这两个属性可以获取元素的<span class="key_words">『可见宽度和高度，包括内容区和内边距』</span></li>
<li>不带单位</li>
</ul>
</li>
<li>offsetWidth | offsetHeight<ul>
<li>获取元素的<span class="key_words">『整个的宽度和高度，包括内容区、内边距和边框』</span></li>
</ul>
</li>
<li>offsetParent<ul>
<li>可以用来获取当前元素的定位父元素</li>
<li>会获取到离当前元素最近的开启了定位的祖先元素</li>
<li>如果所有的祖先元素都没有开启定位，则返回 body</li>
</ul>
</li>
<li>offsetLeft | offsetTop<ul>
<li>当前元素相对于其定位父元素的<span class="key_words">『水平或垂直偏移量』</span></li>
</ul>
</li>
<li>scrollWidth | scrollHeight<ul>
<li>可以获取元素整个滚动区域的宽度和高度</li>
</ul>
</li>
<li>scrollLeft | scrollTop<ul>
<li>可以获取<span class="key_words">『水平或垂直滚动条滚动的距离』</span></li>
</ul>
</li>
<li>判断滚动条是否到底<ul>
<li>垂直滚动条滚动到底：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scrollHeight - scrollTop == clientHeight</span><br></pre></td></tr></table></figure></li>
<li>水平滚动条滚动到底：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scrollWidth - scrollLeft == clientWidth</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ele.setCapture()<ul>
<li>这个元素将会把<span class="key_words">『下一次所有的鼠标按下相关的事件捕获到自身』</span>上</li>
</ul>
</li>
</ul>
<h1 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h1><blockquote>
<p>事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动等</p>
</blockquote>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul>
<li>当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标、按键，键盘的按键，滚轮的方向等</li>
<li>在响应函数中定义一个形参，来使用事件对象，但是在 IE8 及以下的浏览器中，是将事件对象作为 window 对象的属性保存的</li>
<li><span class="key_words">『解决事件对象的兼容性问题』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">元素.事件 = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">	event = event || <span class="variable language_">window</span>.<span class="property">event</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>clientX 可以获取鼠标指针的水平坐标,cilentY 可以获取鼠标指针的垂直坐标</li>
<li><span class="key_words">『获取滚动条滚动的距离』</span><ul>
<li>chrome 认为浏览器的滚动条是 body 的，可以通过 body.scrollTop 来获取</li>
<li>火狐等浏览器认为浏览器的滚动条是 html 的，</li>
<li>解决兼容问题：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">st = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="事件的冒泡（Bubble）"><a href="#事件的冒泡（Bubble）" class="headerlink" title="事件的冒泡（Bubble）"></a>事件的冒泡（Bubble）</h2><ul>
<li>释义：指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。</li>
<li>如果需要取消冒泡，可以将事件对象的 cancelBubble 设置为 true</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">元素.事件 = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">	event = event || <span class="variable language_">window</span>.<span class="property">event</span></span><br><span class="line">	event.<span class="property">cancelBubble</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派"></a>事件的委派</h2><ul>
<li>释义：指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素从而通过祖先元素的响应函数来处理事件。</li>
<li>事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能</li>
<li>target — event 中的 target 表示的触发事件的对象</li>
</ul>
<h2 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定"></a>事件的绑定</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.事件 = 函数</span><br></pre></td></tr></table></figure>
<ul>
<li><p>只能同时为一个元素的一个事件绑定一个响应函数，</p>
</li>
<li><p>不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的</p>
</li>
<li><p>绑定事件的方式：</p>
<ul>
<li>可以在标签的事件属性中设置相应的 JS 代码(<span class="desc">不建议</span>)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;js代码。。。&quot;</span>&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
<li>可以通过为对象的指定事件属性设置回调函数的形式来处理事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="title function_">alert</span>(<span class="string">&quot;你还点~~~&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>addEventListener() (<span class="desc">不支持 IE8 及以下的浏览器</span>)</p>
<ul>
<li>可以为元素绑定响应函数</li>
<li>参数：<ul>
<li>事件的字符串，不要 on</li>
<li>回调函数，当事件触发时该函数会被调用</li>
<li>是否在捕获阶段触发事件，需要一个布尔值，一般都传 false</li>
</ul>
</li>
<li>使用 addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，</li>
<li>这样当事件被触发时，响应函数将会按照函数的绑定顺序执行</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn01.<span class="title function_">addEventListener</span>(</span><br><span class="line">	<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">	<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="number">1</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>attachEvent()</p>
<ul>
<li>在IE8中可以使用 attachEvent()来绑定事件</li>
<li>参数：<ul>
<li>事件的字符串，要 on</li>
<li>回调函数</li>
</ul>
</li>
<li>这个方法也可以同时为一个事件绑定多个处理函数，</li>
<li>不同的是它是后绑定先执行，执行顺序和 addEventListener()相反</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn01.<span class="title function_">attachEvent</span>(<span class="string">&#x27;onclick&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>定义一个函数，用来为指定元素绑定响应函数</p>
<ul>
<li>addEventListener() 中的 this，是绑定事件的对象</li>
<li>attachEvent()中的 this，是 window</li>
<li>需要统一两个方法 this</li>
<li>参数：<ul>
<li>obj 要绑定事件的对象</li>
<li>eventStr 事件的字符串(不要 on)</li>
<li>callback 回调函数</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bind</span>(<span class="params">obj, eventStr, callback</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (obj.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">		<span class="comment">//大部分浏览器兼容的方式</span></span><br><span class="line">		obj.<span class="title function_">addEventListener</span>(eventStr, callback, <span class="literal">false</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//IE8及以下</span></span><br><span class="line">		obj.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + eventStr, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">			<span class="comment">//在匿名函数中调用回调函数</span></span><br><span class="line">			callback.<span class="title function_">call</span>(obj)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><ul>
<li>微软认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，<br>然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。</li>
<li>网景认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素</li>
</ul>
<h3 id="W3C-综合了两个公司的方案，将事件传播分成了三个阶段"><a href="#W3C-综合了两个公司的方案，将事件传播分成了三个阶段" class="headerlink" title="W3C 综合了两个公司的方案，将事件传播分成了三个阶段"></a>W3C 综合了两个公司的方案，将事件传播分成了三个阶段</h3><ul>
<li>捕获阶段<ul>
<li>在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件</li>
</ul>
</li>
<li>目标阶段<ul>
<li>事件捕获到目标元素，捕获结束开始在目标元素上触发事件</li>
</ul>
</li>
<li>冒泡阶段<ul>
<li>事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</li>
</ul>
</li>
<li>在捕获阶段就触发事件，可以将 addEventListener()的第三个参数设置为 true<ul>
<li>一般情况下不会希望在捕获阶段触发事件，所以这个参数一般都是 false</li>
</ul>
</li>
<li>IE8 及以下的浏览器中没有捕获阶段</li>
</ul>
<h2 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件"></a>滚轮事件</h2><ul>
<li>onmousewheel 鼠标滚轮滚动的事件，会在滚轮滚动时触发，但是火狐不支持该属性</li>
<li>在<span class="key_words">『火狐』</span>中需要使用 DOMMouseScroll 且通过 addEventListener()来绑定滚动事件</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">box1.<span class="property">onmousewheel</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">	event = event || <span class="variable language_">window</span>.<span class="property">event</span></span><br><span class="line">	<span class="comment">//event.wheelDelta 可以获取鼠标滚轮滚动的方向</span></span><br><span class="line">	<span class="comment">//向上滚 120   向下滚 -120</span></span><br><span class="line">	<span class="comment">//wheelDelta这个值不看大小，只看正负</span></span><br><span class="line">	<span class="comment">//wheelDelta这个属性火狐中不支持</span></span><br><span class="line">	<span class="comment">//在火狐中使用event.detail来获取滚动的方向</span></span><br><span class="line">	<span class="comment">//向上滚 -3  向下滚 3</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 当鼠标滚轮向下滚动时，box1变长</span></span><br><span class="line"><span class="comment">	 * 	当滚轮向上滚动时，box1变短</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//判断鼠标滚轮滚动的方向</span></span><br><span class="line">	<span class="keyword">if</span> (event.<span class="property">wheelDelta</span> &gt; <span class="number">0</span> || event.<span class="property">detail</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//向上滚，box1变短</span></span><br><span class="line">		box1.<span class="property">style</span>.<span class="property">height</span> = box1.<span class="property">clientHeight</span> - <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//向下滚，box1变长</span></span><br><span class="line">		box1.<span class="property">style</span>.<span class="property">height</span> = box1.<span class="property">clientHeight</span> + <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false</span></span><br><span class="line"><span class="comment">	 * 需要使用event来取消默认行为event.preventDefault();</span></span><br><span class="line"><span class="comment">	 * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	event.<span class="property">preventDefault</span> &amp;&amp; event.<span class="title function_">preventDefault</span>()</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，</span></span><br><span class="line"><span class="comment">	 * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为火狐绑定滚轮事件</span></span><br><span class="line"><span class="title function_">bind</span>(box1, <span class="string">&#x27;DOMMouseScroll&#x27;</span>, box1.<span class="property">onmousewheel</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><ul>
<li>onkeydown: 按键被按下<ul>
<li>对于 onkeydown 来说如果一直按着某个按键不松手，则事件会一直触发</li>
<li>当 onkeydown 连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生。</li>
</ul>
</li>
<li>onkeyup: 按键被松开</li>
<li>键盘事件一般都会绑定给一些可以获取到焦点的对象或者是 document</li>
<li>可以通过 keyCode 来获取按键的编码，通过它可以判断哪个按键被按下</li>
<li>altKey、ctrlKey、shiftKey<ul>
<li>这个三个用来判断 alt、ctrl 和 shift 是否被按下，如果按下则返回 true，否则返回 false</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">onkeyup</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按键松开了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">input.<span class="property">onkeydown</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">	event = event || <span class="variable language_">window</span>.<span class="property">event</span></span><br><span class="line">	<span class="comment">//数字 48 - 57</span></span><br><span class="line">	<span class="comment">//使文本框中不能输入数字</span></span><br><span class="line">	<span class="keyword">if</span> (event.<span class="property">keyCode</span> &gt;= <span class="number">48</span> &amp;&amp; event.<span class="property">keyCode</span> &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">		<span class="comment">//在文本框中输入内容，属于onkeydown的默认行为</span></span><br><span class="line">		<span class="comment">//如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="拖拽事件"><a href="#拖拽事件" class="headerlink" title="拖拽事件"></a>拖拽事件</h2><ul>
<li>拖拽的流程<ul>
<li>当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown</li>
<li>当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove</li>
<li>当鼠标松开时，被拖拽元素固定在当前位置 onmouseup</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> box1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;box1&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> box2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;box2&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> img1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;img1&quot;</span>);</span><br><span class="line">	<span class="comment">//开启box1的拖拽</span></span><br><span class="line">	<span class="title function_">drag</span>(box1);</span><br><span class="line">	<span class="comment">//开启box2的</span></span><br><span class="line">	<span class="title function_">drag</span>(box2);</span><br><span class="line">	<span class="title function_">drag</span>(img1);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 提取一个专门用来设置拖拽的函数</span></span><br><span class="line"><span class="comment">	* 参数：开启拖拽的元素</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">drag</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">		obj.<span class="property">onmousedown</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">		<span class="comment">// 设置box1捕获所有鼠标按下的事件</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * setCapture()</span></span><br><span class="line"><span class="comment">		 * 	- 只有IE支持，但是在火狐中调用时不会报错，而如果使用chrome调用，会报错</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		obj.<span class="property">setCapture</span> &amp;&amp; obj.<span class="title function_">setCapture</span>();</span><br><span class="line">		event = event || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">		<span class="comment">// div的偏移量 鼠标.clentX - 元素.offsetLeft</span></span><br><span class="line">		<span class="comment">// div的偏移量 鼠标.clentY - 元素.offsetTop</span></span><br><span class="line">		<span class="keyword">var</span> ol = event.<span class="property">clientX</span> - obj.<span class="property">offsetLeft</span>;</span><br><span class="line">		<span class="keyword">var</span> ot = event.<span class="property">clientY</span> - obj.<span class="property">offsetTop</span>;</span><br><span class="line">		<span class="comment">// 为document绑定一个onmousemove事件</span></span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">onmousemove</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">			event = event || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">			<span class="comment">// 当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove</span></span><br><span class="line">			<span class="comment">// 获取鼠标的坐标</span></span><br><span class="line">			<span class="keyword">var</span> left = event.<span class="property">clientX</span> - ol;</span><br><span class="line">			<span class="keyword">var</span> top = event.<span class="property">clientY</span> - ot;</span><br><span class="line">			<span class="comment">// 修改box1的位置</span></span><br><span class="line">			obj.<span class="property">style</span>.<span class="property">left</span> = left+<span class="string">&quot;px&quot;</span>;</span><br><span class="line">			obj.<span class="property">style</span>.<span class="property">top</span> = top+<span class="string">&quot;px&quot;</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 为document绑定一个鼠标松开事件</span></span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">onmouseup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="comment">// 当鼠标松开时，被拖拽元素固定在当前位置	onmouseup</span></span><br><span class="line">			<span class="comment">// 取消document的onmousemove事件</span></span><br><span class="line">			<span class="variable language_">document</span>.<span class="property">onmousemove</span> = <span class="literal">null</span>;</span><br><span class="line">			<span class="comment">// 取消document的onmouseup事件</span></span><br><span class="line">			<span class="variable language_">document</span>.<span class="property">onmouseup</span> = <span class="literal">null</span>;</span><br><span class="line">			<span class="comment">// 当鼠标松开时，取消对事件的捕获</span></span><br><span class="line">			obj.<span class="property">releaseCapture</span> &amp;&amp; obj.<span class="title function_">releaseCapture</span>();</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，</span></span><br><span class="line"><span class="comment">		 * 	此时会导致拖拽功能的异常，这个是浏览器提供的默认行为，</span></span><br><span class="line"><span class="comment">		 * 	可以通过return false来取消默认行为，但是这招对IE8不起作用</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="文档的加载"><a href="#文档的加载" class="headerlink" title="文档的加载"></a>文档的加载</h1><ul>
<li><p>浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。</p>
</li>
<li><p>如果将 js 代码编写到页面的上边，当代码执行时，页面中的 DOM 对象还没有加载，<br>此时将会无法正常获取到 DOM 对象，导致 DOM 操作失败。</p>
</li>
<li><p>解决方式一：</p>
<ul>
<li>可以将 js 代码编写到 body 里，放在最下边执行</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&#x27;btn&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>); btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span></span><br><span class="line"><span class="language-javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>解决方式二：</p>
<ul>
<li>将 js 代码编写到 window.onload &#x3D; function(){}中</li>
<li>window.onload 对应的回调函数会在整个页面加载完毕以后才执行，<br>所以可以确保代码执行时，DOM 对象已经加载完毕了</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">		btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><blockquote>
<p>浏览器对象模型</p>
</blockquote>
<ul>
<li>BOM 可以使我们通过 JS 来操作浏览器,在 BOM 中提供了一组对象，用来完成对浏览器的操作</li>
</ul>
<h2 id="BOM-对象"><a href="#BOM-对象" class="headerlink" title="BOM 对象"></a>BOM 对象</h2><ul>
<li><p>Window：代表的是整个浏览器的窗口，同时 window 也是网页中的全局对象</p>
</li>
<li><p>userAgent：是一个字符串，通过这个字符串来判断不同的浏览器</p>
<ul>
<li>火狐的 userAgent<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0</span><br></pre></td></tr></table></figure></li>
<li>Chrome 的 userAgent<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36</span><br></pre></td></tr></table></figure></li>
<li>IE8-10<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mozilla/4.0 (compatible; MSIE 8/9/10.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</span><br></pre></td></tr></table></figure></li>
<li>IE11<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko</span><br></pre></td></tr></table></figure></li>
<li>注意：<span class="key_words">『在IE11中已经将微软和IE相关的标识都已经去除了，所以基本已经不能通过UserAgent来识别一个浏览器是否是IE』</span></li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/firefox/i</span>.<span class="title function_">test</span>(ua)) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&#x27;你是火狐！！！&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/chrome/i</span>.<span class="title function_">test</span>(ua)) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&#x27;你是Chrome&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/msie/i</span>.<span class="title function_">test</span>(ua)) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&#x27;你是IE浏览器~~~&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;ActiveXObject&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&#x27;你是IE11，枪毙了你~~~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息</span></span><br><span class="line"><span class="comment">// 比如：ActiveXObject</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;ActiveXObject&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&#x27;你是IE，我已经抓住你了~~~&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&#x27;你不是IE~~~&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Location：代表当前浏览器的地址栏信息，或者操作浏览器跳转页面</p>
<ul>
<li>直接修改 location 属性，页面会自动跳转到该路径，并且会生成相应的历史记录<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location = <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>assign(): 用来跳转到其他的页面，作用和直接修改 location 一样<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location.<span class="title function_">assign</span>(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>reload(): 用于重新加载当前页面，作用和刷新按钮一样<ul>
<li>如果在方法中传递一个 true，作为参数，则会强制清空缓存刷新页面</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location.<span class="title function_">reload</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>replace(): 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面<ul>
<li>不会生成历史记录，不能使用回退按钮回退</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location.<span class="title function_">replace</span>(<span class="string">&quot;01.BOM.html&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>History：代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录</p>
<ul>
<li>由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页,而且该操作只在当次访问时有效</li>
<li>length: 可以获取到当成访问的链接数量</li>
<li>back(): 可以用来回退到上一个页面，作用和浏览器的回退按钮一样</li>
<li>forward(): 可以跳转下一个页面，作用和浏览器的前进按钮一样</li>
<li>go(): 可以用来跳转到指定的页面<ul>
<li>它需要一个整数作为参数</li>
<li>1:表示向前跳转一个页面 相当于 forward()</li>
<li>正整数:表示向前跳转 n 个页面</li>
<li>负整数:表示向后跳转 n 个页面</li>
</ul>
</li>
</ul>
</li>
<li><p>Screen：代表用户的屏幕信息，通过该对象可以获取到用户显示器的相关信息</p>
</li>
<li><p><span class="key_words">『这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用』</span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>埋点</title>
    <url>/2024/11/01/Engineering/%E5%9F%8B%E7%82%B9/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="前端监控"><a href="#前端监控" class="headerlink" title="前端监控"></a>前端监控</h2><ul>
<li>发现问题和解决问题</li>
<li>做产品的决策依据</li>
<li>提高技术的深度与广度</li>
</ul>
<h2 id="监控目标"><a href="#监控目标" class="headerlink" title="监控目标"></a>监控目标</h2><ul>
<li><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul>
<li>js错误：js执行错误或promise异常</li>
<li>资源异常：script、link等资源加载异常</li>
<li>接口错误：ajax或fetch请求接口异常</li>
<li>白屏：页面空白</li>
</ul>
</li>
<li><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><ul>
<li>加载时间：各个阶段的加载时间</li>
<li>TTFB首字节时间：浏览器发起第一个请求到数据返回第一个字节所消耗的时间，这个是时间包含了网络请求、后端处理时间</li>
<li>FP首次绘制：包括了任何用户自定义的背景绘制，它是将第一个像素点绘制到屏幕的时间</li>
<li>FCP首次内容绘制：浏览器将第一个DOM渲染到屏幕的时间，可以是任何文本、图像、SVG等的时间</li>
<li>FMP首次有意义的绘制：页面可用性的标准</li>
<li>FID首次输入延迟：用户首次和页面交互到页面响应交互的时间</li>
<li>卡顿：超过50ms的长任务</li>
</ul>
</li>
<li><h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><ul>
<li>PV：page view 即页面浏览器会点击量</li>
<li>UV：指访问某个站点的不同IP地址的人数</li>
<li>页面的停留时间： 用户在每一个页面的停留时间</li>
</ul>
</li>
</ul>
<h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><h3 id="自己埋点步骤"><a href="#自己埋点步骤" class="headerlink" title="自己埋点步骤"></a>自己埋点步骤</h3><ul>
<li>埋点 –&gt; 数据采集(前端做到这就行，后面交给阿里云) –&gt;  (阿里云日志服务)数据建模存储 –&gt; 数据传输(实时&#x2F;批量) –&gt; 数据统计(分析&#x2F;挖掘) –&gt;  支线一数据可视化(反馈) –&gt;  支线二报告与报警</li>
</ul>
<h3 id="直接接入现成的："><a href="#直接接入现成的：" class="headerlink" title="直接接入现成的："></a>直接接入现成的：</h3><ul>
<li>sentry <a href="https://docs.sentry.io/">https://docs.sentry.io/</a></li>
<li>fundebug <a href="https://www.fundebug.com/">https://www.fundebug.com/</a></li>
</ul>
<h2 id="常见的埋点方案"><a href="#常见的埋点方案" class="headerlink" title="常见的埋点方案"></a>常见的埋点方案</h2><ul>
<li><h3 id="代码埋点"><a href="#代码埋点" class="headerlink" title="代码埋点"></a>代码埋点</h3><ul>
<li>以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时，插入一段代码，保存这个监听行为或者直接监听行为以某一种数据格式直接传递给服务器端</li>
<li>优点： 在任意时刻，精确的发送或保存所需要的数据信息</li>
<li>缺点：工作量较大</li>
</ul>
</li>
<li><h3 id="可视化埋点"><a href="#可视化埋点" class="headerlink" title="可视化埋点"></a>可视化埋点</h3><ul>
<li>将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等，最后输出的代码耦合了业务代码和埋点代码</li>
<li>本质：用系统代替手工插入埋点代码</li>
</ul>
</li>
<li><h3 id="无痕埋点"><a href="#无痕埋点" class="headerlink" title="无痕埋点"></a>无痕埋点</h3><ul>
<li>前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来<ul>
<li>通过定期上传记录文件，配合文件解析，解析出来外面响应的数据，并生成可视化报告供专业人员分析</li>
<li>优点：采集全量数据，不会出现漏埋和误埋现象</li>
<li>缺点： 给数据传输和服务器增加压力，也无法灵活定制数据结构<br><a href="https://juejin.cn/post/7094899430356156446">埋点部署</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="sdk"><a href="#sdk" class="headerlink" title="sdk"></a>sdk</h2><h3 id="sdk需要监控什么？"><a href="#sdk需要监控什么？" class="headerlink" title="sdk需要监控什么？"></a>sdk需要监控什么？</h3><ul>
<li>错误统计</li>
<li>行为日志埋点</li>
<li>PV&#x2F;UV统计</li>
</ul>
<h3 id="sdk功能拆分"><a href="#sdk功能拆分" class="headerlink" title="sdk功能拆分"></a>sdk功能拆分</h3><ol>
<li>参数注入</li>
<li>sdk初始化</li>
<li>pv统计、uv统计、用户埋点统计、错误监控、全局配置</li>
</ol>
<h2 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h2><h3 id="同步错误：可以被try-catch捕获"><a href="#同步错误：可以被try-catch捕获" class="headerlink" title="同步错误：可以被try&#x2F;catch捕获"></a>同步错误：可以被try&#x2F;catch捕获</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button </span><br><span class="line">	onClick = &#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> name = <span class="string">&#x27;tongbucuowu&#x27;</span></span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(nam)</span><br><span class="line">		&#125;<span class="keyword">catch</span>(error) &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----同步错误----&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&gt;同步错误&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="异步错误：无法被try-catch捕获，可以使用window-onerror处理"><a href="#异步错误：无法被try-catch捕获，可以使用window-onerror处理" class="headerlink" title="异步错误：无法被try&#x2F;catch捕获，可以使用window.onerror处理"></a>异步错误：无法被try&#x2F;catch捕获，可以使用window.onerror处理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button </span><br><span class="line">	onClick = &#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> name = <span class="string">&#x27;yibucuowu&#x27;</span></span><br><span class="line">			name.<span class="title function_">map</span>()</span><br><span class="line">		&#125;<span class="keyword">catch</span>(error) &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----异步错误----&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&gt;异步错误&lt;/button&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">mas,url,roe, col, error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="promise-错误："><a href="#promise-错误：" class="headerlink" title="promise 错误："></a>promise 错误：</h3><ul>
<li>window.onerror处理不了，可以使用catch捕获或者监听unhandledrejection事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unhandledrejection&#x27;</span>, <span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异常&#x27;</span>,error)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="资源加载错误"><a href="#资源加载错误" class="headerlink" title="资源加载错误"></a>资源加载错误</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异常&#x27;</span>，error)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h3 id="error与onerror的区别"><a href="#error与onerror的区别" class="headerlink" title="error与onerror的区别"></a>error与onerror的区别</h3><ul>
<li>error: 可以写多个</li>
<li>onerror：只能写一个，后者会覆盖前者</li>
</ul>
<h3 id="手动捕获"><a href="#手动捕获" class="headerlink" title="手动捕获"></a>手动捕获</h3><ul>
<li>手动埋点：在回调函数中手动调用tracker函数</li>
<li>属性埋点：没有回调函数，直接在属性上传值，可获取到，改属性是定义函数时指定的</li>
<li>自动埋点（无痕埋点）：没有回调也没有属性设置值，就会获取元素的dom，不直观，交互存储压力大</li>
</ul>
<h2 id="统计与路由"><a href="#统计与路由" class="headerlink" title="统计与路由"></a>统计与路由</h2><h3 id="pv统计："><a href="#pv统计：" class="headerlink" title="pv统计："></a>pv统计：</h3><ul>
<li>SPA应用之前只需要监听onload事件</li>
<li>SPA应用中分为hash路由和history路由</li>
</ul>
<h3 id="history路由："><a href="#history路由：" class="headerlink" title="history路由："></a>history路由：</h3><ul>
<li>主要依赖pushState和replaceState来实现，但这两种方法被popstate监听到，所以要重写</li>
<li>history.pushState(): 添加新的历史记录</li>
<li>history.replaceState(): 修改当前的记录项</li>
<li>history.back():返回上一页，回退</li>
<li>history.forward():前进一页，前进</li>
<li>history.go():调账到历史记录中的某一页</li>
<li>监听这一页的停留时间：监听到下一页进入的时间 - 进入这一页的时间</li>
<li>监听那一夜的停留时间，记录上一页的路径</li>
</ul>
<h3 id="hash路由：监听hashchange和重写replaceState"><a href="#hash路由：监听hashchange和重写replaceState" class="headerlink" title="hash路由：监听hashchange和重写replaceState"></a>hash路由：监听hashchange和重写replaceState</h3><h3 id="uv统计"><a href="#uv统计" class="headerlink" title="uv统计"></a>uv统计</h3><ul>
<li>统计用户数量 统计uid，在初始化时只进行上报，其余有服务端处理</li>
<li>fetch上报会有数据丢失，sendBeacon无数据丢失</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>埋点</tag>
      </tags>
  </entry>
  <entry>
    <title>实现h5小游戏基本步骤</title>
    <url>/2024/10/31/JS/JS-h5%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul>
<li>选型：选择自己擅长的框架和语言来搭建项目</li>
<li>搭建好项目，解决路由问题后，先根据要实现的页面将页面静态实现</li>
<li>然后先确定好整体的思路，先总后分</li>
<li>整体思路确定后，先完成游戏的底部逻辑，然后按照游戏思路走，一步一步完成即可。</li>
</ul>
<h2 id="实现-h5-小游戏的技能"><a href="#实现-h5-小游戏的技能" class="headerlink" title="实现 h5 小游戏的技能"></a>实现 h5 小游戏的技能</h2><ul>
<li>数学的逻辑思维，绘图(计算坐标时，可以绘图参考)，技能能力，框架认知</li>
</ul>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul>
<li>一开始，按照自己的思路，用自己熟悉的语法表达出来即可，等到之后多看大佬的代码，学有所成后，觉得有能力对代码进行升级优化，在重新实现</li>
</ul>
<h2 id="遇到问题："><a href="#遇到问题：" class="headerlink" title="遇到问题："></a>遇到问题：</h2><ul>
<li>安装的版本的 typescript，而非 javascript，vue3 会提示找不到模块“@&#x2F;views&#x2F;HomeView.vue”或其相应的类型声明。</li>
<li>解决：在目录中带env.d.ts的文件中添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.vue&#x27;</span> &#123;</span><br><span class="line">   <span class="keyword">import</span> type &#123; <span class="title class_">DefineComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="attr">component</span>: <span class="title class_">DefineComponent</span>&lt;&#123;&#125;, &#123;&#125;, any&gt;</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">default</span> component</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/489216263">扫雷参考</a></p>
<h2 id="扫雷思路"><a href="#扫雷思路" class="headerlink" title="扫雷思路"></a>扫雷思路</h2><ul>
<li>考虑到需要使用到随机函数，先封装一个随机函数</li>
<li>先将棋盘实现： 在初始化函数中实现一个 n*n 的空棋盘，本质上时实现一个二维数组</li>
<li>然后在棋盘中随机埋雷，给定雷的数量是多少，就循环多少次，并定义两个变量 x,y，获取在 0 到 n 的随机数，</li>
<li>然后设置二维数组的对应的 x,y 位置设置为雷</li>
<li>给雷生成提示，需要考虑边界和顶点这两种特殊情况，通过坐标</li>
<li>等提示生成后，存在有多个地雷挨得近的情况，在得到坐标的数组后，在计算从获取到的第一个雷的坐标开始，在距离这个坐标的两个格子，是否存在第二个雷，存在，则对应的值范围内坐标+1</li>
<li>然后将从埋雷开始的代码到提示的生成的代码全部放进点击开始的函数，并设立一个判断游戏开始的标签</li>
<li>处理上层的 mask 格子，需要将二位数组转化成复合要求的数组，这个 mask 数组应该存在 class，y 值，</li>
<li>在开始游戏的函数中需要更新 mask 数组</li>
<li>点击单个 mask 格子通过事件传递 y 值和 index，x 值</li>
<li>在该事件下封装一个函数，将点击格子附近的 n*n 区域除雷的格子背景设置为透明，这里主要注意顶点与其它区域的，设置连两个 x,y 的形参，</li>
<li>然后通过插旗的数量来判断第一次和其它次的点击生成范围</li>
<li>完成游戏失败判断</li>
<li>完成游戏胜利判断</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>案例</tag>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title>配置文件</title>
    <url>/2024/11/01/Engineering/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><h3 id="compileOnSave-true："><a href="#compileOnSave-true：" class="headerlink" title="compileOnSave: true："></a>compileOnSave: true：</h3><ul>
<li>让IDE在保存文件的时候根据tsconfig.json重新生成文件。</li>
</ul>
<h3 id="compilerOptions-编译选项，可以被忽略，有默认值"><a href="#compilerOptions-编译选项，可以被忽略，有默认值" class="headerlink" title="compilerOptions: 编译选项，可以被忽略，有默认值"></a>compilerOptions: 编译选项，可以被忽略，有默认值</h3><ul>
<li>allowJs：默认为false，是否支持js&#x2F;.jsx文件</li>
<li>typeRoots: 默认编译所有@types包，编译指定typeRoots下的所有@types包</li>
<li>types：只有被列出来的包才会被包含，指定types来禁用自动引入@types包</li>
<li><a href="https://typescript.bootcss.com/compiler-options.html">其余选项点击查看文档</a></li>
</ul>
<h3 id="files："><a href="#files：" class="headerlink" title="files："></a>files：</h3><ul>
<li>指定一个包含相对或绝对文件路径的列表,且总是会被包含在内，exclude设置无效</li>
</ul>
<h3 id="outDir"><a href="#outDir" class="headerlink" title="outDir:"></a>outDir:</h3><ul>
<li>指定的目录下的文件永远会被编译器排除，除非明确地使用”files”将其包含进来</li>
</ul>
<h3 id="include"><a href="#include" class="headerlink" title="include:"></a>include:</h3><ul>
<li>包含编译的文件指定一个文件的glob匹配模式列表</li>
</ul>
<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude:"></a>exclude:</h3><ul>
<li>排除编译的文件指定一个文件的glob匹配模式列表,默认排除 node_modules，bower_components，jspm_packages和outDir目录</li>
</ul>
<h3 id="glob匹配模式列表"><a href="#glob匹配模式列表" class="headerlink" title="glob匹配模式列表"></a>glob匹配模式列表</h3><ul>
<li>*：匹配0&#x2F;n个字符</li>
<li>?：匹配一个任意字符</li>
<li>**&#x2F;：递归匹配任意子目录</li>
</ul>
<h3 id="给路径配置别名："><a href="#给路径配置别名：" class="headerlink" title="给路径配置别名："></a>给路径配置别名：</h3><ul>
<li>首先给属性baseUrl: “.”,</li>
<li>其次在属性paths中配置</li>
<li>注意：在配置时要注意给&#x2F;*，才可以获取对应文件夹下的文件，一般ts提示飘红，很可能问题出在这<ul>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">	<span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span>,</span><br><span class="line">	<span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">	<span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;@/*&quot;</span>: [<span class="string">&quot;src/*&quot;</span>],</span><br><span class="line">		<span class="string">&quot;@component/*&quot;</span>: [<span class="string">&quot;component/*&quot;</span>],</span><br><span class="line">		<span class="string">&quot;@utils/*&quot;</span>: [<span class="string">&quot;utils/*&quot;</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>静态模块打包工具，处理应用程序时会在内部从一个或多个入口点构建一个依赖图，将项目中所需的每一个模块组合成一个或多个bundles，这些均为静态资源，用于展示内容。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>模块捆绑器： 将小块代码编译成更大更复杂的代码，运行在web浏览器</li>
</ul>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ul>
<li>入口(entry)、</li>
<li>输出(output)、</li>
<li>loader、</li>
<li>插件(plugin)、</li>
<li>模式(mode)、</li>
<li>浏览器兼容(browser compatibility)、</li>
<li>环境(environment)</li>
</ul>
<h3 id="模块（模块的离散功能块）"><a href="#模块（模块的离散功能块）" class="headerlink" title="模块（模块的离散功能块）"></a>模块（模块的离散功能块）</h3><ul>
<li>每个模块的表面积都比完整程序小，这使得验证、调试和测试变得微不足道。</li>
<li>良好的模块提供了坚实的抽象和封装边界，因此每个模块在整个应用程序中都具有连贯的设计和明确的目的。</li>
</ul>
<h2 id="sass-at-rules"><a href="#sass-at-rules" class="headerlink" title="sass at-rules"></a>sass at-rules</h2><h3 id="use-“sass-color”-基于现有颜色生成新颜色"><a href="#use-“sass-color”-基于现有颜色生成新颜色" class="headerlink" title="@use “sass:color” 基于现有颜色生成新颜色"></a>@use “sass:color” 基于现有颜色生成新颜色</h3><ul>
<li>参数：<ul>
<li>color.red(): 用于获取颜色的红色通道</li>
<li>color.green(): 用于获取颜色的绿色通道</li>
<li>color.blue(): 用于获取颜色的蓝色通道</li>
<li>color.hue(): 用于获取颜色的色调</li>
<li>color.saturation(): 用于获取颜色的饱和度</li>
<li>color.lightness(): 用于获取颜色的亮度</li>
<li>color.whiteness(): 用于获取颜色的白度</li>
<li>color.blackness(): 用于获取颜色的黑度</li>
<li>color.alpha(): 用于获取颜色的 alpha 通道</li>
</ul>
</li>
<li>方法：<ul>
<li>color.scale(): 流畅地缩放的一个或多个属性(不包含本身)</li>
<li>color.change(): 将颜色的一个或多个属性设置为新值。返回的是颜色值</li>
<li>color.adjust(): 按固定量增加或减少一个或多个属性</li>
<li>透明度：<ul>
<li>color.scale()</li>
<li>color.adjust($color，$alpha：-$amount)（保留现有行为）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="mixin"><a href="#mixin" class="headerlink" title="@mixin"></a>@mixin</h3><ul>
<li>跟@include在一起使用的时候可以把多个样式放在一起。</li>
<li>跟@each在一起使用搭配变量遍历meta.keywords(参数)</li>
<li>跟@content在一起，定义整个样式的基调，相当于样式的插槽</li>
<li>跟@media在一起，只有媒体查询的结果符合时，才会应用这一块内容</li>
</ul>
<h3 id="extend-继承"><a href="#extend-继承" class="headerlink" title="@extend 继承"></a>@extend 继承</h3><ul>
<li>selector.unify()：函数返回一个与两个选择器的交集匹配的选择器</li>
<li>selector.extend()：与@extend相似，用于单选择器</li>
<li>占位符选择器%：仅用于扩展的样式规则</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack --- 第二篇</title>
    <url>/2024/11/01/Engineering/webpack--%E7%AC%AC%E4%BA%8C%E7%AF%87%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="模块解析"><a href="#模块解析" class="headerlink" title="模块解析"></a>模块解析</h2><blockquote>
<p>resolver 是一个帮助寻找模块绝对路径的库。一个模块可以作为另一个模块的依赖模块，然后被后者引用。<br>resolver 帮助 webpack 从每个 require&#x2F;import 语句中，找到需要引入到 bundle 中的模块代码。 </p>
</blockquote>
<ul>
<li>当打包模块时，webpack 使用 enhanced-resolve 来解析文件路径。</li>
</ul>
<h3 id="webpack-中的解析规则"><a href="#webpack-中的解析规则" class="headerlink" title="webpack 中的解析规则"></a>webpack 中的解析规则</h3><ul>
<li>使用 enhanced-resolve，webpack 能解析三种文件路径：<ul>
<li>绝对路径：import ‘&#x2F;home&#x2F;me&#x2F;file’;</li>
<li>相对路径：import ‘..&#x2F;src&#x2F;file1’;</li>
<li>模块路径：import ‘module&#x2F;lib&#x2F;file’;</li>
</ul>
</li>
<li>在 resolve.modules 中指定的所有目录中检索模块。可以通过配置别名的方式来替换初始模块路径。</li>
<li>如果 package 中包含 package.json 文件，那么在 resolve.exportsFields 配置选项中指定的字段会被依次查找，package.json 中的第一个字段会根据 package 导出指南确定 package 中可用的 export。<ul>
<li>如果路径指向<span class="key_words">『文件』</span>：<ul>
<li>如果文件具有扩展名，则直接将文件打包。</li>
<li>否则，将使用 resolve.extensions 选项作为文件扩展名来解析。</li>
</ul>
</li>
<li>如果路径指向<span class="key_words">『文件夹』</span>，则寻找具有正确扩展名的文件：<ul>
<li>如果文件夹中包含 package.json 文件，则会根据 resolve.mainFields 配置中的字段顺序查找，并根据 package.json 中的符合配置要求的第一个字段来确定文件路径。</li>
<li>如果不存在 package.json 文件或 resolve.mainFields 没有返回有效路径，则会根据 resolve.mainFiles 配置选项中指定的文件名顺序查找，看是否能在 import&#x2F;require 的目录下匹配到一个存在的文件名。</li>
<li>然后使用 resolve.extensions 选项，以类似的方式解析文件扩展名。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="解析loader"><a href="#解析loader" class="headerlink" title="解析loader"></a>解析loader</h3><ul>
<li>resolveLoader 配置项可以为 loader 设置独立的解析规则。</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>每次文件系统访问文件都会被缓存，以便于更快触发对同一文件的多个并行或串行请求。在 watch 模式下，只有修改过的文件会被从缓存中移出。如果关闭 watch 模式，则会在每次编译前清理缓存</li>
</ul>
<h2 id="Module-Federation"><a href="#Module-Federation" class="headerlink" title="Module Federation"></a>Module Federation</h2><blockquote>
<p>可以实现多个独立 Weppack 构建之间的共享模块和代码。它通过让每个构建的应用程序能够使用其他应用程序中的模块来提高代码共享和复用的效率。<br>多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。这通常被称作微前端。</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>基于webpack的远程容器特性，允许将一个应用程序的某些模块打包为一个独立的、可远程加载的bundle，并在运行时动态加载这些模块。</li>
</ul>
<h3 id="主要优势"><a href="#主要优势" class="headerlink" title="主要优势"></a>主要优势</h3><ul>
<li>多个应用程序之间可以共享代码和模块，从而减少重复代码量</li>
<li>应用程序可以更加灵活地划分为更小的子应用程序，从而降低应用程序的复杂度</li>
<li>可以避免在应用程序之间传递大量数据，从而提高应用程序的性能和效率</li>
<li>可以支持应用程序的动态加载和升级，从而实现更好的版本管理和迭代</li>
</ul>
<h3 id="底层概念"><a href="#底层概念" class="headerlink" title="底层概念"></a>底层概念</h3><ul>
<li>区分本地模块和远程模块。</li>
<li><span class="key_words">『本地模块即为普通模块』</span>，是当前构建的一部分。</li>
<li><span class="key_words">『远程模块』</span>不属于当前构建，并<span class="key_words">『在运行时从所谓的容器加载』</span>。</li>
<li><span class="key_words">『加载远程模块被认为是异步操作』</span>。当使用远程模块时，这些异步操作将被放置在远程模块和入口之间的下一个 chunk的加载操作中。(<span class="desc">如果没有 chunk 加载操作，就不能使用远程模块</span>)</li>
<li>chunk 的加载操作通常是通过调用 import() 实现的，但也支持像以下的旧语法.<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.<span class="property">ensure</span> </span><br><span class="line">或 <span class="built_in">require</span>([...])</span><br></pre></td></tr></table></figure></li>
<li>容器是由容器入口创建的，该入口暴露了对特定模块的异步访问。</li>
<li>容器可以嵌套使用</li>
<li>容器可以使用来自其他容器的模块。</li>
<li>容器之间也可以循环依赖。</li>
<li>暴露的访问分为两个步骤：<ul>
<li>加载模块（<span class="desc">异步的</span>）：将在 chunk 加载期间完成</li>
<li>执行模块（<span class="desc">同步的</span>）：将在与其他（本地和远程）的模块交错执行期间完成</li>
</ul>
</li>
</ul>
<h3 id="高级概念"><a href="#高级概念" class="headerlink" title="高级概念"></a>高级概念</h3><ul>
<li>每个构建都充当一个容器，也可将其他构建作为容器。</li>
<li><span class="key_words">『共享模块』</span>是指既可重写的又可作为向嵌套容器提供重写的模块。它们通常指向每个构建中的相同模块。</li>
<li>packageName 选项允许通过设置包名来查找所需的版本。默认情况下，它会自动推断模块请求，当想禁用自动推断时，请将 requiredVersion 设置为 false 。</li>
</ul>
<h3 id="构建块"><a href="#构建块" class="headerlink" title="构建块"></a>构建块</h3><ul>
<li>ContainerPlugin：使用指定的公开模块来创建一个额外的容器入口。</li>
<li>ContainerReferencePlugin：将特定的引用添加到作为外部资源（externals）的容器中，并允许从这些容器中导入远程模块。它还会调用这些容器的 override API 来为它们提供重载。本地的重载（<span class="desc">当构建也是一个容器时，通过 <code>__webpack_override__</code> 或 override API</span>）和指定的重载被提供给所有引用的容器。</li>
<li>ModuleFederationPlugin：组合了ContainerPlugin和ContainerReferencePlugin</li>
</ul>
<h3 id="概念目标"><a href="#概念目标" class="headerlink" title="概念目标"></a>概念目标</h3><ul>
<li>既可以暴露，又可以使用 webpack 支持的任何模块类型</li>
<li>代码块加载应该并行加载所需的所有内容(web:到服务器的单次往返)</li>
<li>从使用者到容器的控制<ul>
<li>重写模块是一种单向操作</li>
<li>同级容器不能重写彼此的模块。</li>
</ul>
</li>
<li>概念适用于独立于环境</li>
<li>共享中的相对和绝对请求<ul>
<li>会一直提供，即使不使用</li>
<li>会将相对路径解析到 config.context</li>
<li>默认不会使用 requiredVersion</li>
</ul>
</li>
<li>共享中尾部带有 &#x2F;  的模块请求将匹配所有具有这个前缀的模块请求</li>
<li>共享中的模块请求<ul>
<li>只在使用时提供，并且提供所有匹配模块</li>
<li>会匹配构建中所有使用的相等模块请求</li>
<li>将从图中这个位置的 package.json 提取 requiredVersion</li>
<li>当你有嵌套的 node_modules 时，可以提供和使用多个不同的版本</li>
</ul>
</li>
</ul>
<h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><ul>
<li>每个页面单独构建<ul>
<li>可以单独部署每个页面。</li>
<li>在更新路由或添加新路由时部署主体应用程序。</li>
<li>单页应用的每个页面都是在单独的构建中从容器暴露出来的。</li>
<li>主体应用程序将常用库定义为共享模块，以避免在页面构建中出现重复。</li>
<li>主体应用程序(application shell)也是独立构建，会将所有页面作为远程模块来引用。</li>
</ul>
</li>
<li>将组件库作为容器<ul>
<li>可以单独部署对组件库的更改。</li>
<li>应用程序自动使用组件库的最新版本。</li>
<li>每个应用程序使用来自组件库容器的组件。</li>
<li>许多应用程序共享一个通用的组件库，将其构建成暴露所有组件的容器。</li>
</ul>
</li>
</ul>
<h3 id="动态远程容器"><a href="#动态远程容器" class="headerlink" title="动态远程容器"></a>动态远程容器</h3><ul>
<li>支持 get 和 init 方法。</li>
<li>init 是一个兼容 async 的方法，调用时，只含有一个参数：共享作用域对象(shared scope object)。此对象在远程容器中用作共享作用域，并由 host 提供的模块填充。可以利用它在运行时动态地将远程容器连接到 host 容器。<ul>
<li>容器尝试提供共享模块，但是如果共享模块已经被使用，则会发出警告，并忽略所提供的共享模块。容器仍能将其作为降级模块。</li>
<li>在尝试动态连接远程容器之前，确保已加载容器。</li>
<li>通过动态加载的方式，提供一个共享模块的不同版本，从而实现 A&#x2F;B 测试。</li>
</ul>
</li>
<li>基于Promise的动态Remote<ul>
<li>向 remote 传递一个 promise，其会在运行时被调用。</li>
<li>当使用该 API 时，必须 resolve 一个包含 get&#x2F;init API 的对象。</li>
</ul>
</li>
</ul>
<h3 id="动态Public-Path"><a href="#动态Public-Path" class="headerlink" title="动态Public Path"></a>动态Public Path</h3><ul>
<li>提供一个 host api 来设置 publicPath</li>
<li>场景：<br>在 <a href="https://my-host.com/app/">https://my-host.com/app/</a>* 上有一个 host 应用，并且在 <a href="https://foo-app.com/">https://foo-app.com</a> 上有一个子应用。子应用程序也挂载在 host 域上, 因此， <a href="https://foo-app.com/">https://foo-app.com</a> 可以通过 <a href="https://my-host.com/app/foo-app">https://my-host.com/app/foo-app</a> 访问，并且可以通过代理重定向到 <a href="https://foo-app.com/*%E3%80%82">https://foo-app.com/*。</a></li>
<li>从脚本推断公共路径并在运行时使用 <code>__webpack_public_path__module</code> 变量对其进行设置。</li>
</ul>
<h3 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h3><ul>
<li>Q1：应用程序正急切地执行一个作为全局主机运行的应用程序时提示<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">Error</span>: <span class="title class_">Shared</span> <span class="variable language_">module</span> is not available <span class="keyword">for</span> eager consumption</span><br></pre></td></tr></table></figure>
<ul>
<li>A1：在模块联邦的高级 API 中将依赖设置为即时依赖</li>
</ul>
</li>
<li>Q2: 将 webpack beta.16 升级到 webpack beta.17 中提示<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">Error</span>: <span class="title class_">Module</span> <span class="string">&quot;./Button&quot;</span> does not exist <span class="keyword">in</span> container.</span><br></pre></td></tr></table></figure>
<ul>
<li>A2：在 ModuleFederationPlugin 里，更改 exposes，在Button加上.&#x2F;‘.&#x2F;Button’:’.&#x2F;src&#x2F;Button’</li>
</ul>
</li>
<li>Q3: 丢失了远程容器，或加载了容器提示<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: fn is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>
<ul>
<li>A3：使用前添加容器，或需将主机容器的远程容器文件也添加到 HTML 中</li>
</ul>
</li>
<li>Q4: 来自多个 remote 的模块之间的冲突<ul>
<li>A4：加载多个模块，建议为你的远程构建设置output.uniqueName</li>
</ul>
</li>
</ul>
<h2 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h2><ul>
<li>每当一个文件依赖另一个文件时，webpack 都会将文件视为直接存在依赖关系。</li>
<li>当 webpack 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。 </li>
<li>从入口开始，webpack 会递归的构建一个 依赖关系图，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 bundle通常只有一个可由浏览器加载。</li>
</ul>
<h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><ul>
<li>用法：在 webpack 配置中设置 target 字段</li>
<li>每个target 都包含各种 deployment（部署）&#x2F;environment（环境）特定的附加项，以满足其需求</li>
<li>多target：通过设置两个独立配置，来构建对 library 进行同构</li>
</ul>
<h2 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h2><blockquote>
<p>当 compiler 开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。这个数据集合称为 “manifest”，当完成打包并发送到浏览器时，runtime 会通过 manifest 来解析和加载模块。</p>
</blockquote>
<ul>
<li>runtime，以及伴随的 manifest 数据，主要是指：在浏览器运行过程中，webpack 用来连接模块化应用程序所需的所有代码。</li>
<li>在模块交互时，连接模块所需的加载和解析逻辑。包括：已经加载到浏览器中的连接模块逻辑，以及尚未加载模块的延迟加载逻辑。</li>
</ul>
<h2 id="模块热替换-hot-module-replacement"><a href="#模块热替换-hot-module-replacement" class="headerlink" title="模块热替换(hot module replacement)"></a>模块热替换(hot module replacement)</h2><blockquote>
<p>在应用程序运行过程中，替换、添加或删除 模块，而无需重新加载整个页面。</p>
</blockquote>
<h3 id="提高开发速度的方式："><a href="#提高开发速度的方式：" class="headerlink" title="提高开发速度的方式："></a>提高开发速度的方式：</h3><ul>
<li>保留在完全重新加载页面期间丢失的应用程序状态。</li>
<li>只更新变更内容，以节省宝贵的开发时间。</li>
<li>在源代码中 CSS&#x2F;JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</li>
</ul>
<h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><ul>
<li>在应用程序中<ul>
<li>应用程序要求 HMR runtime 检查更新。</li>
<li>HMR runtime 异步地下载更新，然后通知应用程序。</li>
<li>应用程序要求 HMR runtime 应用更新。</li>
<li>HMR runtime 同步地应用更新。</li>
<li>设置 HMR，使此进程自动触发更新，或者选择要求在用户交互时进行更新</li>
</ul>
</li>
<li>在 compiler 中<ul>
<li>除了普通资源，compiler 需要发出 “update”，将之前的版本更新到新的版本。”update” 由两部分组成：<ol>
<li>更新后的 manifest (JSON)</li>
<li>一个或多个 updated chunk (JavaScript)</li>
</ol>
</li>
</ul>
</li>
<li>在模块中<ul>
<li>HMR 是可选功能，只会影响包含 HMR 代码的模块。</li>
<li>如果一个模块没有 HMR 处理函数，更新就会冒泡。这意味着某个单独处理函数能够更新整个模块树。</li>
<li>如果在模块树的一个单独模块被更新，那么整组依赖模块都会被重新加载。</li>
</ul>
</li>
<li>在runtime中<ul>
<li>对于模块系统运行时，会发出额外代码，来跟踪模块parents和children关系。在管理方面，runtime 支持两个方法 check 和 apply。<ul>
<li>check：<ul>
<li><span class="key_words">『发送一个 HTTP 请求来更新 manifest。』</span>如果请求失败，说明没有可用更新。如果请求成功，会将 updated chunk 列表与当前的 loaded chunk 列表进行比较。每个 loaded chunk 都会下载相应的 updated chunk。当所有更新 chunk 完成下载，runtime 就会切换到 ready 状态。</li>
</ul>
</li>
<li>apply：<ul>
<li><span class="key_words">『将所有 updated module 标记为无效。』</span>对于每个无效 module，都需要在模块中有一个 update handler，或者在此模块的父级模块中有 update handler。否则，会进行无效标记冒泡，并且父级也会被标记为无效。继续每个冒泡，直到到达应用程序入口起点，或者到达带有 update handler 的 module。如果它从入口起点开始冒泡，则此过程失败。所有无效 module 都会被处理和解除加载。然后更新当前 hash，并且调用所有 accept handler。runtime 切换回 idle 状态，一切照常继续。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>在开发环境中<ul>
<li>可以将 HMR 作为 LiveReload 的替代。webpack-dev-server 支持 hot 模式，在试图重新加载整个页面之前，hot 模式会尝试使用 HMR 来更新。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>案例-常用例子</title>
    <url>/2024/10/31/JS/JS-%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="键盘移动-div-实例"><a href="#键盘移动-div-实例" class="headerlink" title="键盘移动 div 实例"></a>键盘移动 div 实例</h3><p><a href="https://gitee.com/ovouu/study-notes/blob/master/javascript/exercise/%E9%94%AE%E7%9B%98%E7%A7%BB%E5%8A%A8div%E7%BB%83%E4%B9%A0.html">键盘移动 div 练习</a></p>
<h2 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h2><p><a href="https://gitee.com/ovouu/study-notes/blob/master/javascript/exercise/%E6%89%8B%E5%8A%A8%E5%88%87%E6%8D%A2%E8%BD%AE%E6%92%AD%E5%9B%BE.html">手动切换轮播</a><br><a href="https://gitee.com/ovouu/study-notes/blob/master/javascript/exercise/%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%8C%89%E9%92%AE%E6%8E%A7%E5%88%B6.html">轮播图按钮控制</a><br><a href="https://gitee.com/ovouu/study-notes/blob/master/javascript/exercise/%E8%87%AA%E5%8A%A8%E8%BD%AE%E6%92%AD%E5%92%8C%E5%AE%9A%E6%97%B6%E8%BD%AE%E6%92%AD.html">自动轮播和定时轮播</a></p>
<h2 id="二级菜单"><a href="#二级菜单" class="headerlink" title="二级菜单"></a>二级菜单</h2><p><a href="https://gitee.com/ovouu/study-notes/blob/master/javascript/exercise/03.%E4%BA%8C%E7%BA%A7%E8%8F%9C%E5%8D%95.html">二级菜单</a></p>
<h2 id="类的操作"><a href="#类的操作" class="headerlink" title="类的操作"></a>类的操作</h2><p><a href="https://gitee.com/ovouu/study-notes/blob/master/javascript/exercise/02.%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C.html">类的操作</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-基础</title>
    <url>/2024/10/31/JS/JS-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>负责页面中的的行为,运行在浏览器端的脚本语言。</p>
</blockquote>
<h2 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h2><ul>
<li>alert(): 该语句会在浏览器窗口中弹出一个警告框<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;要输出的内容&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>document.write(): 该内容将会被写到 body 标签中，并在页面中显示<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;要输出的内容&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>console.log(): 该内容会被写到开发者工具的控制台中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;要输出的内容&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li>单行注释 &#x2F;&#x2F; …</li>
<li>多行注释 &#x2F;_ … _&#x2F;</li>
<li>JS 中严格区分大小写</li>
<li>JS 中每一条语句以分号(;)结尾，只有单行内需要分割语句，这个分号才是必须的</li>
<li>JS 中会忽略多个空格和换行</li>
<li>JS 语句是按照自上向下的顺序一条一条执行的</li>
<li>在 JS 中可以使用{}来为语句进行分组,同一个{}中的语句我们称为是一组语句，这一组语句我们也称为一个代码块</li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>在 JS 中所有的可以由我们自主命名的都可以称为是标识符</li>
<li>例如：变量名、函数名、属性名都属于标识符</li>
<li>JS 底层保存标识符时实际上是采用的 Unicode 编码，所以理论上讲，所有的 utf-8 中含有的内容都可以作为标识符</li>
<li>命名规则：<ol>
<li>标识符中<span class="key_words">『可以』</span>含有字母、数字、_、$</li>
<li>标识符<span class="key_words">『不能』</span>以数字开头</li>
<li>标识符<span class="key_words">『不能』</span>是 ES 中的关键字或保留字</li>
<li>标识符一般都采用<span class="key_words">『驼峰命名法aBbbCcc』</span></li>
</ol>
</li>
</ul>
<h2 id="JS-的编写位置"><a href="#JS-的编写位置" class="headerlink" title="JS 的编写位置"></a>JS 的编写位置</h2><ul>
<li>编写到外部 js 文件中，然后通过 script 标签引入(推荐)<ul>
<li>好处：可以复用多个页面</li>
<li>坏处：不能在编写修改，但是可以使用内部 script 标签<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;文件路径&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>编写到 script 标签内 — 写在页面底部<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li>写在超链接的 href 属性中，这样当点击超链接时，会执行 js 代码<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&#x27;点击弹窗&#x27;);&quot;</span>&gt;</span>弹窗<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写到标签的 onclick 属性中，当我们点击按钮时，js 代码才会执行(不推荐)<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&quot;</span><span class="attr">点击弹窗</span>&quot;)&quot;&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据-内存-变量"><a href="#数据-内存-变量" class="headerlink" title="数据 | 内存 | 变量"></a>数据 | 内存 | 变量</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ul>
<li>存储于内存中代表特定信息的, 本质就是 0101 二进制</li>
<li>具有可读和可传递的基本特性</li>
<li>万物(一切)皆数据, 函数也是数据</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul>
<li>内存条通电后产生的存储空间(临时的)</li>
<li>产生和死亡: 内存条(集成电路板)&#x3D;&#x3D;&gt;通电&#x3D;&#x3D;&gt;产生一定容量的存储空间&#x3D;&#x3D;&gt;存储各种数据&#x3D;&#x3D;&gt;断电&#x3D;&#x3D;&gt;内存全部消失</li>
<li>内存的空间是临时的, 而硬盘的空间是持久的</li>
<li>一块内存包含 2 个数据<ul>
<li>内部存储的数据(一般数据&#x2F;地址数据)</li>
<li>内存地址值数据</li>
</ul>
</li>
<li>内存分类<ul>
<li>栈: 全局变量, 局部变量 (空间较小)</li>
<li>堆: 对象 (空间较大)</li>
</ul>
</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>值可以变化的量, 由变量名与变量值组成</li>
<li>一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容</li>
<li>声明变量<ul>
<li>使用 var、const、 let 关键字声明</li>
<li>var a;</li>
</ul>
</li>
<li>为变量赋值： a &#x3D; xxx;</li>
<li>声明和赋值同时进行：var a &#x3D; xx;</li>
</ul>
<h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><ul>
<li>内存是一个容器, 用来存储程序运行需要操作的数据</li>
<li>变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读&#x2F;写)内存中的数据</li>
</ul>
<h3 id="问题-JS-引擎如何管理内存"><a href="#问题-JS-引擎如何管理内存" class="headerlink" title="问题: JS 引擎如何管理内存?"></a>问题: JS 引擎如何管理内存?</h3><ul>
<li>内存生命周期<ol>
<li>分配需要的内存</li>
<li>使用分配到的内存</li>
<li>不需要时将其释放&#x2F;归还</li>
</ol>
</li>
<li>释放内存<ul>
<li>为执行函数分配的栈空间内存: 函数执行完自动释放</li>
<li>存储对象的堆空间内存: 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存</li>
</ul>
</li>
</ul>
<h2 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var &amp; let &amp; const"></a>var &amp; let &amp; const</h2><blockquote>
<p>es6 之前创建变量只有 var，let&#x2F;const 是 es6 后出来的</p>
</blockquote>
<ul>
<li>var 定义的变量，没有块的概念，可以跨块访问，不能跨函数</li>
<li>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问</li>
<li>const 用来定义常量，使用时必须初始化(即赋值)，只能块作用域里访问，且不能修改</li>
<li>var 定义的变量可以先使用，后声明，存在变量提升，let 必须先声明后使用</li>
<li>var 允许在相同作用域内重复声明同一个变量，let 和 const 不允许</li>
<li>在全局上下文中，基于 var 声明的变量会和全局对象(window)有映射，而 let 不会</li>
<li>会产生暂时性死区：检测一个未被声明的变量类型时，不会报错，会返回 undefined</li>
<li>let、const 会把当前所在的大括号作为一个全新的块级上下文</li>
</ul>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><blockquote>
<p>可以用来保存字面量，而且变量的值是可以任意改变的</p>
</blockquote>
<ul>
<li>JS 中的变量都是保存到栈内存中的，</li>
<li><span class="key_words">『基本数据类型的值』</span>直接在<span class="key_words">『栈内存』</span>中存储，值与值之间是<span class="key_words">『独立』</span>存在，修改一个变量<span class="key_words">『不会影响』</span>其他的变量</li>
<li><span class="key_words">『对象』</span>是保存到<span class="key_words">『堆内存』</span>中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，</li>
<li>而<span class="key_words">『变量保存』</span>的是<span class="key_words">『对象的内存地址』</span>(对象的引用)，如果两个变量<span class="key_words">『保存』</span>的是<span class="key_words">『同一个』</span>对象引用，当一个通过一个变量修改属性时，另一个也<span class="key_words">『会受到影响』</span></li>
<li><span class="key_words">『比较』</span>两个<span class="key_words">『基本数据类型的值』</span>时，<span class="key_words">『就是比较值』</span>。</li>
<li><span class="key_words">『比较』</span>两个<span class="key_words">『引用数据类型』</span>时，它是<span class="key_words">『比较对象的内存地址』</span>，如果两个对象是一样，但是地址不同，它也会返回 false</li>
</ul>
<h3 id="关于引用变量赋值问题"><a href="#关于引用变量赋值问题" class="headerlink" title="关于引用变量赋值问题"></a>关于引用变量赋值问题</h3><ul>
<li>2 个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见</li>
<li>2 个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象</li>
</ul>
<h3 id="问题-在-js-调用函数时传递变量参数时-是值传递还是引用传递"><a href="#问题-在-js-调用函数时传递变量参数时-是值传递还是引用传递" class="headerlink" title="问题: 在 js 调用函数时传递变量参数时, 是值传递还是引用传递"></a>问题: 在 js 调用函数时传递变量参数时, 是值传递还是引用传递</h3><ul>
<li>只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据</li>
<li>如果后一种看成是引用传递, 那就值传递和引用传递都可以有</li>
</ul>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\&quot;：表示 &quot;</span><br><span class="line">\&#x27;：表示 &#x27;</span><br><span class="line">\n：表示换行</span><br><span class="line">\t：制表符</span><br><span class="line">\\：表示\</span><br></pre></td></tr></table></figure>

<h2 id="js-的数据类型"><a href="#js-的数据类型" class="headerlink" title="js 的数据类型"></a>js 的数据类型</h2><ul>
<li>七种基本类型，一种引用类型</li>
<li>Number、Boolean、String、undefined、null、Bigint(es2020 新增，范围比 Number 的大)、Symbol(ES6 新增)</li>
<li>Object对象(包括普通Object、Function、Array、Date、RegExp、Math)</li>
</ul>
<h3 id="Number-数值"><a href="#Number-数值" class="headerlink" title="Number 数值"></a>Number 数值</h3><ul>
<li>特殊的数字<br>Infinity 正无穷<br>-Infinity 负无穷<br>NaN 非法数字（Not A Number）</li>
<li>进制：</li>
<li>如果需要表示<span class="key_words">『16进制』</span>的数字，则需要<span class="key_words">『以0x开头』</span></li>
<li>如果需要表示<span class="key_words">『8进制』</span>的数字，则需要<span class="key_words">『以0开头』</span></li>
<li>如果要要表示<span class="key_words">『2进制』</span>的数字，则需要<span class="key_words">『以0b开头』</span>,但是&#96;不是所有的浏览器都支持』</span><ul>
<li>示例：<span class="desc">像”070”这种字符串，有些浏览器会当成 8 进制解析，有些会当成 10 进制解析</span></li>
</ul>
</li>
<li>可以在parseInt()中传递一个<span class="key_words">『第二个参数』</span>，来<span class="key_words">『指定数字的进制』</span><ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">parseInt</span>(a,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h3><ul>
<li>undefined 代表没有赋值</li>
<li>null 代表赋值了, 只是值为 null</li>
<li>由于 undefined 衍生自 null，所以 null &#x3D;&#x3D; undefined 会返回 true。</li>
<li>但是 null &#x3D;&#x3D;&#x3D; undefined 会返回 false。</li>
<li>null 的使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span> <span class="comment">// a 将指向一个对象, 但对象此时还没有确定</span></span><br><span class="line">a = <span class="literal">null</span> <span class="comment">// 让 a 指向不再使用的对象成为垃圾对象(垃圾回收机制 GC)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><ul>
<li><span class="key_words">『与任何值都不相等，包括自身』</span></li>
<li>可以通过 isNaN()函数来判断一个值是否是 NaN<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNaN</span>(<span class="params">x</span>)&#123; </span><br><span class="line">  <span class="keyword">return</span> x! = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>机制：会先判断参数是不是 Number 类型，不是尝试转为 Number，之后再去判断是不是 NaN</li>
</ul>
<h3 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h3><ul>
<li><span class="key_words">『\u四位编码』</span>：在字符串中使用的 Unicode 编码</li>
<li><span class="key_words">『&amp;#编码』</span>：<ul>
<li>在网页中使用的 Unicode 编码，这里的编码需要的是 10 进制</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 200px;&quot;</span>&gt;</span><span class="symbol">&amp;#9760;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="typeof-—-类型检测方案"><a href="#typeof-—-类型检测方案" class="headerlink" title="typeof — 类型检测方案"></a>typeof — 类型检测方案</h2><blockquote>
<p>区分数据类型，并返回 number、 string、 boolean、undefined、object、function、symbol</p>
</blockquote>
<ul>
<li>对于<span class="key_words">『基本数据』</span>类型，<span class="key_words">『除null都可以正确判断』</span></li>
<li>对于<span class="key_words">『引用类型，除function』</span>外，都会<span class="key_words">『返回object』</span></li>
<li>typeof 返回值是 string，即<span class="key_words">『双层typeof』</span>返回的类型是 string</li>
<li>typeof<span class="key_words">『未定义的变量』</span>，返回”undefined”</li>
<li>typeof(null) —&gt; “object”</li>
<li>typeof(NaN) —&gt; “number”</li>
<li>typeof(Infinity) —&gt; “number”</li>
</ul>
<h2 id="instanceof-—-类型检测方案"><a href="#instanceof-—-类型检测方案" class="headerlink" title="instanceof — 类型检测方案"></a>instanceof — 类型检测方案</h2><blockquote>
<p>判断对象的原型链上是否存在构造函数的原型。只能判断引用类型。检查一个对象是否是一个类的实例</p>
</blockquote>
<ul>
<li>语法：A instanceof B,常用来判断 A 是否为 B 的实例，如果是，则返回 true，否则返回 false,</li>
<li>如果 B 函数的显式原型对象在 A 对象的原型链上, 返回 true, 否则返回 false</li>
<li>arr instanceof Array ，可以<span class="key_words">『判断数组类型，但不推荐』</span>，因为如果网页存在多个 iframe，便会存在多个 Array 构造函数，此时判断会存在问题</li>
<li>所有的对象都是 Object 的后代，所以任何对象和 Object 左 instanceof 检查时都会返回 true</li>
<li>Number、Boolean、String 基本类型不能判断</li>
</ul>
<h2 id="Object-prototype-toString-call-value-—-类型检测方案"><a href="#Object-prototype-toString-call-value-—-类型检测方案" class="headerlink" title="Object.prototype.toString.call([value]) — 类型检测方案"></a>Object.prototype.toString.call([value]) — 类型检测方案</h2><blockquote>
<p>可以精准判断数据类型，与 Array.isArray 结合使用可以判断数组和对象，此方式兼容性最好</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="property">isArray</span>) &#123;</span><br><span class="line">	<span class="title class_">Array</span>.<span class="property">isArray</span> = <span class="keyword">function</span> (<span class="params">o</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">			<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o) === <span class="string">&#x27;[object Array]&#x27;</span></span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><blockquote>
<p>在 js 中，只有三种类型转换</p>
</blockquote>
<h3 id="转换为-Number-类型：Number-parseFloat-parseInt"><a href="#转换为-Number-类型：Number-parseFloat-parseInt" class="headerlink" title="转换为 Number 类型：Number()&#x2F;parseFloat()&#x2F;parseInt()"></a>转换为 Number 类型：Number()&#x2F;parseFloat()&#x2F;parseInt()</h3><ul>
<li>显式&#x2F;强制：直接使用 Number()&#x2F;parseFloat()&#x2F;parseInt()</li>
<li>隐式：比较操作(&lt;,&gt;,&lt;&#x3D;,&gt;&#x3D;)、按位操作(|,&amp;,^,~)、算术操作(+,-,*,&#x2F;,%)、一元+-操作</li>
<li>Number 类型使用 toString(整数)可以将数字转为指定的进制，默认 10 进制</li>
<li>parseFloat(): 把一个字符串转换为一个浮点数</li>
<li>parseInt(): 把一个字符串转换为一个整数，将一个字符串中的有效的整数内容取出来<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>].<span class="title function_">map</span>(<span class="built_in">parseInt</span>)相当于执行了以下三次过程：</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>]): radix 为 <span class="number">0</span> 时，默认取 <span class="number">10</span>，最后返回 <span class="number">1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;2&#x27;</span>, <span class="number">1</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>]): radix 取值为 <span class="number">2</span>~<span class="number">36</span>，返回 <span class="title class_">NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3&#x27;</span>, <span class="number">2</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>]): radix 取值为 <span class="number">2</span>，二进制只包括 <span class="number">0</span>，<span class="number">1</span>，返回 <span class="title class_">NaN</span></span><br></pre></td></tr></table></figure></li>
<li><span class="key_words">『对非 String使用 parseInt()或 parseFloat()，会先将其转换为 String 然后在操作』</span></li>
<li>字符串 –&gt; 数字<table>
<thead>
<tr>
<th>类型</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>null</td>
<td>+0</td>
</tr>
<tr>
<td>Boolean</td>
<td>true：1，false：+0</td>
</tr>
<tr>
<td>Number</td>
<td>返回对应的值</td>
</tr>
<tr>
<td>String</td>
<td>空字符串返回 0，出现任何一个非有效数字返回 NaN，其他的直接转换为对应的值</td>
</tr>
<tr>
<td>Object</td>
<td>先执行 ToPrimitive 方法，再执行 Number 类型转换</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="转换为-String-类型：String-toString"><a href="#转换为-String-类型：String-toString" class="headerlink" title="转换为 String 类型：String()&#x2F;toString()"></a>转换为 String 类型：String()&#x2F;toString()</h3><ul>
<li>显式&#x2F;强制：直接使用 String()&#x2F;toString()</li>
<li>隐式：+ 运算符有一侧操作数为 string 类型</li>
<li>null 或 undefined 调用 String()方法，返回字符串格式是它们本身</li>
<li><span class="key_words">『null 或 undefined 使用 toString()会报错』</span></li>
</ul>
<h3 id="转化为-Boolean-类型：Boolean"><a href="#转化为-Boolean-类型：Boolean" class="headerlink" title="转化为 Boolean 类型：Boolean()"></a>转化为 Boolean 类型：Boolean()</h3><ul>
<li>显式&#x2F;强制：直接使用 Boolean()</li>
<li>隐式：通过 !! 或 !</li>
<li><span class="key_words">『除 0,-0,null,NaN,undefined,或空字符串(“”)为 false 外』</span>，其余全为 true</li>
</ul>
<h3 id="隐式转换规则"><a href="#隐式转换规则" class="headerlink" title="&#x3D;&#x3D;隐式转换规则"></a>&#x3D;&#x3D;隐式转换规则</h3><ul>
<li>类型相同的比较<ul>
<li>类型是 undefined 或 null， 返回 true<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>如果一个是+0，另一个是-0，返回 true<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> == -<span class="number">0</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li>如果类型是对象，二者引用同一个对象，返回 true，否则返回 false<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#125; == &#123;&#125; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>null 和 undefined 比较，仅当它们之间比较返回 true<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>NaN 比较，NaN 与任何之后比较都返回 false，包括自己<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">NaN</span> == <span class="title class_">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>字符串与数字比较，先将字符串转换为数字在比较</li>
<li>布尔值与非布尔值比较：先将布尔值转换为数字在比较</li>
<li>对象与原始类型比较，将对象通过<a href="#ref1">ToPrimitive</a>转换为原始类型对应的类型在比较<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#125; == <span class="number">1</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>! 的优先级高，如遇到[] &#x3D;&#x3D; ![], 先进行非运算, <ul>
<li>又因为任何对象转换成布尔值都得到true，先转布尔在非运算</li>
<li>即 ![] &#x3D;&#x3D; false, 根据&#x3D;&#x3D;隐式转换规则，对象与原始类型转换，两边先转为数字在比较，</li>
<li>即 ![] &#x3D;&#x3D;&gt; false &#x3D;&#x3D;&gt; 0</li>
<li>[] 经过 ToPrimitive 方法 转换为’ ‘,</li>
<li>所以[] &#x3D;&#x3D; ![]  变成  ‘ ‘ &#x3D;&#x3D; 0</li>
<li>然后根据字符串与数字比较，先将字符串转为数字在比较,’’ 的布尔值为 0</li>
<li>即 0 &#x3D;&#x3D; 0 ，为 true</li>
</ul>
</li>
<li>其他的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#125; == ！&#123;&#125; <span class="comment">// !&#123;&#125;-&gt;false-&gt;0  &#123;&#125;-&gt;&quot;[object Object]&quot;-&gt;NaN</span></span><br><span class="line">&#123;&#125; == <span class="literal">true</span></span><br><span class="line">[] == [] <span class="comment">// false 比较引用地址</span></span><br><span class="line">&#123;&#125; == [] <span class="comment">// 报错</span></span><br><span class="line">&#123;&#125; + &#123;&#125; <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br><span class="line">&#123;&#125; + [] <span class="comment">// 0 ，&#123;&#125;被当做一个块，并非&#123;&#125;转NaN，相当于执行 (&#123;&#125;,+[])，返回值为小括号最后面的表达式的返回值</span></span><br><span class="line">&#123;<span class="attr">q</span>:<span class="number">1</span>&#125; + [] <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">q</span>:<span class="number">1</span>&#125;;a + [] <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="toString-和-valueOf-方法有什么区别"><a href="#toString-和-valueOf-方法有什么区别" class="headerlink" title="toString 和 valueOf 方法有什么区别"></a>toString 和 valueOf 方法有什么区别</h2><blockquote>
<p>都属于 Object 对象，是为了解决 JavaScript 值运算与显示的问题。</p>
</blockquote>
<ul>
<li>js 对象的键必须是字符串</li>
<li>toString(): 返回当前对象的字符串形式</li>
<li>valueOf(): 返回该对象的原始值<table>
<thead>
<tr>
<th>类型</th>
<th>valueOf</th>
<th>toString</th>
</tr>
</thead>
<tbody><tr>
<td>Array[1,2,3]</td>
<td>数组本身[1,2,3]</td>
<td>“1,2,3”</td>
</tr>
<tr>
<td>Object</td>
<td>对象本身</td>
<td>[object Object]</td>
</tr>
<tr>
<td>Boolean 类型</td>
<td>Boolean 值</td>
<td>“true” 或”false”</td>
</tr>
<tr>
<td>Function</td>
<td>函数本身</td>
<td>function fnName(){code}</td>
</tr>
<tr>
<td>Number</td>
<td>数值</td>
<td>数值的字符串形式</td>
</tr>
<tr>
<td>Date</td>
<td>毫米格式时间戳</td>
<td>GMT 格式时间字符串</td>
</tr>
</tbody></table>
</li>
<li>隐式转换会自动调用 toString 和 valueOf<ul>
<li>强制转化为字符串类型时，优先调用 toString</li>
<li>强制转化为数值类型时，优先调用 valueOf</li>
<li>使用运算符操作符情况下，valueOf 优先级高于 toString</li>
<li>对象类型转换为原始值回调用内置的[ToPrimitive]函数<ul>
<li><span id="ref1">ToPrimitive 方法</span>接受两个参数，输入的值 value，期望转换的类型 Type<ul>
<li>如果未传入 PreferredType 参数，让 hint 等于’default’,后面会将 hint 修改为”number”</li>
<li>如果 value 是 基本类型，直接返回对应的类型的值</li>
<li>否则，调用 valueOf 方法，如果得到原始值，则返回</li>
<li>否则，调用 toString 方法，如果得到原始值，则返回</li>
<li>否则，报错</li>
</ul>
</li>
<li>OrdinaryToPrimitive(input,hint)<ul>
<li>如果 hint 是 ‘string’，那么就将 methodNames 设置为 toString、valueOf</li>
<li>如果 hint 是 ‘number’，那么就将 methodNames 设置为 valueOf、toString</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>设变量a&#x3D;{x：100}，obj&#x3D;{}，然后设obj[a] &#x3D; 100 ,则此时obj[a]为多少？<ul>
<li>解：由于js对象的键必须为字符串，所以先将变量a转换为字符串，即a &#x3D; “{x:100}”</li>
<li>然后因为强制转化为字符串类型时，优先调用toString，通过上方表格可知，obj[a]为[object Object]<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- &#123;&#125; + <span class="number">1</span> <span class="comment">// js引擎回解析成1个代码块和1个1，最终结果为1</span></span><br><span class="line">- <span class="number">1</span> + &#123;&#125;<span class="comment">// 先将&#123;&#125;调用ToPrimitive转为&#x27;[object Object]&#x27;，然后跟1拼串，最终结果1[object Object]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li>!!：将变量<span class="key_words">『转为布尔值』</span></li>
<li>!：取反，对非 boolean 类型的元素，则会将其<span class="key_words">『转boolean』</span>类型<span class="key_words">『再取反』</span></li>
<li>&amp;&amp;：只有两个值都为 true 时，才会返回 true，如果第一个值为 false，则不会看第二个值<ul>
<li>对于非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，并且返回原值</li>
<li>如果<span class="key_words">『第一个值为true』</span>，则必然<span class="key_words">『返回第二个值』</span></li>
<li>如果<span class="key_words">『第一个值为false』</span>，则直接<span class="key_words">『返回第一个值』</span></li>
<li>如果两个值<span class="key_words">『都为true』</span>，则<span class="key_words">『返回后边的』</span></li>
</ul>
</li>
<li>||：两个值中只要有一个 true，就返回 true，如果第一个值为 true，则不会检查第二个值<ul>
<li>对于非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，并且返回原值</li>
<li>如果<span class="key_words">『第一个值为true』</span>，则直接<span class="key_words">『返回第一个值』</span></li>
<li>如果<span class="key_words">『第一个值为false』</span>，则<span class="key_words">『返回第二个值』</span></li>
<li>如果<span class="key_words">『两个值中有false』</span>，则<span class="key_words">『返回靠前的false』</span></li>
</ul>
</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul>
<li><span class="key_words">『&#x3D;』</span>：赋值</li>
<li><span class="key_words">『+&#x3D;』</span>：a +&#x3D; 5 相当于 a &#x3D; a+5</li>
<li><span class="key_words">『-&#x3D;』</span>：a -&#x3D; 5 相当于 a &#x3D; a-5</li>
<li><span class="key_words">『*&#x3D;』</span>：a <em>&#x3D; 5 相当于 a &#x3D; a</em>5</li>
<li><span class="key_words">『&#x2F;&#x3D;』</span>：a &#x2F;&#x3D; 5 相当于 a &#x3D; a&#x2F;5</li>
<li><span class="key_words">『%&#x3D;』</span>：a %&#x3D; 5 相当于 a &#x3D; a%5</li>
<li><span class="key_words">『<code>n++，n--</code>』</span>：先自增，自减，并且赋值时，把自增、自减前的值的赋值,即得到的结果是<span class="key_words">『变量的原值』</span></li>
<li><span class="key_words">『<code>++n，--n</code>』</span>：先自增，自减，并且把变化后的值赋值给变量,即得到的结果是<span class="key_words">『变量的新值』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> n2 = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> n = n1++ <span class="comment">//n1 = 11  n1++ = 10 n = 10</span></span><br><span class="line"><span class="keyword">var</span> m = ++n2 <span class="comment">//n2 = 11  ++n1 = 11 n = 11</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><ul>
<li><span class="key_words">『&#x3D;&#x3D;』</span>：等于，值相等返回 true，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型，然后在比较</li>
<li><span class="key_words">『!&#x3D;』</span>：不等于，两个值是否不相等，不相等返回 true，也会对变量进行自动的类型转换，然后在比较</li>
<li><span class="key_words">『&#x3D;&#x3D;&#x3D;』</span>：绝对等于，类型也相等,不会做自动的类型转换</li>
<li><span class="key_words">『!&#x3D;&#x3D;』</span>：不全等，不会做自动的类型转换，如果两个值的类型不同，直接返回 true</li>
</ul>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><ul>
<li><span class="key_words">『<code>+、-、*、/</code>』</span>：加减乘除，任何值做-、&#x2F;、*运算时都会自动转换为 Number</li>
<li><span class="key_words">『%』</span>：算数运算符，取模运算（取余数）</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul>
<li><span class="key_words">『&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;』</span><ul>
<li>对于<span class="key_words">『非数值』</span>进行比较时，会将其<span class="key_words">『转为数字在比较』</span></li>
<li>如果符号两侧的值<span class="key_words">『都是字符串』</span>时，会分别<span class="key_words">『一位一位比较』</span>字符串中字符的<span class="key_words">『Unicode编码』</span></li>
<li>注：在比较两个字符串型的数字时，一定要转型</li>
</ul>
</li>
</ul>
<h3 id="三元运算符-条件运算符"><a href="#三元运算符-条件运算符" class="headerlink" title="三元运算符(条件运算符)"></a>三元运算符(条件运算符)</h3><ul>
<li>语法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件表达式 ? 语句1 : 语句2</span><br></pre></td></tr></table></figure></li>
<li>执行的流程：<ul>
<li>条件运算符在执行时，首先对条件表达式进行求值，</li>
<li>为 true，则执行语句 1，并返回执行结果，为 false，则执行语句 2，并返回执行结果</li>
<li>如果条件的表达式的求值结果是一个非布尔值，会将其转换为布尔值然后在运算</li>
</ul>
</li>
</ul>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><ul>
<li><span class="key_words">『+、-』</span>：<span class="key_words">『正负号，只需要一个操作数』</span><ul>
<li>对于非 Number 类型的值，会先转换为 Number，然后在运算</li>
<li><span class="key_words">『+ 变量转为Number』</span>类型</li>
<li><span class="key_words">『任何值和字符串相加都会转换为字符串』</span>，叫做拼串操作</li>
</ul>
</li>
</ul>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h3><ul>
<li>语句一:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">  为 <span class="literal">true</span> 语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>语句二<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">  为 <span class="literal">true</span> 语句...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  为 <span class="literal">false</span> 语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>语句三<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">  语句...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">  语句...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="条件分支语句-switch"><a href="#条件分支语句-switch" class="headerlink" title="条件分支语句 switch"></a>条件分支语句 switch</h3><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(条件表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 表达式：</span><br><span class="line">		语句...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>：</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>执行流程<ul>
<li>依次将 case 后的表达式的值和 switch 后的条件表达式的值进行全等比较，如果为 true，则从当前 case 处开始执行代码。</li>
<li>为 false，则继续向下比较，知道所有结果都为 false，只执行 default 后的语句</li>
</ul>
</li>
</ul>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><ul>
<li><p>for循环</p>
<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(① 初始化表达式;② 条件表达式;④ 更新表达式)&#123; </span><br><span class="line">  语句... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>执行流程：<ul>
<li>执行初始化表达式，初始化变量（初始化表达式只会执行一次）</li>
<li>执行条件表达式，判断是否执行循环。为 true，则执行循环，为 false，终止循环</li>
<li>执行更新表达式，更新表达式执行完毕继续重复上一步</li>
</ul>
</li>
<li>注：for 循环中的三个部分都可以省略，也可以写在外部，for(;;){}死循环</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">打印<span class="number">2</span>-<span class="number">1000</span>质数</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span> ; i&lt;=<span class="number">1000</span>; i++)&#123;</span><br><span class="line">	<span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">2</span> ; j&lt;=<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(i) ; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%j == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//如果进入判断则证明i不是质数,修改flag值为false</span></span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是质数，则打印i的值</span></span><br><span class="line">	<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">		<span class="variable language_">document</span>.<span class="title function_">write</span>(i+<span class="string">&#x27;  &#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">打印九九乘法表</span><br><span class="line"><span class="comment">//创建外层循环，用来控制乘法表的高度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span> ; i&lt;=<span class="number">9</span> ; i++ )&#123;</span><br><span class="line">	<span class="comment">// 创建一个内层循环来控制图形的宽度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span> ; j&lt;=i ; j++)&#123;</span><br><span class="line">		<span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;span&gt;&quot;</span>+j+<span class="string">&quot;*&quot;</span>+i+<span class="string">&quot;=&quot;</span>+i*j+<span class="string">&quot;&lt;/span&gt;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;br /&gt;&quot;</span>); <span class="comment">//输出一个换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>while循环</p>
<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)&#123; </span><br><span class="line">  语句... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>执行流程<ul>
<li>先对条件表达式进行求值判断，</li>
<li>如果值为 true，则执行循环体，</li>
<li>循环体执行完毕以后，继续对表达式进行判断，以此类推</li>
<li>如果值为 false，则终止循环</li>
</ul>
</li>
</ul>
</li>
<li><p>do…while循环</p>
<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123; </span><br><span class="line">  语句... </span><br><span class="line">&#125; <span class="keyword">while</span>(条件表达式)</span><br></pre></td></tr></table></figure></li>
<li>执行流程：<ul>
<li>先执行循环体，</li>
<li>循环体执行完毕以后，在对 while 后的条件表达式进行判断，</li>
<li>如果结果为 true，则继续执行循环体，执行完毕继续判断以此类推, 如果结果为 false，则终止循环</li>
</ul>
</li>
</ul>
</li>
<li><p>do…while循环和while循环区别：</p>
<ul>
<li>while 是先判断后执行，</li>
<li>而 do…while 会先执行后判断，</li>
<li>do…while 可以保证循环体至少执行一次，而 while 不能</li>
</ul>
</li>
<li><p>将条件表达式写死为 true 的循环，叫做死循环,可以使用 break，来终止循环</p>
</li>
</ul>
<h2 id="函数-function"><a href="#函数-function" class="headerlink" title="函数 function"></a>函数 function</h2><blockquote>
<p>函数也是一个对象，函数中可以封装一些功能，在需要时可以执行这些功能</p>
</blockquote>
<h3 id="创建一个函数对象"><a href="#创建一个函数对象" class="headerlink" title="创建一个函数对象"></a>创建一个函数对象</h3><ul>
<li>方法一：使用构造函数(少用)<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="keyword">new</span> <span class="title class_">Function</span>(语句...);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>方法二：使用函数声明<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名([形参 <span class="number">1</span>,形参 <span class="number">2.</span>..形参 N])&#123;</span><br><span class="line">   语句... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>方法三：使用函数表达式<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 函数名 = <span class="keyword">function</span>(<span class="params">[形参 <span class="number">1</span>,形参 <span class="number">2.</span>..形参 N]</span>)&#123; </span><br><span class="line">  语句... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="调用方法："><a href="#调用方法：" class="headerlink" title="调用方法："></a>调用方法：</h3><ul>
<li>函数对象([实参 1，实参 2])</li>
<li>new 函数对象()</li>
<li>对象.函数对象()</li>
<li>函数对象.call&#x2F;apply(obj)</li>
</ul>
<h3 id="形参与实参："><a href="#形参与实参：" class="headerlink" title="形参与实参："></a>形参与实参：</h3><ul>
<li>实参：<ul>
<li>在调用函数时，可以在()中指定，实参将会赋值给函数中对应的形参</li>
<li>调用函数时解析器不会检查实参的类型和数量，可以传递任意数据类型的值</li>
<li>多余实参不会被赋值，如果实参的数量少于形参的数量，则没有对应实参的形参将是 undefined</li>
</ul>
</li>
<li>形参：<ul>
<li>定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开</li>
<li>定义形参就相当于在函数内声明了对应的变量但是并不赋值，形参会在调用时才赋值。</li>
</ul>
</li>
</ul>
<h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><ul>
<li>创建一个构造函数：与普通函数一样，但首字母要大写</li>
<li>调用方式：使用 new 关键字来调用</li>
<li>构造函数是专门用来创建对象的函数</li>
<li>一个构造函数我们也可以称为一个类</li>
<li>通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例</li>
<li>通过同一个构造函数创建的对象，我们称为一类对象</li>
<li>构造函数就是一个普通的函数，只是他的调用方式不同，<ul>
<li>如果直接调用，它就是一个普通函数</li>
<li>如果使用 new 来调用，则它就是一个构造函数</li>
</ul>
</li>
<li>执行流程：<ol>
<li>立刻创建一个新的对象</li>
<li>将新建的对象设置为函数中 this,在构造函数中可以使用 this 来引用新建的对象</li>
<li>逐行执行函数中的代码</li>
<li>将新建的对象作为返回值返回</li>
</ol>
</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>定义：变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成。</li>
</ul>
<h4 id="全局作用域："><a href="#全局作用域：" class="headerlink" title="全局作用域："></a>全局作用域：</h4><ul>
<li>直接编写在 script 标签中的 JS 代码，都在全局作用域</li>
<li>全局作用域在页面打开时创建，在页面关闭时销毁</li>
<li>在全局作用域中有一个全局对象 window，</li>
<li>创建的变量都会作为 window 对象的属性保存</li>
<li>创建的函数都会作为 window 对象的方法保存</li>
<li>全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到</li>
<li>在函数作用域中也可以访问到全局作用域的变量。</li>
<li>尽量不要在全局中创建变量</li>
</ul>
<h4 id="函数作用域：函数执行时创建的作用域"><a href="#函数作用域：函数执行时创建的作用域" class="headerlink" title="函数作用域：函数执行时创建的作用域"></a>函数作用域：函数执行时创建的作用域</h4><ul>
<li>函数作用域在函数执行时创建，在函数执行结束时销毁。</li>
<li>每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的</li>
<li>在函数作用域中可以访问到全局作用域的变量，反过来不行</li>
<li>在函数中要访问全局变量可以使用 window 对象</li>
<li>作用：隔离变量，不同作用域同名变量不会有冲突。</li>
</ul>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul>
<li>定义：调用某个函数或属性时，先在当前作用域寻找，如果找不到的情况下去父级寻找，如果父级找不到继续向上级寻找，直到找到全局作用域为止，如果全局作用域中依然没有找到，则会报错 ReferenceError，这就是链式查找的过程</li>
</ul>
<h2 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前"></a>声明提前</h2><h3 id="变量的声明提前"><a href="#变量的声明提前" class="headerlink" title="变量的声明提前"></a>变量的声明提前</h3><ul>
<li>使用 var 关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值）</li>
<li>但是如果声明变量时不使用 var 关键字，则变量不会被声明提前</li>
<li>在函数作用域中，也具有以上特性</li>
<li>在函数作用域中，不使用关键字声明的变量都会成为全局变量</li>
</ul>
<h3 id="函数的声明提前"><a href="#函数的声明提前" class="headerlink" title="函数的声明提前"></a>函数的声明提前</h3><ul>
<li>在全局作用域中， 使用<span class="key_words">『函数声明形式』</span>创建的函数 function 函数(){}，会在所有的代码执行之前就被创建，所以<span class="key_words">『可以在函数声明前来调用函数』</span></li>
<li>在全局作用域中，使用<span class="key_words">『函数表达式』</span>创建的函数 var fun &#x3D; function(){}，<span class="key_words">『不会』</span>被声明提前，所以<span class="key_words">『不能』</span>在声明前调用</li>
<li>在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。</li>
</ul>
<h3 id="函数的方法"><a href="#函数的方法" class="headerlink" title="函数的方法"></a>函数的方法</h3><ul>
<li>call() 和 apply()<ul>
<li>这两个方法都是函数对象的方法，需要通过函数对象来调用</li>
<li>通过两个方法可以直接调用函数，并且可以通过<span class="key_words">『第一个实参(对象)来指定函数执行中 this』</span></li>
<li>call()方法可以将实参在对象之后<span class="key_words">『依次传递』</span></li>
<li>apply()方法需要将实参<span class="key_words">『封装』</span>到一个<span class="key_words">『数组』</span>中<span class="key_words">『统一传递』</span></li>
</ul>
</li>
<li>arguments(封装实参的对象)<ul>
<li>arguments 和 this 类似，都是函数中的隐含的参数</li>
<li>arguments 是一个类数组元素，它可以通过索引来操作数据，获取长度</li>
<li>在调用函数时，我们所传递的实参都会在 arguments 中保存</li>
<li>arguments.length 可以用来获取实参的长度</li>
<li>arguments 中有一个属性 callee 表示当前执行的函数对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a,b</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span> == fun) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>即使不定义形参，也可以通过 arguments 来使用实参<ul>
<li>arguments[0] 表示第一个实参</li>
<li>arguments[1] 表示第二个实参</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="this-函数的上下文对象"><a href="#this-函数的上下文对象" class="headerlink" title="this(函数的上下文对象)"></a>this(函数的上下文对象)</h3><ul>
<li>解析器在每次调用函数都会向函数内部传递进一个隐含的参数,这个隐含的参数就是 this</li>
<li>this 指向的是一个对象，这个对象我们称为函数执行的上下文对象</li>
<li>使用 this 来引用上下文对象，根据函数的调用形式不同，this 的值也不同</li>
<li>当<span class="key_words">『以函数的形式调用时，this是window』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">xxx</span>() <span class="comment">// this 指向 window</span></span><br></pre></td></tr></table></figure></li>
<li>当<span class="key_words">『以方法的形式调用时，谁调用方法this就是谁』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.<span class="title function_">xxx</span>() <span class="comment">// this 指向 obj</span></span><br></pre></td></tr></table></figure></li>
<li>当<span class="key_words">『以构造函数的形式调用时，this就是新创建的那个对象』</span></li>
<li>通过 call&#x2F;apply 指定谁调用: xxx.call(obj)，指向 obj</li>
<li>在全局作用域中 this 代表 window</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">	<span class="comment">// 定义了形参，创建构造函数</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;孙悟空&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>) <span class="comment">// this执行per，并传了实参</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（IIFE）立即执行函数："><a href="#（IIFE）立即执行函数：" class="headerlink" title="（IIFE）立即执行函数："></a>（IIFE）立即执行函数：</h3><ul>
<li>全称: Immediately-Invoked Function Expression 立即调用函数表达式</li>
<li>别名: 匿名函数自调用</li>
<li>定义：函数定义完，立即被调用，往往只会执行一次</li>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="title function_">alert</span>(<span class="string">&quot;我是一个匿名函数~~~&quot;</span>); &#125;)();</span><br></pre></td></tr></table></figure></li>
<li>作用<ul>
<li>隐藏内部实现</li>
<li>不污染外部命名空间</li>
</ul>
</li>
</ul>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><ul>
<li>定义：定义了该函数，没有直接执行，需要按下或者在一定时候才会执行的函数</li>
<li>常见的回调函数<ul>
<li>DOM 事件函数</li>
<li>定时器函数</li>
<li>ajax 回调函数</li>
<li>生命周期回调函数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DOM事件函数</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">innerHTML</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定时器函数</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">// alert(&#x27;到点啦!&#x27;)</span></span><br><span class="line">&#125;, <span class="number">20000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象的分类："><a href="#对象的分类：" class="headerlink" title="对象的分类："></a>对象的分类：</h3><ul>
<li>内建对象: 由 ES 标准中定义的对象，在任何的 ES 的实现中都可以使用<ul>
<li>比如：Math String Number Boolean Function Object….</li>
</ul>
</li>
<li>宿主对象: 由 JS 的运行环境提供的对象，目前来讲主要指由浏览器提供的对象<ul>
<li>比如 BOM DOM</li>
</ul>
</li>
<li>自定义对象: 由开发人员自己创建的对象</li>
</ul>
<h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><ul>
<li>定义：检查一个对象中是否含有指定的属性，有则返回 true，没有则返回 false</li>
<li>语法：”属性名” in 对象</li>
</ul>
<h3 id="使用-new-关键字创建一个对象"><a href="#使用-new-关键字创建一个对象" class="headerlink" title="使用 new 关键字创建一个对象"></a>使用 new 关键字创建一个对象</h3><ul>
<li>语法：使用 new 关键字调用的函数，是构造函数 constructor，<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure></li>
<li>向对象中<span class="key_words">『添加』</span>属性：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.属性名 = 属性值(可以是任意类型，也可以是个函数)</span><br></pre></td></tr></table></figure>
<ul>
<li>特殊属性名的添加方式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象[<span class="string">&quot;属性名&quot;</span>] = 属性值</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><span class="key_words">『读取』</span>对象中的属性：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.属性名</span><br></pre></td></tr></table></figure>
<ul>
<li>如果读取对象中没有的属性，返回 undefined</li>
<li>特殊属性名的读取方式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象[<span class="string">&quot;属性名&quot;</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><span class="key_words">『修改』</span>对象的属性值：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.属性名 = 新值</span><br></pre></td></tr></table></figure></li>
<li><span class="key_words">『删除』</span>对象的属性：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> 对象.属性名</span><br></pre></td></tr></table></figure></li>
<li>调用方法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.函数对象(); <span class="comment">// 如果一个函数作为一个对象的属性值保存，那么我们称这个函数是这个对象的方法</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用对象字面量来创建一个对象"><a href="#使用对象字面量来创建一个对象" class="headerlink" title="使用对象字面量来创建一个对象"></a>使用对象字面量来创建一个对象</h3><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 对象 = &#123;属性名:属性值,属性名:属性值....&#125;; </span><br><span class="line"><span class="comment">// 可以在创建对象时，直接指定对象中的属性，也可以为空</span></span><br></pre></td></tr></table></figure></li>
<li>属性名可以加引号也可以不加，如果要使用一些特殊的名字，则必须加引号</li>
<li>属性名和属性值是一组一组的名值对结构，名和值之间使用:连接，多个名值对之间使用,隔开</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;孙悟空&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">	<span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">	<span class="attr">address</span>: <span class="string">&#x27;花果山&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用工厂方法传建对象"><a href="#使用工厂方法传建对象" class="headerlink" title="使用工厂方法传建对象"></a>使用工厂方法传建对象</h3><ul>
<li>优点：可以批量创建</li>
<li>缺点：创建的对象都是 Object 这个类型，无法区分出多种不同类型的对象</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">	<span class="comment">//创建一个新的对象</span></span><br><span class="line">	<span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">	<span class="comment">//向对象中添加属性</span></span><br><span class="line">	obj.<span class="property">name</span> = name</span><br><span class="line">	obj.<span class="property">age</span> = age</span><br><span class="line">	obj.<span class="property">gender</span> = gender</span><br><span class="line">	obj.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将新的对象返回</span></span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title function_">createPerson</span>(<span class="string">&#x27;猪八戒&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="title function_">createPerson</span>(<span class="string">&#x27;蜘蛛精&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;女&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="枚举对象中的属性使用-for-…-in-语句"><a href="#枚举对象中的属性使用-for-…-in-语句" class="headerlink" title="枚举对象中的属性使用 for … in 语句"></a>枚举对象中的属性使用 for … in 语句</h3><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> 变量 <span class="keyword">in</span> 对象)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>for…in 语句 对象中有几个属性，循环体就会执行几次</li>
<li>每次执行时，会将对象中的一个属性的名字赋值给变量</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">in</span> obj) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;属性名:&#x27;</span> + n)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;属性值:&#x27;</span> + obj[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="break-continue-return"><a href="#break-continue-return" class="headerlink" title="break | continue | return"></a>break | continue | return</h2><h3 id="break-关键字-—-会立即终止离他最近的那个循环语句"><a href="#break-关键字-—-会立即终止离他最近的那个循环语句" class="headerlink" title="break 关键字 — 会立即终止离他最近的那个循环语句"></a>break 关键字 — 会立即终止离他最近的那个循环语句</h3><ul>
<li>可以用来退出 switch 或循环语句，</li>
<li>不能在 if 语句中使用 break 和 continue</li>
</ul>
<h3 id="label-—-标识当前的循环"><a href="#label-—-标识当前的循环" class="headerlink" title="label — 标识当前的循环"></a>label — 标识当前的循环</h3><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">label</span>:循环语句</span><br></pre></td></tr></table></figure></li>
<li>使用 break 语句时，可以在 break 后跟着一个 label，这样 break 将会结束指定的循环</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给循环标识了一个label</span></span><br><span class="line"><span class="attr">outer</span>: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;@外层循环&#x27;</span> + i)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">break</span> outer <span class="comment">// 退出时，结束outer这个循环</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内层循环:&#x27;</span> + j)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="continue-关键字-—-用来跳过当次循环"><a href="#continue-关键字-—-用来跳过当次循环" class="headerlink" title="continue 关键字 — 用来跳过当次循环"></a>continue 关键字 — 用来跳过当次循环</h3><ul>
<li>同样 continue 也是默认只会对离他最近的循环循环起作用</li>
</ul>
<h3 id="return-—-可以结束整个函数"><a href="#return-—-可以结束整个函数" class="headerlink" title="return — 可以结束整个函数"></a>return — 可以结束整个函数</h3><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> 值(任意类型的值，不写相当于 <span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure></li>
<li>可以使用 return 来设置函数的返回值，值将会作为函数的执行结果返回</li>
<li>在 return 后的语句都不会执行</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>知识</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-函数高级</title>
    <url>/2024/10/31/JS/JS-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型 | 原型链"></a>原型 | 原型链</h2><h3 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h3><ul>
<li>定义：每个函数都有一个 prototype 属性, 它默认指向一个 Object 空对象(即称为: 原型对象)</li>
<li>当函数<span class="key_words">『以构造函数』</span>的形式调用时，它所创建的对象中都会有一个隐含的属性执行该原型对象，<span class="key_words">『指向该构造函数的原型对象』</span>，这个隐含的属性可以通过 <code>__proto__</code> 来访问。</li>
<li>原型对象中有一个属性 constructor, 它指向函数对象</li>
<li>理解：<ul>
<li>原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象</li>
<li>创建构造函数时，可以将对象共有的属性和方法，统一添加到构造函数的原型对象中，可以使每个对象都具有这些属性和方法，也不会影响到全局作用域</li>
</ul>
</li>
<li>函数的所有实例对象自动拥有原型中的属性(方法)</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyClass</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 普通函数</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">123</span> <span class="comment">// 向MyClass的原型中添加属性a</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">// 向MyClass的原型中添加一个方法</span></span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> <span class="title class_">MyClass</span>() <span class="comment">// 创建一个构造函数</span></span><br><span class="line">此时mc.<span class="property">__proto__</span> == <span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>,</span><br><span class="line">	可以从<span class="title class_">MyClass</span>的原型上拿属性a和方法sayHello</span><br></pre></td></tr></table></figure></li>
<li>hasOwnProperty()：检查对象自身中是否含有该属性，只有当对象自身中含有属性时，才会返回 true</li>
</ul>
<h3 id="显示原型-隐式原型"><a href="#显示原型-隐式原型" class="headerlink" title="显示原型 | 隐式原型"></a>显示原型 | 隐式原型</h3><ul>
<li>每个函数function都有一个特别的属性: prototype，即<span class="key_words">『显式原型』</span>(属性)</li>
<li>每个<span class="key_words">『实例对象』</span>都有一个特别的属性: <code>__proto__</code> ，可称为<span class="key_words">『隐式原型』</span>(属性)</li>
<li>对象的隐式原型的值为其对应构造函数的显式原型的值<br><img src="/../../img/js/%E6%98%BE%E5%BC%8F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png" alt="内存结构"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>总结:<ul>
<li>函数的 prototype 属性: 在<span class="key_words">『定义函数时自动添加』</span>的, <span class="key_words">『默认值』</span>是一个<span class="key_words">『空Object对象』</span></li>
<li>实例对象的 <code>__proto__</code> 属性: <span class="key_words">『创建对象时自动添加』</span>的, <span class="key_words">『默认值』</span>为<span class="key_words">『构造函数的prototype属性值』</span></li>
<li>程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6 之前)</li>
<li><span class="key_words">『原型对象即为当前实例对象的父对象』</span></li>
</ul>
</li>
</ul>
<h3 id="原型链-隐式原型链"><a href="#原型链-隐式原型链" class="headerlink" title="原型链(隐式原型链)"></a>原型链(隐式原型链)</h3><p><img src="/../../img/js/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90.png" alt="原型链"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>定义：<ul>
<li><span class="key_words">『当访问一个对象的属性或方法时，会先在自身属性中寻找』</span>，找到返回，</li>
<li>如果没有则<span class="key_words">『去原型对象prototype』</span>中寻找，如果没有则<span class="key_words">『去原型的原型<code>__proto__</code>』</span>中寻找,<span class="key_words">『直到找到Object对象的原型Object.prototype』</span></li>
<li>如果在 Object 原型中<span class="key_words">『依然没有』</span>找到，则<span class="key_words">『返回undefined』</span>，这样通过 <code>__proto__</code> 属性就形成了一个链的结构</li>
</ul>
</li>
<li>作用: 查找对象的属性(方法)</li>
<li>注：<ul>
<li>原型对象 prototype 也是对象，所以它也有原型</li>
<li><span class="key_words">『Object对象的原型没有原型』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure></li>
<li>Function 是通过 new 自己产生的实例，所有函数都是 Function 的实例(包含 Function)</li>
<li>所有的实例对象都有 <code>__proto__</code> 属性, 它指向的就是原型对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property">__proto__</span>===<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure></li>
<li>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</li>
<li><span class="key_words">『读取对象的属性值时, 会自动到原型链中查找』</span></li>
<li><span class="key_words">『设置对象的属性值时, 不会查找原型链,如果当前对象中没有此属性, 直接添加此属性并设置其值』</span></li>
<li><span class="key_words">『方法一般定义在原型中,属性一般通过构造函数定义在对象本身上』</span></li>
</ul>
</li>
</ul>
<h2 id="执行上下文与执行上下文栈"><a href="#执行上下文与执行上下文栈" class="headerlink" title="执行上下文与执行上下文栈"></a>执行上下文与执行上下文栈</h2><h3 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h3><ul>
<li>变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)</li>
<li>函数提升: 在函数定义语句之前, 就执行该函数(函数定义对象)</li>
<li>先有变量提升, 再有函数提升</li>
</ul>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul>
<li>执行上下文: 由 js 引擎自动创建的对象, 包含对应作用域中的所有变量属性</li>
<li>执行上下文栈: 用来管理产生的多个执行上下文</li>
<li>分类:<ul>
<li>全局: window</li>
<li>函数: 对程序员来说是透明的</li>
</ul>
</li>
<li>生命周期<ul>
<li>全局: 准备执行全局代码前产生, 当页面刷新&#x2F;关闭页面时死亡</li>
<li>函数: 调用函数时产生, 函数执行完时死亡</li>
</ul>
</li>
</ul>
<h3 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h3><ul>
<li>在执行全局代码前将 window 确定为全局执行上下文</li>
<li>对全局数据进行预处理<ul>
<li>var 定义的全局变量 &#x3D;&#x3D;&gt; undefined, 添加为 window 的属性</li>
<li>function 声明的全局函数 &#x3D;&#x3D;&gt; 赋值(fun), 添加为 window 的方法</li>
<li>this &#x3D;&#x3D;&gt; 赋值(window)</li>
</ul>
</li>
<li>开始执行全局代码</li>
</ul>
<h3 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h3><ul>
<li>在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)</li>
<li>对局部数据进行预处理<ul>
<li>形参变量 &#x3D;&#x3D;&gt; 赋值(对应实参) &#x3D;&#x3D;&gt;添 加为执行上下文的属性</li>
<li>arguments &#x3D;&#x3D;&gt; 赋值(实参列表的伪数组), 添加为执行上下文的属性</li>
<li>var 定义的局部变量 &#x3D;&#x3D;&gt; undefined, 添加为执行上下文的属性</li>
<li>function 声明的函数 &#x3D;&#x3D;&gt; 赋值(fun), 添加为执行上下文的方法</li>
<li>this &#x3D;&#x3D;&gt; 赋值(调用函数的对象, 如果没有指定就是 window )</li>
</ul>
</li>
<li>开始执行函数体代码</li>
</ul>
<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><ul>
<li>在全局代码执行前, JS 引擎就会创建一个栈来存储管理所有的执行上下文对象</li>
<li>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</li>
<li>在函数执行上下文创建后, 将其添加到栈中(压栈)</li>
<li>在当前函数执行完后,将栈顶的对象移除(出栈)</li>
<li>当所有的代码执行完后, 栈中只剩下 window</li>
</ul>
<h3 id="执行上下文创建和初始化的过程"><a href="#执行上下文创建和初始化的过程" class="headerlink" title="执行上下文创建和初始化的过程"></a>执行上下文创建和初始化的过程</h3><ul>
<li>全局:</li>
<li>在全局代码执行前最先创建一个全局执行上下文(window)</li>
<li>收集一些全局变量, 并初始化</li>
<li>将这些变量设置为 window 的属性</li>
<li>函数:</li>
<li>在调用函数时, 在执行函数体之前先创建一个函数执行上下文</li>
<li>收集一些局部变量, 并初始化</li>
<li>将这些变量设置为执行上下文的属性</li>
</ul>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://gitee.com/ovouu/study-notes/blob/master/javascript/exercise/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88%E9%9D%A2%E8%AF%95%E9%A2%98.html">执行上下文与执行上下文栈面试题</a></p>
<h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>作用域: 一块代码区域, 在编码时就确定了, 不会再变化</li>
<li>作用域链: 多个上下级关系(嵌套)的作用域形成的链, 它的方向是从下向上的(从内到外)，查找变量时就是沿着作用域链来查找的</li>
<li>分类:<ul>
<li>全局</li>
<li>函数</li>
<li>js 没有块作用域(在 ES6 之前)</li>
</ul>
</li>
<li>作用<ul>
<li>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突</li>
<li>作用域链: 查找变量</li>
</ul>
</li>
</ul>
<h3 id="区别作用域与执行上下文"><a href="#区别作用域与执行上下文" class="headerlink" title="区别作用域与执行上下文"></a>区别作用域与执行上下文</h3><ul>
<li>区别<ul>
<li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时</li>
<li>全局执行上下文环境是在全局作用域确定之后, js 代码马上执行之前创建</li>
<li>函数执行上下文是在调用函数时, 函数体代码执行之前创建</li>
<li>作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化</li>
<li>执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放</li>
</ul>
</li>
<li>联系<ul>
<li>执行上下文(对象)是从属于所在的作用域</li>
<li>全局上下文环境&#x3D;&#x3D;&gt;全局作用域</li>
<li>函数上下文环境&#x3D;&#x3D;&gt;对应的函数使用域</li>
</ul>
</li>
</ul>
<h3 id="作用域链查找一个变量的规则"><a href="#作用域链查找一个变量的规则" class="headerlink" title="作用域链查找一个变量的规则"></a>作用域链查找一个变量的规则</h3><ul>
<li>在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入上一层作用域查找</li>
<li>在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入上一层作用域查找</li>
<li>以此类推, 直到全局作用域, 如果还找不到就抛出找不到的异常</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h3><ul>
<li>当<span class="key_words">『嵌套的内部函数引用 了外部函数的变量』</span>时就产生了闭包</li>
<li>通过 chrome 工具得知: 闭包<span class="key_words">『本质是内部函数中的一个对象, 这个对象中包含引用的变量属性』</span></li>
<li>在问题的上下文中，闭包被用于保持对定时器变量的引用，即使创建闭包的函数已经返回。这使得取消函数能够访问并修改定时器变量，有效地取消了延迟函数的执行。</li>
</ul>
<h3 id="产生闭包的条件"><a href="#产生闭包的条件" class="headerlink" title="产生闭包的条件?"></a>产生闭包的条件?</h3><ul>
<li>函数嵌套</li>
<li>内部函数引用了外部函数的数据(变量&#x2F;函数)</li>
<li>执行外部函数</li>
</ul>
<h3 id="常见的闭包"><a href="#常见的闭包" class="headerlink" title="常见的闭包"></a>常见的闭包</h3><ul>
<li>将函数作为另一个函数的返回值</li>
<li>将函数作为实参传递给另一个函数调用</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 将函数作为另一个函数的返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>   <span class="comment">//此时闭包产生了，因为函数提升</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fn1</span>()</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 4</span></span><br><span class="line">结果：从以上函数克制，该函数产生多少个闭包，看调用了几次外部函数</span><br><span class="line"><span class="comment">// 2. 将函数的实参传递给内部的函数调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showDelay</span>(<span class="params">msg, time</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(msg)</span><br><span class="line">  &#125;, time)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showDelay</span>(<span class="string">&#x27;atguigu&#x27;</span>, <span class="number">2000</span>)</span><br><span class="line">结论：有产生闭包，一外部函数里面嵌套内部函数，二内部函数调用外部函数的值msg，如果没有msg就不会产生闭包</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><ul>
<li>使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)</li>
<li>让函数外部可以操作(读写)到函数内部的数据(变量&#x2F;函数)</li>
<li>注：<ul>
<li>函数<span class="key_words">『执行完后, 函数内部声明的局部变量一般是不存在, 存在于闭包中的变量才可能存在』</span></li>
<li>在函数<span class="key_words">『外部不能直接访问函数内部的局部变量, 但可以通过闭包让外部操作它』</span></li>
</ul>
</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)</li>
<li>死亡: 在嵌套的内部函数成为垃圾对象时(让包含闭包的函数对象&#x3D;null)</li>
</ul>
<h3 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h3><ul>
<li>模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为(对象或函数)</li>
<li>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能</li>
<li>循环遍历加监听</li>
<li>JS 框架(jQuery)大量使用了闭包</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长</li>
<li>可能导致内存泄露</li>
<li>解决:及时释放<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f = <span class="literal">null</span>; <span class="comment">//让内部函数对象成为垃圾对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ul>
<li>一种程序运行出现的错误</li>
<li>当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</li>
</ul>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><ul>
<li>占用的内存没有及时释放</li>
<li>内存泄露积累多了就容易导致内存溢出</li>
<li>常见的内存泄露:<ul>
<li>意外的全局变量</li>
<li>没有及时清理的计时器或回调函数</li>
<li>闭包</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 内存溢出</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">	obj[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000000</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 内存泄露</span></span><br><span class="line"><span class="comment">// 意外的全局变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">	a = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000000</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"><span class="comment">// 没有及时清理的计时器或回调函数</span></span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">//启动循环定时器后不清理</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(++a)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fn2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fn1</span>()</span><br><span class="line"><span class="title function_">f</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-对象高级</title>
    <url>/2024/10/31/JS/JS-%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h2><h3 id="Object-构造函数模式"><a href="#Object-构造函数模式" class="headerlink" title="Object 构造函数模式"></a>Object 构造函数模式</h3><ul>
<li>套路: 先创建空 Object 对象, 再动态添加属性&#x2F;方法</li>
<li>适用场景: 起始时不确定对象内部数据</li>
<li>问题: 语句太多</li>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">obj.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="对象字面量模式"><a href="#对象字面量模式" class="headerlink" title="对象字面量模式"></a>对象字面量模式</h3><ul>
<li>套路: 使用{}创建对象, 同时指定属性&#x2F;方法</li>
<li>适用场景: 起始时对象内部数据是确定的</li>
<li>问题: 如果创建多个对象, 有重复代码</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">	<span class="attr">setName</span>: <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul>
<li>套路: 通过工厂函数动态创建对象并返回</li>
<li>适用场景: 需要创建多个对象</li>
<li>问题: 对象没有一个具体的类型, 都是 Object 类型</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">	<span class="comment">//返回一个对象的函数===&gt;工厂函数</span></span><br><span class="line">	<span class="keyword">var</span> obj = &#123;</span><br><span class="line">		<span class="attr">name</span>: name,</span><br><span class="line">		<span class="attr">age</span>: age,</span><br><span class="line">		<span class="attr">setName</span>: <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建2个人，都是是Object类型</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">createPerson</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">createPerson</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">13</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自定义构造函数模式"><a href="#自定义构造函数模式" class="headerlink" title="自定义构造函数模式"></a>自定义构造函数模式</h3><ul>
<li>套路: 自定义构造函数, 通过 new 创建对象</li>
<li>适用场景: 需要创建多个类型确定的对象</li>
<li>问题: 每个对象都有相同的数据, 浪费内存</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;tom&#x27;</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="构造函数-原型的组合模式"><a href="#构造函数-原型的组合模式" class="headerlink" title="构造函数+原型的组合模式"></a>构造函数+原型的组合模式</h3><ul>
<li>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</li>
<li>适用场景: 需要创建多个类型确定的对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;tom&#x27;</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="继承模式"><a href="#继承模式" class="headerlink" title="继承模式"></a>继承模式</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><ul>
<li>套路1: 定义父类型构造函数</li>
<li>套路2: 给父类型的原型添加方法</li>
<li>套路3: 定义子类型的构造函数</li>
<li>套路4: 创建父类型的对象赋值给子类型的原型</li>
<li>套路5: 将子类型原型的构造属性设置为子类型</li>
<li>套路6: 给子类型原型添加方法</li>
<li>套路7: 创建子类型的对象: 可以调用父类型的方法</li>
<li>关键：子类型的原型为父类型的一个实例对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 创建父类</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; <span class="comment">// 给父类的原型添加方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 创建子类</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>() <span class="comment">// 子类型的原型指向父类型实例</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>() <span class="comment">//有test()</span></span><br></pre></td></tr></table></figure>

<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><ul>
<li>套路1：定义父类型构造函数</li>
<li>套路2：定义子类型构造函数</li>
<li>套路3：在子类型构造函数中调用父类型构造</li>
<li>关键：在子类型构造函数中通用 call()调用父类型构造函数</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">xxx</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">xxx</span> = xxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">xxx, yyy</span>) &#123;</span><br><span class="line">	<span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, xxx) <span class="comment">//借用构造函数   this.Parent(xxx)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">//child.xxx为&#x27;a&#x27;, 但child没有test()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="原型链-借用构造函数的组合继承"><a href="#原型链-借用构造函数的组合继承" class="headerlink" title="原型链+借用构造函数的组合继承"></a>原型链+借用构造函数的组合继承</h3><ul>
<li><p>利用原型链实现对父类型对象的方法继承</p>
</li>
<li><p>利用 super()借用父类型构建函数初始化相同属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">xxx</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">xxx</span> = xxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">xxx, yyy</span>) &#123;</span><br><span class="line">	<span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, xxx) <span class="comment">//借用构造函数   this.Parent(xxx)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>() <span class="comment">//得到test()</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span> <span class="comment">//修正constructor属性</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>() <span class="comment">//child.xxx为&#x27;a&#x27;, 也有test()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>new 一个对象背后做了些什么?</p>
<ul>
<li>创建一个空对象</li>
<li>给对象设置<code>__proto__</code>, 值为构造函数对象的 prototype 属性值 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">__proto__</span> = <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure></li>
<li>执行构造函数体(给对象添加属性&#x2F;方法)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-工具函数和方法</title>
    <url>/2024/10/31/JS/JS-%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="字符串的相关的方法"><a href="#字符串的相关的方法" class="headerlink" title="字符串的相关的方法"></a>字符串的相关的方法</h2><ul>
<li>length: 获取字符串的长度</li>
<li>charAt(): 可以返回字符串中指定位置的字符</li>
<li>charCodeAt(): 根据索引获取指定的字符编码</li>
<li>String.fromCharCode(): 根据字符编码获取字符</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&#x27;中Hello Atguigu&#x27;</span></span><br><span class="line">result = str.<span class="title function_">charAt</span>(<span class="number">5</span>) <span class="comment">// o</span></span><br><span class="line">result = str.<span class="title function_">charCodeAt</span>(<span class="number">1</span>) <span class="comment">// 72</span></span><br><span class="line">result = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x2692</span>) <span class="comment">// &#x27;⚒&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>concat()<ul>
<li>可以用来连接两个或多个字符串，参数是字符串，用逗号分隔</li>
</ul>
</li>
<li>indexOf() 和 lastIndexOf()<ul>
<li>从一个字符串中检索是否含有指定内容</li>
<li>如果字符串中含有该内容，则会返回其第一次出现的索引，没有找到返回-1</li>
<li>可以指定一个第二个参数，来表示开始查找的位置</li>
<li>indexOf()是从前向后找</li>
<li>lastIndexOf()是从后向前找</li>
</ul>
</li>
<li>slice()<ul>
<li>从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原字符串</li>
<li>参数：<ul>
<li>第一个：截取开始的位置（包括开始）</li>
<li>第二个：截取结束的位置（不包括结束）<ul>
<li>可以省略第二个参数，如果省略则一直截取到最后</li>
</ul>
</li>
<li>可以传负数，如果是负数则从后往前数</li>
</ul>
</li>
</ul>
</li>
<li>substr()<ul>
<li>和 slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量</li>
</ul>
</li>
<li>substring()<ul>
<li>和 slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为 0，</li>
<li>substring()中如果第二个参数小于第一个，自动调整位置</li>
</ul>
</li>
<li>toLowerCase()<ul>
<li>将字符串转换为小写并返回</li>
</ul>
</li>
<li>toUpperCase()<ul>
<li>将字符串转换为大写并返回</li>
</ul>
</li>
</ul>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><blockquote>
<p>日期的对象，在 JS 中通过 Date 对象来表示一个时间</p>
</blockquote>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul>
<li>创建一个当前的时间对象,使用构造函数<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>创建一个指定的时间对象，需要传递一个表示时间的字符串作为参数<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;月/日/年 时:分:秒&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>getDate(): 当前日期对象是几日（1-31）</li>
<li>getDay(): 返回当前日期对象时周几（0-6）<ul>
<li>0 表示周日</li>
<li>1 表示周一 ，以此类推</li>
</ul>
</li>
<li>getMonth(): 返回当前日期对象的月份（0-11）<ul>
<li>0 表示 一月，以此类推</li>
</ul>
</li>
<li>getFullYear(): 获取当前日期对象的年份</li>
<li>getHours(): 返回 Date 对象的小时 (0 ~ 23)。</li>
<li>getMinutes(): 返回 Date 对象的分钟 (0 ~ 59)。</li>
<li>getSeconds(): 返回 Date 对象的秒数 (0 ~ 59)。</li>
<li>getMilliseconds(): 返回 Date 对象的毫秒(0 ~ 999)。</li>
<li>getTime(): 返回当前日期对象的时间戳<ul>
<li>时间戳，指的是从格林威治标准时间的 1970 年月 1 日 0 时 0 分 0 秒，到现在时间的毫秒数</li>
<li>计算机底层保存时间都是以时间戳的形式保存的。</li>
</ul>
</li>
<li>Date.now(): 可以获取当前代码执行时的时间戳</li>
</ul>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><blockquote>
<p>Math 属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法</p>
</blockquote>
<ul>
<li>Math.PI: 常量，圆周率</li>
<li>Math.abs(): 绝对值运算</li>
<li>Math.ceil(): 向上取整，小数位只有有值就自动进 1</li>
<li>Math.floor(): 向下取整，小数部分会被舍掉</li>
<li>Math.round(): 四舍五入取整</li>
<li>Math.random(): 生成一个 0-1 之间的随机数<ul>
<li>生成一个 x-y 之间的随机数: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*(y-x)+x);</span><br></pre></td></tr></table></figure></li>
<li>生成一个 0-x 之间的随机数: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*x);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Math.pow(x,y): 求 x 的 y 次幂</li>
<li>Math.sqrt(): 对一个数进行开方</li>
<li>Math.max(): 求多个数中最大值</li>
<li>Math.min(): 求多个数中的最小值</li>
</ul>
<h2 id="包装类-–-将基本数据类型的数据转换为对象（不建议）"><a href="#包装类-–-将基本数据类型的数据转换为对象（不建议）" class="headerlink" title="包装类 – 将基本数据类型的数据转换为对象（不建议）"></a>包装类 – 将基本数据类型的数据转换为对象（不建议）</h2><blockquote>
<p>在 JS 中为我们提供了三个包装类：String() Boolean() Number()</p>
</blockquote>
<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="keyword">new</span> <span class="title class_">Number</span>()</span><br></pre></td></tr></table></figure></li>
<li>当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，操作完成以后再将这个临时对象进行销毁。</li>
<li>方法和属性只能添加给对象，不能添加给基本数据类型，不会报错结果为 undefined</li>
</ul>
<h2 id="JSON-JavaScript-Object-Notation-JS-对象表示法"><a href="#JSON-JavaScript-Object-Notation-JS-对象表示法" class="headerlink" title="JSON(JavaScript Object Notation,JS 对象表示法)"></a>JSON(JavaScript Object Notation,JS 对象表示法)</h2><blockquote>
<p>一个特殊格式的字符串，可以被任意的语言所识别，并且可以转换为任意语言中的对象，在开发中主要用来数据的交互</p>
</blockquote>
<ul>
<li>如果需要兼容 IE7 及以下的 JSON 操作，则可以通过引入一个外部的 js 文件来处理</li>
<li>JS 中的对象只有 JS 自己认识，其他的语言都不认识</li>
<li>JSON 和 JS 对象的格式一样，只不过 JSON 字符串中的属性名必须加双引号,其他的和 JS 语法一致</li>
<li>JSON 分类：<ol>
<li>对象 {}</li>
<li>数组 []</li>
</ol>
</li>
<li>JSON 中允许的值：<ol>
<li>字符串</li>
<li>数值</li>
<li>布尔值</li>
<li>null</li>
<li>对象</li>
<li>数组</li>
</ol>
</li>
</ul>
<h3 id="JSON-字符串与-JS-互转"><a href="#JSON-字符串与-JS-互转" class="headerlink" title="JSON 字符串与 JS 互转"></a>JSON 字符串与 JS 互转</h3><ul>
<li>JSON.parse()<ul>
<li>可以将以 JSON 字符串转换为 js 对象</li>
<li>它需要一个 JSON 字符串作为参数，会将该字符串转换为 JS 对象并返回</li>
</ul>
</li>
<li>JSON.stringify()<ul>
<li>可以将一个 JS 对象转换为 JSON 字符串</li>
<li>需要一个 js 对象作为参数，会返回一个 JSON 字符串</li>
</ul>
</li>
<li>JSON 这个对象在 IE7 及以下的浏览器中不支持，所以在这些浏览器中调用时会报错</li>
</ul>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><ul>
<li>这个函数可以用来执行一段字符串形式的 JS 代码，并将执行结果返回</li>
<li>如果使用 eval()执行的字符串中含有{},它会将{}当成是代码块</li>
<li>如果不希望将其当成代码块解析，则需要在字符串前后各加一个()</li>
<li>eval()这个函数的功能很强大，可以直接执行一个字符串中的 js 代码，</li>
<li>但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span>+str+<span class="string">&quot;)&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>工具函数</tag>
        <tag>JSON</tag>
        <tag>Math</tag>
        <tag>eval()</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-正则表达式</title>
    <url>/2024/10/31/JS/JS-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h2><h3 id="方法一：使用正则表达式字面量"><a href="#方法一：使用正则表达式字面量" class="headerlink" title="方法一：使用正则表达式字面量"></a>方法一：使用正则表达式字面量</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/正则表达式/</span>匹配模式</span><br></pre></td></tr></table></figure>
<h3 id="方法二：调用-RegExp-对象的构造函数"><a href="#方法二：调用-RegExp-对象的构造函数" class="headerlink" title="方法二：调用 RegExp 对象的构造函数"></a>方法二：调用 RegExp 对象的构造函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;正则表达式&quot;</span>,<span class="string">&quot;匹配模式(可选)&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>注：使用 typeof 检查正则对象，会返回 object</li>
</ul>
<h2 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h2><ul>
<li><span class="key_words">『i』</span>：忽略大小写</li>
<li><span class="key_words">『g』</span>：全局匹配模式</li>
<li><span class="key_words">『m』</span>：多行匹配，使边界字符 ^ 和 $ 匹配每一行的开头和结尾</li>
<li><span class="key_words">『s』</span>：(es2018)匹配单个字符，与.一起使用，使.代表一切字符，称为 dotAll 模式<ul>
<li>使用 reg.dotAll 来判断该正则表达式是否处于动 dotAll 模式</li>
</ul>
</li>
</ul>
<h2 id="正则表达式规则"><a href="#正则表达式规则" class="headerlink" title="正则表达式规则"></a>正则表达式规则</h2><ul>
<li><span class="key_words">『^』</span>：匹配开头</li>
<li><span class="key_words">『$』</span>：匹配结尾</li>
<li><span class="key_words">『\w』</span>：匹配任意字母、数字、_ ([A-z0-9_]) </li>
<li><span class="key_words">『\W』</span>：匹配除了字母、数字、_ ([^A-z0-9_])</li>
<li><span class="key_words">『\d』</span>：匹配任意的数字 ([0-9])</li>
<li><span class="key_words">『\D』</span>：匹配除了数字 ([^0-9])</li>
<li><span class="key_words">『\s』</span>：匹配空格</li>
<li><span class="key_words">『\S』</span>：匹配除了空格</li>
<li><span class="key_words">『\b』</span>：单词边界（在单词两边使用，表示在这个字符串中完整匹配这个单词）</li>
<li><span class="key_words">『\B』</span>：匹配除了单词边界</li>
<li><span class="key_words">『[a-z]』</span>：任意小写字母</li>
<li><span class="key_words">『[A-Z]』</span>：任意大写字母</li>
<li><span class="key_words">『[A-z]』</span>：任意字母</li>
<li><span class="key_words">『[0-9]』</span>：任意数字</li>
<li><span class="key_words">『[ ]』</span>：匹配括号内的任意一个字符。</li>
<li><span class="key_words">『[^ ]』</span>：匹配除了括号内的字符以外的任意一个字符</li>
</ul>
<h2 id="量词-—-只对它前边的一个内容起作用"><a href="#量词-—-只对它前边的一个内容起作用" class="headerlink" title="量词 — 只对它前边的一个内容起作用"></a>量词 — 只对它前边的一个内容起作用</h2><ul>
<li><span class="key_words">『{n}』</span>：正好出现 n 次</li>
<li><span class="key_words">『{m,n}』</span>：出现 m-n 次</li>
<li><span class="key_words">『{m,}』</span>：m 次以上</li>
<li><span class="key_words">『+』</span>：至少一个 &#x3D;&#x3D; {1,}</li>
<li><span class="key_words">『*』</span>：0 个或多个 &#x3D;&#x3D; {0,}</li>
<li><span class="key_words">『?』</span>：0 个或 1 个 &#x3D;&#x3D; {0,1}</li>
<li><span class="key_words">『.』</span>：表示任意字符(除了换行符)</li>
<li>注：<span class="key_words">『*、+ 都是贪婪的，会尽可能匹配更多的文字，在它们后面加上?就可以实现非贪婪或最小匹配』</span></li>
</ul>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul>
<li><span class="key_words">『<code>\</code>』</span>: 转义字符，用于匹配特殊字符本身</li>
<li><span class="key_words">『|』</span>：用于指定多个模式的选择</li>
<li><span class="key_words">『( )』</span>：用于分组和捕获子表达式</li>
<li><span class="key_words">『(?: )』</span>：用于分组但不捕获子表达式</li>
<li><span class="key_words">『?&#x3D;』</span>：exp1(?&#x3D;exp2)：查找 exp2 前面的 exp1，即<span class="key_words">『先行断言』</span></li>
<li><span class="key_words">『?&lt;&#x3D;』</span>：(?&lt;&#x3D;exp2)exp1：查找 exp2 后面的 exp1，即<span class="key_words">『后行断言』</span>，es2018</li>
<li><span class="key_words">『?!』</span>：exp1(?!exp2)：查找后面不是 exp2 的 exp1，即<span class="key_words">『先行否定断言』</span></li>
<li><span class="key_words">『?&lt;!』</span>：exp1(?&lt;!exp2)：查找前面不是 exp2 的 exp1，即<span class="key_words">『后行否定断言』</span>，es2018</li>
<li><span class="key_words">『\1』</span>：指定第一个子匹配项。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">eg1</span>:去除开头的空格</span><br><span class="line">str = str.<span class="title function_">replace</span>(<span class="regexp">/^\s*/</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="attr">eg2</span>:去除结尾的空格</span><br><span class="line">str = str.<span class="title function_">replace</span>(<span class="regexp">/\s*$/</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="attr">eg3</span>:<span class="string">`/^\s*`</span> | <span class="string">`\s*$/g`</span> 匹配开头和结尾的空格</span><br><span class="line">str = str.<span class="title function_">replace</span>(<span class="regexp">/^\s* | \s*$/g</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="常见的匹配规则"><a href="#常见的匹配规则" class="headerlink" title="常见的匹配规则"></a>常见的匹配规则</h2><ul>
<li>匹配 HTML 标记<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;[a-zA-Z]+.*?&gt;([\s\S]*?)&lt;/[a-zA-Z]*?&gt;</span><br></pre></td></tr></table></figure></li>
<li>匹配空行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^\s*$/</span><br></pre></td></tr></table></figure></li>
<li>一个单词连续出现的位置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/\<span class="title function_">b</span>([a-z]+) \<span class="number">1</span>\b/gi</span><br></pre></td></tr></table></figure></li>
<li>匹配一个 URL 解析为协议、域、端口及相对路径<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(\w+):\/\/([^<span class="regexp">/:]+)(:\d*)?([^# ]*)/</span></span><br></pre></td></tr></table></figure></li>
<li>定位章节的位置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^(?:<span class="title class_">Chapter</span>|<span class="title class_">Section</span>) [<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;$/</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="合法手机号"><a href="#合法手机号" class="headerlink" title="合法手机号"></a>合法手机号</h2><ul>
<li>手机号的规则：<ul>
<li>以 1 开头</li>
<li>第二位 3-9 任意数字</li>
<li>三位以后任意数字 9 个</li>
</ul>
</li>
<li>匹配模式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^<span class="number">1</span>[<span class="number">3</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">9</span>&#125;$/</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><ul>
<li>邮件的规则：<ul>
<li>前边可以是任意字符</li>
<li>跟着一个@</li>
<li>后边可以是任意字符</li>
<li>后面是.com | .cn 等</li>
</ul>
</li>
<li>匹配模式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[\w.%+-]+@[\w.-]+(\.[A-z]&#123;<span class="number">2</span>,<span class="number">5</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;$</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h2><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><ul>
<li>在字符串中搜索匹配,返回一个结果数组或 null</li>
</ul>
<h3 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h3><ul>
<li>可以一次性取出所有匹配,返回的是一个遍历器。正则表达式必须使用全局匹配模式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;test1test2test3&#x27;</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.<span class="title function_">matchAll</span>(regex)) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(match)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><ul>
<li>从字符串中将符合正则表达式规则的内容中，返回数组或 null</li>
<li>默认，仅返回第一个匹配的结果 &#x3D;&#x3D; exec()方法</li>
<li>使用全局匹配模式 g，返回与完整正则表达式匹配的所有结果 &#x3D;&#x3D; matchAll()</li>
</ul>
<h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><ul>
<li>用来查看正则表达式与指定的字符串是否匹配,返回 true 或 false</li>
</ul>
<h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><ul>
<li>可以搜索字符串中是否含有指定内容,返回索引值</li>
<li>如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1</li>
<li>注：serach()只会查找第一个，即使设置全局匹配也没用</li>
</ul>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><ul>
<li>可以将字符串中指定内容替换为新的内容，返回字符串</li>
<li>参数：<ul>
<li>被替换的内容，可以接受一个正则表达式作为参数</li>
<li>新的内容</li>
</ul>
</li>
</ul>
<h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><ul>
<li>可以将一个字符串拆分为一个数组</li>
<li>如果传递一个空串作为参数，则会将每个字符都拆分为数组中的一个元素</li>
</ul>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="U-修饰符"><a href="#U-修饰符" class="headerlink" title="U 修饰符"></a>U 修饰符</h3><ul>
<li>es6 新增，末尾加 u，代表 Unicode 模式（正确识别码点大于 0xFFFF 的 Unicode 字符）</li>
</ul>
<h3 id="i-修饰符-u-修饰符"><a href="#i-修饰符-u-修饰符" class="headerlink" title="i 修饰符 + u 修饰符"></a>i 修饰符 + u 修饰符</h3><ul>
<li>可以识别非规范的 K 字符</li>
</ul>
<h3 id="点字符-u-修饰符"><a href="#点字符-u-修饰符" class="headerlink" title="点字符 + u 修饰符"></a>点字符 + u 修饰符</h3><ul>
<li>识别码点大于 0xFFFF 的 Unicode 字符</li>
</ul>
<h3 id="使用大括号表示-Unicode-字符，在正则表达式中必须加上-u-修饰符，否则大括号内容识别成量词"><a href="#使用大括号表示-Unicode-字符，在正则表达式中必须加上-u-修饰符，否则大括号内容识别成量词" class="headerlink" title="使用大括号表示 Unicode 字符，在正则表达式中必须加上 u 修饰符，否则大括号内容识别成量词"></a>使用大括号表示 Unicode 字符，在正则表达式中必须加上 u 修饰符，否则大括号内容识别成量词</h3><ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用-u-修饰符，量词会正确识别-Unicode-字符"><a href="#使用-u-修饰符，量词会正确识别-Unicode-字符" class="headerlink" title="使用 u 修饰符，量词会正确识别 Unicode 字符"></a>使用 u 修饰符，量词会正确识别 Unicode 字符</h3><h3 id="S-u-test-‘𠮷’"><a href="#S-u-test-‘𠮷’" class="headerlink" title="&#x2F;^\S$&#x2F;u.test(‘𠮷’)"></a>&#x2F;^\S$&#x2F;u.test(‘𠮷’)</h3><ul>
<li>&#x2F;S 匹配所有非空白字符，加了 u，能正确匹配码点大于 0xFFFF 的 Unicode 字符</li>
</ul>
<h3 id="RegExp-prototype-unicode-属性"><a href="#RegExp-prototype-unicode-属性" class="headerlink" title="RegExp.prototype.unicode 属性"></a>RegExp.prototype.unicode 属性</h3><ul>
<li>判断是否加了 u 修饰符</li>
</ul>
<h3 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h3><ul>
<li><span class="key_words">『全局匹配』</span>，后一次匹配都从上一次匹配成功的下一个位置开始[<span class="key_words">『必须从剩余的第一个位置开始』</span>]</li>
<li>reg.lastIndex: 指定从那个位置开始匹配，但<span class="key_words">『必须从这个位置发现匹配』</span></li>
<li>reg.sticky: 表示是否设置了 y 修饰符。</li>
<li>reg.flags: 返回正则表达式的修饰符</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span></span><br><span class="line">/a+<span class="regexp">/g.exec(s) /</span>/ 第一回：aaa，第二回：aa</span><br><span class="line">/a+<span class="regexp">/y.exec(s) /</span>/ 第一回：aaa，第二回：<span class="literal">null</span></span><br><span class="line"><span class="comment">// y修饰符+ g修饰符 ：已数组的形式返回所有符合y修饰符规则的元素</span></span><br><span class="line"><span class="string">&#x27;a1a2a3&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a\d/y</span>) <span class="comment">// [&quot;a1&quot;]</span></span><br><span class="line"><span class="string">&#x27;a1a2a3&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a\d/gy</span>) <span class="comment">// [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="修饰符-g-与修饰符-y-区别："><a href="#修饰符-g-与修饰符-y-区别：" class="headerlink" title="修饰符 g 与修饰符 y 区别："></a>修饰符 g 与修饰符 y 区别：</h3><ul>
<li>g：可以在剩余的位置中只要找到对应的内容，就匹配返回</li>
<li>y：必须从剩余第一位匹配，如果第一位不是就返回 null</li>
</ul>
<h3 id="v-修饰符：属性类的运算"><a href="#v-修饰符：属性类的运算" class="headerlink" title="v 修饰符：属性类的运算"></a>v 修饰符：属性类的运算</h3><ul>
<li>前提： 正则表达式必须使用 v 修饰符。</li>
<li>差集运算（A 减去 B）：<code>[A--B]</code></li>
<li>交集运算（A 与 B 的交集）：<code>[A&amp;&amp;B]</code></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[\p&#123;<span class="title class_">Decimal</span>_Number&#125;--[<span class="number">0</span>-<span class="number">9</span>]] <span class="comment">// 十进制去除 ASCII 码的 0 到 9</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="d修饰符：-正则匹配索引"><a href="#d修饰符：-正则匹配索引" class="headerlink" title="d修饰符： 正则匹配索引"></a>d修饰符： 正则匹配索引</h3><ul>
<li>让 exec()、match() 的返回结果<span class="key_words">『添加indices』</span>属性，在该属性上可以拿到<span class="key_words">『匹配的开始位置和结束位置』</span></li>
<li>注：开始位置包含在匹配结果之中，相当于匹配结果的第一个字符的位置。但是，结束位置不包含在匹配结果之中，是匹配结果的下一个字符。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;zabbcdef&#x27;</span></span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(cd)/</span>d</span><br><span class="line"><span class="keyword">const</span> result = re.<span class="title function_">exec</span>(text)</span><br><span class="line"><span class="comment">// 匹配ab到cd的开始和cd的开始</span></span><br><span class="line">result.<span class="property">indices</span> <span class="comment">// [ [ 1, 6 ], [ 4, 6 ] ]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Unicode-属性类"><a href="#Unicode-属性类" class="headerlink" title="Unicode 属性类"></a>Unicode 属性类</h2><ul>
<li>默认是 <span class="key_words">『\u{…}』</span></li>
<li>es2018，<span class="key_words">『\p{…}』</span>：匹配满足条件的所有字符。（<span class="desc">加上 u 修饰符</span>）</li>
<li>es2018，<span class="key_words">『\P{…}』</span>：是<span class="key_words">『\p{…}的反向匹配』</span>，即匹配不满足条件的所有字符。（<span class="desc">加上 u 修饰符</span>）</li>
<li>标准形式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">\p&#123;<span class="title class_">UnicodePropertyName</span>=<span class="title class_">UnicodePropertyValue</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以只写属性名或属性值</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \p&#123;Number&#125;匹配所有数组，包括罗马数字。</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line"><span class="comment">// 匹配所有空格</span></span><br><span class="line">\p&#123;<span class="title class_">White</span>_Space&#125;</span><br><span class="line"><span class="comment">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w</span></span><br><span class="line">[\p&#123;<span class="title class_">Alphabetic</span>&#125;\p&#123;<span class="title class_">Mark</span>&#125;\p&#123;<span class="title class_">Decimal</span>_Number&#125;\p&#123;<span class="title class_">Connector</span>_Punctuation&#125;\p&#123;<span class="title class_">Join</span>_Control&#125;]</span><br><span class="line"><span class="comment">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W</span></span><br><span class="line">[^\p&#123;<span class="title class_">Alphabetic</span>&#125;\p&#123;<span class="title class_">Mark</span>&#125;\p&#123;<span class="title class_">Decimal</span>_Number&#125;\p&#123;<span class="title class_">Connector</span>_Punctuation&#125;\p&#123;<span class="title class_">Join</span>_Control&#125;]</span><br><span class="line"><span class="comment">// 匹配 Emoji</span></span><br><span class="line">/\p&#123;<span class="title class_">Emoji</span>_Modifier_Base&#125;\p&#123;<span class="title class_">Emoji</span>_Modifier&#125;?|\p&#123;<span class="title class_">Emoji</span>_Presentation&#125;|\p&#123;<span class="title class_">Emoji</span>&#125;\uFE0F/gu</span><br><span class="line"><span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line"><span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">regexArrows.<span class="title function_">test</span>(<span class="string">&#x27;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="具名组匹配"><a href="#具名组匹配" class="headerlink" title="具名组匹配"></a>具名组匹配</h2><ul>
<li>在<span class="en">圆括号内部</span>，模式的头部添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法: 问号 + 尖括号 + 组名</span><br><span class="line"><span class="attr">eg</span>: ?&lt;组名&gt;</span><br></pre></td></tr></table></figure></li>
<li>然后在 exec方法 返回结果的 groups 属性上引用该组名。</li>
<li><span class="key_words">『数字序号』</span></span>引用（matchObj[1]）依然<span class="key_words">『有效』</span></li>
<li>如果具名组<span class="key_words">『没有匹配』</span>，那么<span class="key_words">『对应的groups』</span>对象属性会是undefined,但<span class="key_words">『键名』</span>再 groups 始终<span class="key_words">『存在』</span></li>
<li>在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> year = matchObj.<span class="property">groups</span>.<span class="property">year</span> <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.<span class="property">groups</span>.<span class="property">month</span> <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.<span class="property">groups</span>.<span class="property">day</span> <span class="comment">// 31</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span></span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!abc&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="解构赋值和替换"><a href="#解构赋值和替换" class="headerlink" title="解构赋值和替换"></a>解构赋值和替换</h2><ul>
<li>字符串替换时，使用$&lt;组名&gt;引用具名组。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"><span class="string">&#x27;2015-01-02&#x27;</span>.<span class="title function_">replace</span>(re, <span class="string">&#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="遍历器转为数组"><a href="#遍历器转为数组" class="headerlink" title="遍历器转为数组"></a>遍历器转为数组</h2><ul>
<li>方法一：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...string.<span class="title function_">matchAll</span>(regex)]</span><br></pre></td></tr></table></figure></li>
<li>方法二：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(string.<span class="title function_">matchAll</span>(regex))</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-数组</title>
    <url>/2024/10/31/JS/JS-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>也是一个对象,，是一个用来存储数据的对象和 Object 类似，但是它的存储效率比普通对象要高<br>可直接前往MDN学习</p>
</blockquote>
<ul>
<li>数组中保存的内容我们称为元素</li>
<li>数组中的元素可以是任意的数据类型</li>
<li>数组使用索引（index）来操作元素</li>
<li>索引指由 0 开始的整数</li>
</ul>
<h2 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ul>
<li>使用构造函数创建数组，也可以同时添加元素<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：<span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>() <span class="comment">// 空数组</span></span><br><span class="line">语法：<span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(元素 <span class="number">1</span>,元素 <span class="number">2</span>,元素 n) <span class="comment">// 有元素的数组</span></span><br><span class="line">语法：<span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>); <span class="comment">// 只有一个参数且是数字类型，代表创建长度为这个数字的空数组</span></span><br></pre></td></tr></table></figure></li>
<li>使用字面量来创建数组，创建时可以直接添加数组中的元素<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：<span class="keyword">const</span> arr = [] <span class="comment">// 空数组</span></span><br><span class="line">语法：<span class="keyword">const</span> arr = [元素 <span class="number">1</span>,元素 <span class="number">2</span>,元素 n] <span class="comment">// 有元素的数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul>
<li>语法：数组[索引] &#x3D; 值</li>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [元素 <span class="number">1</span>,元素 <span class="number">2.</span>...元素 N];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="读取数组中的元素"><a href="#读取数组中的元素" class="headerlink" title="读取数组中的元素"></a>读取数组中的元素</h3><ul>
<li>语法：数组[索引]</li>
<li>如果读取不存在的索引，返回 undefined</li>
</ul>
<h3 id="获取和修改数组的长度"><a href="#获取和修改数组的长度" class="headerlink" title="获取和修改数组的长度"></a>获取和修改数组的长度</h3><ul>
<li>使用 length 属性来操作数组的长度(元素的个数)</li>
<li>语法：数组.length</li>
<li>length 获取到的是数组的最大索引+1</li>
<li>对于连续的数组，length 获取到的就是数组中元素的个数</li>
<li>对于非连续的数组，使用 length 会获取到数组的最大的索引+1</li>
<li>修改数组的长度<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组.<span class="property">length</span> = 新长度</span><br></pre></td></tr></table></figure>
<ul>
<li>如果修改后的 length 大于原长度，则多出的部分会空出来</li>
<li>如果修改后的 length 小于原长度，则原数组中多出的元素会被删除</li>
</ul>
</li>
<li>向数组的最后添加元素<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组[数组.<span class="property">length</span>] = 值;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><ul>
<li>push()<ul>
<li>用来向数组的末尾添加一个或多个元素，并返回数组新的长度</li>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组.<span class="title function_">push</span>(元素 <span class="number">1</span>,元素 <span class="number">2</span>,元素 N)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>pop()<ul>
<li>用来删除数组的最后一个元素，并返回被删除的元素</li>
</ul>
</li>
<li>unshift()<ul>
<li>向数组的开头添加一个或多个元素，并返回数组的新的长度</li>
</ul>
</li>
<li>shift()<ul>
<li>删除数组的前边的一个元素，并返回被删除的元素</li>
</ul>
</li>
<li>slice()<ul>
<li>可以从一个数组中截取指定的元素</li>
<li>该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回</li>
<li>参数：<ul>
<li>1.截取开始位置的索引（包括开始位置） </li>
<li>2.截取结束位置的索引（不包括结束位置）</li>
</ul>
</li>
<li>第二个参数可以省略不写，如果不写则一直截取到最后 </li>
<li>参数可以传递一个负值，如果是负值，则从后往前数</li>
</ul>
</li>
<li>splice()<ul>
<li>可以用来删除数组中指定元素，并使用新的元素替换</li>
<li>使用 splice()会影响到原数组，会将指定元素从原数组中删除<br>该方法会将删除的元素封装到新数组中返回</li>
<li>参数：<ul>
<li>1.删除开始位置的索引 </li>
<li>2.删除的个数 </li>
<li>3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边</li>
</ul>
</li>
</ul>
</li>
<li>forEach() — <span class="desc">这个方法只支持 IE8 以上的浏览器</span><ul>
<li>需要一个回调函数作为参数</li>
<li>数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素</li>
<li>以实参的形式传递进来，我们可以来定义形参，来读取这些内容</li>
<li>浏览器会在回调函数中传递三个参数：<br>1.就是当前正在遍历的元素 value<br>2.就是当前正在遍历的元素的索引 index<br>3.就是正在遍历的数组本身</li>
</ul>
</li>
<li>concat()<ul>
<li>可以连接两个或多个数组，并将新的数组返回</li>
<li>该方法不会对原数组产生影响</li>
</ul>
</li>
<li>join()<ul>
<li>该方法可以将数组转换为一个字符串</li>
<li>该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回</li>
<li>在 join() 中可以指定一个字符串作为<span class="key_words">『参数』</span>，这个字符串将会成为数组中<span class="key_words">『元素的连接符』</span><br>如果不指定连接符，则默认使用,作为连接符</li>
</ul>
</li>
<li>reverse()<ul>
<li>该方法用来反转数组（前边的去后边，后边的去前边）<ul>
<li>该方法会直接修改原数组</li>
</ul>
</li>
</ul>
</li>
<li>sort() — 默认升序<ul>
<li>可以对一个数组中的内容进行排序，默认是按照 Unicode 编码进行排序，调用以后，会直接修改原数组。</li>
<li>在 sort()添加一个回调函数，来指定排序规则，<ul>
<li>回调函数中需要定义两个形参,浏览器会根据回调函数的返回值来决定元素的顺序</li>
<li>如果需要升序排列，则返回 a-b</li>
<li>如果需要降序排列，则返回 b-a</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对与Number类型</span></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 升序排列</span></span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line"><span class="comment">// 降序排列</span></span><br><span class="line"><span class="keyword">return</span> b - a;</span><br><span class="line">&#125;);</span><br><span class="line">- arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a.<span class="property">val</span>-b.<span class="property">val</span>) 降序</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于String类型</span></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul>
<li><p>去除数组中重复的数字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">		<span class="comment">//判断两个元素的值是否相等</span></span><br><span class="line">		<span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">			<span class="comment">//如果相等则证明出现了重复的元素，则删除j对应的元素</span></span><br><span class="line">			arr.<span class="title function_">splice</span>(j, <span class="number">1</span>)</span><br><span class="line">			<span class="comment">//使j自减</span></span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断一个数组内的元素是否都相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isEqual = (<span class="attr">list</span>: number[]): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> _list = list</span><br><span class="line">		.<span class="title function_">map</span>(<span class="function">(<span class="params">ele, index</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (index &lt; list.<span class="property">length</span> - <span class="number">1</span> &amp;&amp; ele === list[index + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;)</span><br><span class="line">		.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item)</span><br><span class="line">	<span class="keyword">return</span> _list.<span class="property">length</span> === list.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断两个数组是否相等，该情况下两边的数组顺序要一致<br>use1:使用 every 来判断数组两边的值是否相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr1.<span class="property">length</span> === arr2.<span class="property">length</span> &amp;&amp; arr1.<span class="title function_">every</span>(<span class="function">(<span class="params">item,index</span>) =&gt;</span> item === arr2[item])</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历数组是记录数组中最大(小)值？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> max = a[<span class="number">0</span>] <span class="comment">// 辅助变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr; i++) &#123;</span><br><span class="line">	max = <span class="title class_">Math</span>.<span class="title function_">max</span>(a[i], max)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计元素出现的次数？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>] <span class="comment">// 原数组</span></span><br><span class="line"><span class="keyword">let</span> cnt = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="comment">// 索引数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> nums) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i, <span class="keyword">typeof</span> i)</span><br><span class="line">	cnt[i] += <span class="number">1</span> <span class="comment">// 通过i，获取在cnt的对应索引就知道i出现多少次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-线程机制与事件机制</title>
    <url>/2024/10/31/JS/JS-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程:"></a>进程:</h3><ul>
<li>程序的一次执行, 它占有一片独有的内存空间</li>
<li>可以通过 windows 任务管理器查看进程</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程:"></a>线程:</h3><ul>
<li>是进程内的一个独立执行单元</li>
<li>是程序执行的一个完整流程</li>
<li>是 CPU 的最小的调度单元</li>
</ul>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li>一个进程中一般至少有一个运行的线程: 主线程</li>
<li>一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的</li>
<li>一个进程内的数据可以供其中的多个线程直接共享</li>
<li>多个进程之间的数据是不能直接共享的</li>
</ul>
<h3 id="浏览器运行是单进程还是多进程"><a href="#浏览器运行是单进程还是多进程" class="headerlink" title="浏览器运行是单进程还是多进程?"></a>浏览器运行是单进程还是多进程?</h3><ul>
<li>有的是单进程<ul>
<li>firefox</li>
<li>老版 IE</li>
</ul>
</li>
<li>有的是多进程<ul>
<li>chrome</li>
<li>新版 IE</li>
</ul>
</li>
<li>如何查看浏览器是否是多进程运行的呢?<ul>
<li>任务管理器&#x3D;&#x3D;&gt;进程</li>
</ul>
</li>
<li>浏览器运行都是<span class="key_words">『多线程』</span>运行的</li>
<li>单线程是局限与一个进程的概念，判断是否是单线程，看它是否在一个进程里面只有一个线程</li>
</ul>
<h2 id="浏览器内核模块组成"><a href="#浏览器内核模块组成" class="headerlink" title="浏览器内核模块组成"></a>浏览器内核模块组成</h2><ul>
<li>浏览器内核：支持浏览器运行的最核心的程序</li>
</ul>
<h3 id="不同浏览器的内核"><a href="#不同浏览器的内核" class="headerlink" title="不同浏览器的内核"></a>不同浏览器的内核</h3><ul>
<li>Chrome, Safari: webkit</li>
<li>firefox: Gecko</li>
<li>IE: Trident</li>
<li>360,搜狗等国内浏览器: Trident + webkit</li>
</ul>
<h3 id="内核的组成"><a href="#内核的组成" class="headerlink" title="内核的组成"></a>内核的组成</h3><ul>
<li>主线程<ul>
<li>js 引擎模块: 负责 js 程序的编译与运行</li>
<li>html,css 文档解析模块: 负责页面文本的解析</li>
<li>DOM&#x2F;CSS 模块: 负责 dom&#x2F;css 在内存中的相关处理</li>
<li>布局和渲染模块: 负责页面的布局和效果的绘制(内存中的对象)</li>
</ul>
</li>
<li>分线程<ul>
<li>定时器模块：负责定时器的管理</li>
<li>DOM 事件模块：负责事件的管理</li>
<li>网络请求模块：负责服务器请求(常规&#x2F;Ajax)</li>
</ul>
</li>
</ul>
<h2 id="js-线程"><a href="#js-线程" class="headerlink" title="js 线程"></a>js 线程</h2><ul>
<li>js 是单线程执行的(回调函数也是在主线程)</li>
<li>使用 H5 中的 Web Worker 是可以多线程运行</li>
<li>只能是主线程更新界面</li>
</ul>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ol>
<li><p>如何证明 js 执行是单线程的?</p>
<ul>
<li>setTimeout()的回调函数是在主线程执行的</li>
<li>定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行</li>
</ul>
</li>
<li><p>为什么 js 要用单线程模式, 而不用多线程模式?</p>
<ul>
<li>JavaScript 的单线程，与它的用途有关。</li>
<li>作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。</li>
<li>这决定了它只能是单线程，否则会带来很复杂的同步问题</li>
</ul>
</li>
<li><p>代码的分类:</p>
<ul>
<li>初始化代码</li>
<li>回调代码</li>
</ul>
</li>
<li><p>js 引擎执行代码的基本流程</p>
<ul>
<li>先执行初始化代码: 包含一些特别的代码<ul>
<li>回调函数(异步执行)</li>
<li>设置定时器</li>
<li>绑定事件监听</li>
<li>发送 ajax 请求</li>
</ul>
</li>
<li>后面在某个时刻才会执行回调代码</li>
</ul>
</li>
</ol>
<h2 id="定时器问题"><a href="#定时器问题" class="headerlink" title="定时器问题:"></a>定时器问题:</h2><ul>
<li>定时器并<span class="key_words">『不能保证真正完全定时』</span></li>
<li>如果在主线程执行了一个长时间的操作, 可能导致延时才处理</li>
<li>定时器回调函数是在主线程执行的, js 是单线程的</li>
<li>定时器的实现：事件循环模型</li>
</ul>
<h2 id="事件循环模型"><a href="#事件循环模型" class="headerlink" title="事件循环模型"></a>事件循环模型</h2><p><img src="/../../img/js/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8B.png" alt="事件循环模型"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="代码分类"><a href="#代码分类" class="headerlink" title="代码分类"></a>代码分类</h3><ul>
<li>初始化执行代码(同步代码): 包含绑定 dom 事件监听, 设置定时器, 发送 ajax 请求的代码</li>
<li>回调执行代码(异步代码): 处理回调逻辑</li>
</ul>
<h3 id="js-引擎执行代码的基本流程"><a href="#js-引擎执行代码的基本流程" class="headerlink" title="js 引擎执行代码的基本流程:"></a>js 引擎执行代码的基本流程:</h3><ul>
<li>初始化代码 &#x3D;&#x3D;&#x3D;&gt; 回调代码</li>
</ul>
<h3 id="模型的-2-个重要组成部分"><a href="#模型的-2-个重要组成部分" class="headerlink" title="模型的 2 个重要组成部分:"></a>模型的 2 个重要组成部分:</h3><ul>
<li>事件(定时器&#x2F;DOM 事件&#x2F;Ajax)管理模块</li>
<li>回调队列</li>
</ul>
<h3 id="模型的运转流程"><a href="#模型的运转流程" class="headerlink" title="模型的运转流程"></a>模型的运转流程</h3><ul>
<li>执行初始化代码, 将事件回调函数交给对应模块管理</li>
<li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</li>
<li>只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</li>
</ul>
<h2 id="H5-Web-Workers-js-分线程的实现"><a href="#H5-Web-Workers-js-分线程的实现" class="headerlink" title="H5 Web Workers (js 分线程的实现)"></a>H5 Web Workers (js 分线程的实现)</h2><ul>
<li>可以让 js 在分线程执行</li>
</ul>
<p><img src="/../../img/js/H5%20Web%20Workers(%E5%A4%9A%E7%BA%BF%E7%A8%8B).png" alt="Web Workers"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="相关-API"><a href="#相关-API" class="headerlink" title="相关 API"></a>相关 API</h3><ul>
<li>Worker: 构造函数, 加载分线程执行的 js 文件</li>
<li>Worker.prototype.onmessage: 用于接收另一个线程的回调函数</li>
<li>Worker.prototype.postMessage: 向另一个线程发送消息</li>
</ul>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足:"></a>不足:</h3><ul>
<li>worker 内代码不能操作 DOM 更新 UI</li>
<li>不是每个浏览器都支持这个新特性</li>
<li>不能跨域加载 JS</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装的worker.js文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n&lt;=<span class="number">2</span> ? <span class="number">1</span> : <span class="title function_">fibonacci</span>(n-<span class="number">1</span>) + <span class="title function_">fibonacci</span>(n-<span class="number">2</span>)  <span class="comment">//递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> number = event.<span class="property">data</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;分线程接收到主线程发送的数据: &#x27;</span>+number)</span><br><span class="line">  <span class="comment">//计算</span></span><br><span class="line">  <span class="keyword">var</span> result = <span class="title function_">fibonacci</span>(number)</span><br><span class="line">  <span class="title function_">postMessage</span>(result)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;分线程向主线程返回数据: &#x27;</span>+result)</span><br><span class="line">  <span class="comment">// alert(result)  alert是window的方法, 在分线程不能调用</span></span><br><span class="line">  <span class="comment">// 分线程中的全局对象不再是window, 所以在分线程中不可能更新界面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;数值&quot;</span> id=<span class="string">&quot;number&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;number&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	  <span class="keyword">var</span> number = input.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	  <span class="comment">//创建一个Worker对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	  <span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;worker.js&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	  <span class="comment">// 绑定接收消息的监听</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	  worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;主线程接收分线程返回的数据: &#x27;</span>+event.<span class="property">data</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	    <span class="title function_">alert</span>(event.<span class="property">data</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	  <span class="comment">// 向分线程发送消息</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	  worker.<span class="title function_">postMessage</span>(number)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;主线程向分线程发送数据: &#x27;</span>+number)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-运动与游戏开发</title>
    <url>/2024/10/31/JS/JS-%E8%BF%90%E5%8A%A8%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>通过循环不断使用 js 代码来改变元素的位置，样式，动画等</p>
</blockquote>
<h2 id="具备要素"><a href="#具备要素" class="headerlink" title="具备要素"></a>具备要素</h2><ul>
<li>canvas 元素(画布)：用于渲染游戏画面</li>
<li>audio 元素(音频)：用于添加音效和背景音乐</li>
<li>image 元素(图像)：用于加载游戏图像并在 canvas 中显示</li>
<li>浏览器中的计时函数和循环函数：用于实现动画</li>
</ul>
<h2 id="Canvas-关键"><a href="#Canvas-关键" class="headerlink" title="Canvas(关键)"></a>Canvas(关键)</h2><ul>
<li>步骤：开始路径 - 绘制路径 - 关闭路径 - 设置颜色 - 填充</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fill()</td>
<td>填充路径</td>
</tr>
<tr>
<td>stroke()</td>
<td>描边</td>
</tr>
<tr>
<td>arc()</td>
<td>创建圆弧</td>
</tr>
<tr>
<td>rect()</td>
<td>创建矩形</td>
</tr>
<tr>
<td>fillRect()</td>
<td>绘制矩形路径区域</td>
</tr>
<tr>
<td>strokeRect()</td>
<td>绘制矩形路径描边</td>
</tr>
<tr>
<td>clearRect()</td>
<td>在给定的矩形内清除指定的像素</td>
</tr>
<tr>
<td>arcTo()</td>
<td>创建两切线之间的弧&#x2F;曲线</td>
</tr>
<tr>
<td>beginPath()</td>
<td>起始一条路径，或重置当前路径</td>
</tr>
<tr>
<td>moveTo()</td>
<td>把路径移动到画布中的指定点，不创建线条</td>
</tr>
<tr>
<td>lineTo()</td>
<td>添加一个新点，然后在画布中创建从该点到最后指定点的线条</td>
</tr>
<tr>
<td>closePath()</td>
<td>创建从当前点回到起始点的路径</td>
</tr>
<tr>
<td>clip()</td>
<td>从原始画布剪切任意形状和尺寸的区域</td>
</tr>
<tr>
<td>quadraticCurveTo()</td>
<td>创建二次方贝塞尔曲线</td>
</tr>
<tr>
<td>bezierCurveTo()</td>
<td>创建三次方贝塞尔曲线</td>
</tr>
<tr>
<td>isPointInPath()</td>
<td>如果指定的点位于当前路径中，则返回 true，否则返回 false</td>
</tr>
</tbody></table>
<ul>
<li>语法: <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">context<span class="selector-class">.arc</span>(圆心 <span class="attribute">x</span> 的坐标,圆心 <span class="attribute">y</span> 的坐标, 半径, 起始角 sSingle,结束角 eSingle,false 顺时针 true 逆时针绘图)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="改变样式"><a href="#改变样式" class="headerlink" title="改变样式"></a>改变样式</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fillStyle</td>
<td>设置或返回用于填充绘画的颜色、渐变或模式</td>
</tr>
<tr>
<td>strokeStyle</td>
<td>设置或返回用于笔触的颜色、渐变或模式</td>
</tr>
<tr>
<td>shadowColor</td>
<td>设置或返回用于阴影的颜色</td>
</tr>
<tr>
<td>shadowBlur</td>
<td>设置或返回用于阴影的模糊级别</td>
</tr>
<tr>
<td>shadowOffsetX</td>
<td>设置或返回阴影距形状的水平距离</td>
</tr>
<tr>
<td>shadowOffsetY</td>
<td>设置或返回阴影距形状的垂直距离</td>
</tr>
</tbody></table>
<h3 id="直线添加样式"><a href="#直线添加样式" class="headerlink" title="直线添加样式"></a>直线添加样式</h3><table>
<thead>
<tr>
<th>样式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lineCap</td>
<td>设置或返回线条的结束端点样式</td>
</tr>
<tr>
<td>lineJoin</td>
<td>设置或返回两条线相交时，所创建的拐角类型</td>
</tr>
<tr>
<td>lineWidth</td>
<td>设置或返回当前的线条宽度</td>
</tr>
<tr>
<td>miterLimit</td>
<td>设置或返回最大斜接长度</td>
</tr>
</tbody></table>
<h3 id="设置渐变"><a href="#设置渐变" class="headerlink" title="设置渐变"></a>设置渐变</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>createLinearGradient()</td>
<td>创建线性渐变（用在画布内容上）</td>
</tr>
<tr>
<td>createPattern()</td>
<td>在指定的方向上重复指定的元素</td>
</tr>
<tr>
<td>createRadialGradient()</td>
<td>创建放射状&#x2F;环形的渐变（用在画布内容上）</td>
</tr>
<tr>
<td>addColorStop()</td>
<td>规定渐变对象中的颜色和停止位置</td>
</tr>
</tbody></table>
<h3 id="图形转换"><a href="#图形转换" class="headerlink" title="图形转换"></a>图形转换</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>scale()</td>
<td>缩放当前绘图至更大或更小</td>
</tr>
<tr>
<td>rotate()</td>
<td>旋转当前绘图</td>
</tr>
<tr>
<td>translate()</td>
<td>重新映射画布上的 (0,0) 位置</td>
</tr>
<tr>
<td>transform()</td>
<td>替换绘图的当前转换矩阵</td>
</tr>
<tr>
<td>setTransform()</td>
<td>将当前转换重置为单位矩阵，然后运行  transform()</td>
</tr>
</tbody></table>
<h3 id="图像绘制"><a href="#图像绘制" class="headerlink" title="图像绘制"></a>图像绘制</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">context.<span class="title function_">drawImage</span>(img,sx?,sy?,swidth?,sheight?,x,y,width?,height?);</span><br></pre></td></tr></table></figure>
<ul>
<li>drawImage():向画布上绘制图像、画布或视频</li>
<li>img：规定要使用的图像、画布或视频</li>
<li>sx：可选。开始剪切的 x 坐标位置</li>
<li>sy：可选。开始剪切的 y 坐标位置</li>
<li>swidth：可选。被剪切图像的宽度</li>
<li>sheight：可选。被剪切图像的高度</li>
<li>x：在画布上放置图像的 x 坐标位置</li>
<li>y：在画布上放置图像的 y 坐标位置</li>
<li>width：可选。要使用的图像的宽度（伸展或缩小图像）</li>
<li>height：可选。要使用的图像的高度（伸展或缩小图像）</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-遍历对象与映射</title>
    <url>/2024/10/31/JS/JS-%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><ol>
<li>遍历对象所有的可枚举属性（<span class="desc">自有的+继承的属性</span>），使用 for…in</li>
<li>遍历对象自有的所有可枚举属性（<span class="desc">非继承属性</span>），使用 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>() </span><br><span class="line">或 </span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span> + <span class="title class_">Objec</span>.<span class="title function_">hasOwnProperty</span>()</span><br></pre></td></tr></table></figure></li>
<li>获取对象所有继承属性（<span class="desc">非自有属性</span>），可以使用 for…in + Object.keys()</li>
<li>遍历对象自有的所有可枚举和不可枚举属性（<span class="desc">非继承属性</span>），使用 Object.getOwnPropertyNames()</li>
<li>获取对象自有的所有可枚举、不可枚举属性和继承属性，使用 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span> + <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj) </span><br><span class="line">或 </span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span> + <span class="title class_">Object</span>.<span class="title function_">keys</span>() + <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Scarlett&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">37</span>,</span><br><span class="line">	<span class="attr">occupation</span>: <span class="string">&#x27;actress&#x27;</span>, <span class="comment">// 不可枚举属性</span></span><br><span class="line">	[<span class="title class_">Symbol</span>()]: <span class="string">&#x27;Johansson&#x27;</span>, <span class="comment">// symbol</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Reflect-ownKeys-⭐"><a href="#Reflect-ownKeys-⭐" class="headerlink" title="Reflect.ownKeys() ⭐"></a>Reflect.ownKeys() ⭐</h3><ul>
<li>返回指定对象自身的所有属性（<span class="desc">包含不可枚举属性和 Symbol 属性</span>）组成的数组。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">它的返回值等同于 </span><br><span class="line">	<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(target).<span class="title function_">concat</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(target))</span><br></pre></td></tr></table></figure></li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接上demo</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj).<span class="title function_">map</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">name Scarlett</span></span><br><span class="line"><span class="comment">age 37</span></span><br><span class="line"><span class="comment">occupation actress</span></span><br><span class="line"><span class="comment">Symbol() &quot;Johansson&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><ul>
<li>用于以任意顺序遍历对象所有的可枚举属性（<span class="desc">包括对象自身的和继承的可枚举属性，不含 Symbol 属性</span>）</li>
<li>示例:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// name age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><ul>
<li><p>可以使用的范围包括 Array、Set 和 Map 结构、类数组对象（<span class="desc">比如 arguments 对象、DOM NodeList 对象</span>）、字符串等</p>
</li>
<li><p>类数组对象</p>
<ul>
<li>虽然不是所有的类数组对象都具有 Iterator 接口，但可以使用 Array.from()方法转化</li>
</ul>
</li>
<li><p>示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串 | arguments对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str | <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DOM元素集合</span></span><br><span class="line"><span class="keyword">let</span> domList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;p&#x27;</span>) <span class="comment">// 选择器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> domList) &#123;</span><br><span class="line">	p.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通对象</p>
<ul>
<li>不能直接使用 for…of 结构，需要使用 Object.keys()方法将对象的键名生成一个数组，然后遍历。<ul>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><ul>
<li>该方法接收一个对象为参数，返回一个数组，包含该对象自有的可枚举属性（<span class="desc">不含继承的和 Symbol 属性</span>），数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致</li>
<li>该方法如果参数不是一个对象，将被强制转换为一个对象。</li>
<li>只能遍历对象的可枚举属性</li>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">map</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// name  age</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Object-entries-—-ES8"><a href="#Object-entries-—-ES8" class="headerlink" title="Object.entries() — ES8"></a>Object.entries() — ES8</h3><ul>
<li>返回指定对象自身的可枚举属性的键值对（<span class="desc">不含继承的和 Symbol 属性</span>）数组</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj); <span class="comment">// [[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Object-values-—-ES8"><a href="#Object-values-—-ES8" class="headerlink" title="Object.values() — ES8"></a>Object.values() — ES8</h3><ul>
<li>返回指定对象自身的所有可枚举属性的值（<span class="desc">不含继承的和 Symbol 属性</span>）组成的数组</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj);         <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><ul>
<li>接收一个对象为参数，返回该对象所有可枚举和不可枚举属性的属性名（<span class="desc">不含 Symbol 属性</span>）组成的数组。<ul>
<li>for…in 结合 Object.getOwnPropertyNames() 获取对象自有的所有可枚举、不可枚举属性和继承属性<ul>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getAllPropertyNames</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> props = <span class="title class_">Object</span>.<span class="title function_">assign</span>([], <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj))</span><br><span class="line">	<span class="comment">// 得到所有的可枚举属性（自有的和继承的属性）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">		<span class="comment">// 过滤自有的不可枚举属性</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj).<span class="title function_">includes</span>(key)) &#123;</span><br><span class="line">			props.<span class="title function_">push</span>(key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> props</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getAllPropertyNames</span>(obj) <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;occupation&quot;, &quot;nationality&quot;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h3><ul>
<li>返回指定对象自身所有的 Symbol 属性的数组。</li>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj).<span class="title function_">map</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]) <span class="comment">// Symbol() &quot;Johansson&quot;, Symbol(aa) &quot;localSymbol&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>遍历对象</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2024/11/01/JS/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<p><img src="/../../img/Engineering/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="设计模式"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="高内聚，低耦合（五大基本原则SOLID简写）"><a href="#高内聚，低耦合（五大基本原则SOLID简写）" class="headerlink" title="高内聚，低耦合（五大基本原则SOLID简写）"></a>高内聚，低耦合（五大基本原则SOLID简写）</h2><ul>
<li>高层模块不依赖底层模块，即为依赖反转原则。</li>
<li>内部修改关闭，外部扩展开放，即为开放封闭原则。</li>
<li>聚合单一功能，即为单一功能原则。</li>
<li>低知识要求，对外接口简单，即为迪米特法则。</li>
<li>耦合多个接口，不如独立拆分，即为接口隔离原则。</li>
<li>合成复用，子类继承可替换父类，即为里式替换原则</li>
</ul>
<h2 id="为什么封装代码？"><a href="#为什么封装代码？" class="headerlink" title="为什么封装代码？"></a>为什么封装代码？</h2><ol>
<li>不会让内部变量污染外部</li>
<li>封装好的代码可以作为一个模块给外部调用</li>
<li>对扩展开放，对修改关闭，即开放关闭原则。外部不能修改内部源码，保证了内部的正确性；又留出扩展接口，提高灵活性。</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>在软件设计、开发过程中，针对特定场景、特定问题的较优解决方案。</li>
<li>一共分为3大类23种，下面为常用的几种：<ul>
<li>创建型模式：单例模式、工厂模式</li>
<li>结构型模式：适配器模式、装饰器模式</li>
<li>行为型模式：策略模式、观察者模式、发布订阅模式、访问者模式</li>
</ul>
</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>一个类只有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<ul>
<li>实现方法：<ul>
<li>Singleton: 特定类，需要访问的类</li>
<li>instance：单例，特定类的实例</li>
<li>getInstance: 获取单例的方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingLeton</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title class_">Singleton</span>.<span class="property">_instance</span>)&#123;</span><br><span class="line">            <span class="title class_">Singleton</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Singleton</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Singleton</span>.<span class="property">_instance</span> <span class="comment">//存在实例就返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1===s2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>举例：vuex的store</li>
<li>优点：节约资源，保证访问的一致性。</li>
<li>缺点：扩展性不友好，因为单例模式没有接口</li>
<li>场景：<ul>
<li>如果一个类实例化过程消耗资源比较多，可以使用单例避免性能浪费</li>
<li>需要公共状态，可以使用单例保证访问一致性。</li>
</ul>
</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p>根据不同的，返回不同类的实例<br>核心思想：将对象的创建与对象的实现分离</p>
</blockquote>
<ul>
<li>实现方法：<ul>
<li>Visitor：访问者，访问共仓的方法</li>
<li>Factory；工厂，负责返回产品实例</li>
<li>Product：产品，访问者从工厂拿到的产品实例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">tag, data,children</span>)&#123;</span><br><span class="line">  <span class="comment">//各种判断 判断生成什么样的Vnode</span></span><br><span class="line">  <span class="keyword">if</span>(!tag)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">craeteEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(tag,data,children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>举例：document.createElement创建DOM元素,createElement(‘标签名’)</li>
<li>优点：良好的封装，扩展性良好，解耦了高层逻辑和底层产品类</li>
<li>缺点：给系统增加了抽象性，带来了额外的系统复杂度，不能滥用</li>
<li>场景：对象创建复杂，访问者无需了解创建过程。需要处理大量又相同、相似属性的小对象</li>
</ul>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p>用于解决兼容问题，接口&#x2F;方法&#x2F;数据不兼容，将其转换成访问者期望的格式进行使用。</p>
</blockquote>
<ul>
<li>必须包含目标（Target）、源（Adaptee）和适配器（Adapter）三个角色。</li>
<li>优点：可以使原有逻辑得到更好的复用，有助于避免大规模改写现有代码</li>
<li>缺点：会让系统变得零乱，明明调用 A，却被适配到了 B，不能滥用。</li>
<li>场景：<ul>
<li>想要使用一个已经存在的对象，但是接口不满足需求</li>
<li>想要创建一个可以复用的对象，而且确定需要和一些不兼容的对象一起工作</li>
</ul>
</li>
<li>使用：前提有多个不同接口的数据<ul>
<li>定义一个同意的数据结构</li>
<li>通过适配器模块，适配成访问者索要访问的数据格式</li>
<li>将多个不同接口的数据在这里定义号类型，然后其中的相似数据通过调用一个函数转换成一致的类型，然后适配器哪里每一个接口都遍历数据单独返回给对应接口，最终返回适配器列表。通过打.对应的列表。</li>
</ul>
</li>
</ul>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><blockquote>
<p>在不改变原对象的基础上，增加新属性、方法、功能（一个对象被另一个对象包装，在原对象上增加功能）</p>
</blockquote>
<ul>
<li>优点：对象的核心职责和装饰器功能去分开，可以通过动态增删装饰目标对象中的装饰逻辑</li>
</ul>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p>定义一系列算法，根据输入的参数决定使用哪个算法</p>
</blockquote>
<ul>
<li>举例： 双十一满减的活动，表单验证</li>
<li>优点：<ol>
<li>策略相互独立，可以互相切换。</li>
<li>提高了灵活性以及复用性，维护性。</li>
<li>可扩展性好，满足开闭原则。</li>
</ol>
</li>
<li>缺点：<ol>
<li>策略相互独立，一些复杂的算法逻辑无法共享，造成资源浪费。</li>
<li>用户在使用策略时，需要了解具体的策略实现。</li>
<li>不满足最少知识原则，增加了使用成本。</li>
</ol>
</li>
<li>场景：<ul>
<li>算法需要自由切换的场景。</li>
<li>多个算法只有行为上有些不同，可以考虑策略模式动态选择算法。</li>
<li>需要多重判断，可以考虑策略模式规避多重条件判断。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> priceCalculate = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> discountMap = &#123;</span><br><span class="line">    <span class="string">&#x27;discount200-20&#x27;</span>: <span class="keyword">function</span>(<span class="params">price</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> price - <span class="title class_">Math</span>.<span class="title function_">floor</span>(price / <span class="number">200</span>) * <span class="number">20</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;discount300-50&#x27;</span>: <span class="keyword">function</span>(<span class="params">price</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> price - <span class="title class_">Math</span>.<span class="title function_">floor</span>(price/<span class="number">300</span>) * <span class="number">50</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;discount500-100&#x27;</span>: <span class="keyword">function</span>(<span class="params">price</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> price - <span class="title class_">Math</span>.<span class="title function_">floor</span>(price/<span class="number">500</span>) * <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">addStategy</span>(<span class="params">stategyName,fn</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(discountMap[stategyName]) <span class="keyword">return</span>;</span><br><span class="line">        discountMap[stategyName] = fn;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">priceCal</span>(<span class="params">discountType,price</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> discountMap[discountType] &amp;&amp; discountMap[discountType](price);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">  <span class="comment">// 使用</span></span><br><span class="line">  priceCalculate.<span class="title function_">priceCal</span>(<span class="string">&#x27;discount200-20&#x27;</span>,<span class="number">250</span>); <span class="comment">// 230</span></span><br><span class="line">  priceCalculate.<span class="title function_">addStategy</span>(<span class="string">&#x27;discount800-200&#x27;</span>,<span class="keyword">function</span>(<span class="params">price</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> price - <span class="title class_">Math</span>.<span class="title function_">floor</span>(price/<span class="number">800</span>) * <span class="number">200</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p>一个对象（称为subject）维持一系列依赖于它的对象（称为observer），将有关状态的任何变更自动通知给它们（观察者）。</p>
</blockquote>
<ul>
<li>观察者模式中的角色有两类：观察者和被观察者。</li>
<li>优点：目标变化就会通知观察者，这是观察者模式最大的优点。</li>
<li>缺点：不灵活。目标和观察者是耦合在一起的，要实现观察者模式，必须同时引入被观察者和观察者才能达到响应式的效果。</li>
<li>实现：被观察者的类要添加&#x2F;移除&#x2F;通知观察者；观察者的类中要根据被观察者更新</li>
</ul>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><blockquote>
<p>基于一个主题&#x2F;事件通道，希望接收通知的对象（称为subscriber）通过自定义事件订阅主题，被激活事件的对象（称为publisher）通过发布主题事件的方式被通知。</p>
</blockquote>
<ul>
<li>发布-订阅模式的角色有两类：发布者和订阅者</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventEmitter</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type] = <span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type].<span class="title function_">filter</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> event !== fn;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布</span></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">type</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventEmitter</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">event</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Vue 双向绑定通过数据劫持和发布-订阅模式实现。<ol>
<li>通过DefineProperty劫持各个数据的setter和getter，并为每个数据添加一个订阅者列表，这个列表将会记录所有依赖这个数据的组件。响应式后的数据相当于消息的发布者。</li>
<li>每个组件都对应一个Watcher订阅者，当组件渲染函数执行时，会将本组件的Watcher加入到所依赖的响应式数据的订阅者列表中。相当于完成了一次订阅，这个过程叫做“依赖收集”。</li>
<li>当响应式数据发生变化时，会出setter，setter负责通知数据的订阅者列表中的Watcher，Watcher触发组件重新渲染来更新视图。视图层相当于消息的订阅者。</li>
</ol>
</li>
</ul>
<p><img src="/../../img/Engineering/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E4%B8%8E%E8%A7%82%E5%AF%9F%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB.webp" alt="发布订阅者与观察者的区别"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="观察者模式与发布订阅者模式的区别"><a href="#观察者模式与发布订阅者模式的区别" class="headerlink" title="观察者模式与发布订阅者模式的区别"></a>观察者模式与发布订阅者模式的区别</h2><ul>
<li>观察者模式：<ul>
<li>媒介： 观察者 –&gt; 被观察者(一有变化就通知被观察者)</li>
<li>方式： 同步，即当发生某些事件时，主题调用其所有观察者的适当方法3</li>
<li>松耦合： 观察者和被观察者松散耦合</li>
</ul>
</li>
<li>发布订阅者模式：<ul>
<li>媒介： 发布者 –&gt; 中间代理 –&gt; 订阅者 （通过中间代理通信）</li>
<li>方式： 异步（使用消息队列）</li>
<li>松耦合： 组件与观察者模式完全分离</li>
<li>模式： 更像是一种跨应用程序模式，可以驻留在两个不同的应用程序中。每一个都通过消息代理或消息队列进行通信。</li>
</ul>
</li>
</ul>
<h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h2><ul>
<li>优点：</li>
</ul>
<ol>
<li>时间解耦：注册的订阅行为由发布者决定何时调用，订阅者无需持续关注，由发布者负责通知。</li>
<li>对象解耦：发布者无需知道消息的接受者，只需遍历订阅该消息类型的订阅者发送消息，解耦了发布者和订阅者之间的联系，互不持有，都依赖于抽象。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>资源消耗：创建订阅者需要一定的时间和内存。</li>
<li>增加复杂度：弱化了联系，难以维护调用关系，增加了理解成本。</li>
</ol>
<ul>
<li>场景：各模块相互独立，存在一对多的依赖关系，依赖模块不稳定、依赖关系不稳定，各模块由不同的人员开发</li>
</ul>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><blockquote>
<p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于其内部各个元素的新操作。访问者模式是一种将数据操作和数据结构分离的设计模式</p>
</blockquote>
<ul>
<li>场景：<ul>
<li>对象结构比较稳定，但经常需要在此对象结构上定义新的操作。</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ul>
</li>
<li>实现：<ul>
<li>在每个员工的类中添加以下语句和各自对应的方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="title function_">accept</span>(<span class="params">Visitor visitor</span>)&#123;</span><br><span class="line">  visitor.<span class="title function_">visit</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在员工的基类中定义好共同的方法和核心方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">public abstract <span class="keyword">void</span> <span class="title function_">accept</span>(<span class="title class_">Visitor</span> visitor)</span><br></pre></td></tr></table></figure></li>
<li>然后汇集到员工业务报表，并为访问者提供接口。</li>
<li>定义Visitor的方法，访问员工，然后领导可以根据自己要访问的要求找到对应的数据。<ul>
<li>Visitor：<ul>
<li>接口或者抽象类，定义了对每个 Element 访问的行为</li>
<li>参数: 被访问的元素，方法个数理论上与元素的个数是一样的，</li>
<li>因此，访问者模式要求元素的类型要稳定，如果经常添加、移除元素类，说明不适合使用访问者模式。</li>
</ul>
</li>
<li>ConcreteVisitor：<ul>
<li>具体的访问者，它需要给出对每一个元素类访问时所产生的具体行为。</li>
</ul>
</li>
<li>Element：<ul>
<li>元素接口或者抽象类，它定义了一个接受访问者（accept）的方法，其意义是指每一个元素都要可以被访问者访问。</li>
</ul>
</li>
<li>ElementA、ElementB：<ul>
<li>具体的元素类，它提供接受访问的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li>
</ul>
</li>
<li>ObjectStructure：<ul>
<li>定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素提供访问者访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>优点：</li>
</ul>
<ol>
<li>各角色责职分离，符合单一职责原则</li>
<li>具有优秀的扩展性</li>
<li>灵活性</li>
<li>使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>具体元素对访问者公布细节，违反了迪米特原则</li>
<li>具体元素变更时导致修改成本大</li>
<li>违反了依赖倒置原则，位类达到“区别对待”而依赖了具体类，没有依赖抽象<br><img src="/../../img/Engineering/UML%E8%AE%BE%E8%AE%A1%E5%9B%BE.webp" alt="UML设计图"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-定时器与延时器</title>
    <url>/2024/11/19/JS/%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E5%BB%B6%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><ul>
<li><span class="key_words">『用于重复执行一个函数或代码片段』</span>，每次调用之间都有一个<span class="key_words">『固定的时间』</span>延迟。它</li>
<li>参数：<ol>
<li>回调函数，该函数会每隔一段时间被调用一次</li>
<li>每次调用间隔的时间，单位是毫秒</li>
</ol>
</li>
<li>返回值：<ul>
<li>返回一个 Number 类型的数据，这个数字用来作为定时器的唯一标识</li>
</ul>
</li>
<li>当调用 setInterval 时，它会在<span class="key_words">『初始延迟后安排执行』</span>指定的函数的第一次执行。随后的执行将根据指定的延迟重复发生。(<span class="desc">所以如果要从0毫秒开始执行，要提前调用指定函数</span>)</li>
<li>注意:<span class="key_words">『setInterval 不是完全精确的。』</span></li>
<li>可以接受无限数量的参数</li>
</ul>
<h3 id="clearInterval"><a href="#clearInterval" class="headerlink" title="clearInterval"></a>clearInterval</h3><ul>
<li>取消先前通过调用 setInterval 建立的定时重复操作</li>
<li>参数：setInterval 返回的间隔 ID</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>编辑应用中的自动保存</li>
<li>动画和幻灯片播放定时</li>
<li>基于时间的提醒</li>
<li>间隔取消</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cancellable</span>(<span class="params">fn: <span class="built_in">Function</span>, args: any[], t: number</span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>(...args); <span class="comment">// 从0开始执行</span></span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="title function_">fn</span>(...args), t); <span class="comment">// 从t开始执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">cancelFn</span> = (<span class="params"></span>) =&gt; <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    <span class="keyword">return</span> cancelFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="延时器"><a href="#延时器" class="headerlink" title="延时器"></a>延时器</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><ul>
<li>允许在指定的延迟之后安排一个函数的执行</li>
<li>接受无限数量的参数，但通常前两个参数总是要执行的函数和以毫秒为单位的延迟时间。</li>
</ul>
<h3 id="clearTimeout"><a href="#clearTimeout" class="headerlink" title="clearTimeout"></a>clearTimeout</h3><ul>
<li>取消先前通过调用 setTimeout 建立的延时操作</li>
<li>参数：setTimeout 返回的间隔 ID</li>
</ul>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li>当调用 setTimeout 时，它启动一个计时器，并设置它在指定的延迟后运行</li>
<li>在延迟到期后，JavaScript事件循环将指定的函数放入执行队列。</li>
<li>一旦调用堆栈为空，函数就会被执行，其中的任何相关代码都会运行。</li>
<li>如果在延迟到期之前取消了 setTimeout 函数，计划的函数将不会被执行。</li>
</ul>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delayedFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;延迟函数执行！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> delay = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timerId = <span class="built_in">setTimeout</span>(delayedFunction, delay);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在延迟到期之前取消执行：</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timerId);</span><br></pre></td></tr></table></figure>

<h2 id="延时器和定时器的区别"><a href="#延时器和定时器的区别" class="headerlink" title="延时器和定时器的区别"></a>延时器和定时器的区别</h2><ul>
<li>定时调用会执行多次，而延时调用只会执行一次</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>定时器</tag>
        <tag>延时器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存</title>
    <url>/2024/10/31/JS/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>浏览器端存储 API：cookie、localStorage、sessionStorage、IndexedDB</li>
<li>源专用文件系统（Origin Private File System，简称 OPFS）</li>
</ul>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul>
<li>数据会以字符串键值对的形式存储在本地，数据会<span class="key_words">『自动的传递到服务器』</span></li>
<li>cookie设置的<span class="key_words">『过期时间之前一直有效』</span></li>
<li><span class="key_words">『cookie数据大小』</span>不能超过4k</li>
<li>与服务端通信时，每次都会携带在请求中的 header 中，影响安全和请求的性能</li>
</ul>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><ul>
<li>数据会以字符串键值对的形式存储在本地</li>
<li>数据在<span class="key_words">『当前浏览器窗口关闭后自动删除』</span></li>
<li>数据大小不能超过 5M</li>
<li>如果存储的 value 是对象或数据，最好使用 JSON.stringify() 转化，拿的时候 JSON.parse()</li>
<li>使用：<ul>
<li>存储：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;value&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>获取：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>删除对应 key 中的数据：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>删除所有保存的数据：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注：<ul>
<li>如果存储的 value 是对象或数据，最好使用 JSON.stringify() 转化，拿的时候 JSON.parse()</li>
<li>getItem(xxx)，如果 xxx 对应的 value 获取不到，那么 getItem 的返回值是 null</li>
<li>JSON.parse(null) 的结果依然是 null</li>
</ul>
</li>
</ul>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><ul>
<li>数据会以字符串键值对的形式存储在本地</li>
<li><span class="key_words">『永久存储』</span>，浏览器关闭后数据不丢失除非主动删除数据；</li>
<li>数据大小不能超过 5M</li>
<li>使用：<ul>
<li>存储：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;value&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>获取：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>删除对应 key 中的数据：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>删除所有保存的数据：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注：<ul>
<li>如果存储的 value 是对象或数据，最好使用 JSON.stringify() 转化，拿的时候 JSON.parse()</li>
<li>getItem(xxx): 如果 xxx 对应的 value 获取不到，那么 getItem 的返回值是 null</li>
<li>JSON.parse(null) 的结果依然是 null</li>
</ul>
</li>
</ul>
<h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><ul>
<li>非关系型数据库，数据存储在数据库中</li>
<li>除非被清理，否则一直存在</li>
<li>通常 数百 MB 到 几 GB</li>
<li>术语：<ul>
<li>数据库：IDBDatabase 对象</li>
<li>对象仓库：IDBObjectStore 对象(<span class="desc">相当于数据库中的表</span>)</li>
<li>索引：IDBIndex 对象</li>
<li>事务：IDBTransaction 对象(<span class="desc">数据记录的读写和删改，都要通过事务完成</span>) </li>
<li>操作请求：IDBRequest 对象</li>
<li>指针： IDBCursor 对象</li>
<li>主键集合：IDBKeyRange 对象</li>
</ul>
</li>
<li>使用:<ul>
<li><p>打开数据库：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="variable language_">window</span>.<span class="property">indexedDB</span>.<span class="title function_">open</span>(<span class="attr">databaseName</span>: string, <span class="attr">version</span>: number)</span><br></pre></td></tr></table></figure></li>
<li><p>定义一个数据库存储对象：let db;</p>
</li>
<li><p>打开数据库成功的处理器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onsucess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; db = event.<span class="property">target</span>.<span class="property">result</span>;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>打开数据库失败的处理器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;数据库错误：&quot;</span>,$&#123;event.<span class="property">target</span>.<span class="property">errorCode</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个新的数据库或者增加已存在的数据库的版本号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>; <span class="comment">// 保存 IDBDatabase 接口</span></span><br><span class="line">	<span class="keyword">const</span> objectStore; <span class="comment">// 新建对象仓库</span></span><br><span class="line">	<span class="keyword">if</span> (!db.<span class="property">objectStoreNames</span>.<span class="title function_">contains</span>(<span class="string">&#x27;tableName&#x27;</span>)) &#123; <span class="comment">// 判断该数据库是否存在该表，不存在则创建</span></span><br><span class="line">		objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;tableName&quot;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&quot;primary key&quot;</span> &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	objectStore.<span class="title function_">createIndex</span>(<span class="string">&#x27;indeName&#x27;</span>, <span class="string">&#x27;indexProperty&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;) <span class="comment">// 新建索引，unique: 是否包含重复的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增数据：通过事务完成</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> request = db.<span class="title function_">transaction</span>([<span class="string">&#x27;tableName&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">		.<span class="title function_">objectStore</span>(<span class="string">&#x27;tableName&#x27;</span>)</span><br><span class="line">		.<span class="title function_">add</span>(&#123; primary <span class="attr">key</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>:<span class="number">10</span>&#125;) <span class="comment">// 添加数据</span></span><br><span class="line"></span><br><span class="line">	request.<span class="property">onsucess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据写入成功&#x27;</span>)&#125;</span><br><span class="line">	request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据写入失败&#x27;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>读取数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">read</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&#x27;tableName&#x27;</span>])</span><br><span class="line">	<span class="keyword">const</span> objectStore = transaction.<span class="title function_">objectStore</span>(<span class="string">&#x27;tableName&#x27;</span>)</span><br><span class="line">	<span class="keyword">const</span> request = objectStore.<span class="title function_">get</span>(<span class="number">1</span>) <span class="comment">// get的参数时主键的值</span></span><br><span class="line"></span><br><span class="line">	request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事务失败&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (request.<span class="property">result</span>) &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Name:&#x27;</span> + request.<span class="property">result</span>.<span class="property">name</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;未获得数据记录&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">readAll</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> objectStore = db.<span class="title function_">transaction</span>(<span class="string">&#x27;tableName&#x27;</span>).<span class="title function_">objectStore</span>(<span class="string">&#x27;tableName&#x27;</span>)</span><br><span class="line">	objectStore.<span class="title function_">openCursor</span>().<span class="property">onsucess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span></span><br><span class="line">		<span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Primary Key:&#x27;</span> + cursor.<span class="property">key</span>) <span class="comment">// 获取主键</span></span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Name:&#x27;</span> + cursor.<span class="property">value</span>.<span class="property">name</span>) <span class="comment">// 其余键值以这种方式获取</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有更多数据&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">readAll</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">update</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> request = db.<span class="title function_">transaction</span>([<span class="string">&#x27;tableName&#x27;</span>],<span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">		.<span class="title function_">objectStore</span>(<span class="string">&#x27;tableName&#x27;</span>)</span><br><span class="line">		.<span class="title function_">put</span>(&#123; primary <span class="attr">key</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>:<span class="number">10</span>&#125;) <span class="comment">// 自动更新primary key为1的记录</span></span><br><span class="line">	request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据更新成功&#x27;</span>) &#125;</span><br><span class="line">	request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据更新失败&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">update</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">remove</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> request = db</span><br><span class="line">		.<span class="title function_">transaction</span>([<span class="string">&#x27;tableName&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">		.<span class="title function_">objectStore</span>(<span class="string">&#x27;tableName&#x27;</span>)</span><br><span class="line">		.<span class="title function_">delete</span>(<span class="number">1</span>) <span class="comment">// 通过主键去删除对应的记录</span></span><br><span class="line">	request.<span class="property">onsucess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">		conosle.<span class="title function_">log</span>(<span class="string">&#x27;数据删除成功&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">remove</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">设：存在objectStore.<span class="title function_">createIndex</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, &#123;<span class="attr">unique</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">取：</span><br><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&#x27;tableName&#x27;</span>], <span class="string">&#x27;readonly&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> store = transacton.<span class="title function_">objectStore</span>(<span class="string">&#x27;tableName&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> index = store.<span class="title function_">index</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> request = index.<span class="title function_">get</span>(<span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">request.<span class="property">onsucess</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> result = e.<span class="property">target</span>.<span class="property">result</span></span><br><span class="line">	<span class="keyword">if</span> (result) &#123; ... &#125; <span class="keyword">else</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="OPFS"><a href="#OPFS" class="headerlink" title="OPFS"></a>OPFS</h3><ul>
<li>存储空间数 GB 到几十 GB，有设备磁盘空间决定。</li>
<li>时效性： 持久存储，除非手动清除或用户明确授权清理数据</li>
<li>性能：直接对文件操作，支持流式处理，可以在主线程或 web worker 中使用</li>
<li>API：提供类 Unix 文件系统的 API，如 mkdir、open、close、read、write</li>
<li>属于页面私有，用户需通过对应的浏览器插件，查看存储的文件</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>案例-点击空白关闭弹窗</title>
    <url>/2024/10/31/JS/%E7%82%B9%E5%87%BB%E7%A9%BA%E7%99%BD%E5%85%B3%E9%97%AD%E5%BC%B9%E7%AA%97/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<p>方案一：监听 document.body 的点击事件，如果来源不在目标范围内则关闭</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">mouseup</span>(<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> _con = $(<span class="string">&#x27; 目标区域 &#x27;</span>);   <span class="comment">// 设置目标区域</span></span><br><span class="line">  <span class="keyword">if</span>(!_con.<span class="title function_">is</span>(e.<span class="property">target</span>) &amp;&amp; _con.<span class="title function_">has</span>(e.<span class="property">target</span>).<span class="property">length</span> === <span class="number">0</span>)&#123; <span class="comment">// Mark 1</span></span><br><span class="line">    some code...   <span class="comment">// 功能代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/* Mark 1 的原理：</span></span><br><span class="line"><span class="comment">判断点击事件发生在区域外的条件是：</span></span><br><span class="line"><span class="comment">1. 点击事件的对象不是目标区域本身</span></span><br><span class="line"><span class="comment">2. 事件对象同时也不是目标区域的子元素</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>方案二：在弹窗下、所有页面内容上放一个遮罩，点遮罩关闭<br>方案三：利用事件冒泡和 setTimeout 跳出事件队列的方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;shard&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>clickMe<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span>show<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $(<span class="string">&#x27;#shard&#x27;</span>).<span class="title function_">hide</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $(<span class="string">&#x27;#button&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      $(<span class="string">&#x27;#content&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;display&#x27;</span>,<span class="string">&#x27;block&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      $(<span class="string">&#x27;#shard&#x27;</span>).<span class="title function_">off</span>(<span class="string">&#x27;click&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      $(<span class="string">&#x27;#shard&#x27;</span>).<span class="title function_">hide</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          $(<span class="string">&#x27;#shard&#x27;</span>).<span class="title function_">show</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          $(<span class="string">&#x27;#shard&#x27;</span>).<span class="title function_">one</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click ...&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              $(<span class="string">&#x27;#content&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;display&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              $(<span class="string">&#x27;#shard&#x27;</span>).<span class="title function_">hide</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          , <span class="number">0</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-JS算法的核心知识</title>
    <url>/2024/10/31/JS/%E7%AE%97%E6%B3%95%EF%BC%9AJS%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<p>算常数总和-性能好-时间复杂度 O(1)：<br>飞蛾公式： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(n / 2) \*(1 + n)</span><br></pre></td></tr></table></figure>

<h2 id="题库：leetcode"><a href="#题库：leetcode" class="headerlink" title="题库：leetcode"></a>题库：leetcode</h2><ul>
<li>性能上：for &gt; forEach &gt; map</li>
<li>for in 是键值的遍历，for of 是 es6 的产物，是迭代器的遍历方式，需要判断遍历对象是否存在</li>
<li>本质上 forEach 和 map 是用来遍历 Array</li>
<li>反转字符串：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">prev,curr</span>)=&gt;</span>prev+curr)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="时-空间复杂度"><a href="#时-空间复杂度" class="headerlink" title="时&#x2F;空间复杂度"></a>时&#x2F;空间复杂度</h2><ul>
<li><a href="/2024/10/31/network/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="时&#x2F;空间复杂度">时&#x2F;空间复杂度</a></li>
</ul>
<h3 id="计算时间复杂度？"><a href="#计算时间复杂度？" class="headerlink" title="计算时间复杂度？"></a>计算时间复杂度？</h3><h4 id="求数字的总和"><a href="#求数字的总和" class="headerlink" title="求数字的总和"></a>求数字的总和</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">50</span>]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sumNumbers</span>(<span class="params">numbers</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, curNum</span>) =&gt;</span> sum + curNum, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sumNumbers</span>(numbers))</span><br><span class="line"><span class="comment">//T = 3 + n ==&gt; O(n) ==&gt; Linear Time Complexity ==&gt; 最好的结果，性能好</span></span><br></pre></td></tr></table></figure>

<h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n = 5</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">1</span>] <span class="comment">// 1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="comment">// 1</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Running&#x27;</span>) <span class="comment">// n-1，可以在循环中写一个log，控制台可以看到它执行多少次</span></span><br><span class="line">		numbers.<span class="title function_">push</span>(numbers[i - <span class="number">2</span>] + numbers[i - <span class="number">1</span>]) <span class="comment">// n-1次</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> numbers[n] <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// T = 1 + 1 + 1 + 2(n - 1) = 3 + 2n - 2 = 1 + 2n ==&gt; O(n) ==&gt; Linear Time Complexity</span></span><br></pre></td></tr></table></figure>

<ul>
<li>总结：使用渐进分析法给每种算法分析以下 3 种情况，最后得到时间复杂度<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Best Case: number = 1 OR number = 2 =&gt; O(1) // 数值少</span><br><span class="line">Average Case: O(n)</span><br><span class="line">Worst Case: number = 27,277 =&gt; O(n) (Improved: O(sqrt(n))) // 数值大</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="判断是否为-2-的幂"><a href="#判断是否为-2-的幂" class="headerlink" title="判断是否为 2 的幂"></a>判断是否为 2 的幂</h4><ul>
<li>使用位运算符：二进制 与 &amp;</li>
<li>&amp;：按位相乘，有 0 为 0,<span class="desc">示例：4 &amp; 7 &#x3D;&#x3D;&gt; 100 &amp; 111 &#x3D;&#x3D;&gt; 100 &#x3D;&#x3D;&gt; 4(最终结果)</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">number</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (number &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	<span class="keyword">return</span> (number &amp; (number - <span class="number">1</span>)) === <span class="number">0</span> <span class="comment">// O(1), (number &amp; (number - 1))始终返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><h3 id="阶乘算法"><a href="#阶乘算法" class="headerlink" title="阶乘算法"></a>阶乘算法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fact</span>(<span class="params">number</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (number === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// space complexity： 1</span></span><br><span class="line">	<span class="keyword">return</span> number * <span class="title function_">fact</span>(number - <span class="number">1</span>) <span class="comment">// space complexity： 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但n次调用的回调函数的时间复杂度是: O(n)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fact</span>(<span class="number">5</span>)) <span class="comment">// 5 * 4 * 3 * 2 * 1</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(n)</span></span><br></pre></td></tr></table></figure>

<h3 id="以递归实现斐波那契数列来证明递归不全是最好的实现方式"><a href="#以递归实现斐波那契数列来证明递归不全是最好的实现方式" class="headerlink" title="以递归实现斐波那契数列来证明递归不全是最好的实现方式"></a>以递归实现斐波那契数列来证明递归不全是最好的实现方式</h3><ul>
<li>问题：建立了一个嵌套树，从 n&#x3D;4 时会产生多余的相同结果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">fib</span>(n - <span class="number">1</span>) + <span class="title function_">fib</span>(n - <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// 每次执行回调函数都有两个函数要执行，表示时间长度是指数级增长</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基于普通循环的时间复杂度为 O(n)</span></span><br><span class="line"><span class="comment">// 基于递归实现的时间复杂度为 O(n^2)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="动态编程-Dynamic-Programming"><a href="#动态编程-Dynamic-Programming" class="headerlink" title="动态编程(Dynamic Programming)"></a>动态编程(Dynamic Programming)</h2><ul>
<li>在第一个函数也就是该方法的全局中添加存储空间的变量</li>
<li>在添加一个记忆变量的形式变量</li>
<li>在每次该回调函数结束前，把存储变量赋值给记忆变量</li>
<li>判断记忆变量有这个值就返回记忆变量的值不执行后面的内容避免冗余</li>
</ul>
<h3 id="以递归实现的斐波那契为例进行改造"><a href="#以递归实现的斐波那契为例进行改造" class="headerlink" title="以递归实现的斐波那契为例进行改造"></a>以递归实现的斐波那契为例进行改造</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n, memo</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> result</span><br><span class="line">	<span class="keyword">if</span> (memo[n]) <span class="keyword">return</span> memo[n]</span><br><span class="line">	<span class="keyword">if</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		result = <span class="title function_">fib</span>(n - <span class="number">1</span>, memo) + <span class="title function_">fib</span>(n - <span class="number">2</span>, memo)</span><br><span class="line">	&#125;</span><br><span class="line">	memo[n] = result</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">5</span>, &#123;&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="自下而上的方法"><a href="#自下而上的方法" class="headerlink" title="自下而上的方法"></a>自下而上的方法</h3><blockquote>
<p>建立一个存储所有这些值的存储，将所有结果存储在此存储中的 bonachi 序列。执行方法的过程中，不断生成数据，知道目标值生成完成函数执行。当数据够多，一旦检索到 nf 元素然后我们取消完成函数执行。</p>
</blockquote>
<ul>
<li>使用场景：<ol>
<li>在循环中使用底部应用程序方法</li>
<li>带有递归的动态规划方法</li>
</ol>
</li>
</ul>
<h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><h3 id="线性搜索-可以是任意类型的数据"><a href="#线性搜索-可以是任意类型的数据" class="headerlink" title="线性搜索(可以是任意类型的数据)"></a>线性搜索(可以是任意类型的数据)</h3><ul>
<li>从头到尾遍历查找，找到对应的值就返回并停止，只返回第一个目标结果就停止</li>
<li>适用于有序和无序列表，所以列表不必排序</li>
<li>当然可以用系统内置的方法 find(), findIndex()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 搜索对象</span></span><br><span class="line"><span class="keyword">const</span> obj = [</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&#x27;mary&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&#x27;moli&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;22&#x27;</span> &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>, -<span class="number">10</span>, <span class="number">33</span>, <span class="number">51</span>]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findElement</span>(<span class="params">arr, element, comparatorFn</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">		<span class="comment">// item只是临时的，并不依赖数组长度</span></span><br><span class="line">		<span class="keyword">if</span> (</span><br><span class="line">			<span class="keyword">typeof</span> element === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">			element !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">			<span class="title function_">comparatorFn</span>(element, item)</span><br><span class="line">		)</span><br><span class="line">			<span class="keyword">return</span> index</span><br><span class="line">		<span class="keyword">if</span> (item === element) <span class="keyword">return</span> index</span><br><span class="line">		index++ <span class="comment">// 只是改变现有的值，并不会返回新值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findElement</span>(arr, <span class="number">33</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">	<span class="title function_">findElement</span>(obj, &#123; <span class="attr">name</span>: <span class="string">&#x27;moli&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;22&#x27;</span> &#125;, <span class="keyword">function</span> (<span class="params">el, it</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> el.<span class="property">name</span> === it.<span class="property">name</span></span><br><span class="line">	&#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 空间复杂度为O(1)</span></span><br></pre></td></tr></table></figure>

<h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><blockquote>
<p>需要先排序，然后根据中有两边的值，从中间划分查找</p>
</blockquote>
<ol>
<li><p>基于循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">99</span>, <span class="number">100</span>]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findElement</span>(<span class="params">sortedArr, element</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> startIndex = <span class="number">0</span></span><br><span class="line">	<span class="keyword">let</span> endIndex = sortedArr.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> (startIndex &lt;= endIndex) &#123;</span><br><span class="line">		<span class="keyword">const</span> middleIndex = startIndex + <span class="title class_">Math</span>.<span class="title function_">floor</span>((endIndex - startIndex) / <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> (element === sortedArr[middleIndex]) <span class="keyword">return</span> middleIndex</span><br><span class="line">		<span class="keyword">if</span> (sortedArr[middleIndex] &lt; element) startIndex = middleIndex + <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span> endIndex = middleIndex - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findElement</span>(arr, <span class="number">9</span>))</span><br><span class="line"><span class="comment">// Best Case: 目标刚好正中间 O(1)</span></span><br><span class="line"><span class="comment">// Average Case: 趋于O(log n)</span></span><br><span class="line"><span class="comment">// Worst Case: 目标在开头或结尾 O(log n)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>递归的二分查找</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">99</span>, <span class="number">100</span>]</span><br><span class="line"><span class="comment">// sortedArr: 原数组   element： 目标元素   offset：索引偏移量,目标元素在新数组与旧数组的偏差</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findElement</span>(<span class="params">sortedArr, element, offset</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> startIndex = <span class="number">0</span></span><br><span class="line">	<span class="keyword">let</span> endIndex = sortedArr.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> (startIndex &lt;= endIndex) &#123;</span><br><span class="line">		<span class="keyword">const</span> middleIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((endIndex - startIndex) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (element === sortedArr[middleIndex]) <span class="keyword">return</span> middleIndex + offset <span class="comment">// 返回目标元素在原数组的索引：当前元素索引+offest</span></span><br><span class="line">		<span class="keyword">if</span> (sortedArr[middleIndex] &lt; element) &#123;</span><br><span class="line">			startIndex = middleIndex + <span class="number">1</span></span><br><span class="line">			offset = offset + middleIndex + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			endIndex = middleIndex</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">findElement</span>(</span><br><span class="line">			sortedArr.<span class="title function_">slice</span>(startIndex, endIndex + <span class="number">1</span>),</span><br><span class="line">			element,</span><br><span class="line">			offset</span><br><span class="line">		) <span class="comment">// endIndex +1 是为了防止元素出现在最末尾</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findElement</span>(arr, <span class="number">9</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment">// a: 1 (这里看return那一句时递归的，只执行一次，所以为1)</span></span><br><span class="line"><span class="comment">// b: 2 (这里看切分成多少次，从代码看数组被切分成两次)</span></span><br><span class="line"><span class="comment">// O(n^logb a) =&gt; O(n^log2 1) =&gt; O(n^0) =&gt; O(1)</span></span><br><span class="line"><span class="comment">// overall the algorithms:O(n^logb alog n) =&gt; O(1 * log n) =&gt; O(log n)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>与基于循环的解决方案的主要区别： 是在循环中只是改变了索引然后计算不同的中间指标</li>
<li>在递归方案中总是计算相同的中间指标，改变 index 来调用新函数，再次使用原始数组的子集。即真的切数组为不同函数调用分成切片，在不同的数组切片上操作</li>
</ul>
<h3 id="主定理-Master-Theorem"><a href="#主定理-Master-Theorem" class="headerlink" title="主定理(Master Theorem)"></a>主定理(Master Theorem)</h3><ul>
<li>递归的运行时间： O(n<sup>log<sub>b</sub>a</sup>)</li>
<li>公式里的变量知识面意思?<ul>
<li>a：等于子问题数（递归拆分数）多久拆分一次数组</li>
<li>b：等于相对子问题大小（每次拆分的输入减少）</li>
<li>f(n)：等于递归外部运行时，指整个代码</li>
</ul>
</li>
<li>使用主定理得到算法的整体时间复杂度的三种情况：<ul>
<li>case 1：递归步骤，完成最多工作，具有最大的运行时间，算法的运行时间为 O(n<sup>log<sub>b</sub>a</sup>)</li>
<li>case 2：非递归部分做更多工作：O(fn(n))</li>
<li>case 3：递归开始时的相同工作量推到整个算法的运行时间 O(n<sup>log<sub>b</sub>a</sup>log n)</li>
</ul>
</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> resultArr = [...arr]</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> outer = <span class="number">0</span>; outer &lt; resultArr.<span class="property">length</span>; outer++) &#123;</span><br><span class="line">		<span class="keyword">let</span> outerEl = resultArr[outer]</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> inner = outer + <span class="number">1</span>; inner &lt; resultArr.<span class="property">length</span>; inner++) &#123;</span><br><span class="line">			<span class="keyword">let</span> innerEl = resultArr[inner]</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (outerEl &gt; innerEl) &#123;</span><br><span class="line">				resultArr[outer] = innerEl</span><br><span class="line">				resultArr[inner] = outerEl</span><br><span class="line">				outerEl = resultArr[outer]</span><br><span class="line">				innerEl = resultArr[inner]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resultArr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sortedArr = <span class="title function_">sort</span>([<span class="number">3</span>, <span class="number">10</span>, -<span class="number">3</span>, <span class="number">48</span>, <span class="number">5</span>, <span class="number">33</span>, <span class="number">99</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Best Case: item 已经排序的情况 O(n)</span></span><br><span class="line"><span class="comment">// Average Case: 随机排序，趋于 O(n^2)</span></span><br><span class="line"><span class="comment">// Worst Case: O(n^2)</span></span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> copiedArr = [...arr]</span><br><span class="line">	<span class="keyword">if</span> (copiedArr.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> copiedArr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> smElArr = []</span><br><span class="line">	<span class="keyword">const</span> bigElArr = []</span><br><span class="line">	<span class="keyword">const</span> pivotEl = copiedArr.<span class="title function_">shift</span>()</span><br><span class="line">	<span class="keyword">const</span> centerElArr = [pivotEl] <span class="comment">// 中心元素包含枢轴元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (copiedArr.<span class="property">length</span>) &#123;</span><br><span class="line">		<span class="keyword">const</span> currentEl = copiedArr.<span class="title function_">shift</span>()</span><br><span class="line">		<span class="keyword">if</span> (currentEl === pivotEl) centerElArr.<span class="title function_">push</span>(currentEl)</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (currentEl &lt; pivotEl) smElArr.<span class="title function_">push</span>(currentEl)</span><br><span class="line">		<span class="keyword">else</span> bigElArr.<span class="title function_">push</span>(currentEl)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> smElSortedArr = <span class="title function_">sort</span>(smElArr)</span><br><span class="line">	<span class="keyword">const</span> bigElSortedArr = <span class="title function_">sort</span>(bigElArr)</span><br><span class="line">	<span class="keyword">return</span> smElSortedArr.<span class="title function_">concat</span>(centerElArr, bigElSortedArr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sortArr = <span class="title function_">sort</span>([-<span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">100</span>, -<span class="number">10</span>, <span class="number">22</span>, <span class="number">15</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortArr)</span><br><span class="line"><span class="comment">// 递归步骤的运行时间：O(n^logb a) =&gt; O(n^log2 2) =&gt; O(n^l) =&gt; O(n) // a,b为2是因为最大最小，一共两次</span></span><br><span class="line"><span class="comment">// 递归的外部运行时间：O(n)</span></span><br><span class="line"><span class="comment">// 算法的运行时间：O(n^logb a * log n) =&gt; O(n * log n)</span></span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (arr.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">	<span class="keyword">if</span> (arr.<span class="property">length</span> === <span class="number">2</span>) <span class="keyword">return</span> arr[<span class="number">0</span>] &gt; arr[<span class="number">1</span>] ? [arr[<span class="number">1</span>], arr[<span class="number">0</span>]] : arr</span><br><span class="line">	<span class="keyword">const</span> middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">const</span> leftArray = arr.<span class="title function_">slice</span>(<span class="number">0</span>, middle)</span><br><span class="line">	<span class="keyword">const</span> rightArray = arr.<span class="title function_">slice</span>(middle) <span class="comment">// 从这看出b=2</span></span><br><span class="line">	<span class="keyword">const</span> leftSortedArr = <span class="title function_">sort</span>(leftArray)</span><br><span class="line">	<span class="keyword">const</span> rightSortedArr = <span class="title function_">sort</span>(rightArray) <span class="comment">// 从这看出时间复杂度a=2，也看出空间复杂度值与数组长度有关</span></span><br><span class="line">	<span class="keyword">const</span> mergedArr = []</span><br><span class="line">	<span class="keyword">let</span> leftArrIndex = <span class="number">0</span></span><br><span class="line">	<span class="keyword">let</span> rightArrIndex = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> (</span><br><span class="line">		leftArrIndex &lt; leftSortedArr.<span class="property">length</span> ||</span><br><span class="line">		rightSortedArr &lt; rightSortedArr.<span class="property">length</span></span><br><span class="line">	) &#123;</span><br><span class="line">		<span class="keyword">if</span> (</span><br><span class="line">			leftArrIndex &gt;= leftSortedArr.<span class="property">length</span> ||</span><br><span class="line">			leftSortedArr[leftArrIndex] &gt; rightSortedArr[rightArrIndex]</span><br><span class="line">		) &#123;</span><br><span class="line">			mergedArr.<span class="title function_">push</span>(rightSortedArr[rightArrIndex])</span><br><span class="line">			rightArrIndex++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mergedArr.<span class="title function_">push</span>(leftSortedArr[leftArrIndex])</span><br><span class="line">			leftArrIndex++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mergedArr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sortedArray = <span class="title function_">sort</span>([-<span class="number">10</span>, <span class="number">33</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>, -<span class="number">19</span>, -<span class="number">99</span>, <span class="number">100</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortedArray)</span><br><span class="line"><span class="comment">// 时间复杂度：使用主定理推算</span></span><br><span class="line"><span class="comment">// 递归步骤的运行时间： O(n)</span></span><br><span class="line"><span class="comment">// 非递归的运行时间： O(n)</span></span><br><span class="line"><span class="comment">// 整体的运行时间：O(nlogn)</span></span><br></pre></td></tr></table></figure>

<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><h3 id="集合-sets（数组）算法"><a href="#集合-sets（数组）算法" class="headerlink" title="集合 sets（数组）算法"></a>集合 sets（数组）算法</h3><h4 id="笛卡儿乘积算法"><a href="#笛卡儿乘积算法" class="headerlink" title="笛卡儿乘积算法"></a>笛卡儿乘积算法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 衣服制造问题--衣服尺码颜色组合问题</span></span><br><span class="line"><span class="comment">// 只能返回给定两个数组的组合集合</span></span><br><span class="line"><span class="comment">// [[&#x27;blue&#x27;,&#x27;m&#x27;],...]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cartProduct</span>(<span class="params">setA, setB</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> product = []</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> setAEl <span class="keyword">of</span> setA) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(setAEl)) setAEl = [setAEl]</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> setBEl <span class="keyword">of</span> setB) &#123;</span><br><span class="line">			product.<span class="title function_">push</span>([...setAEl, setBEl])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> product</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以组合多种情况的集合,但要结合上面的函数</span></span><br><span class="line"><span class="comment">// [[&#x27;blue&#x27;,&#x27;m&#x27;,&#x27;v neck&#x27;], ...]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cartesian</span>(<span class="params">...sets</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> tempProduct = sets[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; sets.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		tempProduct = <span class="title function_">cartProduct</span>(tempProduct, sets[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tempProduct</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> colors = [<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> sizes = [<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;xl&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> styles = [<span class="string">&#x27;round neck&#x27;</span>, <span class="string">&#x27;v neck&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cartesian</span>(colors, sizes, styles))</span><br><span class="line"><span class="comment">// 时间复杂度： O(n) =&gt; O(n^x)</span></span><br><span class="line"><span class="comment">// 空间复杂度： O(n) =&gt; O(n^x)</span></span><br></pre></td></tr></table></figure>

<h4 id="全排列-无重复"><a href="#全排列-无重复" class="headerlink" title="全排列 无重复"></a>全排列 无重复</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPermutations</span>(<span class="params">options</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> permutations = []</span><br><span class="line">	<span class="keyword">if</span> (options.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> [options]</span><br><span class="line">	<span class="keyword">const</span> partialPermutations = <span class="title function_">getPermutations</span>(options.<span class="title function_">slice</span>(<span class="number">1</span>))</span><br><span class="line">	<span class="keyword">const</span> firstOption = options[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; partialPermutations.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">const</span> partialPermutation = partialPermutations[i]</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; partialPermutation.<span class="property">length</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">const</span> permutationInFront = partialPermutation.<span class="title function_">slice</span>(<span class="number">0</span>, j)</span><br><span class="line">			<span class="keyword">const</span> permutationAfter = partialPermutation.<span class="title function_">slice</span>(j)</span><br><span class="line">			permutations.<span class="title function_">push</span>(</span><br><span class="line">				permutationInFront.<span class="title function_">concat</span>([firstOption], permutationAfter)</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> permutations</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> todoListItems = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;sliver&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getPermutations</span>(todoListItems))</span><br><span class="line"><span class="comment">// 时间复杂度：O(n!) =&gt; 4*3*2*1 =24 ,n指的是todoListItems的长度</span></span><br></pre></td></tr></table></figure>

<h4 id="全排列-有重复"><a href="#全排列-有重复" class="headerlink" title="全排列 有重复"></a>全排列 有重复</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPermutations</span>(<span class="params">options, length</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> permutations = []</span><br><span class="line">	<span class="keyword">if</span> (length === <span class="number">1</span>) <span class="keyword">return</span> options.<span class="title function_">map</span>(<span class="function">(<span class="params">option</span>) =&gt;</span> [option])</span><br><span class="line">	<span class="keyword">const</span> partialPermutations = <span class="title function_">getPermutations</span>(options, length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> option <span class="keyword">of</span> options) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> existingPermutation <span class="keyword">of</span> partialPermutations) &#123;</span><br><span class="line">			permutations.<span class="title function_">push</span>([option].<span class="title function_">concat</span>(existingPermutation))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> permutations</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> digits = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> resultLength = <span class="number">3</span> <span class="comment">// 生成的子数组不能超过这个长度</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getPermutations</span>(digits, resultLength))</span><br><span class="line"><span class="comment">// 时间复杂度： O(n^r)  // n指的是digits的长度，r是生成的子数组的长度</span></span><br></pre></td></tr></table></figure>

<h2 id="复杂的算法和解决的方法"><a href="#复杂的算法和解决的方法" class="headerlink" title="复杂的算法和解决的方法"></a>复杂的算法和解决的方法</h2><h3 id="结构化方案"><a href="#结构化方案" class="headerlink" title="结构化方案"></a>结构化方案</h3><ol>
<li>验证输入的问题</li>
<li>思考问题和提出解决方案</li>
<li>编写第一个版本的解决方案</li>
<li>验证结果</li>
<li>推到时间复杂度</li>
<li>探索替代方案</li>
</ol>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><blockquote>
<p>排列出从所给的 items 中拿出不超过背包重量的 item</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">knapsack</span>(<span class="params">items, cap, itemIndex</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (cap === <span class="number">0</span> || itemIndex &lt; <span class="number">0</span>) <span class="keyword">return</span> &#123; <span class="attr">items</span>: [], <span class="attr">value</span>: <span class="number">0</span>, <span class="attr">weight</span>: <span class="number">0</span> &#125;</span><br><span class="line">	<span class="keyword">if</span> (cap &lt; items[itemIndex].<span class="property">weight</span>) <span class="keyword">return</span> <span class="title function_">knapsack</span>(items, cap, itemIndex - <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">const</span> sackWithItem = <span class="title function_">knapsack</span>(</span><br><span class="line">		items,</span><br><span class="line">		cap - items[itemIndex].<span class="property">weight</span>,</span><br><span class="line">		itemIndex - <span class="number">1</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">const</span> sackWithoutItem = <span class="title function_">knapsack</span>(items, cap, itemIndex - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> valueWithItem = sackWithItem.<span class="property">value</span> + items[itemIndex].<span class="property">value</span></span><br><span class="line">	<span class="keyword">const</span> valueWithoutItem = sackWithItem.<span class="property">value</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (valueWithItem &gt; valueWithoutItem) &#123;</span><br><span class="line">		<span class="keyword">const</span> updateSack = &#123;</span><br><span class="line">			<span class="attr">items</span>: sackWithItem.<span class="property">items</span>.<span class="title function_">concat</span>(items[itemIndex]),</span><br><span class="line">			<span class="attr">value</span>: sackWithItem.<span class="property">value</span> + items[itemIndex].<span class="property">value</span>,</span><br><span class="line">			<span class="attr">weight</span>: sackWithItem.<span class="property">weight</span> + items[itemIndex].<span class="property">weight</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> updateSack</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> sackWithoutItem</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">value</span>: <span class="number">3</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">value</span>: <span class="number">6</span>, <span class="attr">weight</span>: <span class="number">8</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">value</span>: <span class="number">10</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> maxCap = <span class="number">8</span> <span class="comment">// 背包最大容量</span></span><br><span class="line"><span class="keyword">const</span> allPermutations = <span class="title function_">knapsack</span>(items, maxCap, items.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(allPermutations)</span><br><span class="line"><span class="comment">// time complexity : 2^n</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>改进版</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">knapsackFn</span>(<span class="params">items, cap, itemIndex, memo</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (memo[cap][itemIndex]) <span class="keyword">return</span> memo[cap][itemIndex]</span><br><span class="line">	<span class="keyword">if</span> (cap === <span class="number">0</span> || itemIndex &lt; <span class="number">0</span>) <span class="keyword">return</span> &#123; <span class="attr">items</span>: [], <span class="attr">value</span>: <span class="number">0</span>, <span class="attr">weight</span>: <span class="number">0</span> &#125;</span><br><span class="line">	<span class="keyword">if</span> (cap &lt; items[itemIndex].<span class="property">weight</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">knapsackFn</span>(items, cap, itemIndex - <span class="number">1</span>, memo)</span><br><span class="line">	<span class="keyword">const</span> sackWithItem = <span class="title function_">knapsackFn</span>(</span><br><span class="line">		items,</span><br><span class="line">		cap - items[itemIndex].<span class="property">weight</span>,</span><br><span class="line">		itemIndex - <span class="number">1</span>,</span><br><span class="line">		memo</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">const</span> sackWithoutItem = <span class="title function_">knapsackFn</span>(items, cap, itemIndex - <span class="number">1</span>, memo)</span><br><span class="line">	<span class="keyword">const</span> valueWithItem = sackWithItem.<span class="property">value</span> + items[itemIndex].<span class="property">value</span></span><br><span class="line">	<span class="keyword">const</span> valueWithoutItem = sackWithItem.<span class="property">value</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> resultSack</span><br><span class="line">	<span class="keyword">if</span> (valueWithItem &gt; valueWithoutItem) &#123;</span><br><span class="line">		<span class="keyword">const</span> updateSack = &#123;</span><br><span class="line">			<span class="attr">items</span>: sackWithItem.<span class="property">items</span>.<span class="title function_">concat</span>(items[itemIndex]),</span><br><span class="line">			<span class="attr">value</span>: sackWithItem.<span class="property">value</span> + items[itemIndex].<span class="property">value</span>,</span><br><span class="line">			<span class="attr">weight</span>: sackWithItem.<span class="property">weight</span> + items[itemIndex].<span class="property">weight</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		resultSack = updateSack</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		resultSack = sackWithoutItem</span><br><span class="line">	&#125;</span><br><span class="line">	memo[cap][itemIndex] = resultSack</span><br><span class="line">	<span class="keyword">return</span> resultSack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成空的数组,from从高的值创建一个新数组, fill不会创建新数组， 这是创建内存的最好方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">knapsack</span>(<span class="params">items, cap, index</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> mem = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(cap + <span class="number">1</span>), <span class="function">() =&gt;</span></span><br><span class="line">		<span class="title class_">Array</span>(items.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">undefined</span>)</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">knapsackFn</span>(items, cap, index, mem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">value</span>: <span class="number">3</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">value</span>: <span class="number">6</span>, <span class="attr">weight</span>: <span class="number">8</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">value</span>: <span class="number">10</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> maxCap = <span class="number">8</span> <span class="comment">// 背包最大容量</span></span><br><span class="line"><span class="keyword">const</span> allPermutations = <span class="title function_">knapsack</span>(items, maxCap, items.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(allPermutations)</span><br><span class="line"><span class="comment">// Time Complexity (without memoization): O(2^n)</span></span><br><span class="line"><span class="comment">// Time Complexity (with memoization): O(2*C) C指的是容量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>贪心算法 vs 动态算法</p>
<ul>
<li>解决背包问题的方式： 贪心 和 动态</li>
</ul>
</li>
</ul>
<h3 id="贪心背包算法"><a href="#贪心背包算法" class="headerlink" title="贪心背包算法"></a>贪心背包算法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次只能返回一个满足要求的选项</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">knapsack</span>(<span class="params">elements, capacity</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> sack = &#123; <span class="attr">items</span>: [], <span class="attr">value</span>: <span class="number">0</span>, <span class="attr">weight</span>: <span class="number">0</span> &#125;</span><br><span class="line">	<span class="keyword">let</span> remainingCapacity = capacity</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> elements) &#123;</span><br><span class="line">		<span class="keyword">if</span> (el.<span class="property">weight</span> &lt; remainingCapacity) &#123;</span><br><span class="line">			sack.<span class="property">items</span>.<span class="title function_">push</span>(el)</span><br><span class="line">			sack.<span class="property">value</span> += el.<span class="property">value</span></span><br><span class="line">			sack.<span class="property">weight</span> += el.<span class="property">weight</span></span><br><span class="line">			remainingCapacity -= el.<span class="property">weight</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sack</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">value</span>: <span class="number">3</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">value</span>: <span class="number">6</span>, <span class="attr">weight</span>: <span class="number">8</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">value</span>: <span class="number">10</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> maxCap = <span class="number">8</span> <span class="comment">// 背包最大容量</span></span><br><span class="line"><span class="keyword">const</span> sack = <span class="title function_">knapsack</span>(items, maxCap)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sack)</span><br></pre></td></tr></table></figure>

<h3 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  存储对象的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computeChange</span>(<span class="params">coins, amount</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> remainingAmount = amount</span><br><span class="line">	<span class="keyword">const</span> calculatedChange = &#123;</span><br><span class="line">		<span class="attr">selectedCoins</span>: &#123;&#125;,</span><br><span class="line">		<span class="attr">numberOfCoins</span>: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">		<span class="keyword">const</span> count = <span class="title class_">Math</span>.<span class="title function_">floor</span>(remainingAmount / coin)</span><br><span class="line">		calculatedChange[coin] = count</span><br><span class="line">		calculatedChange.<span class="property">numberOfCoins</span> += count</span><br><span class="line">		remainingAmount = remainingAmount - coin * count</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> calculatedChange</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> availableCoins = [<span class="number">100</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> targetAmount = <span class="number">50</span></span><br><span class="line"><span class="keyword">const</span> change = <span class="title function_">computeChange</span>(availableCoins, targetAmount)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(change)</span><br></pre></td></tr></table></figure>

<h3 id="暴力找零"><a href="#暴力找零" class="headerlink" title="暴力找零"></a>暴力找零</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  存储对象的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computeChange</span>(<span class="params">coins, amount</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> remainingAmount = amount</span><br><span class="line">	<span class="keyword">const</span> calculatedChange = &#123;</span><br><span class="line">		<span class="attr">selectedCoins</span>: &#123;&#125;,</span><br><span class="line">		<span class="attr">numberOfCoins</span>: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">		<span class="keyword">const</span> count = <span class="title class_">Math</span>.<span class="title function_">floor</span>(remainingAmount / coin)</span><br><span class="line">		calculatedChange[coin] = count</span><br><span class="line">		calculatedChange.<span class="property">numberOfCoins</span> += count</span><br><span class="line">		remainingAmount = remainingAmount - coin * count</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> calculatedChange</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computeChangeBruteForce</span>(<span class="params">coins, amount</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> results = []</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; coins.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		results.<span class="title function_">push</span>(<span class="title function_">computeChange</span>(coins.<span class="title function_">slice</span>(i), amount))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> smallestAmountOfCoins = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span></span><br><span class="line">	<span class="keyword">let</span> finalResult</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> result <span class="keyword">of</span> results) &#123;</span><br><span class="line">		<span class="keyword">if</span> (result.<span class="property">numberOfCoins</span> &lt; smallestAmountOfCoins) &#123;</span><br><span class="line">			smallestAmountOfCoins = result.<span class="property">numberOfCoins</span></span><br><span class="line">			finalResult = result</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> finalResult</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> availableCoins = [<span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> targetAmount = <span class="number">83</span></span><br><span class="line"><span class="keyword">const</span> change = <span class="title function_">computeChangeBruteForce</span>(availableCoins, targetAmount)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(change)</span><br><span class="line"><span class="comment">// 贪心算法的解决方法的时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 暴力算法的解决方法的时间复杂度：O(n^2)</span></span><br></pre></td></tr></table></figure>

<h2 id="Set-和-new-Map"><a href="#Set-和-new-Map" class="headerlink" title="Set 和 new Map"></a>Set 和 new Map</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ol>
<li><p>并集：利用 set 特性给两个数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">22</span>, <span class="number">38</span>, <span class="number">31</span>, <span class="number">18</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">122</span>, <span class="number">138</span>, <span class="number">19</span>, <span class="number">18</span>]</span><br><span class="line"><span class="keyword">const</span> setArr1 = <span class="keyword">new</span> <span class="title class_">Set</span>(arr1)</span><br><span class="line"><span class="keyword">const</span> setArr2 = <span class="keyword">new</span> <span class="title class_">Set</span>(arr2)</span><br><span class="line"><span class="keyword">const</span> union = <span class="title function_">newSet</span>([...setArr1, ...setArr2])</span><br></pre></td></tr></table></figure>
</li>
<li><p>交集：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intersection = <span class="keyword">new</span> <span class="title class_">Set</span>([...setArr1].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> setArr2.<span class="title function_">has</span>(item)))</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 差集：</span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">const intersection = new Set([...setArr1].filter((item) =&gt; !setArr2.has(item)))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断元素是否存在,时间复杂度为 O(1),速度快</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">38</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">const</span> newNums = <span class="keyword">new</span> <span class="title class_">Set</span>(nums)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNums.<span class="title function_">has</span>(<span class="number">11</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现队列,队尾添加，队头删除&#x2F;栈的数据结构，在表尾即可完成添加和删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> alignment = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">alignment.<span class="title function_">add</span>(<span class="number">10</span>)</span><br><span class="line">alignment.<span class="title function_">add</span>(<span class="number">11</span>)</span><br><span class="line">alignment.<span class="title function_">delete</span>(alignment.<span class="title function_">values</span>().<span class="title function_">next</span>().<span class="property">value</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="new-Map"><a href="#new-Map" class="headerlink" title="new Map"></a>new Map</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种数据结构适用</span></span><br><span class="line"><span class="keyword">const</span> result = [</span><br><span class="line">	[<span class="string">&#x27;iphone4&#x27;</span>, <span class="number">19999</span>],</span><br><span class="line">	[<span class="string">&#x27;ipad&#x27;</span>, <span class="number">3999</span>],</span><br><span class="line">	[<span class="string">&#x27;iMac&#x27;</span>, <span class="number">29999</span>],</span><br><span class="line">	[<span class="string">&#x27;iphone13&#x27;</span>, <span class="number">6999</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">findPrice</span> = (<span class="params">data, name</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Map</span>(data).<span class="title function_">get</span>(name)</span><br><span class="line"><span class="title function_">finPrice</span>(result, <span class="string">&#x27;iMac&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Object-与-new-Map"><a href="#Object-与-new-Map" class="headerlink" title="Object 与 new Map"></a>Object 与 new Map</h3><ul>
<li>创建一个 new Map(),可以适用.set(key,value)设置该 Map 的键值，使用.get(key)查找 Map 中该键的值，.has 是否存在该键</li>
<li>Map 的键值支持正则，Map 是可迭代的，<span class="desc">例如：forEach 循环 for…of…循环 ，Object 是不能直接迭代的</span></li>
<li>适用场景：<ol>
<li>当插入的顺序是需要考虑的，并且使用除 String 和 Symbol 以外的键名是，使用 Map</li>
<li>需要遍历键值对并且需要考虑顺序，优先 Map</li>
<li>频繁增删改查的场景使用 Map</li>
<li>表单自定义字段使用 Map</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map4 = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map4.<span class="title function_">set</span>(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> map4) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> object4 = &#123;</span><br><span class="line">	<span class="attr">key1</span>: <span class="string">&#x27;value1&#x27;</span>,</span><br><span class="line">	<span class="attr">key2</span>: <span class="string">&#x27;value2&#x27;</span>,</span><br><span class="line">	<span class="attr">key3</span>: <span class="string">&#x27;value3&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(object4)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元素的顺序和长度"><a href="#元素的顺序和长度" class="headerlink" title="元素的顺序和长度"></a>元素的顺序和长度</h3><ul>
<li>Map 保持对长度的跟踪，使其能够在 O(1)复杂度中进行访问</li>
<li>Object 想要获得对象的属性长度，需要手动进行迭代，使其文 O(n)复杂度，属性长度为 n</li>
<li>Map 始终保持按插入顺序返回键名</li>
<li>Object 从 es6 开始，String 和 Symbol 键是按顺序保存起来的，但是通过隐式转换保存成 String 的键是乱序的</li>
</ul>
<h3 id="Set-的时间复杂度"><a href="#Set-的时间复杂度" class="headerlink" title="Set 的时间复杂度"></a>Set 的时间复杂度</h3><table>
<thead>
<tr>
<th>Set 操作</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>Set.prototype.get()</td>
<td>O(1) ~ O(logn)</td>
</tr>
<tr>
<td>Set.prototype.add()</td>
<td>O(1) ~ O(logn)</td>
</tr>
<tr>
<td>Set.prototype.has()</td>
<td>O(1) ~ O(logn)</td>
</tr>
<tr>
<td>Set.prototype.forEach()</td>
<td>O(n)</td>
</tr>
<tr>
<td>Set.prototype.entries()</td>
<td>O(n)</td>
</tr>
<tr>
<td>Set.prototype.values()</td>
<td>O(n)</td>
</tr>
<tr>
<td>Set.prototype.keys()</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul>
<li>使用一层循环来获取需要双层循环的结果</li>
<li>列举：求两数之和：<ul>
<li>使用 new Map() 创建一个空的 map 数组</li>
<li>在遍历的过程中通过 map 数组使用 has 方法判断 target-数组中的某一项得到的值是否存在<ul>
<li>存在就使用 get 方法获取对应值的小标并返回</li>
<li>不存在就使用 set 方法设置下标给 map 数组</li>
</ul>
</li>
<li>如果把 for 循环换成 forEach 有问题</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>() <span class="comment">// 创建一个空映射</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (map.<span class="title function_">has</span>(target - nums[i])) &#123;</span><br><span class="line">			<span class="comment">// 这个存在适当，map将两个符合要求的结果都已经存储的情况下执行的</span></span><br><span class="line">			<span class="keyword">return</span> [map.<span class="title function_">get</span>(target - nums[i]), i]</span><br><span class="line">		&#125;</span><br><span class="line">		map.<span class="title function_">set</span>(nums[i], i) <span class="comment">// 遍历第一回肯定不存在，就将键值添加到map中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><ul>
<li>本质：暴力穷举算法</li>
<li>列如：给定两个整数 n 和 k，返回范围[1,n]中所有可能的 k 的组合，不要求顺序</li>
<li>其中：k 指的是组合的长度，如[2,4],并且按照数学规范[最小值，最大值]， n 指最大区间<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">combine</span> = (<span class="params">n, k</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> ans = []</span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">getAns</span> = (<span class="params">val, arr</span>) =&gt; &#123;</span><br><span class="line">		arr.<span class="title function_">push</span>(val) <span class="comment">// 将获取到的值添加到数组中，并计算如果数组长度和k的长度一样就直接添加到对应数组中</span></span><br><span class="line">		<span class="keyword">if</span> (arr.<span class="property">length</span> === k) &#123;</span><br><span class="line">			ans.<span class="title function_">push</span>(arr)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n - val &lt; k - arr.<span class="property">length</span>) <span class="keyword">return</span> <span class="comment">//  n-val &lt; k-arr.length ,是控制组合的展示形式符合数学规范，并且最大值不在选择范围</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = val + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="comment">// 如果长度不满足就再次进入循环知道满足</span></span><br><span class="line">			<span class="title function_">getAns</span>(i, [...arr])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="title function_">getAns</span>(i, []) <span class="comment">//  传一个空数组，用来存储k的组合，之后在把所有k组合存进ans中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="动态规划-DP-算法"><a href="#动态规划-DP-算法" class="headerlink" title="动态规划 DP 算法"></a>动态规划 DP 算法</h2><ul>
<li>设定一个数组，存放到达第 n 层的跳法，假定只能从当前元素的左和下移动<ul>
<li>找一个位置，分析到达这个位置的前置条件，并将这些条件以二维数组的方式相加</li>
<li>例如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a[i][j] = a[i-<span class="number">1</span>][j] + a[i][j-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>倒着分析，找关系</li>
<li>处理极值<ul>
<li>arr[i][0] &#x3D; 1</li>
<li>arr[0][j] &#x3D; 1</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个二维数据的空数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Array2</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> _array = <span class="keyword">new</span> <span class="title class_">Array</span>(m)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">let</span> emptyArr = <span class="keyword">new</span> <span class="title class_">Array</span>(n)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			emptyArr[j] = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		_array2[i] = emptyArr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _array2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">totalPath</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> arr = <span class="title class_">Array2</span>(m, n)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		arr[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">		arr[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">			arr[i][j] = arr[i - <span class="number">1</span>][j] + arr[i][j - <span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-指针相关</title>
    <url>/2024/10/31/JS/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<p>滑动窗口 就是 双指针</p>
<h3 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h3><blockquote>
<p>leetcode 167.两数之和 –&gt; 进阶变形 15.三数之和</p>
</blockquote>
<ol>
<li>一个指针指向数组最左，一个指针指向数组最右</li>
<li>一般来说数组需要从小到大排序</li>
<li>默认左指针一定会小于右指针</li>
<li>左指针+右指针之和小于目标值，左指针加 1，否则右指针减 1</li>
</ol>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><blockquote>
<p>leetcode 3096</p>
</blockquote>
<ol>
<li>一般来说，按顺序求和，分为两个子数组</li>
<li>指针只改变一个</li>
</ol>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><blockquote>
<p>leetcode 209、713、3</p>
</blockquote>
<ol>
<li>一般来说两个循环+一个指针或者说两个指针也可以，第二个指针包含在外部循环里</li>
<li>两个指针方向要一致，从 0 开始，就都从 0 开始，外部循环是外部指针跟随每次遍历而动，内部循环是满足条件后，第二指针改变</li>
<li>一般来说第二指针会比第一指针慢，两个指针可以相等，但要看条件是什么，如果求长度+1，能保证最小长度为 1</li>
</ol>
<ul>
<li>模板<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> L = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> len = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> R =<span class="number">0</span>,R&lt;arr.<span class="property">length</span>;R++)&#123;</span><br><span class="line">	sum += arr[R] <span class="comment">// 位置可变，或先内循环在计算</span></span><br><span class="line">	<span class="keyword">while</span>(sum &lt; target) &#123; <span class="comment">// 条件可变</span></span><br><span class="line">		len = <span class="title class_">Math</span>.<span class="title function_">max</span>(len, R-L+<span class="number">1</span>) <span class="comment">// 位置可变，或外循环</span></span><br><span class="line">		sum -= arr[L]</span><br><span class="line">		L++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二分查找的基础知识"><a href="#二分查找的基础知识" class="headerlink" title="二分查找的基础知识"></a>二分查找的基础知识</h3><blockquote>
<p>leetcode 34. 在排序数组中查找元素的第一个和最后一个位置<br>leetcode 不是有序的数组也能使用二分查找。162 也算跳跃窗口</p>
</blockquote>
<ul>
<li><p>三种解法，适用 &gt;&#x3D;target</p>
<ul>
<li>如果是 &gt;target 的话，把它看成 x&gt;&#x3D;target+1</li>
<li>如果是 &lt;target 的话，把它看成 (x&gt;&#x3D;target)-1</li>
<li>如果是 &lt;&#x3D;target 的话，把它看成 (x&gt;target)-1</li>
</ul>
</li>
<li><p>模板</p>
</li>
</ul>
<ol>
<li><p>闭区间解法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = (<span class="attr">nums</span>:number[],<span class="attr">targrt</span>:number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">	<span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span> <span class="comment">// 闭区间【left，right】</span></span><br><span class="line">	<span class="keyword">while</span> left &lt;= <span class="attr">right</span>: <span class="comment">// 区间不为空</span></span><br><span class="line">		<span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((L+R)/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span> <span class="comment">// [mid+1, right]</span></span><br><span class="line">		<span class="keyword">else</span> right = mid -<span class="number">1</span> <span class="comment">// [left, mid-1]</span></span><br><span class="line">	<span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>左闭右开区间解法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = (<span class="attr">nums</span>: number[], <span class="attr">target</span>: number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">	<span class="keyword">let</span> right = nums.<span class="property">length</span> <span class="comment">// 左闭右开区间【left，right)</span></span><br><span class="line">	<span class="keyword">while</span> left &lt; <span class="attr">right</span>: <span class="comment">// 区间不为空</span></span><br><span class="line">		<span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((L+R)/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; target) left = mid +<span class="number">1</span> <span class="comment">// [mid+1, right)</span></span><br><span class="line">		<span class="keyword">else</span> right = mid <span class="comment">// [left, mid)</span></span><br><span class="line">	<span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开区间解法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = (<span class="attr">nums</span>: number[], <span class="attr">target</span>: number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> left = -<span class="number">1</span></span><br><span class="line">	<span class="keyword">let</span> right = nums.<span class="property">length</span> <span class="comment">// 开区间(left，right)</span></span><br><span class="line">	<span class="keyword">while</span> left + <span class="number">1</span> &lt; <span class="attr">right</span>: <span class="comment">// 区间不为空</span></span><br><span class="line">		<span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((L+R)/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; target) left = mid  <span class="comment">// (mid+1, right)</span></span><br><span class="line">		<span class="keyword">else</span> right = mid <span class="comment">// (left, mid)</span></span><br><span class="line">	<span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="旋转排序数组"><a href="#旋转排序数组" class="headerlink" title="旋转排序数组"></a>旋转排序数组</h3><blockquote>
<p>leetcode 162.寻找峰值,153.寻找旋转排序数组中的最小值，33.搜索旋转排序数组</p>
</blockquote>
<ul>
<li>模板<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> L = -<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> R = arr.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (L + <span class="number">1</span> &lt; R) &#123;</span><br><span class="line">	<span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((L + R) / <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> (arr[mid] &lt; arr[arr.<span class="property">length</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">		<span class="comment">// 条件可改</span></span><br><span class="line">		L = mid</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		R = mid</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nums[R] <span class="comment">// 结果可改</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="单调栈-pop"><a href="#单调栈-pop" class="headerlink" title="单调栈(pop)"></a>单调栈(pop)</h3><blockquote>
<p>leetcode 739</p>
</blockquote>
<ul>
<li>利用栈的特性：后进先出</li>
</ul>
<ol>
<li>先初始化数组</li>
<li>每次判断临时数组数组长度大于 0 并且当前元素大于等于栈中的最后一个元素对应在数组中的元素，如果有这个情况临时数组就出栈</li>
<li>如果临时数组经过出栈后仍然保留则向对应位置的初始化数组添加元素</li>
<li>每次都先向临时数组中添加当前元素的索引</li>
<li>最后返回初始化数组</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-数学相关</title>
    <url>/2024/10/31/JS/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="快速幂模运算"><a href="#快速幂模运算" class="headerlink" title="快速幂模运算"></a>快速幂模运算</h3><blockquote>
<p>leetcode: 2961.双模幂运算、50. Pow(x, n)</p>
</blockquote>
<ul>
<li>模板：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">powMod</span>(<span class="params">x, y, mod</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> res = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((y &amp; <span class="number">1</span>) === <span class="number">1</span>) &#123;</span><br><span class="line">			res = (res * x) % mod</span><br><span class="line">		&#125;</span><br><span class="line">		x = (x * x) % mod</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>7种强大的JavaScript继承技术</title>
    <url>/2025/03/19/JS/%E7%BB%A7%E6%89%BF%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h2><ul>
<li>最直接的继承方法之一</li>
<li>允许对象通过原型连接的”链”继承属性和方法</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">species</span> = <span class="string">&#x27;Mammal&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">habits</span> = [<span class="string">&#x27;sleep&#x27;</span>, <span class="string">&#x27;eat&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">breed</span> = <span class="string">&#x27;Bulldog&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d1 = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="keyword">let</span> d2 = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">d1.<span class="property">habits</span>.<span class="title function_">push</span>(<span class="string">&#x27;bark&#x27;</span>); <span class="comment">// 向Animal.habits添加了bark</span></span><br></pre></td></tr></table></figure></li>
<li>优点：设置简单，为子类提供所有父原型方法的访问权限</li>
<li>缺点：共享引用类型可能会导致副作用，为每个实例调用父对象的构造函数</li>
</ul>
<h2 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2. 构造函数继承"></a>2. 构造函数继承</h2><ul>
<li>子对象通过在子构造函数中调用父对象的构造函数来继承属性</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">species</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">species</span> = species;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">activities</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">breed</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&#x27;Mammal&#x27;</span>); <span class="comment">// 给Dog中的父species赋值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;dog&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>优点：每个实例都有不同的属性，参数可以传递给父级</li>
<li>缺点：无法跨实例重用方法，从而导致冗余</li>
</ul>
<h2 id="3-复合继承"><a href="#3-复合继承" class="headerlink" title="3. 复合继承"></a>3. 复合继承</h2><ul>
<li>合并了原型链和构造函数继承，以便子类提供唯一属性和对父方法的访问</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">species</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">species</span> = species;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">activities</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSpecies</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 父方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">species</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">breed</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&#x27;Mammal&#x27;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>;</span><br></pre></td></tr></table></figure></li>
<li>优点：子类有自己的属性和原型方法</li>
<li>缺点：父构造函数被调用两次，增加了开销</li>
</ul>
<h2 id="4-寄生继承"><a href="#4-寄生继承" class="headerlink" title="4. 寄生继承"></a>4. 寄生继承</h2><ul>
<li>创建、修改和返回对象，使继承变得灵活，但增加了复杂性</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">species</span> = <span class="string">&#x27;Mammal&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">habits</span> = [<span class="string">&#x27;eat&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">breed</span> = <span class="string">&#x27;Bulldog&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>;</span><br></pre></td></tr></table></figure></li>
<li>优点：允许在克隆对象上使用原型扩展</li>
<li>缺点：不太适合大型继承结构</li>
</ul>
<h2 id="5-原型继承"><a href="#5-原型继承" class="headerlink" title="5. 原型继承"></a>5. 原型继承</h2><ul>
<li>Object.create()直接创建具有指定原型的对象</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  <span class="attr">species</span>: <span class="string">&#x27;Mammal&#x27;</span>,</span><br><span class="line">  <span class="attr">traits</span>: [<span class="string">&#x27;warm-blooded&#x27;</span>, <span class="string">&#x27;vertebrate&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj);</span><br><span class="line">  clone.<span class="property">getTraits</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">traits</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="title function_">createClone</span>(animal);</span><br></pre></td></tr></table></figure></li>
<li>优点：简单且不需要构造函数</li>
<li>缺点：所有实例共享 prototype 属性</li>
</ul>
<h2 id="6-寄生组合继承"><a href="#6-寄生组合继承" class="headerlink" title="6. 寄生组合继承"></a>6. 寄生组合继承</h2><ul>
<li>改进的复合继承，使用Object.create()</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">species</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">species</span> = species;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">traits</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">breed</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&#x27;Mammal&#x27;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>;</span><br></pre></td></tr></table></figure></li>
<li>优点：解决 double 构造函数调用问题;保留综合效益</li>
<li>缺点：代码复杂性和需要额外的封装</li>
</ul>
<h2 id="7-ES6类继承"><a href="#7-ES6类继承" class="headerlink" title="7. ES6类继承"></a>7. ES6类继承</h2><ul>
<li>es6 中，在js中引入class语法</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">species</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">species</span> = species;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getSpecies</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">species</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">breed</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&#x27;Mammal&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>优点：干净、可读的语法，类似于传统的 OOP</li>
<li>缺点：可能需要转译,与基于原型的方法相比，性能略有不同</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-一些补充</title>
    <url>/2024/10/31/JS/%E9%94%99%E9%A2%98%E6%9C%AC%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="函数篇"><a href="#函数篇" class="headerlink" title="函数篇"></a>函数篇</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul>
<li>没有自己的 this 值，会捕获上下文中的 this 值，在箭头函数中访问 this，它将引用外层作用域中的 this 值，所以调用 obj.fn1()时，输出结果是 window(或 undefined)，使用 new 运算符创建实例会导致 TypeError 错误</li>
</ul>
<h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><ul>
<li>this 值在运行时动态绑定，</li>
<li>当使用普通函数调用(func())：this 会指向全局对象 window</li>
<li>当使用调用方式(obj.func())：this 会指向调用该方法的对象</li>
</ul>
<h3 id="匿名函数-立即执行函数："><a href="#匿名函数-立即执行函数：" class="headerlink" title="匿名函数&#x2F;立即执行函数："></a>匿名函数&#x2F;立即执行函数：</h3><ul>
<li>在这个函数中定义的变量只能在该函数作用域内有效，改变不了全局变量的值</li>
</ul>
<h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><blockquote>
<p>指在一定的时间间隔内，定时向服务器发送请求，获取最新数据的过程。通常用于从服务器获取实时更新的数据。</p>
</blockquote>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>会产生大量的无效请求，浪费带宽和服务器资源，并且对服务器的压力比较大</li>
<li>在短时间内频繁地发送请求可能会被服务器视为恶意攻击，导致 IP 被封禁等问题</li>
</ul>
<h3 id="如何避免？"><a href="#如何避免？" class="headerlink" title="如何避免？"></a>如何避免？</h3><ul>
<li>使用 WebSocket、SSE(Server-Sent Events)等技术来实现实时数据更新</li>
<li>WebSocket 是一种双向通信协议，能狗实现服务器与客户端之间的实时通信</li>
<li>SSE 是一种居于 HTTP 的单向通信协议，可以实现服务器向客户端推送实时数据。</li>
</ul>
<h3 id="前端轮询的实现方式"><a href="#前端轮询的实现方式" class="headerlink" title="前端轮询的实现方式"></a>前端轮询的实现方式</h3><ul>
<li>基于定时器的轮询： 使用 setInterval()方法来定时发送请求</li>
<li>基于递归的轮询：使用 setTimeout()方法来控制下一次请求的时间</li>
</ul>
<h3 id="与长轮询的区别"><a href="#与长轮询的区别" class="headerlink" title="与长轮询的区别"></a>与长轮询的区别</h3><ul>
<li>轮询是在固定的时间间隔内向服务器发送请求，即使服务器没有数据更新也会继续发送请求</li>
<li>长轮询时先发送一个请求，服务器如果没有数据更新，则不会立即返回，而是将请求挂起，知道数据更新时再返回结果</li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><blockquote>
<p>一种“编程范式”，一种写编写程序的方法论</p>
</blockquote>
<h3 id="主要的编程范式：命令式编程，声明式编程和函数式编程"><a href="#主要的编程范式：命令式编程，声明式编程和函数式编程" class="headerlink" title="主要的编程范式：命令式编程，声明式编程和函数式编程"></a>主要的编程范式：命令式编程，声明式编程和函数式编程</h3><ul>
<li><p>相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断推进，追曾推到复杂的运算，而非设计一个复杂的执行过程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令式编程</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	array[i] = <span class="title class_">Math</span>.<span class="title function_">pow</span>(array[i], <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数式编程</span></span><br><span class="line">;[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(num, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>纯函数：无状态 + 数据不可变</p>
</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>函数内部传入的指定的值，就会返回确定唯一的值</li>
<li>不会造成超出作用域的变化</li>
</ul>
<h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul>
<li>不会产生副作用，提高函数的复用性</li>
<li>可读性更强</li>
<li>看组装成复杂任务的可能性。</li>
</ul>
<h3 id="高阶函数：-就是以函数作为输入或输出的函数"><a href="#高阶函数：-就是以函数作为输入或输出的函数" class="headerlink" title="高阶函数： 就是以函数作为输入或输出的函数"></a>高阶函数： 就是以函数作为输入或输出的函数</h3><ul>
<li>存在缓存特性，主要利用闭包作用</li>
</ul>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><ul>
<li>把一个多参数函数转化成一个嵌套的一元函数的过程</li>
</ul>
<h3 id="组合与管道："><a href="#组合与管道：" class="headerlink" title="组合与管道："></a>组合与管道：</h3><ul>
<li>把很多小的函数组合起来完成更复杂的逻辑。组合函数的执行顺序是从右到左。而管道函数的执行顺序是从左到右。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>更好的管理状态</li>
<li>更简单的复用：固定输入 -&gt; 固定输出，没有其他外部变量影响，并且无副作用。</li>
<li>更优雅的组合</li>
<li>减少代码量，提高维护性</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销</li>
<li>资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式</li>
<li>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>知识</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Solid</title>
    <url>/2025/03/19/Solid/%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="什么是-Solid？"><a href="#什么是-Solid？" class="headerlink" title="什么是 Solid？"></a>什么是 Solid？</h2><ul>
<li>一个 JavaScript 框架</li>
<li>局部更新，只更新改动的内容</li>
<li>当依赖的数据发生变化时更新</li>
<li>类似 react 语法</li>
</ul>
<h2 id="创建-Solid-应用程序"><a href="#创建-Solid-应用程序" class="headerlink" title="创建 Solid 应用程序"></a>创建 Solid 应用程序</h2><ul>
<li>前提： 安装 Node.js 或 Deno</li>
<li>创建：<ul>
<li>JS版：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pnpm dlx degit solidjs/templates/js my-app</span><br></pre></td></tr></table></figure></li>
<li>TS版：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">pnpm dlx degit solidjs/templates/ts my-app</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>导航：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd my-app</span><br></pre></td></tr></table></figure></li>
<li>安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pnpm install</span><br></pre></td></tr></table></figure></li>
<li>运行：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pnpm run dev</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="反应性"><a href="#反应性" class="headerlink" title="反应性"></a>反应性</h2><ul>
<li><p>含义：系统<span class="key_words">『自动响应』</span>数据或状态变化的能力，确保应用程序与底层数据<span class="key_words">『保持同步』</span></p>
</li>
<li><p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">createSignal</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(<span class="function">(<span class="params">prev</span>) =&gt;</span> prev + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>Count: &#123;count()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#x27; &#x27;&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;/* 仅单击按钮时调用increment改变count，不刷新整个组件 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&#x27;button&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        Increment</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到跟 react hook 的相似处</p>
<ul>
<li>createSignal() &#x3D;&#x3D;&gt; useState()</li>
<li>count() &#x3D;&#x3D;&gt; count</li>
</ul>
</li>
</ul>
<h2 id="反应原理"><a href="#反应原理" class="headerlink" title="反应原理"></a>反应原理</h2><h3 id="信号-Signals"><a href="#信号-Signals" class="headerlink" title="信号 Signals"></a>信号 Signals</h3><ul>
<li>反应式系统的核心元素，在数据管理和系统响应能力中发挥着重要作用。</li>
<li>由两个主要功能组成：<ul>
<li>getter：访问存储在组件内 signal 的数据,用于获取 signal 当前值的<span class="key_words">『函数』</span>。</li>
<li>setter：触发反应式更新,用于修改 signal 的<span class="key_words">『函数』</span>。</li>
<li>通过使用 getter 和 setter 来负责存储和管理数据，以及触发整个系统的更新。</li>
</ul>
</li>
<li>createSignal：该函数执行两个主要任务<ul>
<li>初始值</li>
<li>返回一个包含两个元素的数组：getter和setter函数</li>
<li>示例：createSignal的原型<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createSignal</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="comment">// 这个阶段不存在反应性</span></span><br><span class="line">  <span class="keyword">let</span> value = initialValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setter</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [getter, setter];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="订阅者-Subscribers"><a href="#订阅者-Subscribers" class="headerlink" title="订阅者 Subscribers"></a>订阅者 Subscribers</h3><ul>
<li>反应式系统的核心元素。</li>
<li>负责<span class="key_words">『跟踪信号的变化并相应地更新系统』</span>。</li>
<li>是自动响应程序，使系统与最新的数据更改保持同步。</li>
<li>订阅者基于两个主要行为：<ul>
<li>Observation：订阅者的核心是观察信号。能及时捕抓正在跟踪的信号变化</li>
<li>Response：信号改变，订阅者会收到通知。触发响应信号的改变</li>
</ul>
</li>
</ul>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><ul>
<li>作用：是处理和处理影响 Web 应用程序的行为和表示的数据的过程。涉及存储和更新数据</li>
<li>实现方式：通过信号和订阅者来处理。信号用于存储和更新数据，订阅者用于响应数据的更改</li>
<li>三要素：<ul>
<li>State：用于确定要向用户显示的内容的数据</li>
<li>View：状态对用户的只管表示</li>
<li>Actions：修改状态的事件</li>
<li>这些元素协同工作创建”单向数据流”。当修改状态行为，视图将更新当前状态并展示。</li>
</ul>
</li>
</ul>
<h3 id="管理基本状态"><a href="#管理基本状态" class="headerlink" title="管理基本状态"></a>管理基本状态</h3><ul>
<li>状态是应用程序的实施来源，用于确定要向用户显示的内容。</li>
<li>状态由信号表示,创建和使用过程与信号一样</li>
</ul>
<h3 id="跟踪更改"><a href="#跟踪更改" class="headerlink" title="跟踪更改"></a>跟踪更改</h3><ul>
<li>通过订阅者来监控数据的任何更新，并作出响应</li>
<li>响应式原句可用于创建订阅者</li>
<li>注意：<span class="desc">要跟踪信号，必须在订阅者的范围内访问。否则不会触发</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">createSignal</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">createEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">count</span>())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">setCount</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在UI中呈现状态"><a href="#在UI中呈现状态" class="headerlink" title="在UI中呈现状态"></a>在UI中呈现状态</h3><ul>
<li>使用JSX语法</li>
</ul>
<h3 id="派生信号"><a href="#派生信号" class="headerlink" title="派生信号"></a>派生信号</h3><ul>
<li>基于现有state值计算新的state值</li>
<li>注意：<span class="desc">只可计算简单计算，而且每次使用都会重新计算</span></li>
<li>频繁使用或高昂计算可以使用createMemo替代，因为memo仅在值更新时运行一次，并且可以多次访问</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">createSignal</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doubleCount</span> = (<span class="params"></span>) =&gt; <span class="title function_">count</span>() * <span class="number">2</span> <span class="comment">// 这个就是派生信号</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="提升状态"><a href="#提升状态" class="headerlink" title="提升状态"></a>提升状态</h3><ul>
<li>含义：将state提升到一个共同的祖先组件</li>
<li>做法：就是在一个父组件定义state，然后这个父组件调用使用这个state的多个组件</li>
<li>在组件之间共享 state 时，可以通过props。</li>
<li>注意：<ul>
<li><span class="key_words">『从父组件向下传递的 props 值是只读的。』</span></li>
<li><span class="key_words">『从父组件向下传递 setter 函数，子组件就可以间接修改父组件的状态。』</span></li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSignal, createEffect, createMemo &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">createSignal</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [doubleCount, setDoubleCount] = <span class="title function_">createSignal</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> squaredCount = <span class="title function_">createMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">count</span>() * <span class="title function_">count</span>());</span><br><span class="line"></span><br><span class="line">  <span class="title function_">createEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setDoubleCount</span>(<span class="title function_">count</span>() * <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/*父组件传递setter函数 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Counter</span> <span class="attr">count</span>=<span class="string">&#123;count()&#125;</span> <span class="attr">setCount</span>=<span class="string">&#123;setCount&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">DisplayCounts</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">count</span>=<span class="string">&#123;count()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">doubleCount</span>=<span class="string">&#123;doubleCount()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">squaredCount</span>=<span class="string">&#123;squaredCount()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 子组件可以使用setter函数修改</span></span><br><span class="line">    props.<span class="title function_">setCount</span>(<span class="function">(<span class="params">prev</span>) =&gt;</span> prev + <span class="number">1</span>); </span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DisplayCounts</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Current count: &#123;props.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Doubled count: &#123;props.doubleCount&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Squared count: &#123;props.squaredCount&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="管理复杂状态"><a href="#管理复杂状态" class="headerlink" title="管理复杂状态"></a>管理复杂状态</h3><ul>
<li>使用store</li>
</ul>
<h2 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a>同步 vs 异步</h2><h3 id="同步反应性"><a href="#同步反应性" class="headerlink" title="同步反应性"></a>同步反应性</h3><ul>
<li>默认模式，系统以直接和线性的方式相应变化。</li>
<li>当信号发生变化时，任何相应的订阅者都会立即以<span class="key_words">『有序的方式更新』</span></li>
</ul>
<h3 id="异步反应性"><a href="#异步反应性" class="headerlink" title="异步反应性"></a>异步反应性</h3><ul>
<li>系统以延迟或非线性方式响应变化。</li>
<li>当信号变化时，相应的订阅者不会立即更新。系统会等待特定事件或任务完成在更新</li>
<li>这在订阅者依赖多个信号的情况下非常重要，避免信号更新不同步导致数据不一致</li>
<li>注意：<span class="key_words">『当存在异步响应性时，延迟非常重要。batch 可用于延迟更新』</span></li>
</ul>
<h2 id="关键概念（简单总结）"><a href="#关键概念（简单总结）" class="headerlink" title="关键概念（简单总结）"></a>关键概念（简单总结）</h2><ul>
<li>信号负责存储和管理数据。</li>
<li>由于 getter 和 setter，信号既可读又可写。</li>
<li>订阅者是自动响应者，可以跟踪信号的变化并相应地更新系统。</li>
<li>Signals 和 subscribers 协同工作，以确保系统与最新的数据更改保持同步。</li>
<li>反应式系统建立在数据驱动反应性原则之上。意味着系统的反应性是由它所基于的数据驱动。</li>
<li>反应式系统可以是同步的，也可以是异步的。</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>基本跟 react 一样，省略</li>
</ul>
<h3 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h3><ul>
<li><p>作用：多个类应用于同一个元素时使用，处理多个条件类更有效</p>
</li>
<li><p>可以传递字符串或对象，其中 key 为类名，值为布尔表达式，当值为 false 删除</p>
</li>
<li><p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [current, setCurrent] = <span class="title function_">createSignal</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;button</span><br><span class="line">  classList=&#123;&#123; <span class="string">&quot;selected&quot;</span>: <span class="title function_">current</span>() === <span class="string">&#x27;foo&#x27;</span> &#125;&#125;</span><br><span class="line">  onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">setCurrent</span>(<span class="string">&#x27;foo&#x27;</span>)&#125;</span><br><span class="line">&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
<ul>
<li>与 class 一起用时，都是动态的情况下，应用 class 删除 classList<ul>
<li>解决方式：class 设置为静态或动态的计算值，然后放在 classList 前</li>
</ul>
</li>
<li><span class="key_words">『classList 是一个伪属性，不适用于<code>&lt;div &#123;...props&#125; /&gt;</code> 或 Dynamic标签 中的 prop 跨页』</span></li>
</ul>
</li>
</ul>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><ul>
<li><span class="key_words">『<code>on:__</code>』</span>: 将事件侦听器添加到元素，这也称为本机事件</li>
<li><span class="key_words">『<code>on__</code>』</span>: 向 document 添加事件侦听器并将其调度到元素，这称为<span class="key_words">『委托事件』</span></li>
<li>注意：<span class="desc">委托事件不区分大小写，本机事件区分大小写</span></li>
</ul>
<h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><ul>
<li>避免使用 js 的 bind 方法和添加额外闭包的开销</li>
<li>以数组作为事件处理程序传递，数组第二项作为处理程序的第一个参数</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">data, event</span>) =&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 单击按钮时，Hello!当作handler的第一个参数data传递进来</span></span><br><span class="line">&lt;button onClick=&#123;[handler, <span class="string">&#x27;Hello!&#x27;</span>]&#125;&gt;<span class="title class_">Click</span> <span class="title class_">Me</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="动态处理程序"><a href="#动态处理程序" class="headerlink" title="动态处理程序"></a>动态处理程序</h3><ul>
<li>事件处理程序<span class="key_words">『不构成响应式系统的一部分』</span></li>
<li>事件不会动态更新，并且绑定不是反应性的</li>
<li>如果要将处理程序当作 signal 传递，将不会响应<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div onClick=&#123;<span class="function">() =&gt;</span> props.<span class="property">handleClick</span>?.()&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="活动委托"><a href="#活动委托" class="headerlink" title="活动委托"></a>活动委托</h3><ul>
<li>通过 <code>on__</code>形式</li>
<li>支持的事件：看下方的委托事件列表</li>
<li>如果需要将事件侦听器附加到<span class="key_words">『事件委托不支持的元素』</span>，如自定义元素，<span class="key_words">『使用 <code>on:__</code>』</span></li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>事件委托是为了通过 JSX 树而不是 DOM 树进行事件传播而设计的</li>
<li>委托事件侦听器按事件类型添加一次，并处理该类型的所有未来事件。 这意味着，即使删除了添加委托事件侦听器的元素及其处理程序，委托事件侦听器仍保持活动状态。<ul>
<li><span class="desc">例：如果 div 监听 mousemove 并在稍后被删除，则事件仍将被分派给 document，以防其他元素也在监听鼠标移动。</span></li>
</ul>
</li>
<li><span class="key_words">『对于不经常发生的事件使用 on:__』</span></li>
<li><span class="key_words">『event.stopPropagation()未按预期工作』</span>，因为事件附加到 document 而不是 element。<ul>
<li><span class="key_words">『使用 on:__ 解决』</span></li>
</ul>
</li>
<li>onChange 和 onInput 事件根据其<span class="key_words">『本机行为』</span>工作：<ul>
<li><span class="key_words">『onInput 将在值更改后立即触发』</span></li>
<li><span class="key_words">『在 input标签 字段中，onChange 仅在字段失去焦点后触发』</span>。</li>
</ul>
</li>
</ul>
<h3 id="委托事件列表"><a href="#委托事件列表" class="headerlink" title="委托事件列表"></a>委托事件列表</h3><ul>
<li>beforeinput</li>
<li>click</li>
<li>dbclick</li>
<li>contextmenu</li>
<li>focusin</li>
<li>focusout</li>
<li>input</li>
<li>keydown</li>
<li>keyup</li>
<li>mousedown</li>
<li>mousemove</li>
<li>mouseout</li>
<li>mouseover</li>
<li>mouseup</li>
<li>pointerdown</li>
<li>pointermove</li>
<li>pointerout</li>
<li>pointerover</li>
<li>poinyerup</li>
<li>touchend</li>
<li>touchmove</li>
<li>touchstart</li>
</ul>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><ul>
<li>将 state 从父组件传递到子组件的方法</li>
<li>使用方法跟 react 一样</li>
</ul>
<h3 id="mergeProps"><a href="#mergeProps" class="headerlink" title="mergeProps"></a>mergeProps</h3><ul>
<li>一个实用函数</li>
<li>作用：把多个潜在的反应性对象合并在一起。行为类似于 Object.assign 但将保留正在合并的属性的响应性。</li>
<li>合并 props 时，如果 props 没有该值，则将使用第一个对象的值。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeProps &#125; <span class="keyword">from</span> <span class="string">&#x27;solid-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">// mergeProps 第一个对象是设置默认值，当props中没有该值则使用第一个对象的值</span></span><br><span class="line">  <span class="keyword">const</span> finalProps = <span class="title function_">mergeProps</span>(&#123; <span class="attr">defaultName</span>: <span class="string">&#x27;Ryan Carniato&#x27;</span> &#125;, props)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;finalProps.defaultName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage: &lt;MyComponent defaultName=&quot;Ryan Carniato&quot; /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解构-props"><a href="#解构-props" class="headerlink" title="解构 props"></a>解构 props</h3><ul>
<li>在Solid中，不建议使用解构 props，会破坏响应性。正确使用方式看示例</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">name</span> = (<span class="params"></span>) =&gt; props.<span class="property">name</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="splitProps"><a href="#splitProps" class="headerlink" title="splitProps"></a>splitProps</h3><ul>
<li>实用函数，<span class="key_words">『将单个 props 对象拆分成多组 props』</span>，同时保留其响应性</li>
<li>含义：定义一个或多个 key 数组，并能提取到单独的 props 对象中，同时保留各个属性的响应性。</li>
<li>返回：一个与每组键相关的 props 对象数组，以及一个包含任何剩余键的附加 props 对象。</li>
<li>用途：当 props 传递给子组件时，使用 splitProps 将 props 分成多个组，然后将每个组传递给相应的子组件：</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; splitProps &#125; <span class="keyword">from</span> <span class="string">&#x27;solid-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">// 第一个参数是props， 之后的参数是要拆分的组</span></span><br><span class="line">  <span class="keyword">const</span> [greetingProps, personalInfoProps, restProps] = <span class="title function_">splitProps</span>(</span><br><span class="line">    props,</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// greetingProps == name组（组中包含name属性）</span></span><br><span class="line">  <span class="comment">// personalInfoProps == age组（组中包含啊age属性）</span></span><br><span class="line">  <span class="comment">// restProps == props除去name和age 的组，附加 props 对象</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Greeting</span> &#123;<span class="attr">...greetingProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">PersonalInfo</span> &#123;<span class="attr">...personalInfoProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* restProps can be passed down or used as needed */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="将-props-传递给-children"><a href="#将-props-传递给-children" class="headerlink" title="将 props 传递给 children"></a>将 props 传递给 children</h3><ul>
<li>多数情况下，直接使用props。</li>
<li>避免重复创建子组件或元素</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; children &#125; <span class="keyword">from</span> <span class="string">&#x27;solid-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ColoredList</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> safeChildren = <span class="title function_">children</span>(<span class="function">() =&gt;</span> props.<span class="property">children</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;safeChildren()&#125;<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="螺旋桨钻孔-Prop-Drilling"><a href="#螺旋桨钻孔-Prop-Drilling" class="headerlink" title="螺旋桨钻孔 Prop Drilling"></a>螺旋桨钻孔 Prop Drilling</h3><ul>
<li>含义：用于描述将 prop 传递多个组件的过程</li>
<li>由于 Solid 中的组件不拥有 state，因此不需要 props 在组件之间传递 state，但可以使用 props。因此，有时可能需要通过多层组件传递 props。</li>
<li>多层级传递的缺点：props 难以管理，组件收到它们不需要的 props、不必要的重渲染和麻烦的重构</li>
<li><h3 id="避免多层级传递props"><a href="#避免多层级传递props" class="headerlink" title="避免多层级传递props"></a>避免多层级传递props</h3><ul>
<li>常见解决方案：使用 Context 将 state 传递给深度嵌套的组件</li>
</ul>
</li>
</ul>
<h2 id="条件渲染-Show标签"><a href="#条件渲染-Show标签" class="headerlink" title="条件渲染 Show标签"></a>条件渲染 Show标签</h2><ul>
<li>属性值<ul>
<li>when：判断是否渲染 children</li>
<li>fallback：当结果为 false，展示失败时的渲染 children</li>
</ul>
</li>
<li>有多个条件需要处理，采用嵌套的方式</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Show</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;solid-js&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Show</span></span><br><span class="line">  when=&#123;!data.<span class="property">loading</span>&#125;</span><br><span class="line">  fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi, I am &#123;data().name&#125;.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Show</span> <span class="attr">when</span>=<span class="string">&#123;data.error&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Error: &#123;data.error&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Show</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Show</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Switch-标签和-Match-标签"><a href="#Switch-标签和-Match-标签" class="headerlink" title="Switch 标签和 Match 标签"></a>Switch 标签和 Match 标签</h2><ul>
<li>处理多个条件,类似于 switch&#x2F;case</li>
<li>属性值：<ul>
<li>fallback：当所有条件都不符合时渲染</li>
<li>when：判断是否渲染这个Match</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Switch</span>, <span class="title class_">Match</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;solid-js&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Switch</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Fallback content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Match</span> <span class="attr">when</span>=<span class="string">&#123;condition1&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Outcome 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Match</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Match</span> <span class="attr">when</span>=<span class="string">&#123;condition2&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Outcome 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Match</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Dynamic-标签"><a href="#Dynamic-标签" class="headerlink" title="Dynamic 标签"></a>Dynamic 标签</h2><ul>
<li>允许根据数据动态渲染组件</li>
<li>比 Switch标签 和 Match标签 简洁</li>
<li>属性值：<ul>
<li>component：传递一个动态的事件</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSignal, <span class="title class_">For</span> &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Dynamic</span> &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js/web&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">RedDiv</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>Red<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">GreenDiv</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: green&quot;</span>&gt;</span>Green<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">BlueDiv</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: blue&quot;</span>&gt;</span>Blue<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">red</span>: <span class="title class_">RedDiv</span>,</span><br><span class="line">  <span class="attr">green</span>: <span class="title class_">GreenDiv</span>,</span><br><span class="line">  <span class="attr">blue</span>: <span class="title class_">BlueDiv</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [selected, setSelected] = <span class="title function_">createSignal</span>(<span class="string">&quot;red&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">select</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;selected()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onInput</span>=<span class="string">&#123;(e)</span> =&gt;</span> setSelected(e.currentTarget.value)&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">For</span> <span class="attr">each</span>=<span class="string">&#123;Object.keys(options)&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;(color) =&gt; <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span>&gt;</span>&#123;color&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">For</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- 选择对应的颜色，触发对应的事件--&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Dynamic</span> <span class="attr">component</span>=<span class="string">&#123;options[selected()]&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="列表呈现"><a href="#列表呈现" class="headerlink" title="列表呈现"></a>列表呈现</h2><ul>
<li>渲染列表</li>
</ul>
<h3 id="For-标签"><a href="#For-标签" class="headerlink" title="For 标签"></a>For 标签</h3><ul>
<li>循环组件，根据数组或对象的内容呈现元素</li>
<li>使用场景：与复杂的数据结构一起使用，如列表的顺序和长度会频繁更改的情况使用</li>
<li>唯一的属性：<ul>
<li>each：指定要循环访问的数据收集，接受一个<span class="key_words">『数组或者使用 Object.entries()或 Object.value 处理的对象』</span></li>
</ul>
</li>
<li>标签之间，组件需要有一个回调函数，类似于 map<ul>
<li>item：表示正在渲染的数据收集中的当前项</li>
<li>index：当前项在数据中的索引，<span class="key_words">『index 是一个信号，必须使用函数调用』</span>才能检索</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">For</span> each=&#123;<span class="title function_">data</span>()&#125;&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">color:</span> <span class="attr">index</span>() % <span class="attr">2</span> === <span class="string">0</span> ? &#x27;<span class="attr">red</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">blue</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;item.name&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/<span class="title class_">For</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Index-标签"><a href="#Index-标签" class="headerlink" title="Index 标签"></a>Index 标签</h3><ul>
<li>循环组件，与 For标签 类似</li>
<li>使用场景：列表顺序和长度保持稳定，但内容会频繁更改时使用</li>
<li>Index标签 更关注元素在数组中的索引，所以回调中 index 固定</li>
<li><span class="key_words">『item 是信号，必须使用函数调用』</span>才能检索</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Index</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;solid-js&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Index</span> each=&#123;<span class="title function_">data</span>()&#125;&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;item().name&#125; - &#123;item().completed&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/<span class="title class_">Index</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Index-标签-vs-For-标签"><a href="#Index-标签-vs-For-标签" class="headerlink" title="Index 标签 vs For 标签"></a>Index 标签 vs For 标签</h3><ul>
<li>For: <ul>
<li><span class="key_words">『当列表的顺序和长度可能频繁更改时使用。』</span></li>
<li><span class="key_words">『当列表值更改时，将刷新整个列表。但是，如果数据发生变化，如元素位置移动，只会修改列表中元素的索引，而不是重新渲染整个列表』</span></li>
<li>最佳使用场景：在不需要信号、嵌套循环或动态列表的情况下</li>
</ul>
</li>
<li>Index: <ul>
<li>当列表的顺序和长度保持稳定，但<span class="key_words">『内容可能会频繁更改时使用。』</span></li>
<li><span class="key_words">『当列表值更改时，只会更新指定索引处的内容，而列表的其余部分保持不变。』</span></li>
<li>最佳使用场景：处理信号，JavaScript 基元（如字符串和数字）或 input 字段时</li>
</ul>
</li>
</ul>
<h2 id="Portal-标签"><a href="#Portal-标签" class="headerlink" title="Portal 标签"></a>Portal 标签</h2><ul>
<li>Portal标签 通过将元素放在文档中的其他位置，将元素引入文档流中</li>
<li>默认情况下，嵌套的内容将呈现并放置在正文末尾</li>
<li>可以通过 prop 传递给 Portal 标签来更改当前内容的挂载点。prop 接受一个 DOM 节点</li>
<li>使用场景：<ul>
<li>弹窗</li>
<li>父元素溢出等行为影响到 Portal标签 的内容时，可以将其放在父元素外</li>
<li>元素需要在文档流外进行渲染时，堆叠内容和 z-index影响到视图</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Portal</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;solid-js/web&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Portal</span> mount=&#123;<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;main&#x27;</span>)&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;popup&#x27;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Portal</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li>注意：<ul>
<li>Portal标签 将呈现包装，除非针对 document.head</li>
<li>事件会根据组件层次结构而不是元素层次结构</li>
<li><span class="key_words">『默认情况下，子项包裹在 div。如果应用在 SVG 上，必须使用 isSVG 属性来避免子项包裹在 div 中』</span></li>
</ul>
</li>
</ul>
<h2 id="ErrorBoundary-标签"><a href="#ErrorBoundary-标签" class="headerlink" title="ErrorBoundary 标签"></a>ErrorBoundary 标签</h2><ul>
<li>含义：用于创建错误边界。它会捕获在渲染或更新其子项期间发生的任何错误</li>
<li>注意: <span class="desc">在渲染过程之外发生的错误(如在事件处理程序中或在 setTimeout 之后)不会被捕获</span></li>
<li>属性值：<ul>
<li>fallback：可用于在发生错误时显示用户友好的错误消息或通知。<ul>
<li>如果 fallback 是回调函数：<ul>
<li>error：error 对象</li>
<li>reset：重新渲染其子项并重置错误状态，为用户提供一种从错误中恢复的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Effects"><a href="#Effects" class="headerlink" title="Effects"></a>Effects</h2><ul>
<li>管理副作用，当它们所依赖的信号发生变化时触发的函数</li>
<li>场景：DOM、数据获取和订阅</li>
<li>createEffect: 传入一个函数，该函数立即调用其中的函数<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createEffect</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="管理依赖项"><a href="#管理依赖项" class="headerlink" title="管理依赖项"></a>管理依赖项</h3><ul>
<li>Solid 会自动跟踪效果的依赖关系，因此<span class="key_words">『无需手动指定依赖项』</span></li>
<li>signals、变量、props、context 或任何其他响应式值，任何一个更改，都会重新运行</li>
<li><span class="key_words">『初始化后，将运行一次』</span>，无论它是否有任何依赖项。<span class="key_words">『当依赖性更改才会再次运行』</span></li>
</ul>
<h3 id="订阅信号"><a href="#订阅信号" class="headerlink" title="订阅信号"></a>订阅信号</h3><ul>
<li>当 Effect 设置为观察信号事，它会创建对该信号的订阅</li>
<li>一个 Effect 具有观察多个信号的能力，多个 Effect 可以跟踪单个信号</li>
<li>注意：<span class="key_words">『当信号更新时，会按顺序通知所有订阅者，虽然可以保证 effect 在信号更新时运行，但执行可能不是即时的。这意味 Effect 的执行下顺序无法保证』</span></li>
</ul>
<h3 id="嵌套效果"><a href="#嵌套效果" class="headerlink" title="嵌套效果"></a>嵌套效果</h3><ul>
<li><span class="key_words">『允许每个效果单独跟踪自己的依赖项，而不会影响它嵌套在其中的效果』</span></li>
<li>执行顺序很重要。<span class="key_words">『内部效果不会影响外部效果。』</span></li>
<li>内部效果器中访问的信号不会注册为外部效果器的依赖项。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSignal, createEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;solid-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">createSignal</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">createEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Outer effect starts&#x27;</span>)</span><br><span class="line">  <span class="title function_">createEffect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">count</span>())) <span class="comment">// 当count变化, 仅运行该条Effect不影响外部</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Outer effect ends&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h3><h4 id="onMount"><a href="#onMount" class="headerlink" title="onMount"></a>onMount</h4><ul>
<li>只运行一次副作用,类似于 Effect，但不跟踪依赖项。</li>
<li><span class="key_words">『一旦组件初始化，回调将被执行且不会再次执行』</span></li>
<li>比较适合只调用一次的 API</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMount &#125; <span class="keyword">from</span> <span class="string">&#x27;solid-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">createSignal</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">createEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>() <span class="comment">// will run every time data changes</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMount</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// will run only once, when the component is mounted</span></span><br><span class="line">    <span class="keyword">const</span> fetchedData = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/data&#x27;</span>)</span><br><span class="line">    <span class="title function_">setData</span>(fetchedData)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="onCleanup"><a href="#onCleanup" class="headerlink" title="onCleanup"></a>onCleanup</h4><ul>
<li>在不需要任务时清理任务。</li>
<li><span class="key_words">『将在组件卸载时运行，并删除 Effect 具有的所有订阅』</span></li>
<li>可以避免内存泄漏</li>
<li>适合清除定时器</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onCleanup &#125; <span class="keyword">from</span> <span class="string">&#x27;solid-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> [count, setCount] = <span class="title function_">createSignal</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="title function_">setCount</span>(<span class="function">(<span class="params">prev</span>) =&gt;</span> prev + <span class="number">1</span>)</span><br><span class="line">	&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">	<span class="title function_">onCleanup</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">clearInterval</span>(timer)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Count: &#123;count()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h2><ul>
<li>是一种响应式值，可用于记忆派生状态或昂贵的计算</li>
<li><span class="key_words">『仅对其依赖项的每次更改执行一次』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createMemo, createSignal &#125; <span class="keyword">from</span> <span class="string">&#x27;solid-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">createSignal</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isEven = <span class="title function_">createMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">count</span>() % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEven</span>()) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setCount</span>(<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEven</span>()) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Memo-vs-Effect"><a href="#Memo-vs-Effect" class="headerlink" title="Memo vs Effect"></a>Memo vs Effect</h3><table>
<thead>
<tr>
<th></th>
<th>Memo</th>
<th>Effect</th>
</tr>
</thead>
<tbody><tr>
<td>返回值</td>
<td>返回计算或派生状态结果的 getter</td>
<td>不返回，但执行代码块以响应更改</td>
</tr>
<tr>
<td>缓存结果</td>
<td>是</td>
<td>不</td>
</tr>
<tr>
<td>行为</td>
<td>参数应该是干净的，没有反应式的副作用</td>
<td>可能会导致 UI 更新或数据获取等副作用</td>
</tr>
<tr>
<td>依赖项跟踪</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>示例用例</td>
<td>转换数据结构、计算聚合值、派生状态或其他昂贵的计算</td>
<td>UI 更新、网络请求或外部集</td>
</tr>
</tbody></table>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><ul>
<li>不会引起任何副作用的函数。意味着函数的输出取决于其输入</li>
<li>在memo中引入Effect，会导致无限循环，应改用createEffect()</li>
</ul>
<h4 id="将逻辑保留在memo中"><a href="#将逻辑保留在memo中" class="headerlink" title="将逻辑保留在memo中"></a>将逻辑保留在memo中</h4><ul>
<li>当派生state，使用memo</li>
</ul>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><ul>
<li><a href="https://docs.solidjs.com/concepts/context">Context文档</a></li>
</ul>
<h3 id="何时使用？"><a href="#何时使用？" class="headerlink" title="何时使用？"></a>何时使用？</h3><ul>
<li>需要共享state的大型组件树时，可以避免prop钻探</li>
<li>共享全局数据或应用程序组件树的多个组件定期访问的信息</li>
</ul>
<h3 id="创建和使用"><a href="#创建和使用" class="headerlink" title="创建和使用"></a>创建和使用</h3><ul>
<li>在全局中创建&#x2F;content&#x2F;create.js<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title function_">createContext</span>()</span><br></pre></td></tr></table></figure></li>
<li>在全局中创建&#x2F;context&#x2F;component.jsx<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MyContext</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./create.js&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Provider</span> (<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>传递单个值，直接在MyContext.Provider传递<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Provider</span> value=<span class="string">&quot;new value&quot;</span>&gt;&lt;/<span class="title class_">MyContext</span>.<span class="property">Provider</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>传递多个值（如数组或Object）使用store</li>
</ul>
<h3 id="自定义上下文实用程序"><a href="#自定义上下文实用程序" class="headerlink" title="自定义上下文实用程序"></a>自定义上下文实用程序</h3><ul>
<li>当app包含多个上下文对象时，很难追踪正在使用的上下文对象。解决方式：创建自定义app</li>
</ul>
<h4 id="在app的不同区域访问Provider-导入组件并封装组件树"><a href="#在app的不同区域访问Provider-导入组件并封装组件树" class="headerlink" title="在app的不同区域访问Provider,导入组件并封装组件树"></a>在app的不同区域访问Provider,导入组件并封装组件树</h4><ul>
<li>结合·创建和使用·的代码一起看，步骤相似</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CounterProvider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./counterProvider&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">CounterProvider</span> <span class="attr">count</span>=<span class="string">&#123;1&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to Counter<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">NestedComponents</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">CounterProvider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="创建自定义实用程序来访问上下文"><a href="#创建自定义实用程序来访问上下文" class="headerlink" title="创建自定义实用程序来访问上下文"></a>创建自定义实用程序来访问上下文</h4><ul>
<li>可以更轻松访问所需值，而不是在使用它的组件上导入和传入上下文对象</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useContext</span>(<span class="title class_">CounterContext</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用</span></span><br><span class="line"><span class="keyword">import</span> &#123; useCounter &#125; <span class="keyword">from</span> <span class="string">&quot;./counter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">CounterProvider</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useCounter</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="更新上下文"><a href="#更新上下文" class="headerlink" title="更新上下文"></a>更新上下文</h3><ul>
<li>信号提供一种方式使用上下文去同步和管理组件之间共享的数据方法。</li>
<li>是一种跨组件管理状态的方法，中间不必通过中间元素传递props</li>
<li><span class="key_words">『可以将信号直接传递给 Provider 组件的 value属性』</span>，对信号的任何更改都将反映在所有使用上下文的组件中。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Context.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; createSignal, useContext &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">CounterProvider</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">createSignal</span>(props.<span class="property">initialCount</span> || <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> counter = [</span><br><span class="line">    count,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function"><span class="params">prev</span> =&gt;</span> prev + <span class="number">1</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function"><span class="params">prev</span> =&gt;</span> prev - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">CounterContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;counter&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">CounterContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useCounter</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="title function_">useContext</span>(<span class="title class_">CounterContext</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用到全局App.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CounterProvider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./Context&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Child</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./Child&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">CounterProvider</span> <span class="attr">count</span>=<span class="string">&#123;1&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to Counter App<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">CounterProvider</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个组件单独使用上下文Child.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; useCounter &#125; <span class="keyword">from</span> <span class="string">&quot;./Context&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, &#123; increment, decrement &#125;] = <span class="title function_">useCounter</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;decrement&#125;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用上下文进行调试"><a href="#使用上下文进行调试" class="headerlink" title="使用上下文进行调试"></a>使用上下文进行调试</h3><ul>
<li>createContext接受可选的 default 值，如果未提供，则可能会返回undefined</li>
<li>解决TS报错：<ul>
<li>1.指定默认值</li>
<li>2.使用自定义app处理好后在使用（<span class="desc">错误在自定义app中处理，使用处理好后的自定义app</span>）</li>
</ul>
</li>
</ul>
<h3 id="createContext-和-useContext-常见问题"><a href="#createContext-和-useContext-常见问题" class="headerlink" title="createContext 和 useContext 常见问题"></a>createContext 和 useContext 常见问题</h3><ul>
<li>如果没有将默认值传递给 createContext，则 useContext 可能会返回 undefined。</li>
<li>解决TS报错：将 useContext 的所有使用包装在一个函数中，如果上下文未定义，该函数将显式地抛出一个有用的错误。</li>
<li>示例：跟createContext的处理方式一样<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useCounterContext</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">CounterContext</span>)</span><br><span class="line">  <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;can&#x27;t find CounterContext&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="仓库-Store"><a href="#仓库-Store" class="headerlink" title="仓库 Store"></a>仓库 Store</h2><ul>
<li>store 可以生成一组反应式信号，每个信号对应于一个特定的属性，这在处理复杂状态时可能很有用</li>
</ul>
<h3 id="创建Store"><a href="#创建Store" class="headerlink" title="创建Store"></a>创建Store</h3><ul>
<li>可以管理多种数据类型，包括对象、数组、字符串和数字</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js/store&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize store</span></span><br><span class="line"><span class="keyword">const</span> [store, setStore] = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">userCount</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">users</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&quot;felix909&quot;</span>,</span><br><span class="line">      <span class="attr">location</span>: <span class="string">&quot;England&quot;</span>,</span><br><span class="line">      <span class="attr">loggedIn</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&quot;tracy634&quot;</span>,</span><br><span class="line">      <span class="attr">location</span>: <span class="string">&quot;Canada&quot;</span>,</span><br><span class="line">      <span class="attr">loggedIn</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&quot;johny123&quot;</span>,</span><br><span class="line">      <span class="attr">location</span>: <span class="string">&quot;India&quot;</span>,</span><br><span class="line">      <span class="attr">loggedIn</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="访问Store"><a href="#访问Store" class="headerlink" title="访问Store"></a>访问Store</h3><ul>
<li>语句：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">xxx</span>(xxx指仓库的属性)</span><br></pre></td></tr></table></figure></li>
<li>Store初始状态不会跟踪更改，此时去更改会报错。这些信号是惰性创建的，这意味着只有在响应式上下文中访问时才会形成（<span class="desc">例如在组件函数、计算属性或效果的 return 语句中</span>）</li>
<li><span class="key_words">『创建完后放在createEffect，会建立起跟踪，就可以访问到。』</span></li>
</ul>
<h3 id="修改Store值"><a href="#修改Store值" class="headerlink" title="修改Store值"></a>修改Store值</h3><ul>
<li>语句：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setStore</span>(key, newValue)</span><br></pre></td></tr></table></figure></li>
<li>会自动更新的</li>
<li>也可以使用嵌套store来设置属性</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [store, setStore] = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">userCount</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">users</span>: [ ... ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [users, setUsers] = <span class="title function_">createStore</span>(store.<span class="property">users</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">setUsers</span>(<span class="function">(<span class="params">currentUsers</span>) =&gt;</span> [</span><br><span class="line">  ...currentUsers,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;michael584&quot;</span>,</span><br><span class="line">    <span class="attr">location</span>: <span class="string">&quot;Nigeria&quot;</span>,</span><br><span class="line">    <span class="attr">loggedIn</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Path语法灵活性"><a href="#Path语法灵活性" class="headerlink" title="Path语法灵活性"></a>Path语法灵活性</h3><ul>
<li>初始参数用于指定导致要修改的目标值的键，而最后一个参数提供新值。</li>
<li>不仅可以使用字符串键，还可以选择使用键数组</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setState</span>([<span class="number">1</span>,<span class="number">3</span>], <span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">loggedln</span>, <span class="literal">false</span>) <span class="comment">// 把users数组中索引为1和3的user.loggedln状态改为false&lt;/span&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="修改数组中的值"><a href="#修改数组中的值" class="headerlink" title="修改数组中的值"></a>修改数组中的值</h3><ul>
<li>path语法不依赖于发现单个索引，而是引入几种强大的数组作技术。</li>
</ul>
<h4 id="追加新值"><a href="#追加新值" class="headerlink" title="追加新值"></a>追加新值</h4><ul>
<li>要将新元素追加到 store 中的数组，请指定目标数组并将索引设置为所需位置。 <ul>
<li><span class="desc">例如: 如果要将新元素追加到数组的末尾，则可以将索引设置为：array.length</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setStore</span>(<span class="string">&quot;users&quot;</span>, <span class="function">(<span class="params">otherUsers</span>) =&gt;</span> [</span><br><span class="line">  ...otherUsers,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;michael584&quot;</span>,</span><br><span class="line">    <span class="attr">location</span>: <span class="string">&quot;Nigeria&quot;</span>,</span><br><span class="line">    <span class="attr">loggedIn</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变成这样</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setStore</span>(<span class="string">&quot;users&quot;</span>, store.<span class="property">users</span>.<span class="property">length</span>, &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&quot;michael584&quot;</span>,</span><br><span class="line">  <span class="attr">location</span>: <span class="string">&quot;Nigeria&quot;</span>,</span><br><span class="line">  <span class="attr">loggedIn</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="修改多个元素"><a href="#修改多个元素" class="headerlink" title="修改多个元素"></a>修改多个元素</h4><ul>
<li>使用路径语法，可以定位数组的元素子集，或对象的属性，通过指定数组或索引范围。</li>
<li>如果store.users是对象数组，可以一次设置多个索引对应的属性<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setStore</span>(<span class="string">&quot;users&quot;</span>, [<span class="number">2</span>, <span class="number">7</span>, <span class="number">10</span>], <span class="string">&quot;loggedIn&quot;</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果store.users是对象将对象名映射到对象，可以一次设置多个用户的属性<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setStore</span>(<span class="string">&quot;users&quot;</span>, [<span class="string">&quot;me&quot;</span>, <span class="string">&quot;you&quot;</span>], <span class="string">&quot;loggedIn&quot;</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>特别是对于数组，可以通过from 和 to指定索引范围（包括from 和to值）<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setStore</span>(<span class="string">&quot;users&quot;</span>, &#123;<span class="attr">from</span>: <span class="number">1</span>, <span class="attr">to</span>: store.<span class="property">users</span>.<span class="property">length</span> - <span class="number">1</span>&#125;, <span class="string">&quot;loggedIn&quot;</span>, <span class="literal">false</span>) <span class="comment">// 除了索引0都改变</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在 range 对象中包含一个键来指定步长<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setStore</span>(<span class="string">&quot;users&quot;</span>, &#123; <span class="attr">from</span>: <span class="number">0</span>, <span class="attr">to</span>: store.<span class="property">users</span>.<span class="property">length</span> - <span class="number">1</span>, <span class="attr">by</span>: <span class="number">2</span> &#125;, <span class="string">&quot;loggedIn&quot;</span>, <span class="literal">false</span>) 每<span class="number">2</span>的倍数改变</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="动态值分配"><a href="#动态值分配" class="headerlink" title="动态值分配"></a>动态值分配</h4><ul>
<li>函数接收旧值作为参数，允许您根据现有值计算新值</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setStore</span>(<span class="string">&quot;users&quot;</span>, <span class="number">3</span>, <span class="string">&quot;loggedIn&quot;</span> , <span class="function">(<span class="params">loggedIn</span>) =&gt;</span> !loggedIn)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="筛选值"><a href="#筛选值" class="headerlink" title="筛选值"></a>筛选值</h4><ul>
<li>使用函数充当过滤器，该函数接收旧值和索引作为参数</li>
<li>除了.startsWith，还可以使用其他数组方法，例如.find以筛选所需的值。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setStore</span>(<span class="string">&quot;users&quot;</span>, <span class="function">(<span class="params">user</span>) =&gt;</span> user.<span class="property">username</span>.<span class="title function_">startsWith</span>(<span class="string">&quot;t&quot;</span>), <span class="string">&quot;loggedIn&quot;</span>, <span class="literal">false</span>) <span class="comment">// username开头为t的改变</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="修改对象"><a href="#修改对象" class="headerlink" title="修改对象"></a>修改对象</h3><ul>
<li>如果新值是对象，则会与现有值进行浅层合并。如果新对象中的值于旧对象有重叠，把旧值改为新值。</li>
<li>可以直接对 store 进行更改，而无需展开现有对象的属性。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setStore</span>(<span class="string">&quot;users&quot;</span>, <span class="number">0</span>, &#123; <span class="attr">id</span>: <span class="number">109</span>,&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Store-的实体函数"><a href="#Store-的实体函数" class="headerlink" title="Store 的实体函数"></a>Store 的实体函数</h3><h4 id="存储更新-produce"><a href="#存储更新-produce" class="headerlink" title="存储更新 produce"></a>存储更新 produce</h4><ul>
<li>提供了一种处理数据的方法，就好像它是可变的 JavaScript 对象一样。</li>
<li>还提供了一种同时更改多个属性的方法，无需多次调用。</li>
<li>注意：<span class="key_words">『它是专门为处理数组和对象而设计的。其他集合类型与此实用程序不兼容。』</span></li>
<li>produce vs setStore<ul>
<li>两者都可用于修改状态，但关键区别在于它们如何处理数据。 </li>
<li>produce：允许使用 State 的临时 Draft，应用更改，然后生成新的 Store 不可变版本。</li>
<li>setStore：提供了一种更直接的方式来直接更新 store，而无需创建新版本。</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; produce &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js/store&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改users的0号元素的值</span></span><br><span class="line"><span class="title function_">setStore</span>(</span><br><span class="line">  <span class="string">&quot;users&quot;</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="title function_">produce</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    user.<span class="property">username</span> = <span class="string">&quot;newUsername&quot;</span></span><br><span class="line">    user.<span class="property">location</span> = <span class="string">&quot;newLocation&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数据集成reconcile"><a href="#数据集成reconcile" class="headerlink" title="数据集成reconcile"></a>数据集成reconcile</h4><ul>
<li>当需要将新信息合并到现有store时，reconcile可能会很有用。</li>
<li><span class="key_words">『reconcile 将确定新数据和现有数据之间的差异，并仅在值发生更改时启动更新』</span>，从而避免不必要的更新</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createStore, reconcile &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js/stores&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [data, setData] = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">animals</span>: [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;gorilla&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newData = <span class="title function_">getNewData</span>() <span class="comment">// eg. contains [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;bird&#x27;, &#x27;gorilla&#x27;, &#x27;koala&#x27;]</span></span><br><span class="line"><span class="title function_">setData</span>(<span class="string">&#x27;animals&#x27;</span>, <span class="title function_">reconcile</span>(newData))</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="提取原始数据unwrap"><a href="#提取原始数据unwrap" class="headerlink" title="提取原始数据unwrap"></a>提取原始数据unwrap</h4><ul>
<li>将 store 转换为标准对象的方法</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, unwrap &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js/store&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [data, setData] = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">animals</span>: [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;bird&quot;</span>, <span class="string">&quot;gorilla&quot;</span>],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rawData = <span class="title function_">unwrap</span>(data)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ul>
<li>以附加到任何元素，用于引用 DOM 元素或组件实例</li>
</ul>
<h3 id="访问DOM元素"><a href="#访问DOM元素" class="headerlink" title="访问DOM元素"></a>访问DOM元素</h3><ul>
<li>不建议通过元素选择器访问 DOM 元素</li>
<li>由于 Solid 中的元素可以根据state在 DOM 中添加或删除，因此需要等到元素附加到 DOM 后才能访问它。可以通过使用onMount等到元素附加到 DOM 后再访问它</li>
</ul>
<h3 id="JSX作为值"><a href="#JSX作为值" class="headerlink" title="JSX作为值"></a>JSX作为值</h3><ul>
<li>可以在直接访问 DOM 元素时分配给变量</li>
<li>优点：可以多次使用，而不用担心重复</li>
<li>缺点：将元素和任何子元素与 JSX 结构的其余部分分开。难阅读</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> myElement = <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>My Element<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;myElement&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Solid-中的-Refs"><a href="#Solid-中的-Refs" class="headerlink" title="Solid 中的 Refs"></a>Solid 中的 Refs</h3><ul>
<li>可以直接在 JSX 模板中访问 DOM 元素，从而保持元素的结构不变</li>
<li>先赋值后再添加DOM<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> myElement;<span class="comment">//  先定义一个变量（赋值发生在将元素添加到 DOM 之前的创建时）</span></span><br><span class="line">  <span class="comment">// TS声明定义：let myElement!: HTMLDivElement;</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&#123;myElement&#125;</span>&gt;</span>My Element<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果在将元素添加到 DOM 之前需要访问该元素，则可以使用以下回调形式：<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p ref=&#123;<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  myElement = el <span class="comment">// el已经创建但不能添加到DOM</span></span><br><span class="line">  &#125;&#125;&gt;</span><br><span class="line">  <span class="title class_">My</span> <span class="title class_">Element</span></span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="信号也可以用作-refs"><a href="#信号也可以用作-refs" class="headerlink" title="信号也可以用作 refs"></a>信号也可以用作 refs</h3><ul>
<li>直接访问元素时有用，但在组件首次呈现时该元素可能不存在，或者可能在某个时候从 DOM 中删除。</li>
<li>可以嵌套在条件判断中，条件添加成立才显示</li>
</ul>
<h3 id="转发refs"><a href="#转发refs" class="headerlink" title="转发refs"></a>转发refs</h3><ul>
<li>作用：允许将 ref 从父组件传递到子组件的技术</li>
<li>过程：将 ref 传递给子组件，然后将 ref 分配给子组件的元素，子组件获取props拿到该值</li>
<li>类似于react中的组件传递值</li>
</ul>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li>作用：允许将可重用的行为附加到 DOM 元素</li>
<li>功能：<ul>
<li>在一个元素上有多个指令</li>
<li>将响应式数据传递给回调</li>
</ul>
</li>
<li>本质：具有特定签名的函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">directive</span>(<span class="params">element: Element, accessor: () =&gt; any</span>): <span class="keyword">void</span></span><br></pre></td></tr></table></figure>
<ul>
<li>element: 应用指令的DOM元素</li>
<li>accessor：一个函数，用于访问传递给指令的值</li>
</ul>
</li>
<li>指令函数在渲染时调用，但在将元素添加到DOM之前调用</li>
<li>用途： <ul>
<li>创建信号</li>
<li>启动Effect</li>
<li>添加事件侦听器等</li>
</ul>
</li>
</ul>
<h2 id="细粒度反应性"><a href="#细粒度反应性" class="headerlink" title="细粒度反应性"></a>细粒度反应性</h2><ul>
<li>反应性确保对数据更改的自动响应，无需手动更新用户界面（UI）。通过将 UI 元素连接到基础数据，更新变得自动化。 在细粒度的反应式系统中，应用程序现在将能够进行高度针对性和特定的更新。</li>
<li>Solid vs React<ul>
<li>在 Solid 中，对需要更改的目标属性进行更新，从而避免更广泛的更新，有时甚至是不必要的更新。 </li>
<li>React 会重新执行整个组件来更改单个 attribute，这可能效率较低。</li>
</ul>
</li>
</ul>
<h3 id="构建反应式系统"><a href="#构建反应式系统" class="headerlink" title="构建反应式系统"></a>构建反应式系统</h3><ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createSignal</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createEffect</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">createSignal</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 按照观察者模式：signals 将维护订阅者effect的</span></span><br><span class="line"><span class="title function_">createEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The count is &quot;</span> + <span class="title function_">count</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="响应式原语"><a href="#响应式原语" class="headerlink" title="响应式原语"></a>响应式原语</h3><ul>
<li>在Solid的响应性系统中，有两个关键元素：信号和观察者。</li>
<li>响应式功能的基础，也是核心元素：<ul>
<li>Stores：这些代理在后台创建、读取和写入信号</li>
<li>Memo：类似于Effects，但区别在于它们返回信号并通过缓存优化计算。它们根据效果的行为进行更新，但更适合计算优化。</li>
<li>resources：基于 memo 的概念，将网络请求的异步性转换为同步性，其中结果嵌入到 signal 中。</li>
<li>渲染效果是一种立即启动的定制效果，专为管理渲染过程而设计。</li>
</ul>
</li>
</ul>
<h3 id="制作系统反应式"><a href="#制作系统反应式" class="headerlink" title="制作系统反应式"></a>制作系统反应式</h3><ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentSubscriber = <span class="literal">null</span> <span class="comment">// 初始化订阅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSignal</span>(<span class="params">initValue</span>) &#123; <span class="comment">// 创建信号</span></span><br><span class="line">  <span class="keyword">let</span> value = initValue</span><br><span class="line">  <span class="keyword">const</span> subscribers = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(currentSubscriber) &#123; <span class="comment">// 添加订阅者</span></span><br><span class="line">      subscribers.<span class="title function_">add</span>(currentSubscriber)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setter</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(value === initValue) <span class="keyword">return</span> <span class="comment">// 相同不处理</span></span><br><span class="line">    value = newValue  <span class="comment">// 更新变量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> subscribers <span class="keyword">of</span> subscribes) &#123; <span class="comment">// 通知所有订阅者</span></span><br><span class="line">      <span class="title function_">subscriber</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  [getter, setter]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createEffect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> preSubscriber = currentSubscriber</span><br><span class="line">  currentSubscriber = fn</span><br><span class="line">  <span class="title function_">fn</span>() <span class="comment">// 注册signals</span></span><br><span class="line">  currentSubscriber = preSubscriber <span class="comment">// 一旦函数运行，重置订阅者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="验证反应式系统"><a href="#验证反应式系统" class="headerlink" title="验证反应式系统"></a>验证反应式系统</h3><ul>
<li>可以使用定时器验证每隔n秒是否有响应更改</li>
</ul>
<h3 id="管理反应式系统中的生命周期"><a href="#管理反应式系统中的生命周期" class="headerlink" title="管理反应式系统中的生命周期"></a>管理反应式系统中的生命周期</h3><ul>
<li>在反应式系统中，各种元素（同称为节点）是相互关联的。</li>
<li>这些节点可以是signal、effect或其他反应式基元。</li>
<li>它们充当共同构成系统反应行为的各个单元。</li>
</ul>
<h4 id="效果跟踪的同步性质"><a href="#效果跟踪的同步性质" class="headerlink" title="效果跟踪的同步性质"></a>效果跟踪的同步性质</h4><ul>
<li>系统注册订阅者，运行effect函数，然后取消注册订阅者。所有的这些都是以线性、同步的顺序进行</li>
<li>在createEffect中创建setTimeout。由于系统式同步的，因此它不会等待完成。在setTimeout中触发getter式，全局范围不在具有已注册的订阅者。跟踪会出现问题</li>
</ul>
<h4 id="处理异步效果"><a href="#处理异步效果" class="headerlink" title="处理异步效果"></a>处理异步效果</h4><ul>
<li>虽然基本的响应式系统式同步的。但是像Solid这样的框架提供了处理异步的功能。</li>
<li>on：提供了手动指定效果的依赖关系方法</li>
<li>resource: 将网络请求的异步性转换为同步性，并将结果嵌入信号中</li>
</ul>
<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><ul>
<li>安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install @solidjs/router</span><br></pre></td></tr></table></figure></li>
<li>基础设置：组件将匹配URL以显示所需的页面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>))</span><br></pre></td></tr></table></figure></li>
<li>提供根级布局: 不会在页面更改时更新，是顶级导航和上下文提供程序的理想位置<ul>
<li>把 router 的 根节点挂载在App上<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js/web&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Router</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@solidjs/router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">root</span>=<span class="string">&#123;App&#125;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>添加路由: 在Router嵌入Route，Route可以指定一个path和一个组件</li>
<li>catchall路由：用于路由器找不到的页面，如404页面。<ul>
<li>使用方式：<span class="key_words">『*参数名』</span>，参数名为可选</li>
</ul>
</li>
<li>创建指向路由的链接<ul>
<li>途径1：可以使用原生锚点标签（<code>&lt;a&gt;</code>）</li>
<li>途径2：使用 A组件：提供路由的导航，可以使用CSS、inactiveClass和activeClass属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js/web&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Router</span>, <span class="title class_">Route</span>, A &#125; <span class="keyword">from</span> <span class="string">&quot;@solidjs/router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;./pages/Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Users</span> <span class="keyword">from</span> <span class="string">&quot;./pages/Users&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NotFound</span> <span class="keyword">from</span> <span class="string">&quot;./pages/NotFound&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params">props</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* 创建指向路由的链接: href指向path一样的路由 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">A</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">A</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">A</span> <span class="attr">href</span>=<span class="string">&quot;/users&quot;</span>&gt;</span>Users<span class="tag">&lt;/<span class="name">A</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Site Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">root</span>=<span class="string">&#123;App&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     &#123;/*  添加路由 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/users&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Users&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/*  catchall路由示例，NotFound为遇到404是显示的页面组件 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;*paramName&quot;</span> <span class="attr">component</span>=<span class="string">&#123;NotFound&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">  ),</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="延迟加载路由组件"><a href="#延迟加载路由组件" class="headerlink" title="延迟加载路由组件"></a>延迟加载路由组件</h3><ul>
<li>lazy函数：推迟组件的加载，直到导航到该组件为止</li>
<li>示例：组件引入时使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lazy &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Users</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./pages/Users&quot;</span>));</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./pages/Home&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul>
<li>使用<span class="key_words">『冒号:』</span>,后面可以是任意字符串，只要url符合该模式，组件都会显示</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/users/:id&quot;</span> component=&#123;<span class="title class_">User</span>&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>关于动画&#x2F;过渡的注意事项：共享相同路径的路由将被视为同一路由。<ul>
<li>如果想强制重新渲染，可以将组件包装在一个带键的<code>&lt;Show&gt;</code>:</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Show</span> when=&#123;params.<span class="property">something</span>&#125; keyed&gt;</span><br><span class="line">    &lt;<span class="title class_">MyComponent</span>&gt;</span><br><span class="line">&lt;/<span class="title class_">Show</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="访问参数-useParams"><a href="#访问参数-useParams" class="headerlink" title="访问参数 useParams()"></a>访问参数 useParams()</h4><ul>
<li>含义：使用useParams访问后，可以在组件中使用它们</li>
<li>useParams对于 createResource 和 createSignal，可以基于路由参数创建动态行为</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createResource &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useParams &#125; <span class="keyword">from</span> <span class="string">&quot;@solidjs/router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchUser</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(</span><br><span class="line">    <span class="string">`https://jsonplaceholder.typicode.com/users/<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">User</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> params = <span class="title function_">useParams</span>();</span><br><span class="line">  <span class="keyword">const</span> [data] = <span class="title function_">createResource</span>(<span class="function">() =&gt;</span> params.<span class="property">id</span>, fetchUser); <span class="comment">// 通过参数去创建resource</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Show</span> <span class="attr">when</span>=<span class="string">&#123;!data.loading&#125;</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">p</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: &#123;data().name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>Email: &#123;data().email&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>Phone: &#123;data().phone&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Show</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="验证路由-matchFilters"><a href="#验证路由-matchFilters" class="headerlink" title="验证路由 matchFilters"></a>验证路由 matchFilters</h4><ul>
<li>含义：传递一个每个参数对应的验证规则的对象</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">filters</span>: <span class="title class_">MatchFilters</span> = &#123; <span class="comment">// 任何一个不符合都不匹配</span></span><br><span class="line">  <span class="attr">parent</span>: [<span class="string">&quot;mom&quot;</span>, <span class="string">&quot;dad&quot;</span>], <span class="comment">// 只允许是这两个字符串</span></span><br><span class="line">  <span class="attr">id</span>: <span class="regexp">/^\d+$/</span>, <span class="comment">// 只允许数字</span></span><br><span class="line">  <span class="attr">withHtmlExtension</span>: <span class="function">(<span class="params">v: string</span>) =&gt;</span> v.<span class="property">length</span> &gt; <span class="number">5</span> &amp;&amp; v.<span class="title function_">endsWith</span>(<span class="string">&quot;.html&quot;</span>), <span class="comment">// 只允许v的长度大于5，且后缀为.html</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">path</span>=<span class="string">&quot;/users/:parent/:id/:withHtmlExtension&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">component</span>=<span class="string">&#123;User&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">matchFilters</span>=<span class="string">&#123;filters&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数 ?"></a>可选参数 ?</h4><ul>
<li>在参数名称的<span class="key_words">『末尾添加?』</span>，将指定参数设置为可选参数</li>
<li>示例: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/stories/:id?&quot;</span> component=&#123;<span class="title class_">Stories</span>&#125; /&gt; <span class="comment">//  id可有可无都不影响</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="通配符路由"><a href="#通配符路由" class="headerlink" title="通配符路由 *"></a>通配符路由 *</h4><ul>
<li>*必须是<span class="key_words">『路径的最后一部分』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;foo/*&quot;</span> component=&#123;<span class="title class_">Foo</span>&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>要将通配符部分作为参数公开给组件，可以将其命名：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;foo/*any&quot;</span> component=&#123;<span class="title class_">Foo</span>&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多路径"><a href="#多路径" class="headerlink" title="多路径"></a>多路径</h4><ul>
<li>使用数组定义路径</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=&#123;[<span class="string">&quot;login&quot;</span>, <span class="string">&quot;register&quot;</span>]&#125; component=&#123;<span class="title class_">Login</span>&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ul>
<li>component 属性可以直接传递同页面的函数组件，也可以直接使用箭头函数返回一个Dom</li>
<li>只有叶节点（最里面的组件）才会被赋予</li>
<li>路由可以无限嵌套</li>
<li>示例： 两个指向同一个URL并渲染同一组件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/users&quot;</span> component=&#123;<span class="title class_">Users</span>&#125; /&gt; <span class="comment">// 让 parent 成为自己的路由，你必须单独指定它</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/users/:id&quot;</span> <span class="attr">component</span>=<span class="string">&#123;User&#125;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* 嵌套组件 */</span>&#125;</span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/users&quot;</span>&gt; <span class="comment">// 可以在这里添加一个component=&#123;函数组件&#125;，该组件中&lt;A&gt;指向/，还使用props.children ,返回的节点应该是声明props.children的父节点，而不是下面单独指定的父节点</span></span><br><span class="line">  &#123;<span class="comment">/* 必须单独指定父节点，才会成为自己的路由 */</span>&#125;</span><br><span class="line">  &lt;<span class="title class_">Route</span> path=<span class="string">&quot;/&quot;</span> component=&#123;<span class="title class_">Users</span>&#125; /&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/:id&quot;</span> <span class="attr">component</span>=<span class="string">&#123;User&#125;</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Route</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="预加载函数-preload"><a href="#预加载函数-preload" class="headerlink" title="预加载函数 preload"></a>预加载函数 preload</h3><ul>
<li>使用 preload 函数，数据获取与加载 route 并行启动</li>
<li>preload 函数通过在 Route 加载后调用或者在链接悬停时急切地调用</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">preloadUser</span>(<span class="params">&#123; params, location &#125;</span>) &#123;&#125; <span class="comment">// 该函数传递用于访问路由信息的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并传递preload</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/users/:id&quot;</span> component=&#123;<span class="title class_">User</span>&#125; preload=&#123;preloadUser&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>可以从专用文件或文件中导出与路由相对应的预加载函数和数据包装器。此模式提供了一种无需加载其他任何内容即可导入 data 函数的方法</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/pages/users/[id].data.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; query &#125; <span class="keyword">from</span> <span class="string">&quot;@solidjs/router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getUser = <span class="title function_">query</span>(<span class="title function_">async</span> (id) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://swapi.tech/api/people/<span class="subst">$&#123;id&#125;</span>/`</span>)).<span class="title function_">json</span>();</span><br><span class="line">&#125;, <span class="string">&quot;getUser&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">preloadUser</span>(<span class="params">&#123; params, location, intent &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getUser</span>(params.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时直接导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; preloadUser &#125; <span class="keyword">from</span> <span class="string">&quot;./pages/users/[id].data.js&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>在除 preload 之外的任何时间调用时，preload 函数的值都会传递给页面组件。可以初始化页面或使用createAsync</li>
<li>注意：<span class="desc">要防止多次提取或触发重新提取，使用query</span></li>
</ul>
<h2 id="数据获取-createResource"><a href="#数据获取-createResource" class="headerlink" title="数据获取 createResource"></a>数据获取 createResource</h2><ul>
<li>专为管理异步数据获取而设计的专用信号。</li>
<li>它包装了异步操作，提供了一种处理各种状态的方法：loading、success 和 error。</li>
<li>此功能是非阻塞的，这意味着即使在检索信息期间，也可以保证应用程序保持响应。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>createResource需要一个返回 Promise 作为其参数的函数。在调用时返回一个信号，该信号具有反应性属性：<ul>
<li>state：当前状态(unresolved、pending、ready、refreshing 或 errored)</li>
<li>loading：当前任务是否正在进行，boolean类型</li>
<li>error：错误的信息。</li>
<li>latest：返回最新数据或结果。</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetchUser</span> = <span class="keyword">async</span> (<span class="params">id</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://swapi.dev/api/people/<span class="subst">$&#123;id&#125;</span>/`</span>);</span><br><span class="line">  <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [user] = <span class="title function_">createResource</span>(userId, fetchUser);</span><br><span class="line"><span class="comment">// 使用 user.loading ...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="调用多个异步事件-Suspense"><a href="#调用多个异步事件-Suspense" class="headerlink" title="调用多个异步事件 Suspense"></a>调用多个异步事件 Suspense</h3><ul>
<li><span class="key_words">『同步多个异步事件的显示』</span>。允许等待所有异步事件解析时回退占位符，防止显示部分加载内容</li>
<li>直接在使用异步语句的最外层添加</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Suspense</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Match</span> <span class="attr">when</span>=<span class="string">&#123;user.error&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>Error: &#123;user.error.message&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Match</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Match</span> <span class="attr">when</span>=<span class="string">&#123;user()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;JSON.stringify(user())&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Match</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Suspense</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="动态数据处理"><a href="#动态数据处理" class="headerlink" title="动态数据处理"></a>动态数据处理</h3><h4 id="mutate"><a href="#mutate" class="headerlink" title="mutate"></a>mutate</h4><ul>
<li>在即时反馈或响应很重要的情况下，该方法提供“乐观突变”。</li>
<li>此功能在任务列表等应用程序中特别有价值。</li>
<li><span class="desc">例如: 当用户输入新任务并单击按钮时，无论与服务器正在进行的数据通信如何，列表都将立即刷新。</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">For</span>, createResource &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TodoList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [tasks, &#123; mutate &#125;] = <span class="title function_">createResource</span>(fetchTasksFromServer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">For</span> <span class="attr">each</span>=<span class="string">&#123;tasks()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;(task) =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;task.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          )&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">For</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          mutate((todos) =&gt; [...todos, &quot;do new task&quot;]); // add todo for user</span></span><br><span class="line"><span class="language-xml">          // make a call to send to database</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        Add Task</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="refetch"><a href="#refetch" class="headerlink" title="refetch"></a>refetch</h4><ul>
<li>当需要实时反馈时，该方法可用于重新加载当前查询，而不管任何更改。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createResource, onCleanup &#125; <span class="keyword">from</span> <span class="string">&quot;solid-js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">StockPriceTicker</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [prices, &#123; refetch &#125;] = <span class="title function_">createResource</span>(fetchStockPrices);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">refetch</span>()</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="title function_">onCleanup</span>(<span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JS框架</category>
      </categories>
      <tags>
        <tag>Solid</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-安装和编译</title>
    <url>/2024/11/01/TS/ts-%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ol>
<li>在使用typeScript的文件夹下执行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure></li>
<li>新建一个.ts后缀的文件然后贴上例子</li>
<li>在终端执行命令且不报错<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tsc greeter.<span class="property">ts</span></span><br></pre></td></tr></table></figure></li>
<li>报错：以管理员身份开启Windows Powershell</li>
<li>输入指令：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">set-<span class="title class_">ExecutionPolicy</span> <span class="title class_">RemoteSigned</span></span><br></pre></td></tr></table></figure></li>
<li>输入y或a没报错执行成功</li>
<li>回到终端再次执行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tsc greeter.<span class="property">ts</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-实用类 Utility Types</title>
    <url>/2024/11/01/TS/ts%E5%AE%9E%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="在一个类型里面部分-必选"><a href="#在一个类型里面部分-必选" class="headerlink" title="在一个类型里面部分+必选"></a>在一个类型里面<span class="key_words">部分+必选</span></h3><ul>
<li>Required<T>、Pick&lt;T, K&gt; - (<span class="desc">T☞type， K☞keys</span>)<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> totalProps &#123;</span><br><span class="line">  a?: <span class="built_in">number</span>;</span><br><span class="line">  b?: <span class="built_in">string</span>;</span><br><span class="line">  c?: <span class="built_in">string</span></span><br><span class="line">  d?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> aPropsPick = <span class="title class_">Pick</span>&lt;totalProps, <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;c&#x27;</span> | <span class="string">&#x27;d&#x27;</span> &gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: <span class="title class_">Required</span>&lt;aPropsPick&gt; = &#123; <span class="attr">a</span>: <span class="number">5</span> ,<span class="attr">c</span>: <span class="string">&#x27;ddd&#x27;</span>,<span class="attr">d</span>: <span class="number">123</span> &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="适用于构造对象类型"><a href="#适用于构造对象类型" class="headerlink" title="适用于构造对象类型"></a>适用于构造<span class="key_words">对象类型</span></h3><ul>
<li>Record&lt;Keys, Type&gt; - (<span class="desc">键，值</span>)<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> keyType = <span class="string">&#x27;input&#x27;</span> | <span class="string">&#x27;arrow&#x27;</span> | <span class="string">&#x27;pick&#x27;</span> | <span class="string">&#x27;icon&#x27;</span> | <span class="string">&#x27;radio&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> totalProps &#123;</span><br><span class="line">  <span class="attr">classname</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">placeholder</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: <span class="title class_">Record</span>&lt;keyType, totalProps&gt; = &#123;</span><br><span class="line">  <span class="attr">input</span>: &#123;</span><br><span class="line">    <span class="attr">classname</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">    <span class="attr">placeholder</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">arrow</span>: &#123;</span><br><span class="line">    <span class="attr">classname</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">    <span class="attr">placeholder</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">pick</span>: &#123;</span><br><span class="line">    <span class="attr">classname</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">    <span class="attr">placeholder</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">icon</span>: &#123;</span><br><span class="line">    <span class="attr">classname</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">    <span class="attr">placeholder</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">radio</span>: &#123;</span><br><span class="line">    <span class="attr">classname</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">    <span class="attr">placeholder</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="省略-排除"><a href="#省略-排除" class="headerlink" title="省略 排除"></a>省略 排除</h3><ul>
<li>Omit&lt;对象，要省略的字段&gt;</li>
<li>Exclude&lt;字符串字面量，要排除的字段&gt;</li>
<li>Extract&lt;Type,Union&gt;: 返回的是一个并集</li>
<li>type TodoPreview &#x3D; Exclude&lt;’a’ | “b” |”c” | “d”, “b”&gt;;</li>
</ul>
<h3 id="更多映射类型-—"><a href="#更多映射类型-—" class="headerlink" title="更多映射类型 — "></a>更多映射类型 — <a href="/2024/11/01/TS/%E5%85%AB%E3%80%81%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/" title="TS-高级类型">TS-高级类型</a></h3>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-基础类型和类型推论</title>
    <url>/2024/11/01/TS/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isBoolean</span>: boolean = <span class="literal">true</span> or <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isNumber</span>: number = <span class="number">6</span> <span class="comment">// 可赋值null和undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: string = <span class="string">`this <span class="subst">$&#123;变量&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: number[] or <span class="title class_">Array</span>&lt;number&gt;= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// 数值类型的数组</span></span><br></pre></td></tr></table></figure>


<h3 id="元组（Tuple）：已知元素数量和类型的数组，各元素的类型不必相同"><a href="#元组（Tuple）：已知元素数量和类型的数组，各元素的类型不必相同" class="headerlink" title="元组（Tuple）：已知元素数量和类型的数组，各元素的类型不必相同"></a>元组（Tuple）：已知元素数量和类型的数组，各元素的类型不必相同</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [string, number]</span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>,<span class="number">10</span>] <span class="comment">// 顺序不能写错</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul>
<li><a href="/2024/11/01/TS/%E5%85%AD%E3%80%81%E6%9E%9A%E4%B8%BE/" title="TS-枚举">TS-枚举</a></li>
</ul>
<h3 id="any：允许赋任意值，且可以调用在这个变量上的任意方法，而Object不能调用这些方法"><a href="#any：允许赋任意值，且可以调用在这个变量上的任意方法，而Object不能调用这些方法" class="headerlink" title="any：允许赋任意值，且可以调用在这个变量上的任意方法，而Object不能调用这些方法"></a>any：允许赋任意值，且可以调用在这个变量上的任意方法，而Object不能调用这些方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: any[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;free&quot;</span>];</span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>; <span class="comment">// 给list[1]赋值,覆盖原数组</span></span><br></pre></td></tr></table></figure>

<h3 id="空值-void-没有返回值的返回类型"><a href="#空值-void-没有返回值的返回类型" class="headerlink" title="空值(void): 没有返回值的返回类型"></a>空值(void): 没有返回值的返回类型</h3><h3 id="null和undefined-返回各自类型"><a href="#null和undefined-返回各自类型" class="headerlink" title="null和undefined: 返回各自类型"></a>null和undefined: 返回各自类型</h3><ul>
<li>默认情况下，可以赋值给number</li>
<li>指定–strictNullChecks标记，null和undefined只能赋值给void和自己</li>
</ul>
<h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><ul>
<li>永不存在的值的类型(<span class="desc">异常，箭头函数返回值，无返回值的函数表达式，永不为真的变量)</span></li>
<li>never可以赋值给其它类型，但除never本身，任意类型都不可以赋值给never</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="keyword">void</span></span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;) <span class="comment">// 这里规定只可以出现对象或null，其它为error</span></span><br><span class="line">obj[key] <span class="comment">// obj[]是对象的一种写法,将key作为obj里面的一个key,返回value</span></span><br></pre></td></tr></table></figure>


<h2 id="类型断言-类型转换"><a href="#类型断言-类型转换" class="headerlink" title="类型断言:类型转换"></a>类型断言:类型转换</h2><h3 id="is关键字"><a href="#is关键字" class="headerlink" title="is关键字"></a>is关键字</h3><ul>
<li>当一个变量存在多个类型时，编译器识别不出来使用</li>
<li>eg: 假值判断<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type <span class="title class_">Falsy</span> = <span class="literal">false</span> | <span class="string">&#x27;&#x27;</span> | <span class="number">0</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isFalsy = (<span class="attr">val</span>: unknown): val is <span class="title class_">Falsy</span> =&gt; !val;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="“尖括号”语法-使用指定someValue的类型为string"><a href="#“尖括号”语法-使用指定someValue的类型为string" class="headerlink" title="“尖括号”语法: 使用&lt;&gt;指定someValue的类型为string"></a>“尖括号”语法: 使用&lt;&gt;指定someValue的类型为string</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: any = <span class="string">&quot;this is a string&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: number = (&lt;string&gt;someValue).<span class="property">length</span> </span><br></pre></td></tr></table></figure>

<h3 id="as语法：使用as指定类型"><a href="#as语法：使用as指定类型" class="headerlink" title="as语法：使用as指定类型"></a>as语法：使用as指定类型</h3><ul>
<li>在TS里使用JSX时，只有as语法断言是被允许的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: number = (someValue <span class="keyword">as</span> string).<span class="property">length</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><ul>
<li>基础类型,通过值来推出类型: 发生在初始化变量和成员，设置默认参数值和决定函数返回值时</li>
</ul>
<h3 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h3><ul>
<li>多个表达式中存在不同类型，需要找到通用的类型</li>
<li>有存在共享相同的类型时,可以通过类,继承关系将选项中不存在的值类型获取到<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">zoo</span>: <span class="title class_">Animal</span>[] = [<span class="keyword">new</span> <span class="title class_">Rhino</span>(), <span class="keyword">new</span> <span class="title class_">Elephant</span>(), <span class="keyword">new</span> <span class="title class_">Snake</span>()];</span><br></pre></td></tr></table></figure></li>
<li>如未找到最佳通用类型，类型推断的结果为<span class="key_words">『联合数组类型』</span><ul>
<li>(Rhino | Elephant | Snake)[]</li>
</ul>
</li>
</ul>
<h3 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h3><ul>
<li>通过 &#x3D; 或 : 的左边来推出右边的类型(明确给出类型则忽略推断结果)</li>
<li>使用场景: 函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。</li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-类型兼容</title>
    <url>/2024/11/01/TS/%E4%B8%83%E3%80%81%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>如果x要兼容y，那么y至少具有与x相同的属性(只有检查对象)</p>
</blockquote>
<h3 id="比较原始类型和对象类型"><a href="#比较原始类型和对象类型" class="headerlink" title="比较原始类型和对象类型"></a>比较原始类型和对象类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="title class_">Named</span>;</span><br><span class="line"><span class="comment">// 这里y推断的类型为&#123; name: string; location: string; &#125;</span></span><br><span class="line"><span class="keyword">let</span> y = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">location</span>: <span class="string">&#x27;Seattle&#x27;</span> &#125;;</span><br><span class="line">x = y; <span class="comment">// =左边的成员能否在=右边中找到 (名字和类型都要一一对应)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"><span class="attr">n</span>: <span class="title class_">Named</span></span>) &#123; <span class="comment">//Named目标,才会一一检查,传进来的是否能满足要求</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + n.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">greet</span>(y);<span class="comment">//对于检查函数的参数也适用</span></span><br></pre></td></tr></table></figure>

<h3 id="比较两个函数"><a href="#比较两个函数" class="headerlink" title="比较两个函数"></a>比较两个函数</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">x</span> = (<span class="params"><span class="attr">a</span>: <span class="built_in">number</span></span>) =&gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">y</span> = (<span class="params"><span class="attr">b</span>: <span class="built_in">number</span>, <span class="attr">s</span>: <span class="built_in">string</span></span>) =&gt; <span class="number">0</span>;</span><br><span class="line">y = x <span class="comment">//跟上面不一样,看的是=右边的成员能否在=左边中找到(且只看类型,名字不同无所谓)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><span class="key_words">比较返回值类型</span>: 目标函数返回值类型的子类型<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">x</span> = (<span class="params"></span>) =&gt; (&#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">y</span> = (<span class="params"></span>) =&gt; (&#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">location</span>: <span class="string">&#x27;Seattle&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// 目标函数x的返回类型在y中找得到所以成功</span></span><br></pre></td></tr></table></figure></li>
<li><span class="key_words">函数参数双向协变</span>: <ul>
<li>只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。</li>
</ul>
</li>
<li><span class="key_words">可选参数及剩余参数</span>: <ul>
<li>可选和必须参数是可互换,剩余参数被当作无限个可选参数</li>
</ul>
</li>
<li><span class="key_words">函数重载</span>: <ul>
<li>源函数的每个重载都要在目标函数上找到对应的函数签名</li>
</ul>
</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul>
<li>不同枚举不兼容(除了枚举与数字枚举互相兼容)</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li>比较两个类类型的对象时，只有实例(方法)的成员会被比较,<span class="desc">静态和构造不比较</span></li>
<li><span class="key_words">类的私有成员和受保护成员:</span> <ul>
<li>目标类型包含一个私有&#x2F;保护成员，那么源类型必须包含来自同一个类的这个私有&#x2F;保护成员.</li>
<li>这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</li>
</ul>
</li>
</ul>
<h3 id="泛型-没参时-当作any比较-有参时-比较参数类型"><a href="#泛型-没参时-当作any比较-有参时-比较参数类型" class="headerlink" title="泛型: 没参时,当作any比较;有参时,比较参数类型"></a>泛型: 没参时,当作any比较;有参时,比较参数类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NotEmpty</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="attr">data</span>: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="title class_">NotEmpty</span>&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="title class_">NotEmpty</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">x = y <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<h3 id="高级主题-子类型与赋值"><a href="#高级主题-子类型与赋值" class="headerlink" title="高级主题: 子类型与赋值"></a>高级主题: 子类型与赋值</h3><ul>
<li>赋值扩展了子类型兼容性，允许和any来回赋值，以及enum和对应数字值之间的来回赋值</li>
<li>类型兼容性是由赋值兼容性来控制的，即使在implements和extends语句也不例外</li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-接口与类</title>
    <url>/2024/11/01/TS/%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> labelValue &#123;</span><br><span class="line">  label : <span class="built_in">string</span> <span class="comment">// 接口里面有一个label属性，且为字符串类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel2</span>(<span class="params"><span class="attr">obj</span>: labelValue</span>) &#123; <span class="comment">// 规定传参的类型是这个接口的属性</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">label</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printLabel2</span>(myObj) <span class="comment">// 通过调用传参，只要有一个参数跟接口里面的属性名和类型相同，就会打印</span></span><br></pre></td></tr></table></figure>
<h3 id="duck-typing特性（鸭子类型）"><a href="#duck-typing特性（鸭子类型）" class="headerlink" title="duck-typing特性（鸭子类型）"></a>duck-typing特性（鸭子类型）</h3><ul>
<li>检验两个比较的对象是否具有相同的属性及类型，b是否包含a</li>
<li>如person与Person的比较，虽然person的属性数量大于Person，但是person具有Person的所有属性且类型相同，所以，检验过程成功<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;schnuffel&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;1231312312&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">testFunc</span> = (<span class="params"><span class="attr">param</span>: <span class="title class_">Person</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> param</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">testFunc</span>(person)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="可选、只读属性："><a href="#可选、只读属性：" class="headerlink" title="可选、只读属性："></a>可选、只读属性：</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">  color?: <span class="built_in">string</span> <span class="comment">// 可选属性</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span> <span class="comment">// 只读属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSquare</span>(<span class="params"><span class="attr">config</span>: <span class="title class_">SquareConfig</span></span>): &#123; <span class="attr">color</span>: <span class="built_in">string</span>; <span class="attr">area</span>: <span class="built_in">number</span> &#125; &#123; </span><br><span class="line">  <span class="comment">// 规定传参的类型是这个接口的属性，又定义了函数返回的数据类型</span></span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123;<span class="attr">color</span>: <span class="string">&quot;white&quot;</span>, <span class="attr">area</span>: <span class="number">100</span>&#125;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">color</span>) &#123;</span><br><span class="line">    newSquare.<span class="property">color</span> = config.<span class="property">color</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123;<span class="attr">color</span>: <span class="string">&quot;black&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">SquareConfig</span> = &#123; <span class="attr">y</span>: <span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="只读数组ReadonlyArray：创建后不能被修改"><a href="#只读数组ReadonlyArray：创建后不能被修改" class="headerlink" title="只读数组ReadonlyArray：创建后不能被修改"></a>只读数组ReadonlyArray<T>：创建后不能被修改</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">ro</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = a</span><br><span class="line"><span class="comment">// 只读数组ro不可以赋值给一个普通数组,要赋值只能断言重写</span></span><br><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[] <span class="comment">//as把ro从只读数组变为数组类型</span></span><br></pre></td></tr></table></figure>
<h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">  color?: <span class="built_in">string</span></span><br><span class="line">  width?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSquare</span>(<span class="params"><span class="attr">config</span>:<span class="title class_">SquareConfig</span></span>): &#123;<span class="attr">color</span>: <span class="built_in">string</span>; <span class="attr">area</span>: <span class="built_in">number</span>&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;) </span><br><span class="line"><span class="comment">// colour不在createSquare的类型中，报错</span></span><br><span class="line"></span><br><span class="line">解决方法<span class="number">1</span>：类型断言：</span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">opacity</span>: <span class="number">0.5</span> &#125; <span class="keyword">as</span> <span class="title class_">SquareConfig</span>)</span><br><span class="line"></span><br><span class="line">解决方法<span class="number">2</span>：字符串索引签名（最佳）：</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 只要不是color和width，其他的属性都能通过检验</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解决方法<span class="number">3</span>： 将这个对象赋值给另一个变量</span><br><span class="line"><span class="keyword">let</span> squareOptions = &#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(squareOptions)</span><br></pre></td></tr></table></figure>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">  (<span class="attr">source</span>: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数顺序及类型只要与接口中的一样，属性名可不同</span></span><br><span class="line">mySearch：<span class="title class_">SearchFunc</span> = <span class="keyword">function</span>(<span class="params"><span class="attr">src</span>: <span class="built_in">string</span>, <span class="attr">sub</span>: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.<span class="title function_">search</span>(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><ul>
<li>ts支持两种索引签名：字符串和数字。可同时使用，但是数字索引的返回值必须是字符串索引返回值类型的子类型</li>
<li>可以设置为只读: <span class="en">readonly [index: number]: string</span><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">StringArray</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: number]: string  <span class="comment">// 定义了一个索引签名[index : number]，它的返回类型是string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><h3 id="实现接口-implements"><a href="#实现接口-implements" class="headerlink" title="实现接口 implements"></a>实现接口 implements</h3><ul>
<li>接口描述了类的公共部分。它不会帮你检查类是否具有某些私有成员。<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInterface</span> &#123; <span class="comment">// 接口ClockInterface</span></span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span> <span class="comment">// 方法1</span></span><br><span class="line">  <span class="title function_">setTime</span>(<span class="attr">d</span>: <span class="title class_">Date</span>) <span class="comment">// 方法2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123; <span class="comment">// Clock 实施 ClockInterface</span></span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span>;    <span class="comment">//实例部分检查</span></span><br><span class="line">  <span class="title function_">setTime</span>(<span class="params"><span class="attr">d</span>: <span class="title class_">Date</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentTime</span> = d <span class="comment">// 在Clock类里实现这个方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">h</span>: <span class="built_in">number</span>, <span class="attr">m</span>: <span class="built_in">number</span></span>) &#123;&#125; <span class="comment">//类静态部分，不检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="继承接口-extends"><a href="#继承接口-extends" class="headerlink" title="继承接口 extends"></a>继承接口 extends</h3><ul>
<li>一个接口可以继承多个接口，继承多个接口的接口叫做合成接口<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>, <span class="title class_">PenStroke</span> &#123; <span class="comment">// 合成接口</span></span><br><span class="line">  <span class="attr">sideLength</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;<span class="title class_">Square</span>&gt;&#123;&#125; <span class="comment">// 定义一个变量去使用合成接口的方法</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="混合接口：js使用第三方库时用"><a href="#混合接口：js使用第三方库时用" class="headerlink" title="混合接口：js使用第三方库时用"></a>混合接口：js使用第三方库时用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Counter</span> &#123;</span><br><span class="line">  (<span class="attr">start</span>: number): string;</span><br><span class="line">  <span class="attr">interval</span>: number;</span><br><span class="line">  <span class="title function_">reset</span>(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCounter</span>(<span class="params"></span>): <span class="title class_">Counter</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = &lt;<span class="title class_">Counter</span>&gt;<span class="keyword">function</span> (<span class="params">start: number</span>) &#123;&#125; <span class="comment">// 作为函数</span></span><br><span class="line">  counter.<span class="property">interval</span> = <span class="number">123</span></span><br><span class="line">  counter.<span class="property">reset</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口继承类型"><a href="#接口继承类型" class="headerlink" title="接口继承类型"></a>接口继承类型</h3><ul>
<li>接口继承类，可继承类的私有属性和protected，但只能被这个类和它的子类实现<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Control</span> &#123; <span class="comment">// 父类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">state</span>: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SelectableControl</span> <span class="keyword">extends</span> <span class="title class_">Control</span> &#123; <span class="comment">// 接口继承父类</span></span><br><span class="line">  <span class="title function_">select</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Control</span> <span class="keyword">implements</span> <span class="title class_">SelectableControl</span> &#123; </span><br><span class="line">  <span class="comment">// 子接口继承父类实施接口</span></span><br><span class="line">  <span class="title function_">select</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Control</span> &#123;</span><br><span class="line">  <span class="comment">// 子接口继承父类人可以使用接口方法</span></span><br><span class="line">  <span class="title function_">select</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote>
<p>通过extends的类叫做<span class="en">派生类或子类</span>，而父类叫做<span class="en">基类或超类</span></p>
</blockquote>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li>public：默认，公共属性</li>
<li>private：私有属性，不能在声明它的类的外部访问。<ul>
<li>private和protected在比较类型时，只有两个类型都有同样的修饰符，并且该修饰符来自同一基类时，才认为这两个类型是兼容的。<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">theName</span>: <span class="built_in">string</span></span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = theName &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rhino</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">super</span>(<span class="string">&quot;Rhino&quot;</span>) &#125; <span class="comment">// 使用了父类的构造方法，名字为Rhino</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Goat&quot;</span>)	<span class="comment">// Goat</span></span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> <span class="title class_">Rhino</span>() <span class="comment">// Rhino</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>protected：保护属性<ul>
<li>不能在声明它的类的外部访问，但派生类中仍然可以访问</li>
<li>构造函数也可以被标记成 protected。这意味着这个类不能在包含它的类外被实例化，但是能被继承</li>
</ul>
</li>
<li>readonly：只读修饰符，必须在声明时或构造函数里被初始化。</li>
<li>static: 静态属性，只有当前类才有的属性</li>
<li>abstract：抽象类<ul>
<li>做为其它派生类的基类使用。 它们一般不会直接被实例化</li>
<li>定义的方法必须在派生类中实现，派生类的构造函数必须调用super()<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">department</span>: <span class="title class_">Department</span> <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> 子类名() <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.<span class="title function_">printName</span>() <span class="comment">// 在声明的抽象类中不存在的不可以调用，子类有也不可以</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="存取器：get和set成对出现"><a href="#存取器：get和set成对出现" class="headerlink" title="存取器：get和set成对出现"></a>存取器：get和set成对出现</h3><ul>
<li>get 变量名()</li>
<li>set 变量名()<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getToken</span>(): <span class="title class_">Itoken</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Initoken</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">setToken</span>( <span class="attr">tokenData</span>: <span class="title class_">Itoken</span> ): <span class="title class_">Itoken</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ( <span class="title class_">Initoken</span> = &#123; ...<span class="title class_">Initoken</span>, ...tokenData &#125; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>类定义会创建两个东西：类的实例类型和一个构造函数。<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> standardGreeting = <span class="string">&quot;Hello,there&quot;</span></span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">message</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;，</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">greeter</span>: <span class="title class_">Greeter</span> <span class="comment">// 这一行编译为js时是构造函数</span></span><br><span class="line">greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&quot;world&quot;</span>) <span class="comment">// 创建一个类实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">greeterMaker</span>: <span class="keyword">typeof</span> <span class="title class_">Greeter</span> = <span class="title class_">Greeter</span> <span class="comment">// 这个变量保存了类构造函数的类型</span></span><br><span class="line">greeterMaker.<span class="property">standardGreeting</span> = <span class="string">&quot;Hey there!&quot;</span> <span class="comment">// 可以用这个类型中包含的所有静态成员和构造函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="把类当做接口使用"><a href="#把类当做接口使用" class="headerlink" title="把类当做接口使用"></a>把类当做接口使用</h3><ul>
<li>类可以创建出类型，所以在允许使用接口的地方可以使用类<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3</span>d <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="es5-vs-es6-的类区别"><a href="#es5-vs-es6-的类区别" class="headerlink" title="es5 vs es6 的类区别"></a>es5 vs es6 的类区别</h3><ul>
<li>es6：class类必须new调用，不能直接执行<ul>
<li>不存在变量提升</li>
<li>无法遍历它实例原型链上的属性和方法</li>
</ul>
</li>
<li>es5：类和普通函数无区别，可以执行</li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-symbols和迭代器和生成器</title>
    <url>/2024/11/01/TS/%E4%B9%9D%E3%80%81symbols%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h1 id="symbols"><a href="#symbols" class="headerlink" title="symbols"></a>symbols</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="创建symbol类型"><a href="#创建symbol类型" class="headerlink" title="创建symbol类型"></a>创建symbol类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = <span class="title class_">Symbol</span>() <span class="comment">// 只能通过Symbol构造函数创建的</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbols是不可改变且唯一的"><a href="#Symbols是不可改变且唯一的" class="headerlink" title="Symbols是不可改变且唯一的"></a>Symbols是不可改变且唯一的</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym2 = <span class="title class_">Symbol</span>(<span class="string">&quot;key&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> sym3 = <span class="title class_">Symbol</span>(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">sym2 === sym3 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="symbols也可以被用做对象属性的键"><a href="#symbols也可以被用做对象属性的键" class="headerlink" title="symbols也可以被用做对象属性的键"></a>symbols也可以被用做对象属性的键</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; [sym]: <span class="string">&quot;value&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="可以与计算出的属性名声明相结合来声明对象的属性和类成员"><a href="#可以与计算出的属性名声明相结合来声明对象的属性和类成员" class="headerlink" title="可以与计算出的属性名声明相结合来声明对象的属性和类成员"></a>可以与计算出的属性名声明相结合来声明对象的属性和类成员</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getClassNameSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">	[getClassNameSymbol]()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>()</span><br><span class="line"><span class="keyword">let</span> className = c[getClassNameSymbol]() <span class="comment">// &quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="众所周知的Symbols"><a href="#众所周知的Symbols" class="headerlink" title="众所周知的Symbols"></a>众所周知的Symbols</h2><h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><ul>
<li>识别一个对象是否是其实例</li>
</ul>
<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><ul>
<li>含义：表示当在一个对象上调用Array.prototype.concat时，这个对象的数组元素是否可展开</li>
<li>返回：布尔值</li>
</ul>
<h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><ul>
<li>含义：for-of语句,返回默认迭代器</li>
</ul>
<h3 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h3><ul>
<li>含义：正则表达式用来匹配字符串</li>
</ul>
<h3 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h3><ul>
<li>含义：正则表达式用来替换字符串中匹配的子串</li>
</ul>
<h3 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h3><ul>
<li>含义: 正则表达式返回被匹配部分在字符串中的索引</li>
</ul>
<h3 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h3><ul>
<li>含义：正则表达式来用分割字符串</li>
</ul>
<h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h3><ul>
<li>含义：用来创建派生对象</li>
<li>返回：函数值，为一个构造函数</li>
</ul>
<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><ul>
<li>含义：把对象转换为相应的原始值</li>
</ul>
<h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><ul>
<li>返回： 创建对象时默认的字符串描述。</li>
</ul>
<h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3><ul>
<li>含义：它自己拥有的属性会被with作用域排除在外。</li>
<li>返回：一个对象</li>
</ul>
<h3 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h3><ul>
<li>含义：返回Symbol对象的可选描述的字符串。</li>
<li>语法：<ul>
<li>Symbol(‘myDescription’).description;</li>
<li>Symbol.iterator.description;</li>
<li>Symbol.for(‘foo’).description;</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">description</span>;      <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"><span class="title class_">Symbol</span>().<span class="property">description</span>;           <span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">description</span>;  <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><h3 id="for…of-迭代对象的键对应的值"><a href="#for…of-迭代对象的键对应的值" class="headerlink" title="for…of: 迭代对象的键对应的值"></a>for…of: 迭代对象的键对应的值</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> x)&#123;&#125; <span class="comment">// 遍历的结果是a,d</span></span><br></pre></td></tr></table></figure>

<h3 id="for…in-迭代对象的键的列表"><a href="#for…in-迭代对象的键的列表" class="headerlink" title="for…in: 迭代对象的键的列表"></a>for…in: 迭代对象的键的列表</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> x)&#123;&#125; <span class="comment">//遍历的结果是值的下标0,1</span></span><br></pre></td></tr></table></figure>

<h2 id="mixins-结合-可提前给混合进来的属性方法占位"><a href="#mixins-结合-可提前给混合进来的属性方法占位" class="headerlink" title="mixins: 结合,可提前给混合进来的属性方法占位"></a>mixins: 结合,可提前给混合进来的属性方法占位</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ad</span> <span class="keyword">implements</span> a,b&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三斜线指令-单行注释-注释内容会作为编译器指令使用"><a href="#三斜线指令-单行注释-注释内容会作为编译器指令使用" class="headerlink" title="三斜线指令: &#x2F;&#x2F;&#x2F; 单行注释,注释内容会作为编译器指令使用"></a>三斜线指令: &#x2F;&#x2F;&#x2F; 单行注释,注释内容会作为编译器指令使用</h2><ol>
<li>声明文件间的依赖,当使用–out或–outFile时，可调整输出内容的顺序。文件在输出文件内容中的位置与经过预处理后的输入顺序一致。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;...&quot; /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>指定<span class="en">–noResolve</span>编译选项，三斜线引用会被忽略,它们不会增加新文件，也不会改变给定文件的顺序。</li>
<li>声明了对某个包的依赖。(d.ts文件): <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt;reference types=&quot;...&quot; /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>把一个文件标记成默认库<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt;reference no-default-lib=&quot;true&quot;/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>默认生成的AMD模块都是匿名的。允许给编译器传入一个可选的模块名<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt;amd-module /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-变量声明</title>
    <url>/2024/11/01/TS/%E4%BA%8C%E3%80%81%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ol>
<li>存在变量提升</li>
<li>同一变量重复声明多次只拿到一个结果</li>
<li>可以在包含它的函数、模块、命名空间、全局作用域内部任何位置被访问</li>
</ol>
<h2 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h2><ol>
<li>都有块级作用域</li>
<li>一个作用域内只能声明一次</li>
<li>不能在被声明之前读或写</li>
<li>直到声明前的区域都属于<span class="key_words">『暂时性死区』</span><ul>
<li>使用最小特权原则，所有变量除了计划去修改的都应该使用const</li>
</ul>
</li>
</ol>
<h2 id="type-类型别名"><a href="#type-类型别名" class="headerlink" title="type 类型别名"></a>type 类型别名</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给number这个类型命名为second，而second引用这个类型</span></span><br><span class="line">type <span class="title class_">Second</span> = number </span><br></pre></td></tr></table></figure>

<h2 id="数组解构：『一一对应』"><a href="#数组解构：『一一对应』" class="headerlink" title="数组解构：『一一对应』"></a>数组解构：<span class="key_words">『一一对应』</span></h2><ul>
<li>let [, second, , fourth] &#x3D; [1, 2, 3, 4]</li>
<li>使用…语法创建剩余变量：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first,rest); <span class="comment">// 1, [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对象解构：『一一对应』"><a href="#对象解构：『一一对应』" class="headerlink" title="对象解构：『一一对应』"></a>对象解构：<span class="key_words">『一一对应』</span></h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">	<span class="attr">b</span>: <span class="number">12</span>,</span><br><span class="line">	<span class="attr">c</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = o <span class="comment">// 直接解构对象</span></span><br><span class="line"></span><br><span class="line">(&#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="string">&quot;baz&quot;</span>, <span class="attr">b</span>: <span class="number">101</span> &#125;) <span class="comment">// 没有声明的赋值，要加()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; a, ...passthrough &#125; = o <span class="comment">// ...语法创建剩余变量</span></span><br></pre></td></tr></table></figure>

<h2 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: newName1, <span class="attr">b</span>: newName2 &#125; = o <span class="comment">// 从左到右读，a重命名为newName1</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">	<span class="attr">b</span>: <span class="number">12</span>,</span><br><span class="line">	<span class="attr">c</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认值：属性为-undefined-时使用缺省值"><a href="#默认值：属性为-undefined-时使用缺省值" class="headerlink" title="默认值：属性为 undefined 时使用缺省值"></a>默认值：属性为 undefined 时使用缺省值</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">tempObject</span>(<span class="attr">wholeObject</span>: &#123; <span class="attr">a</span>: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;) =&gt; &#123;</span><br><span class="line">	<span class="comment">// 即使b没有传值也为undefined</span></span><br><span class="line">	<span class="keyword">let</span> &#123; a, b = <span class="number">1001</span> &#125; = wholeObject </span><br><span class="line">	<span class="comment">// 当b位undefined时使用默认值1001</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> C = &#123; <span class="attr">a</span>: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b &#125;: C</span>): <span class="built_in">void</span> &#123; </span><br><span class="line">	<span class="comment">// 解构赋值：a，b为对象C里面的值，该函数本身无返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a=<span class="string">&quot;&quot;</span>, b=<span class="number">0</span> &#125; = &#123;&#125;</span>): <span class="built_in">void</span> &#123; <span class="comment">/*给a，b指定默认值*/</span> &#125;</span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure>

<h2 id="展开操作符…"><a href="#展开操作符…" class="headerlink" title="展开操作符…"></a>展开操作符…</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// 对first和second的浅拷贝，不会对原数组进行改变</span></span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul>
<li><span class="key_words">『从左向右处理，所以后面的属性会覆盖前面的属性』</span><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123; <span class="attr">food</span>: <span class="string">&quot;spicy&quot;</span>, <span class="attr">price</span>: <span class="string">&quot;$$&quot;</span>, <span class="attr">ambiance</span>: <span class="string">&quot;noisy&quot;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> search = &#123; ...defaults, <span class="attr">food</span>: <span class="string">&quot;rich&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">	p = <span class="number">12</span></span><br><span class="line">	<span class="title function_">m</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>()</span><br><span class="line"><span class="keyword">let</span> clone = &#123; ...c &#125;</span><br><span class="line">clone.<span class="property">p</span> <span class="comment">// ok</span></span><br><span class="line">clone.<span class="title function_">m</span>() <span class="comment">// error! 展开对象实例时会丢失方法</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-泛型 &lt;&gt;</title>
    <url>/2024/11/01/TS/%E4%BA%94%E3%80%81%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p> 无法创建泛型枚举和泛型命名空间</p>
</blockquote>
<h2 id="泛型变量T"><a href="#泛型变量T" class="headerlink" title="泛型变量T"></a>泛型变量T</h2><ul>
<li>相当与一个形参变量,只是它返回的是值的类型,传什么类型就返回什么类型,保证传入的值和返回的类型相同<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> test&lt;T&gt;(<span class="attr">arg</span>: T): T &#123; </span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = test&lt;string&gt;(<span class="string">&#x27;arg&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><h3 id="调用签名的对象字面量来定义泛型函数"><a href="#调用签名的对象字面量来定义泛型函数" class="headerlink" title="调用签名的对象字面量来定义泛型函数"></a>调用签名的对象字面量来定义泛型函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mytest</span>: &#123;&lt;T&gt;(<span class="attr">arg</span>: T): T&#125; = identity</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface fnType&#123;</span><br><span class="line">  &lt;T&gt;(arg : T) : T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> test&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">mytest</span>: fnType = test <span class="comment">// 添加类型指定泛型类型</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型类-ClassName-指的是实例部分的类型-类的静态属性不能使用"><a href="#泛型类-ClassName-指的是实例部分的类型-类的静态属性不能使用" class="headerlink" title="泛型类 ClassName: 指的是实例部分的类型,类的静态属性不能使用"></a>泛型类 ClassName<T>: 指的是实例部分的类型,类的静态属性不能使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">zeroValue</span>: T</span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;number&gt;()</span><br></pre></td></tr></table></figure>

<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><ul>
<li>操作某类型的值时,发现某类型具有T类型,但在调用某个属性时，编译器不能保证T中具有该属性就会报错。所以要继承一个任意类的包含的属性，这样在任意类型中就可以使用且不报错<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Lengthwise</span> &#123; <span class="comment">// 1.将这个属性放在接口中</span></span><br><span class="line">  length : number</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> check&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T) : T&#123; <span class="comment">// 2.让T继承这个接口</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">check</span>(&#123;<span class="attr">length</span>: <span class="number">10</span>&#125;) <span class="comment">// 3.使用,一定要传入length里的必须属性</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在泛型约束中使用类型参数：通过调用属性名从对象上获取属性-同时保证这个属性就在这个对象上"><a href="#在泛型约束中使用类型参数：通过调用属性名从对象上获取属性-同时保证这个属性就在这个对象上" class="headerlink" title="在泛型约束中使用类型参数：通过调用属性名从对象上获取属性,同时保证这个属性就在这个对象上"></a>在泛型约束中使用类型参数：通过调用属性名从对象上获取属性,同时保证这个属性就在这个对象上</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getProperty</span>(<span class="params">obj: T, key: K</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key] <span class="comment">// obj[]是对象的一种写法,将key作为obj里面的一个key,返回value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在泛型里使用类类型-使用泛型创建工厂函数时，需要引用构造函数的类类型"><a href="#在泛型里使用类类型-使用泛型创建工厂函数时，需要引用构造函数的类类型" class="headerlink" title="在泛型里使用类类型: 使用泛型创建工厂函数时，需要引用构造函数的类类型"></a>在泛型里使用类类型: 使用泛型创建工厂函数时，需要引用构造函数的类类型</h3><ul>
<li>调用的函数可以调用继承父类的方法</li>
<li>使用场景: 多个类继承一个父类</li>
<li>定义：定义几个类和一个父类,然后创建多个子类继承父类,并且子类中将某个子类赋值给变量(这个变量要统一)，这样就可以使用多个子类、某个类和父类的方法和变量</li>
<li>使用：<pan class="key_words">createInstance(子类).父类方法.子类方法</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> createInstance&lt;T <span class="keyword">extends</span> 父类&gt;(<span class="attr">c</span>: <span class="title function_">new</span>() =&gt;T): T &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-高级类型</title>
    <url>/2024/11/01/TS/%E5%85%AB%E3%80%81%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="交叉类型-多个类型合并为一个类型"><a href="#交叉类型-多个类型合并为一个类型" class="headerlink" title="交叉类型 &amp;: 多个类型合并为一个类型"></a>交叉类型 &amp;: 多个类型合并为一个类型</h2><ul>
<li><span class="key_words">『let c &#x3D; 接口A &amp; 接口B』</span> 的合并类型，c继承A和B的方法又可以使用自身方法</li>
</ul>
<h2 id="联合类型-规定了几个类型-不同的类型使用不同的方法-和类型保护typeof一起使用"><a href="#联合类型-规定了几个类型-不同的类型使用不同的方法-和类型保护typeof一起使用" class="headerlink" title="联合类型 |: 规定了几个类型,不同的类型使用不同的方法(和类型保护typeof一起使用)"></a>联合类型 |: 规定了几个类型,不同的类型使用不同的方法(和类型保护typeof一起使用)</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">img</span> = (<span class="params"><span class="attr">width</span>: <span class="built_in">string</span> | <span class="built_in">number</span>, <span class="attr">height</span>: <span class="built_in">string</span> | <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span>.<span class="property">width</span> === <span class="built_in">number</span>)&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span>.<span class="property">width</span> === <span class="built_in">string</span>)&#123;&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">函数的联合类型:</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): a | b &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型保护与区分类型"><a href="#类型保护与区分类型" class="headerlink" title="类型保护与区分类型"></a>类型保护与区分类型</h2><h3 id="用户自定义的类型保护"><a href="#用户自定义的类型保护" class="headerlink" title="用户自定义的类型保护"></a>用户自定义的类型保护</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123; <span class="title function_">a</span>() &#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flog</span> &#123; <span class="title function_">c</span>() &#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params"><span class="attr">pet</span>: <span class="title class_">Fish</span> | <span class="title class_">Flog</span></span>): pet is <span class="title class_">Fish</span> &#123; <span class="comment">// 手动将pet指定为Fish类型 </span></span><br><span class="line">  <span class="keyword">return</span> (&lt;<span class="title class_">Fish</span>&gt;pet).<span class="property">a</span> !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typeof类型保护"><a href="#typeof类型保护" class="headerlink" title="typeof类型保护"></a>typeof类型保护</h3><ul>
<li>跟联合类型一起使用, 通过判断这个是不是要判断的类型来进入不同代码段</li>
</ul>
<h3 id="instanceof-类型保护-通过构造函数来细化类型"><a href="#instanceof-类型保护-通过构造函数来细化类型" class="headerlink" title="instanceof 类型保护: 通过构造函数来细化类型"></a>instanceof 类型保护: 通过构造函数来细化类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> fu &#123; <span class="comment">// 父类</span></span><br><span class="line">  <span class="title function_">getPaddingString</span>(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">one</span> <span class="keyword">implements</span> fu &#123; <span class="comment">// 子类1实施父类,构造函数为number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="attr">numSpaces</span>: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(<span class="params"></span>) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">two</span> <span class="keyword">implements</span> fu &#123; <span class="comment">// 子类2实施父类,构造函数为string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="attr">value</span>: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(<span class="params"></span>) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRandomPadder</span>(<span class="params"></span>) &#123; <span class="comment">// 定义一个函数,返回这两个子类</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span> ?</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SpaceRepeatingPadder</span>(<span class="number">4</span>) :</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">StringPadder</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">padder</span>: fu = <span class="title function_">getRandomPadder</span>(); <span class="comment">// 此时Padder有两种类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> one) &#123; </span><br><span class="line">  <span class="comment">// 根据instanceof来判断padder是否等于one的构造函数的类型</span></span><br><span class="line">  padder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可以为null的类型"><a href="#可以为null的类型" class="headerlink" title="可以为null的类型"></a>可以为null的类型</h2><ul>
<li>ts中把<span class="key_words">『null和undefined区分为两种类型』</span>，并且null和undefined可以赋值给任意类型</li>
<li>可选参数和可选属性会自动加上undefined</li>
</ul>
<h3 id="类型保护和类型断言-『类型保护用来去除null』"><a href="#类型保护和类型断言-『类型保护用来去除null』" class="headerlink" title="类型保护和类型断言: 『类型保护用来去除null』"></a>类型保护和类型断言: <span class="key_words">『类型保护用来去除null』</span></h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>  <span class="title function_">f</span>(<span class="params"><span class="attr">sn</span>: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">//1.用if...else来判断</span></span><br><span class="line">  <span class="keyword">return</span> sn || <span class="string">&quot;default&quot;</span> <span class="comment">//2.用短路运算符,这样就不可能是null</span></span><br><span class="line">  <span class="comment">//3.用类型断言 参数! : return sn! 去除null和undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型别名-别名-参数名"><a href="#类型别名-别名-参数名" class="headerlink" title="类型别名(别名: 参数名)"></a>类型别名(别名: 参数名)</h2><ul>
<li>不会新建一个类型,只是引用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Tpost</span> = a &amp; b <span class="comment">// Tpost存储了a和b的方法</span></span><br><span class="line"><span class="comment">// 当遇见a,b的复合类型时直接调用Tpost即可</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接口vs类型别名"><a href="#接口vs类型别名" class="headerlink" title="接口vs类型别名"></a>接口vs类型别名</h3><ul>
<li>类型别名不能被extends和implements</li>
</ul>
<h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type A = <span class="string">&quot;B&quot;</span> | <span class="string">&quot;C&quot;</span> | <span class="string">&quot;D&quot;</span> <span class="comment">// A的值只能为&quot;B&quot;或&quot;C&quot;或&quot;D&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type A = <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> <span class="comment">// A的值只能为0或1或2</span></span><br></pre></td></tr></table></figure>

<h2 id="可辨识联合"><a href="#可辨识联合" class="headerlink" title="可辨识联合"></a>可辨识联合</h2><ul>
<li>合并单例类型，联合类型，类型保护和类型别名来创建一个叫做<span class="key_words">『可辨识联合的高级模式』</span>,也叫做<span class="key_words">『标签联合』</span>或<span class="key_words">『代数数据类型』</span><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 可辨识的特征或标签: 要联合的接口存在相同的属性</span><br><span class="line"><span class="keyword">interface</span> a &#123;</span><br><span class="line">  kind : <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  width : <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> b &#123;</span><br><span class="line">  kind : <span class="string">&quot;b&quot;</span>,</span><br><span class="line">  height : <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 联合</span><br><span class="line"><span class="keyword">type</span> union = a | b </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 使用: 当没有涵盖所有可辨识联合的变化，想让编译器通知使用完整性检查</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assertNever</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">never</span></span>): <span class="built_in">never</span> &#123; <span class="comment">// 使用never类型,来检查</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unexpected object: &quot;</span> + x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"><span class="attr">r</span>: union</span>): <span class="built_in">string</span> &#123; <span class="comment">// 完整性检查的方法一: 指定类型</span></span><br><span class="line">  <span class="keyword">switch</span> (r.<span class="property">kind</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>: <span class="keyword">return</span> r.<span class="property">width</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>: <span class="keyword">return</span> r.<span class="property">height</span></span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">return</span> <span class="title function_">assertNever</span>(r) <span class="comment">// 存在除这两种情况的返回assertNever函数</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">  完整性检查: 当代码变化时,让编译器提醒</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="索引类型-通过索引去访问某个值"><a href="#索引类型-通过索引去访问某个值" class="headerlink" title="索引类型: 通过索引去访问某个值"></a>索引类型: 通过索引去访问某个值</h2><ul>
<li>索引类型查询操作符: <span class="key_words">『keyof T』</span>,其值为T上已知的联合属性<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">personProps</span>: keyof <span class="title class_">Person</span>; <span class="comment">// &#x27;name&#x27; | &#x27;age&#x27;</span></span><br><span class="line">使用：</span><br><span class="line">personProps = <span class="string">&#x27;name&#x27;</span> <span class="comment">// 指的是key值</span></span><br></pre></td></tr></table></figure></li>
<li>索引访问操作符: <span class="key_words">『T[K]』</span><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getProperty = &lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">o</span>: T, <span class="attr">name</span>: K): T[K] =&gt; o[name]</span><br><span class="line"><span class="comment">// o[name]：选择T中的K（name这个key）得到对应key的value</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="索引类型和字符串索引签名-keyof和-T-K-与字符串索引签名进行交互"><a href="#索引类型和字符串索引签名-keyof和-T-K-与字符串索引签名进行交互" class="headerlink" title="索引类型和字符串索引签名: keyof和 T[K]与字符串索引签名进行交互"></a>索引类型和字符串索引签名: keyof和 T[K]与字符串索引签名进行交互</h3><ul>
<li>如果带有一个字符串索引签名的类型，则 keyof T是 string类型,且T[string]为索引签名的类型<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Map</span>&lt;T&gt; &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span>]: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">keys</span>: keyof <span class="title class_">Map</span>&lt;<span class="built_in">number</span>&gt; <span class="comment">// T的类型为number,遍历key,得到的类型为string</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: <span class="title class_">Map</span>&lt;<span class="built_in">number</span>&gt;[<span class="string">&#x27;foo&#x27;</span>] <span class="comment">// T的类型为number,获取当key等于foo的值,值为number类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="映射类型-新类型以相同的形式去转换旧类型里每个属性"><a href="#映射类型-新类型以相同的形式去转换旧类型里每个属性" class="headerlink" title="映射类型: 新类型以相同的形式去转换旧类型里每个属性"></a>映射类型: 新类型以相同的形式去转换旧类型里每个属性</h3><ul>
<li>Readonly<T>: T中的属性都为只读</li>
<li>Partial<T>：T中的属性都为可选</li>
<li>Record&lt;K extends string, T&gt;：从T中获取key，T为value的类型</li>
<li>Pick&lt;T, K extends keyof T&gt;：从T中选取几个属性K使用 <span class="desc">条件类型</span></li>
<li>Exclude&lt;T, U&gt;: 从T中剔除可以赋值给U的类型</li>
<li>Extract&lt;T, U&gt;: 提取T中可以赋值给U的类型 <span class="desc">条件类型</span></li>
<li>NonNullable<T>: 从T中剔除null和undefined</li>
<li>ReturnType<T>: 获取函数返回值类型。</li>
<li>InstanceType<T>: 获取构造函数类型的实例类型。</li>
<li>Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;: 实现Omit&lt;T, K&gt;类型</li>
<li>ConditionalType&lt;T, U&gt;: 如果T可以赋值给U，则条件为真，类型X将被选择；否则，类型Y将被选择。<span class="desc">条件类型</span></li>
<li>示例：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123; <span class="comment">// 只读</span></span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123; <span class="comment">// 可选</span></span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonPartial</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Person</span>&gt; <span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyPerson</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Person</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Flags</span> = &#123; [K <span class="keyword">in</span> <span class="title class_">Keys</span>]: <span class="built_in">boolean</span> &#125; <span class="comment">// k遍历keys,将值添加在flags中,值的类型为boolean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123; <span class="comment">// 类型</span></span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span>&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, T&gt; = &#123;  <span class="comment">// 不需要类型</span></span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ConditionalType</span>&lt;T, U&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> U ? X : Y <span class="comment">// 条件类型, 如果T可以赋值给U，则条件为真，类型X将被选择；否则，类型Y将被选择。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常用的映射类型："><a href="#常用的映射类型：" class="headerlink" title="常用的映射类型："></a>常用的映射类型：</h3><ul>
<li>1.初始化对象<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="title class_">Record</span>&lt;keyof <span class="title class_">IPerson</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;moli&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&quot;26&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2.枚举值管理<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>=<span class="string">&quot;RED&quot;</span></span><br><span class="line">  <span class="title class_">Green</span>=<span class="string">&quot;GREEN&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ColorHex</span> = <span class="title class_">Recode</span>&lt;<span class="title class_">Color</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">colorHex</span>: <span class="title class_">ColorHex</span> = &#123;</span><br><span class="line">  [<span class="title class_">Color</span>.<span class="property">Red</span>]: <span class="string">&quot;#FF0000&quot;</span>,</span><br><span class="line">  [<span class="title class_">Color</span>.<span class="property">Green</span>]: <span class="string">&quot;#00FF00&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3.字面量<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&quot;up&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;down&quot;</span> | <span class="string">&quot;left&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RecordDirect</span> = <span class="title class_">Record</span>&lt;<span class="title class_">Direction</span>, <span class="built_in">number</span>&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">direction</span>: <span class="title class_">RecordDirect</span> = &#123;</span><br><span class="line">  <span class="attr">up</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">right</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">down</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">left</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-模块和命名空间</title>
    <url>/2024/11/01/TS/%E5%8D%81%E3%80%81%E6%A8%A1%E5%9D%97%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>内部模块现在称做“命名空间”。 外部模块现在则简称为“模块”</p>
</blockquote>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="export-导出声明的关键字"><a href="#export-导出声明的关键字" class="headerlink" title="export: 导出声明的关键字"></a>export: 导出声明的关键字</h3><ul>
<li>导入一个模块的多个模块: export * from ‘module’</li>
</ul>
<h3 id="import"><a href="#import" class="headerlink" title="import:"></a>import:</h3><ul>
<li>导入一个模块的某个导出内容: <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; xx &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> xx</span><br></pre></td></tr></table></figure></li>
<li>导入内容重命名：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; xx <span class="keyword">as</span> a &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>将整个模块导入到一个变量，并通过它来访问模块的导出部分    <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> validator <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span></span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> validator.<span class="title class_">ZipCodeValidator</span>()</span><br></pre></td></tr></table></figure></li>
<li>具有副作用的导入模块  </li>
<li>设置全局状态供其它模块使用(该模块可能没有任何导出或没人在意他的导出):<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./my-module.js&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="默认导出-export-default-也可以导出一个值"><a href="#默认导出-export-default-也可以导出一个值" class="headerlink" title="默认导出: export default(也可以导出一个值)"></a>默认导出: export default(也可以导出一个值)</h3><h3 id="export-语法-用来支持传统的CommonJS和AMD的工作流模块"><a href="#export-语法-用来支持传统的CommonJS和AMD的工作流模块" class="headerlink" title="export &#x3D; 语法: 用来支持传统的CommonJS和AMD的工作流模块"></a>export &#x3D; 语法: 用来支持传统的CommonJS和AMD的工作流模块</h3><ul>
<li>定义一个模块的导出对象，这里的对象一词指的是类，接口，命名空间，函数或枚举。</li>
<li>若要导入使用该语法的模块，则必须使用Ts的特定语法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="生成模块代码"><a href="#生成模块代码" class="headerlink" title="生成模块代码"></a>生成模块代码</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;xx&#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span> <span class="comment">// es6</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> t = xx + <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>编译 : <ul>
<li>对于node.js: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tsc --<span class="variable language_">module</span> commonjs xxx.<span class="property">ts</span></span><br></pre></td></tr></table></figure></li>
<li>对于require.js: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tsc --<span class="variable language_">module</span> amd xxx.<span class="property">ts</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="可选模块加载和其它高级加载场景"><a href="#可选模块加载和其它高级加载场景" class="headerlink" title="可选模块加载和其它高级加载场景"></a>可选模块加载和其它高级加载场景</h3><ul>
<li>模块核心是import id &#x3D; require(“…”)语句可以让我们访问模块导出的类型</li>
<li>为了确保类型安全性，使用typeof关键字,当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型</li>
</ul>
<h3 id="使用其他的js库-通常在-d-ts文件里定义的"><a href="#使用其他的js库-通常在-d-ts文件里定义的" class="headerlink" title="使用其他的js库: 通常在.d.ts文件里定义的"></a>使用其他的js库: 通常在.d.ts文件里定义的</h3><ul>
<li><p>在Node.js里大部分工作是通过加载一个或多个模块实现的。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;url&quot;</span> &#123;</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Url</span> &#123;</span><br><span class="line">		hostname?: <span class="built_in">string</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> name = <span class="title function_">requir</span>(<span class="string">&quot;module&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>加载模块的方法:</p>
<ul>
<li>方法一: 使用&#x2F;&#x2F;&#x2F;语句和es6规范引入<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference&gt; path=&quot;node.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">URL</span> <span class="keyword">from</span> <span class="string">&quot;url&quot;</span></span><br><span class="line"><span class="keyword">let</span> myUrl = <span class="variable constant_">URL</span>.<span class="title function_">parse</span>(<span class="string">&quot;http://www.typescriptlang.org&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>方法二: 使用&#x2F;&#x2F;&#x2F;语句和commonJS规范引入<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference&gt; path=&quot;node.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="keyword">import</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>外部模块简写: </p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;name&quot;</span> <span class="comment">// 简写模块里所有导出的类型将是any</span></span><br><span class="line"><span class="keyword">import</span> x, &#123;y&#125; <span class="keyword">from</span> <span class="string">&quot;hot-new-module&quot;</span>;</span><br><span class="line"><span class="title function_">x</span>(y);</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块声明通配符: </p>
<ul>
<li>向SystemJS和AMD支持加载非js内容,就可以使用前缀*!或后缀!*加载<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;*!test&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> content : <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> content</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;json!*&quot;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value : <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> file <span class="keyword">from</span> <span class="string">&quot;./xxx!test&quot;</span></span><br><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&quot;json!http://example.com/data.json&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="UMD模块"><a href="#UMD模块" class="headerlink" title="UMD模块:"></a>UMD模块:</h3><blockquote>
<p>有些模块被设计成兼容多个模块加载器，或不使用模块加载器(全局变量)<br>这些库可以通过导入的形式或全局变量的形式访问</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isPrime</span>(<span class="params"><span class="attr">x</span>:<span class="built_in">number</span></span>) : <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> <span class="title class_">math</span>.<span class="property">Lib</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; isPrime &#125; <span class="keyword">from</span> <span class="string">&quot;module&quot;</span></span><br><span class="line"><span class="title function_">isPrime</span>(<span class="number">2</span>) <span class="comment">//模块中可以使用</span></span><br><span class="line">mathLib.<span class="title function_">isPrime</span>(<span class="number">2</span>) <span class="comment">//通过全局变量使用,但只能脚本里使用</span></span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><ul>
<li>尽可能在顶层导出,导入只明确导入的名字<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">&quot;./路径&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>如果仅导出<span class="key_words">『单个class或单个function』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span></span><br></pre></td></tr></table></figure></li>
<li>使用命名空间导入: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;./路径&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>模块里不要使用命名空间</li>
</ul>
<h2 id="命名空间namespace"><a href="#命名空间namespace" class="headerlink" title="命名空间namespace:"></a>命名空间namespace:</h2><ol>
<li>一个模块的多个模块用namespace name{}来包裹,其中的每个模块都使用了export关键字</li>
<li>多文件中的命名空间: 就是同一个命名空间,但模块被拆分在不同的文件中,在不同文件中的被拆分模块外层都保留它原有的命名空间</li>
<li>编译: <ul>
<li>把所有的输入文件编译为一个输出文件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tsc --outFile xxx.<span class="property">js</span> xx.<span class="property">ts</span></span><br></pre></td></tr></table></figure></li>
<li>编译每个文件后通过页面的script标签按顺序引入</li>
</ul>
</li>
<li>别名: 简化命名空间操作的方法是使用import q &#x3D; x.y.z<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Polygons</span> &#123;</span><br><span class="line">		<span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123; &#125;</span><br><span class="line">		<span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons = <span class="title class_">Shapes</span>.<span class="property">Polygons</span>;</span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.<span class="title class_">Square</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="外部命名空间-在-d-ts中写"><a href="#外部命名空间-在-d-ts中写" class="headerlink" title="外部命名空间: 在.d.ts中写"></a>外部命名空间: 在.d.ts中写</h3><ul>
<li>如程序库D3在全局对象d3中定义它的功能,因为这个库通过一个script标签加载，它的声明文件使用内部模块来定义它的类型。Ts编译器使用外部命名空间声明才能识别<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">declare namespace <span class="variable constant_">D3</span> &#123;</span><br><span class="line">	<span class="keyword">export</span> interface <span class="title class_">Event</span> &#123;</span><br><span class="line">		<span class="attr">x</span>: number;</span><br><span class="line">		<span class="attr">y</span>: number;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">export</span> interface <span class="title class_">Base</span> <span class="keyword">extends</span> <span class="title class_">Selectors</span> &#123;</span><br><span class="line">		<span class="attr">event</span>: <span class="title class_">Event</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="keyword">var</span> <span class="attr">d3</span>: <span class="variable constant_">D3</span>.<span class="property">Base</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="命名空间和模块-大型使用模块-小型项目使用命名空间"><a href="#命名空间和模块-大型使用模块-小型项目使用命名空间" class="headerlink" title="命名空间和模块: 大型使用模块,小型项目使用命名空间"></a>命名空间和模块: 大型使用模块,小型项目使用命名空间</h3><ul>
<li>陷阱:<ul>
<li>应该使用import引用模块文件，而非<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>不应该对模块使用命名空间<ul>
<li>模块的取舍: 指定的模块系统不同,可能无法连接多个模块源文件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-枚举</title>
    <url>/2024/11/01/TS/%E5%85%AD%E3%80%81%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>定义一些带名字的常量</p>
</blockquote>
<h3 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h3><ul>
<li>枚举是一个相互映射（赋值）的，比如数字枚举中up&#x3D;1，调用时可以看到up&#x3D;1，1也等于up</li>
</ul>
<h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><ul>
<li>默认从0开始增加，定义了初始值，从初始值开始增加</li>
<li>使用：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span>&#123;</span><br><span class="line">	up = <span class="number">1</span>, <span class="comment">//Direction.up的值为 1</span></span><br><span class="line">	left, <span class="comment">//Direction.left的值为 2，以此类推</span></span><br><span class="line">	right,</span><br><span class="line">	down</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">	<span class="title class_">Up</span> = <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">	<span class="title class_">Down</span> = <span class="string">&quot;DOWN&quot;</span>,</span><br><span class="line">	<span class="title class_">Left</span> = <span class="string">&quot;LEFT&quot;</span>,</span><br><span class="line">	<span class="title class_">Right</span> = <span class="string">&quot;RIGHT&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Direction</span>.<span class="property">Up</span>  <span class="comment">// &quot;UP&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="异构枚举：既有数字枚举又有字符串枚举"><a href="#异构枚举：既有数字枚举又有字符串枚举" class="headerlink" title="异构枚举：既有数字枚举又有字符串枚举"></a>异构枚举：既有数字枚举又有字符串枚举</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="variable constant_">YIGOU</span> &#123;</span><br><span class="line">	<span class="title class_">No</span> = <span class="number">0</span>,</span><br><span class="line">	<span class="title class_">Yes</span> = <span class="string">&quot;YES&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="headerlink" title="联合枚举与枚举成员的类型"></a>联合枚举与枚举成员的类型</h3><ul>
<li><span class="key_words">数字、应用一元-符号的数字(如： -1)或字符串</span>的字面量都是number,string的子集</li>
<li>比如字符串字面量枚举&#x3D;String，但String !&#x3D;&#x3D; 字符串字面量</li>
</ul>
<h3 id="运行时的枚举：可以在函数中运行，不单单去定义一个常量"><a href="#运行时的枚举：可以在函数中运行，不单单去定义一个常量" class="headerlink" title="运行时的枚举：可以在函数中运行，不单单去定义一个常量"></a>运行时的枚举：可以在函数中运行，不单单去定义一个常量</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  x,y,z <span class="comment">//定义一个枚举，里面有x,y,z，默认值为0，1，2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"><span class="attr">obj</span>: &#123;x:<span class="built_in">number</span>&#125;</span>)&#123; <span class="comment">//传一个对象，类型为number</span></span><br><span class="line">  <span class="keyword">return</span> obj.<span class="property">x</span>  <span class="comment">//返回x的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(E) <span class="comment">//传枚举E到函数中</span></span><br></pre></td></tr></table></figure>

<h3 id="const-枚举："><a href="#const-枚举：" class="headerlink" title="const 枚举："></a>const 枚举：</h3><ul>
<li>定义后不会编译,直到使用到时才会被执行,且显示的结果为[值&#x2F;<em>属性名</em>&#x2F;],而普通枚举在定义后就编译了<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">		A = <span class="number">1</span>,</span><br><span class="line">		B = A * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> directions = [<span class="title class_">Enum</span>.<span class="property">A</span>, <span class="title class_">Enum</span>.<span class="property">B</span>]</span><br><span class="line"><span class="keyword">var</span> directions = [<span class="number">1</span> <span class="comment">/* A */</span>, <span class="number">2</span> <span class="comment">/* B */</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="外部枚举：描述已经存在的枚举类型"><a href="#外部枚举：描述已经存在的枚举类型" class="headerlink" title="外部枚举：描述已经存在的枚举类型"></a>外部枚举：描述已经存在的枚举类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">	A = <span class="number">1</span>,</span><br><span class="line">	B,</span><br><span class="line">	C = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举映射元组"><a href="#枚举映射元组" class="headerlink" title="枚举映射元组"></a>枚举映射元组</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">enumMap</span>:<span class="title class_">IDirection</span>  = &#123;</span><br><span class="line">	<span class="string">&quot;up&quot;</span>: <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">	<span class="string">&quot;down&quot;</span>: <span class="string">&quot;DOWM&quot;</span>,</span><br><span class="line">	<span class="string">&quot;left&quot;</span>: <span class="string">&quot;LEFT&quot;</span>,</span><br><span class="line">	<span class="string">&quot;right&quot;</span>: <span class="string">&quot;RIGHT&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDirection</span> &#123;</span><br><span class="line">	[<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">	up,</span><br><span class="line">	down,</span><br><span class="line">	left,</span><br><span class="line">	right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(enumMap[<span class="title class_">Direction</span>[<span class="number">0</span>]])	<span class="comment">// &quot;UP&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="映射类型与条件类型"><a href="#映射类型与条件类型" class="headerlink" title="映射类型与条件类型"></a>映射类型与条件类型</h3><a href="/2024/11/01/TS/%E5%85%AB%E3%80%81%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/" title="TS-高级类型">TS-高级类型</a>的143行左右]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-模块解析</title>
    <url>/2024/11/01/TS/%E5%8D%81%E4%B8%80%E3%80%81%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="相对-vs-非相对模块导入"><a href="#相对-vs-非相对模块导入" class="headerlink" title="相对 vs. 非相对模块导入"></a>相对 vs. 非相对模块导入</h2><ul>
<li>相对导入是以&#x2F;，.&#x2F;或..&#x2F;开头的,其它的都为非相对导入</li>
</ul>
<h2 id="模块解析策略"><a href="#模块解析策略" class="headerlink" title="模块解析策略"></a>模块解析策略</h2><ul>
<li>共有两种可用的模块解析策略：<span class="key_words">『Node』</span>和<span class="key_words">『Classic』</span>。</li>
<li>使用 –moduleResolution标记来指定使用哪种模块解析策略。</li>
<li>若未指定，那在使用 –module AMD | System | ES2015时的默认值为Classic，其它情况时则为Node</li>
</ul>
<h3 id="Classic解析流程"><a href="#Classic解析流程" class="headerlink" title="Classic解析流程"></a>Classic解析流程</h3><h4 id="相对导入-相对与导入它的文件进行解析"><a href="#相对导入-相对与导入它的文件进行解析" class="headerlink" title="相对导入: 相对与导入它的文件进行解析"></a>相对导入: 相对与导入它的文件进行解析</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; b &#125; <span class="keyword">from</span> <span class="string">&quot;./moduleB&quot;</span></span><br><span class="line">/root/src/folder/moduleB.<span class="property">ts</span></span><br><span class="line">/root/src/folder/moduleB.<span class="property">d</span>.<span class="property">ts</span></span><br></pre></td></tr></table></figure>
<h4 id="非相对的导入-从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件"><a href="#非相对的导入-从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件" class="headerlink" title="非相对的导入: 从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件"></a>非相对的导入: 从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; b &#125; <span class="keyword">from</span> <span class="string">&quot;moduleB&quot;</span></span><br><span class="line">/root/src/folder/moduleB.<span class="property">ts</span></span><br><span class="line">/root/src/folder/moduleB.<span class="property">d</span>.<span class="property">ts</span></span><br><span class="line">/root/src/moduleB.<span class="property">ts</span></span><br><span class="line">/root/src/moduleB.<span class="property">d</span>.<span class="property">ts</span></span><br><span class="line">/root/moduleB.<span class="property">ts</span></span><br><span class="line">/root/moduleB.<span class="property">d</span>.<span class="property">ts</span></span><br><span class="line">/moduleB.<span class="property">ts</span></span><br><span class="line">/moduleB.<span class="property">d</span>.<span class="property">ts</span></span><br></pre></td></tr></table></figure>

<h3 id="Node-解析流程"><a href="#Node-解析流程" class="headerlink" title="Node 解析流程"></a>Node 解析流程</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x= <span class="built_in">require</span>(<span class="string">&quot;./moduleB&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><span class="key_words">相对的: </span><ul>
<li>检查该文件是否存在  </li>
<li>–&gt; 检查该目录是否包含package.json,且package.json指定一个main模块，就引入这个main指定模块</li>
<li>–&gt; 检查该目录下是否有index.js文件(隐式的当作main模块)</li>
</ul>
</li>
<li><span class="key_words">非相对: </span><ul>
<li>在node_module查找对应的模块的js,package.json,index.js,在一共扫描9个文件，从第4和第7个文件开始，在上一循环的文件上跳一级目录</li>
</ul>
</li>
</ul>
<h3 id="Typescript-解析流程"><a href="#Typescript-解析流程" class="headerlink" title="Typescript 解析流程"></a>Typescript 解析流程</h3><ul>
<li>在Node解析逻辑基础上增加了TypeScript源文件的扩展名(.ts，.tsx和.d.ts)。</li>
<li>TypeScript在 package.json里使用字段”types”来表示类似”main”的意义 - 编译器会使用它来找到要使用的”main”定义文件。</li>
<li>TypeScript检查对应模块的.ts,.tsx,.d.ts,package.josn,index.ts,index.tsx,index.d.ts文件，一共检查21个文件,然后8和15时会在上衣循环的文件上向上跳一级目录</li>
</ul>
<h2 id="附加的模块解析标记"><a href="#附加的模块解析标记" class="headerlink" title="附加的模块解析标记"></a>附加的模块解析标记</h2><h3 id="Base-URL-设置baseUrl来告诉编译器到哪里去查找模块"><a href="#Base-URL-设置baseUrl来告诉编译器到哪里去查找模块" class="headerlink" title="Base URL: 设置baseUrl来告诉编译器到哪里去查找模块"></a>Base URL: 设置baseUrl来告诉编译器到哪里去查找模块</h3><ul>
<li><span class="key_words">所有非相对模块导入都会被当做相对于 baseUrl</span>,相对模块的导入不会被baseUrl所影响</li>
<li>baseUrl的值由以下两者之一决定：<ul>
<li>命令行中baseUrl的值(给定的路径是相对的，那么将相对于当前路径进行计算)</li>
<li>‘tsconfig.json’里的baseUrl属性(给定的路径是相对的，那么将相对于’tsconfig.json’路径进行计算)</li>
</ul>
</li>
</ul>
<h3 id="路径映射"><a href="#路径映射" class="headerlink" title="路径映射"></a>路径映射</h3><ul>
<li>TS编译器通过使用tsconfig.json文件里的”paths”来支持模块不是直接放在baseUrl下面的声明映射。(“paths”是相对于”baseUrl”进行解析)</li>
</ul>
<h3 id="rootDirs指定虚拟目录"><a href="#rootDirs指定虚拟目录" class="headerlink" title="rootDirs指定虚拟目录:"></a>rootDirs指定虚拟目录:</h3><ul>
<li>多个目录下的工程源文件在编译时会进行合并放在某个输出目录下。 相当于源目录创建了一个“虚拟”目录。</li>
<li>利用rootDirs，可以告诉编译器生成这个虚拟目录的roots</li>
<li>在逻辑上合并的物理目录列表,提供的数组可以包含任意数量的任何名字的目录，不论它们是否存在</li>
</ul>
<h3 id="跟踪模块解析-tsc-–traceResolution"><a href="#跟踪模块解析-tsc-–traceResolution" class="headerlink" title="跟踪模块解析: tsc –traceResolution"></a>跟踪模块解析: tsc –traceResolution</h3><h3 id="使用–noResolve-不要添加任何不是在命令行上传入的文件到编译列表"><a href="#使用–noResolve-不要添加任何不是在命令行上传入的文件到编译列表" class="headerlink" title="使用–noResolve: 不要添加任何不是在命令行上传入的文件到编译列表"></a>使用–noResolve: 不要添加任何不是在命令行上传入的文件到编译列表</h3><ul>
<li>tsc app.ts moduleA.ts –noResolve <span class="desc">&#x2F;&#x2F;指定了moduleA.ts 找到它就编译,是其它不编译 </span></li>
</ul>
<h3 id="常见问题-—-为什么在exclude列表里的模块还会被编译器使用"><a href="#常见问题-—-为什么在exclude列表里的模块还会被编译器使用" class="headerlink" title="常见问题 — 为什么在exclude列表里的模块还会被编译器使用?"></a>常见问题 — 为什么在exclude列表里的模块还会被编译器使用?</h3><ul>
<li>想利用exclude排除某些文件，甚至想指定所有要编译的文件列表，请使用“files”</li>
<li>要从编译列表中排除一个文件，需要在排除它的同时，排除所有对它进行import或使用了<code>/// &lt;reference path=&quot;...&quot; /&gt;</code>指令的文件</li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-声明合并</title>
    <url>/2024/11/01/TS/%E5%8D%81%E4%BA%8C%E3%80%81%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>类不能与其它类或变量合并</li>
<li>针对同一个名字的两个独立声明合并为单一声明。 </li>
<li>合并后的声明同时拥有原先两个声明的特性。 </li>
<li>任何数量的声明都可被合并；不局限于两个声明</li>
</ul>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li>ts中的声明会创建三种实体之一：命名空间，类型或值。 </li>
<li>创建命名空间的声明: 新建一个命名空间，它包含了用（.）符号来访问使用的名字</li>
<li>创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上</li>
<li>创建值的声明: 创建在JavaScript输出中看到的值</li>
</ul>
<h3 id="合并接口-把双方的成员放到一个同名的接口里"><a href="#合并接口-把双方的成员放到一个同名的接口里" class="headerlink" title="合并接口: 把双方的成员放到一个同名的接口里"></a>合并接口: 把双方的成员放到一个同名的接口里</h3><ul>
<li>接口的非函数的成员应该是唯一的(就是上面接口有一个a, 下面的接口最好不要有a),且类型要相同<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>,</span><br><span class="line">  b :<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  c : <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> box : <span class="title class_">Box</span> = &#123;a : <span class="string">&quot;d&quot;</span> , b : <span class="string">&quot;k&quot;</span> ,c : <span class="string">&quot;10&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>对于函数成员,每个同名函数声明,都会当成这个函数的一个重载,且后来合并的接口优先级更高<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span> (animal : <span class="title class_">Dog</span>) : <span class="title class_">Dog</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span> (animal : <span class="title class_">Sheep</span>) : <span class="title class_">Sheep</span></span><br><span class="line">  <span class="title function_">clone</span> (animal : <span class="title class_">Fish</span>) : <span class="title class_">Fish</span></span><br><span class="line">  <span class="title function_">clone</span> (tagName : <span class="string">&quot;yyyy&quot;</span>) : vjukg</span><br><span class="line">&#125;</span><br><span class="line">等同于 :<span class="keyword">interface</span> <span class="title class_">Box</span>&#123;</span><br><span class="line">  <span class="title function_">clone</span> (tagName : <span class="string">&quot;yyyy&quot;</span>) : vjukg <span class="comment">//参数的类型是单一的字符串字面量的也会提到最前面</span></span><br><span class="line">  <span class="title function_">clone</span> (animal : <span class="title class_">Sheep</span>) : <span class="title class_">Sheep</span>  <span class="comment">//后来合并的接口顺序往前</span></span><br><span class="line">  <span class="title function_">clone</span> (animal : <span class="title class_">Fish</span>) : <span class="title class_">Fish</span></span><br><span class="line">  <span class="title function_">clone</span> (animal : <span class="title class_">Dog</span>) : <span class="title class_">Dog</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="合并命名空间-namespace-xxx"><a href="#合并命名空间-namespace-xxx" class="headerlink" title="合并命名空间: namespace xxx{}"></a>合并命名空间: namespace xxx{}</h3><ul>
<li>非export成员合并后仅在原有命名空间可见(因为没有导出),无法访问非export成员</li>
</ul>
<h3 id="命名空间与类和函数和枚举类型合并-合并结果包含两者的声明"><a href="#命名空间与类和函数和枚举类型合并-合并结果包含两者的声明" class="headerlink" title="命名空间与类和函数和枚举类型合并: 合并结果包含两者的声明"></a>命名空间与类和函数和枚举类型合并: 合并结果包含两者的声明</h3>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-JSX</title>
    <url>/2024/11/01/TS/%E5%8D%81%E4%B8%89%E3%80%81JSX/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul>
<li>1.文件命名使用.tsx后缀</li>
<li>2.启用jSX选项(preserve，react和react-native):<ul>
<li>可通过在命令行里使用–jsx标记</li>
<li>或tsconfig.json里的选项来指定模式</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>输入</th>
<th>输出</th>
<th>输出文件扩展名</th>
</tr>
</thead>
<tbody><tr>
<td>preserve</td>
<td><code>&lt;div /&gt;</code></td>
<td><code>&lt;div /&gt;</code></td>
<td>.jsx</td>
</tr>
<tr>
<td>react</td>
<td><code>&lt;div /&gt;</code></td>
<td>React.createElement(“div”)</td>
<td>.js</td>
</tr>
<tr>
<td>react-native</td>
<td><code>&lt;div /&gt;</code></td>
<td><code>&lt;div /&gt;</code></td>
<td>.js</td>
</tr>
</tbody></table>
<ul>
<li>注意：<span class="key_words">React标识符是写死的硬编码，所以必须保证React是可用的。</span></li>
</ul>
<h2 id="as操作符-在-ts和-tsx里都可用"><a href="#as操作符-在-ts和-tsx里都可用" class="headerlink" title="as操作符:在.ts和.tsx里都可用"></a>as操作符:在.ts和.tsx里都可用</h2><ul>
<li>并且与尖括号<span class="key_words">『类型断言』</span>行为是等价的</li>
</ul>
<h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><h3 id="理解固有元素与基于值的元素之间的区别"><a href="#理解固有元素与基于值的元素之间的区别" class="headerlink" title="理解固有元素与基于值的元素之间的区别:"></a>理解固有元素与基于值的元素之间的区别:</h3><ul>
<li>对于React，固有元素会生成字符串（React.createElement(“div”)），然而自定义的组件却不会</li>
<li>传入JSX元素里的属性类型的查找方式不同。固有元素属性本身就支持，然而自定义的组件会自己去指定它们具有哪个属性。</li>
</ul>
<h3 id="固有元素"><a href="#固有元素" class="headerlink" title="固有元素:"></a>固有元素:</h3><ul>
<li>使用JSX.IntrinsicElements来查找<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IntrinsicElements</span> &#123; </span><br><span class="line">	<span class="attr">foo</span>: <span class="built_in">any</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 只有&lt;foo /&gt; 才符合要求</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基于值的元素-在所在作用域里按标识符查找"><a href="#基于值的元素-在所在作用域里按标识符查找" class="headerlink" title="基于值的元素: 在所在作用域里按标识符查找"></a>基于值的元素: 在所在作用域里按标识符查找</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&quot;./myComponent&quot;</span></span><br><span class="line">&lt;<span class="title class_">MyComponent</span> /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="无状态函数组件-SFC"><a href="#无状态函数组件-SFC" class="headerlink" title="无状态函数组件(SFC):"></a>无状态函数组件(SFC):</h4><ul>
<li>第一个参数是prop对象,ts会强制它的返回值给JSX.Element<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClickableProps</span> &#123; <span class="attr">children</span>: <span class="variable constant_">JSX</span>.<span class="property">Element</span>[] | <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SideProps</span> <span class="keyword">extends</span> <span class="title class_">ClickableProps</span> &#123; <span class="attr">side</span>: <span class="variable constant_">JSX</span>.<span class="property">Element</span> | <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MainButton</span>(<span class="params"><span class="attr">prop</span>: <span class="title class_">SideProps</span></span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="类组件"><a href="#类组件" class="headerlink" title="类组件:"></a>类组件:</h4><ul>
<li><span class="key_words">元素类的类型</span><ul>
<li>如<code>&lt;Expr /&gt;</code> 元素类的类型为Expr的类型，如果Expr是个工厂函数，类类型就是这个函数</li>
</ul>
</li>
<li><span class="key_words">元素的实例类型</span><ul>
<li>在es6类的情况下,实例类型为这个类的实例的类型</li>
<li>工厂函数: 实例类型就是这个函数返回值类型</li>
<li>类类型：实例类型就是类类型调用签名的返回值与构造签名的联合类型</li>
<li>必须赋值给JSX.ElementClass或抛出一个错误。默认的JSX.ElementClass为{}</li>
</ul>
</li>
</ul>
<h3 id="属性类型检查"><a href="#属性类型检查" class="headerlink" title="属性类型检查"></a>属性类型检查</h3><ul>
<li>对于固有元素，是JSX.IntrinsicElements属性的类型</li>
<li>对于基于值得元素，取决于JSX.ElementAttributesProperty</li>
<li>元素属性类型用于的JSX里进行属性的类型检查。支持可选属性和必须属性。<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">JSX</span> &#123;</span><br><span class="line">	<span class="keyword">interface</span> <span class="title class_">IntrinsicElements</span> &#123;</span><br><span class="line">		<span class="attr">foo</span>: &#123; <span class="attr">requiredProp</span>: <span class="built_in">string</span>; optionalProp?: <span class="built_in">number</span> &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;foo requiredProp=<span class="string">&quot;bar&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="子孙类型检查："><a href="#子孙类型检查：" class="headerlink" title="子孙类型检查："></a>子孙类型检查：</h3><ul>
<li>children是元素属性(attribute)类型的一个属性(property)</li>
<li>利用JSX.ElementChildrenAttribute来决定children名</li>
<li>指定方式：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PropType</span> &#123;</span><br><span class="line">	<span class="attr">children</span>: <span class="variable constant_">JSX</span>.<span class="property">Element</span></span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Component</span> = memo&lt;<span class="title class_">PropType</span>&gt;(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="JSX结果类型：默认地JSX表达式结果的类型为any"><a href="#JSX结果类型：默认地JSX表达式结果的类型为any" class="headerlink" title="JSX结果类型：默认地JSX表达式结果的类型为any"></a>JSX结果类型：默认地JSX表达式结果的类型为any</h3><h3 id="嵌入的表达式：JSX允许使用-标签来内嵌表达式"><a href="#嵌入的表达式：JSX允许使用-标签来内嵌表达式" class="headerlink" title="嵌入的表达式：JSX允许使用{}标签来内嵌表达式"></a>嵌入的表达式：JSX允许使用{}标签来内嵌表达式</h3><h3 id="React整合：使用React类型定义"><a href="#React整合：使用React类型定义" class="headerlink" title="React整合：使用React类型定义"></a>React整合：使用React类型定义</h3><h2 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h2><ul>
<li>jsx: react编译选项使用的工厂函数是可配置的，使用jsxFactory命令行选项或内联的@jsx注释指令在每个文件上设置。</li>
<li>如果工厂函数使用React.createElement定义（默认），编译器会先检查React.JSX，之后才检查全局的JSX。</li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-JS文件类型检查</title>
    <url>/2024/11/01/TS/%E5%8D%81%E4%BA%94%E3%80%81js%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="严格检查标记"><a href="#严格检查标记" class="headerlink" title="严格检查标记"></a>严格检查标记</h3><ol>
<li>对js文件进行类型检查和错误提示: 『–checkJs』</li>
<li>忽略类型检查：『&#x2F;&#x2F; @ts-nocheck』</li>
<li>忽略本行的错误：『&#x2F;&#x2F; @ts-ignore』</li>
<li>去掉『–checkJs』设置并添加一个『&#x2F;&#x2F; @ts-check』注释来x选择检查某些.js文件</li>
</ol>
<h3 id="用JSDoc类型表示类型信息"><a href="#用JSDoc类型表示类型信息" class="headerlink" title="用JSDoc类型表示类型信息"></a>用JSDoc类型表示类型信息</h3><ul>
<li>.js中类型和.ts中的类型一样可以被推断，类型推断不了使用JSDoc来指定<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">number</span>&#125; */</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="从类内部赋值语句推断属性声明"><a href="#从类内部赋值语句推断属性声明" class="headerlink" title="从类内部赋值语句推断属性声明"></a>从类内部赋值语句推断属性声明</h3><ul>
<li>ES2015&#x2F;ES6不存在类属性的声明</li>
<li>.js文件中，属性声明是由类内部的属性赋值语句推断出来的。</li>
<li>属性的类型是赋值语句右侧所有值的联合。</li>
<li>构造函数里定义的属性是永远存在的，在方法存取器里定义的被认为是可选的。</li>
<li>如果属性永远都不在类的内部被设置，那么它们被当成是未知的。</li>
<li>如果类具有只读的属性，考虑在构造函数里给它初始化成undefined。</li>
</ul>
<h3 id="更多注意点"><a href="#更多注意点" class="headerlink" title="更多注意点"></a>更多注意点</h3><ol>
<li>构造函数等同于类</li>
<li>支持CommonJS模块</li>
<li>类，函数和对象字面量是命名空间</li>
<li>对象字面量是开放的</li>
<li>null，undefined，和空数组的类型是any或any[]</li>
<li>函数参数是默认可选的</li>
<li>由arguments推断出的var-args参数声明<ul>
<li>如果函数的体内有对arguments的引用，那么这个函数会隐式地被认为具有一个var-arg参数（比如:(…arg: any[]) &#x3D;&gt; any）</li>
</ul>
</li>
<li>未指定的类型参数默认为any</li>
</ol>
<h3 id="支持的JSDoc"><a href="#支持的JSDoc" class="headerlink" title="支持的JSDoc"></a>支持的JSDoc</h3><ul>
<li><p>@type: 引用一个类型名称</p>
<ul>
<li>可以指定联合类型:@type {(string | boolean)},()是可选,</li>
<li>多种方式指定数组类型,</li>
<li>可指定对象字面量类型<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">可使用字符串和数字索引签名来指定map-like 和array-like的对象</span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">Object.&lt;number, object&gt;</span>&#125; */</span></span><br><span class="line"><span class="keyword">var</span> arrayLike;</span><br><span class="line">指定函数类型：</span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">(s: string, b: boolean) =&gt; number</span>&#125; Typescript syntax */</span></span><br><span class="line"><span class="keyword">var</span> sbn2;</span><br><span class="line">直接使用未指定函数类型</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">number | string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numberOrString = <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span> ? <span class="string">&quot;hello&quot;</span> : <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> typeAssertedNumber = <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">number</span>&#125; */</span> (numberOrString)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>@param (或 @arg 或 @argument): 和@type相同</p>
<ul>
<li>使用[]把参数声明为可选的：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@typedef</span> Pet &#123; import(&quot;./a&quot;).Pet &#125; // 导入类型从其它文件中导入声明 */</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">Pet</span>&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myPet;<span class="comment">//可以使用类型别名</span></span><br><span class="line">myPet.<span class="property">name</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>@returns (或 @return): 同上</p>
</li>
<li><p>@typedef: 声明复杂类型</p>
</li>
<li><p>@callback: 指定函数类型</p>
</li>
<li><p>@template: 声明泛型</p>
</li>
<li><p>@class (或 @constructor): 通过this属性的赋值来推断构造函数，可以添加一个@constructor标记友好提示</p>
</li>
<li><p>@this: 通过上下文来推断出this的类型</p>
</li>
<li><p>@extends (或 @augments): 只作用于类,指定类型参数的类型</p>
</li>
<li><p>@enum: 允许创建一个对象字面量，它的成员都有确定的类型,不允许额外添加</p>
</li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-装饰器</title>
    <url>/2024/11/01/TS/%E5%8D%81%E5%9B%9B%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>目前装饰器是一项实验性特性,使用可以参照java</p>
</blockquote>
<h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3><ul>
<li>命令行：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tsc --target <span class="title class_">ES5</span> --experimentalDecorators</span><br></pre></td></tr></table></figure></li>
<li>在tsconfig.json中的compilerOptions设置:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，访问符，属性或参数上。</li>
<li>装饰器使用 <span class="key_words">『@expression』形式</span>，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</li>
</ul>
<h3 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">color</span> = (<span class="params">value: string</span>) =&gt;&#123; <span class="comment">//装饰器工厂</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;&#125; <span class="comment">//装饰器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="装饰器组合"><a href="#装饰器组合" class="headerlink" title="装饰器组合"></a>装饰器组合</h3><ul>
<li>书写同一行或多行都可: @f</li>
<li>当多个装饰器应用于同一个声明上，从上到下，求值的结果从下到上</li>
<li>示例<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f(): evaluated&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target,<span class="attr">propertyKey</span>: <span class="built_in">string</span>, <span class="attr">descriptor</span>: <span class="title class_">PropertyDescriptor</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f():called&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;g(): evaluated&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target,<span class="attr">propertyKey</span>: <span class="built_in">string</span>, <span class="attr">descriptor</span>: <span class="title class_">PropertyDescriptor</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;g():called&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@f</span></span><br><span class="line">  <span class="meta">@g</span></span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">控制台：</span><br><span class="line"><span class="title function_">f</span>(): evaluated</span><br><span class="line"><span class="title function_">g</span>(): evaluated</span><br><span class="line"><span class="title function_">g</span>():called</span><br><span class="line"><span class="title function_">f</span>():called</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="装饰器求值"><a href="#装饰器求值" class="headerlink" title="装饰器求值"></a>装饰器求值</h3><ol>
<li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个<span class="key_words">实例成员</span>。</li>
<li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个<span class="key_words">静态成员</span>。</li>
<li>参数装饰器应用到构造函数。</li>
<li>类装饰器应用到类</li>
</ol>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><ul>
<li>类装饰器在类声明之前被声明(紧靠着类声明)</li>
<li>类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 </li>
<li>类装饰器不能用在声明文件中(.d.ts)，也不能用在任何外部上下文中</li>
<li>定义装饰器,在类中应用</li>
<li>示例<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@sealed</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">message</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello,&quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sealed</span>(<span class="params"><span class="attr">constructor</span>: <span class="title class_">Function</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor)</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法装饰器-和-访问器装饰器（-后面表示不同其他基本一致）"><a href="#方法装饰器-和-访问器装饰器（-后面表示不同其他基本一致）" class="headerlink" title="方法装饰器 和 访问器装饰器（&#x2F;后面表示不同其他基本一致）"></a>方法装饰器 和 访问器装饰器（&#x2F;后面表示不同其他基本一致）</h3><ul>
<li>声明在一个方法&#x2F;访问器的声明之前(紧靠着方法&#x2F;访问器声明)。</li>
<li>会被应用到方法&#x2F;访问器的属性描述符上，可以用来监视，修改或者替换方法&#x2F;访问器定义。</li>
<li>不能用在声明文件(.d.ts)，重载或者任何外部上下文中</li>
<li>运行时会当作函数被调用,传入3个参数:<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>成员的名字</li>
<li>成员的属性描述符</li>
</ol>
</li>
<li>返回一个值，它会被用作方法的属性描述符。</li>
</ul>
<h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><ul>
<li>声明在一个属性声明之前(紧靠着属性声明)。</li>
<li>不能用在声明文件中(.d.ts)，或者任何外部上下文里</li>
<li>运行时当作函数被调用，传入下列2个参数：<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>成员的名字</li>
</ol>
</li>
</ul>
<h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><ul>
<li>声明在一个参数声明之前(紧靠着参数声明)。 </li>
<li>应用于类构造函数或方法声明。</li>
<li>不能用在声明文件中(.d.ts)，或者任何外部上下文里</li>
<li>运行时当作函数被调用，传入下列3个参数：<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>成员的名字</li>
<li>参数在函数参数列表中的索引</li>
</ol>
</li>
<li>只能用来监视一个方法的参数是否被传入，返回值会被忽略。</li>
</ul>
<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><ul>
<li>安装: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i reflect-metadata --save</span><br></pre></td></tr></table></figure></li>
<li>启用：<ul>
<li>命令行：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tsc --target <span class="title class_">ES5</span> --experimentalDecorators --emitDecoratorMetadata</span><br></pre></td></tr></table></figure></li>
<li>直配置<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">tsconfig.<span class="property">json</span>:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">testDecorator</span> = (<span class="params"><span class="attr">xxx</span>: xxx</span>) =&gt; &#123; <span class="comment">// 创建一个装饰器， 如果有形参则@的表达式也要有形参</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params"><span class="attr">target</span>: <span class="built_in">any</span></span>) =&gt;</span> &#123; <span class="comment">// target代表装饰的目标，等于例子的DecoratorTest</span></span><br><span class="line">    target.<span class="property">isTeatable</span> =<span class="literal">true</span>; <span class="comment">//target.xxx：往target原型上的constructor添加方法或属性</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@testDecorator</span>() <span class="comment">// 装饰器指定要装饰的目标</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">DecoratorTest</span> &#123; <span class="comment">// 被装饰的目标target</span></span><br><span class="line">  <span class="keyword">public</span> name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">public</span> age = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-函数和this</title>
    <url>/2024/11/01/TS/%E5%9B%9B%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8Cthis/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数类型：创建有名字的函数和匿名函数"><a href="#函数类型：创建有名字的函数和匿名函数" class="headerlink" title="函数类型：创建有名字的函数和匿名函数"></a>函数类型：创建有名字的函数和匿名函数</h3><ul>
<li>具名函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x,y</span>) &#123; </span><br><span class="line">	<span class="keyword">return</span> x+y </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>匿名函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="keyword">function</span>(<span class="params">x,y</span>) &#123; </span><br><span class="line">	<span class="keyword">return</span> x+y </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="完整的函数类型"><a href="#完整的函数类型" class="headerlink" title="完整的函数类型"></a>完整的函数类型</h3><ul>
<li>定义：<span class="key_words">(形参：参数类型) &#x3D;&gt; 返回类型 &#x3D; 函数(形参：参数类型)：返回类型{}</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">add</span>: <span class="function">(<span class="params">x:number,y:number</span>) =&gt;</span> number </span><br><span class="line">= <span class="keyword">function</span>(<span class="params">x:number,y:number</span>):number &#123; <span class="keyword">return</span> x+y &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="推断类型-ts编译器会自动识别出类型"><a href="#推断类型-ts编译器会自动识别出类型" class="headerlink" title="推断类型: ts编译器会自动识别出类型"></a>推断类型: ts编译器会自动识别出类型</h3><h3 id="可选和默认参数"><a href="#可选和默认参数" class="headerlink" title="可选和默认参数"></a>可选和默认参数</h3><ul>
<li>ts规定，<span class="key_words">『形参个数和传参个数要一致』</span></li>
<li><span class="key_words">『可选必须放在必选后面』</span>，没传默认为undefined</li>
<li>没传或传undefined时叫默认初始值。<span class="key_words">『带默认值的参数为可选，位置随意』</span></li>
<li><span class="key_words">『可选参数与末尾的默认参数共享参数类型』</span></li>
</ul>
<h3 id="剩余参数：个数不限的可选参数"><a href="#剩余参数：个数不限的可选参数" class="headerlink" title="剩余参数：个数不限的可选参数"></a>剩余参数：个数不限的可选参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: string, ...restOfName: string[]</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h3><ol>
<li>从参数1到末尾创建参数列表</li>
<li>call方法的参数一是this值，其余的参数是调用函数的形参<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">thing</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> + <span class="string">&quot; says hello &quot;</span> + thing)</span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="title function_">call</span>(<span class="string">&quot;Yehuda&quot;</span>, <span class="string">&quot;world&quot;</span>) <span class="comment">// Yehuda says hello world</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="this和箭头函数"><a href="#this和箭头函数" class="headerlink" title="this和箭头函数"></a>this和箭头函数</h3><ul>
<li><span class="key_words">『在js中，顶级的非方法式调用会将this视为window』</span></li>
<li>注意：<span class="key_words">『在严格模式下，this为undefined而不是window』</span></li>
<li>解决方法：<span class="key_words">『使用箭头函数』</span>，在函数被返回时就绑好正确的this，箭头函数能保存函数创建时的 this值，而不是调用时的值</li>
<li>ts中设置–noImplicitThis标记。它会指出里的this的类型</li>
</ul>
<h3 id="this参数：是假的参数"><a href="#this参数：是假的参数" class="headerlink" title="this参数：是假的参数"></a>this参数：是假的参数</h3><ul>
<li>形式:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"><span class="variable language_">this</span>: <span class="keyword">void</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="回调函数里的this参数"><a href="#回调函数里的this参数" class="headerlink" title="回调函数里的this参数"></a>回调函数里的this参数</h3><ul>
<li>显式指定this类型，函数要带有this:void。但只能这个实例里的这个函数可用。</li>
<li>用箭头函数，它不会捕获this，实例里的this都指向一个。但每个对象都会创建一次。</li>
</ul>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul>
<li>同一个函数提供多个函数类型定义来进行函数重载<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>]</span><br><span class="line"><span class="comment">// 接收对象数组,并返回数字类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params"><span class="attr">x</span>: &#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>&#125;[]</span>): <span class="built_in">number</span></span><br><span class="line"><span class="comment">// 接收数字，并返回一个对象类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span></span>): &#123;<span class="attr">suit</span>: <span class="built_in">string</span>; <span class="attr">card</span>: <span class="built_in">number</span>&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">	<span class="comment">// typeof检测非undefined，string，number，boolean之外，都只会返回object</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;object&quot;</span>) &#123; <span class="comment">// 传对象数组进入这个判断</span></span><br><span class="line">		<span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * x.<span class="property">length</span>)</span><br><span class="line">		<span class="keyword">return</span> pickedCard</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;number&quot;</span>) &#123; <span class="comment">// 传数字进入这个判断</span></span><br><span class="line">		<span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">13</span>)</span><br><span class="line">		<span class="keyword">return</span> &#123; <span class="attr">suit</span>: suits[pickedSuit], <span class="attr">card</span>: x % <span class="number">13</span> &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [&#123;</span><br><span class="line">	<span class="attr">suit</span>: <span class="string">&quot;diamonds&quot;</span>, <span class="attr">card</span>: <span class="number">2</span></span><br><span class="line">	&#125;, &#123;</span><br><span class="line">	<span class="attr">suit</span>: <span class="string">&quot;spades&quot;</span>, <span class="attr">card</span>: <span class="number">10</span></span><br><span class="line">	&#125;, &#123;</span><br><span class="line">	<span class="attr">suit</span>: <span class="string">&quot;hearts&quot;</span>, <span class="attr">card</span>: <span class="number">4</span>&#125;] <span class="comment">// 定义一组数据</span></span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[<span class="title function_">pickCard</span>(myDeck)] <span class="comment">// 传值</span></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = <span class="title function_">pickCard</span>(<span class="number">15</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-关于Echarts图表的相关内容</title>
    <url>/2024/11/04/WeChatMini/echart/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="echarts-初始化篇"><a href="#echarts-初始化篇" class="headerlink" title="echarts 初始化篇"></a>echarts 初始化篇</h2><ol>
<li>去GitHub上找到 <a href="https://github.com/ecomfe/echarts-for-weixin">echarts-for-weixin</a> 并将其clone到本地</li>
<li>将其中的ec-canvas目录复制到自己项目的某个目录下</li>
<li>根据需要，替换echarts.js</li>
</ol>
<h3 id="React-Taro-TS-微信小程序篇"><a href="#React-Taro-TS-微信小程序篇" class="headerlink" title="React+Taro+TS+微信小程序篇"></a>React+Taro+TS+微信小程序篇</h3><ol>
<li>使用分包将对应图形的ec-canvas放在分包组件中</li>
<li>新建一个.tsx后缀的页面，引入ec-canvas中的echarts</li>
<li>定义data类型</li>
<li>初始化data数据、option和charts.init</li>
<li>在页面返回<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ec-canvas id=<span class="string">&quot;自定义&quot;</span> canvas-id=<span class="string">&quot;自定义&quot;</span> ec=&#123;&#123;<span class="attr">onInit</span>: 初始化函数&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>在 <code>&lt;ec-canvas /&gt;</code>外在包裹一层并且给个高度</li>
<li>初始化图表</li>
<li>设置data数据</li>
<li>设置option数据</li>
<li>示例（饼图）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;../../components/ec-canvas/echarts&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; memo, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">View</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@tarojs/components&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NoteLabelDto</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@apis/itinerary&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useImmer &#125; <span class="keyword">from</span> <span class="string">&#x27;use-immer&#x27;</span></span><br><span class="line"></span><br><span class="line">interface <span class="title class_">PieProps</span> &#123;</span><br><span class="line">  <span class="attr">list</span>: <span class="title class_">NoteLabelDto</span>[]</span><br><span class="line">&#125;</span><br><span class="line">interface pieDataType &#123;</span><br><span class="line">  <span class="attr">value</span>: number</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Pie</span> = memo&lt;<span class="title class_">PieProps</span>&gt;(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; list &#125; = props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [pieData, setPieData] = useImmer&lt;pieDataType[]&gt;([])</span><br><span class="line">  <span class="keyword">const</span> chartRef = useRef&lt;any&gt;()</span><br><span class="line">  <span class="keyword">const</span> optionRef = <span class="title function_">useRef</span>(&#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>: <span class="string">&#x27;#ffffff&#x27;</span>,</span><br><span class="line">    <span class="attr">series</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">label</span>: &#123;</span><br><span class="line">          <span class="attr">formatter</span>: <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`&#123;hr|&#125; &#123;name|<span class="subst">$&#123;params.name&#125;</span>&#125;\n&#123;value|<span class="subst">$&#123;params.value&#125;</span>%&#125;`</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">minMargin</span>: <span class="number">5</span>,</span><br><span class="line">          <span class="attr">lineHeight</span>: <span class="number">15</span>,</span><br><span class="line">          <span class="attr">fontSize</span>: <span class="number">14</span>,</span><br><span class="line">          <span class="attr">rich</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: &#123;</span><br><span class="line">              <span class="attr">fontWeight</span>: <span class="number">600</span>,</span><br><span class="line">              <span class="attr">lineHeight</span>: <span class="number">18</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">value</span>: &#123;</span><br><span class="line">              <span class="attr">fontWeight</span>: <span class="string">&#x27;normal&#x27;</span>,</span><br><span class="line">              <span class="attr">color</span>: <span class="string">&#x27;rgba(0, 0, 0, 0.65)&#x27;</span>,</span><br><span class="line">              <span class="attr">lineHeight</span>: <span class="number">18</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">hr</span>: &#123;</span><br><span class="line">              <span class="attr">backgroundColor</span>: <span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">              <span class="attr">borderRadius</span>: <span class="number">5</span>,</span><br><span class="line">              <span class="attr">width</span>: <span class="number">5</span>,</span><br><span class="line">              <span class="attr">height</span>: <span class="number">5</span>,</span><br><span class="line">              <span class="attr">padding</span>: [<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">        <span class="attr">stillShowZeroSum</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">center</span>: [<span class="string">&#x27;50%&#x27;</span>, <span class="string">&#x27;50%&#x27;</span>],</span><br><span class="line">        <span class="attr">radius</span>: [<span class="string">&#x27;20%&#x27;</span>, <span class="string">&#x27;40%&#x27;</span>],</span><br><span class="line">        <span class="attr">emphasis</span>: &#123;</span><br><span class="line">          <span class="attr">disabled</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">scale</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">itemStyle</span>: &#123;</span><br><span class="line">          <span class="attr">borderWidth</span>: <span class="number">0</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">data</span>: pieData,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置option数据</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    optionRef.<span class="property">current</span> = &#123;</span><br><span class="line">      <span class="attr">backgroundColor</span>: <span class="string">&#x27;#ffffff&#x27;</span>,</span><br><span class="line">      <span class="attr">series</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">label</span>: &#123;</span><br><span class="line">            <span class="attr">formatter</span>: <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">`&#123;hr|&#125; &#123;name|<span class="subst">$&#123;params.name&#125;</span>&#125;\n&#123;value|<span class="subst">$&#123;params.value&#125;</span>%&#125;`</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">minMargin</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">lineHeight</span>: <span class="number">15</span>,</span><br><span class="line">            <span class="attr">fontSize</span>: <span class="number">14</span>,</span><br><span class="line">            <span class="attr">rich</span>: &#123;</span><br><span class="line">              <span class="attr">name</span>: &#123;</span><br><span class="line">                <span class="attr">fontWeight</span>: <span class="number">600</span>,</span><br><span class="line">                <span class="attr">lineHeight</span>: <span class="number">18</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">value</span>: &#123;</span><br><span class="line">                <span class="attr">fontWeight</span>: <span class="string">&#x27;normal&#x27;</span>,</span><br><span class="line">                <span class="attr">color</span>: <span class="string">&#x27;rgba(0, 0, 0, 0.65)&#x27;</span>,</span><br><span class="line">                <span class="attr">lineHeight</span>: <span class="number">18</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">hr</span>: &#123;</span><br><span class="line">                <span class="attr">backgroundColor</span>: <span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">                <span class="attr">borderRadius</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">width</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">height</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">padding</span>: [<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">          <span class="attr">stillShowZeroSum</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">center</span>: [<span class="string">&#x27;50%&#x27;</span>, <span class="string">&#x27;50%&#x27;</span>],</span><br><span class="line">          <span class="attr">radius</span>: [<span class="string">&#x27;20%&#x27;</span>, <span class="string">&#x27;40%&#x27;</span>],</span><br><span class="line">          <span class="attr">emphasis</span>: &#123;</span><br><span class="line">            <span class="attr">disabled</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">scale</span>: <span class="literal">false</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">itemStyle</span>: &#123;</span><br><span class="line">            <span class="attr">borderWidth</span>: <span class="number">0</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">data</span>: pieData,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!chartRef.<span class="property">current</span>) <span class="keyword">return</span></span><br><span class="line">    chartRef.<span class="property">current</span>.<span class="title function_">setOption</span>(optionRef.<span class="property">current</span>)</span><br><span class="line">  &#125;, [pieData])</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置data数据</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> _data = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> value = item.<span class="property">percent</span>.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="built_in">parseInt</span>(value),</span><br><span class="line">        <span class="attr">name</span>: item.<span class="property">name</span>,</span><br><span class="line">        <span class="attr">itemStyle</span>: &#123; <span class="attr">color</span>: item.<span class="property">val</span> &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">setPieData</span>(_data)</span><br><span class="line">  &#125;, [list, setPieData])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化图表</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">initChart</span> = (<span class="params">canvas, width, height, dpr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> chart = echarts.<span class="title function_">init</span>(canvas, <span class="literal">null</span>, &#123;</span><br><span class="line">      <span class="attr">width</span>: width,</span><br><span class="line">      <span class="attr">height</span>: height,</span><br><span class="line">      <span class="attr">devicePixelRatio</span>: dpr,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    chartRef.<span class="property">current</span> = chart</span><br><span class="line">    canvas.<span class="title function_">setChart</span>(chart)</span><br><span class="line">    chart.<span class="title function_">setOption</span>(optionRef.<span class="property">current</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chart</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> &#x27;<span class="attr">600rpx</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ec-canvas</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">id</span>=<span class="string">&quot;mychart-dom-pie&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">canvas-id</span>=<span class="string">&quot;mychart-pie&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">ec</span>=<span class="string">&#123;&#123;</span> <span class="attr">onInit:</span> <span class="attr">initChart</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Pie</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="React-TS篇"><a href="#React-TS篇" class="headerlink" title="React+TS篇"></a>React+TS篇</h3><ol>
<li><p>安装echarts</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install echarts</span><br></pre></td></tr></table></figure></li>
<li><p>把获取dom和高度及初始化ECharts的方法先封装好写成组件</p>
</li>
<li><p>示例（适用多个类型的echart）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;useEffect, useRef&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">Chart</span> = &#123; </span><br><span class="line">  <span class="attr">option</span>:any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MoneyChart</span>:<span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">Chart</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; option &#125; = props</span><br><span class="line">  <span class="keyword">const</span> chartWrapper = useRef&lt;<span class="title class_">HTMLDivElement</span>&gt;(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> chart = useRef&lt;any&gt;(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> height = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)?.<span class="property">clientHeight</span> </span><br><span class="line">    <span class="keyword">if</span>(!chartWrapper.<span class="property">current</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    chartWrapper.<span class="property">current</span>.<span class="property">style</span>.<span class="property">height</span> =<span class="string">`<span class="subst">$&#123;height&#125;</span>px`</span></span><br><span class="line">    chart.<span class="property">current</span>=echarts.<span class="title function_">init</span>(chartWrapper.<span class="property">current</span>,<span class="string">&#x27;vintage&#x27;</span>) <span class="comment">//初始化ECharts</span></span><br><span class="line">  &#125;,[])</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    chart.<span class="property">current</span>.<span class="title function_">setOption</span>(option)</span><br><span class="line">  &#125;,[option])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;chartWrapper&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;height:</span>&#x27;<span class="attr">600px</span>&#x27;&#125;&#125;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MoneyChart</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在父组件中调用组件</p>
</li>
<li><p>初始化option和data</p>
</li>
<li><p>分别设置option和data</p>
</li>
<li><p>然后将option传给组件即可</p>
</li>
</ol>
<h2 id="问题与方案"><a href="#问题与方案" class="headerlink" title="问题与方案"></a>问题与方案</h2><h3 id="Q1-关于echart图表显示不出来的问题"><a href="#Q1-关于echart图表显示不出来的问题" class="headerlink" title="Q1: 关于echart图表显示不出来的问题"></a>Q1: 关于echart图表显示不出来的问题</h3><ul>
<li>确认是否使用了webpack5 持久化缓存，启用了持久化缓存后，echarts图表显示不出来（前提是你的图表原本能正常显示）</li>
</ul>
<h3 id="Q2-关于标签显示不全问题，标签数据太多，当某个角度的标签太多，标签文字超出边界则显示不出来"><a href="#Q2-关于标签显示不全问题，标签数据太多，当某个角度的标签太多，标签文字超出边界则显示不出来" class="headerlink" title="Q2: 关于标签显示不全问题，标签数据太多，当某个角度的标签太多，标签文字超出边界则显示不出来"></a>Q2: 关于标签显示不全问题，标签数据太多，当某个角度的标签太多，标签文字超出边界则显示不出来</h3><ol>
<li>如标签多已成事实，尽可能标签文本占一行，不要换行</li>
<li>设置这些属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">minAngle</span>: <span class="number">15</span>, <span class="comment">//最小角度</span></span><br><span class="line"><span class="attr">startAngle</span>: <span class="number">270</span>, <span class="comment">//起始角度</span></span><br><span class="line"><span class="attr">avoidLabelOverlap</span>: <span class="literal">true</span>, <span class="comment">//是否启用防止标签重叠策略</span></span><br></pre></td></tr></table></figure></li>
<li>一行文字过多，建议商量去掉部分文字，或开启文字太长省略<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">position</span>: <span class="string">&#x27;outer&#x27;</span>,</span><br><span class="line"><span class="attr">alignTo</span>: <span class="string">&#x27;labelLine&#x27;</span>,</span><br><span class="line"><span class="attr">bleedMargin</span>: <span class="number">20</span>,</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Q3-echart图表警告：没有宽高"><a href="#Q3-echart图表警告：没有宽高" class="headerlink" title="Q3: echart图表警告：没有宽高"></a>Q3: echart图表警告：没有宽高</h3><ul>
<li>用style指定宽高</li>
</ul>
<h3 id="Q4-echart图表在小程序体积过大"><a href="#Q4-echart图表在小程序体积过大" class="headerlink" title="Q4: echart图表在小程序体积过大"></a>Q4: echart图表在小程序体积过大</h3><ul>
<li>使用分包<br>1.把对应的图形的ec-canvas下载下来，<br>2.将整个ec-canvas放在使用分包的组件内<br>3.分包组件调用</li>
<li>按需定制化echarts,然后替换原文件的echarts.js</li>
</ul>
<h3 id="Q5-echarts-使用极坐标或坐标图时提示Cannot-read-properties-of-undefined-reading-‘findAxisModel’"><a href="#Q5-echarts-使用极坐标或坐标图时提示Cannot-read-properties-of-undefined-reading-‘findAxisModel’" class="headerlink" title="Q5: echarts 使用极坐标或坐标图时提示Cannot read properties of undefined (reading ‘findAxisModel’)"></a>Q5: echarts 使用极坐标或坐标图时提示Cannot read properties of undefined (reading ‘findAxisModel’)</h3><ul>
<li>检查option的参数是否配置正确，是否少了polar 配置或者其他参数</li>
</ul>
<h3 id="Q6-echarts-给饼图上的文本标签加⚪点样式"><a href="#Q6-echarts-给饼图上的文本标签加⚪点样式" class="headerlink" title="Q6: echarts 给饼图上的文本标签加⚪点样式"></a>Q6: echarts 给饼图上的文本标签加⚪点样式</h3><ul>
<li>设置series中的label，在label中的rich中写好样式然后通过的formatter实现</li>
<li>效果图<br><img src="/../../img/WeChatMini/%E9%A5%BC%E5%9B%BE%E5%9B%BE%E5%BD%A2%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F.jpg" alt="饼图图形文本样式"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">label</span>: &#123;</span><br><span class="line">  <span class="attr">formatter</span>: <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">    returvn <span class="string">`&#123;hr|&#125; &#123;name|<span class="subst">$&#123;params.name&#125;</span>&#125;\n&#123;value|<span class="subst">$&#123;params.value&#125;</span>%&#125;`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">minMargin</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">lineHeight</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="attr">fontSize</span>: <span class="number">14</span>,</span><br><span class="line">  <span class="attr">rich</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">      <span class="attr">fontWeight</span>: <span class="number">600</span>,</span><br><span class="line">      <span class="attr">lineHeight</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: &#123;</span><br><span class="line">      <span class="attr">fontWeight</span>: <span class="string">&#x27;normal&#x27;</span>,</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;rgba(0, 0, 0, 0.65)&#x27;</span>,</span><br><span class="line">      <span class="attr">lineHeight</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">hr</span>: &#123;</span><br><span class="line">      <span class="attr">backgroundColor</span>: <span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">      <span class="attr">borderRadius</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">width</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">height</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">padding</span>: [<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Q7-echarts-给饼图去掉鼠标滑过的放大效果"><a href="#Q7-echarts-给饼图去掉鼠标滑过的放大效果" class="headerlink" title="Q7: echarts 给饼图去掉鼠标滑过的放大效果"></a>Q7: echarts 给饼图去掉鼠标滑过的放大效果</h3><ul>
<li>设置series里的emphasis配置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">emphasis</span>: &#123;</span><br><span class="line">  <span class="attr">disabled</span>: <span class="literal">true</span>, <span class="comment">// 关闭高亮</span></span><br><span class="line">  <span class="attr">scale</span>: <span class="literal">false</span>, <span class="comment">// 关闭放大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Q8-echarts-使用自定义颜色时标签与颜色不一致"><a href="#Q8-echarts-使用自定义颜色时标签与颜色不一致" class="headerlink" title="Q8: echarts 使用自定义颜色时标签与颜色不一致"></a>Q8: echarts 使用自定义颜色时标签与颜色不一致</h3><ul>
<li><p>在处理data数据时添加itemStyle:{color: ‘’}</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> _data = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> value = item.<span class="property">percent</span>.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="built_in">parseInt</span>(value),</span><br><span class="line">    <span class="attr">name</span>: item.<span class="property">name</span>,</span><br><span class="line">    <span class="attr">itemStyle</span>: &#123; <span class="attr">color</span>: item.<span class="property">val</span> &#125;,</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="title function_">setPieData</span>(_data)</span><br><span class="line">&#125;, [list, setPieData])</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://developers.weixin.qq.com/community/develop/article/doc/000ec2223a43881b1eb0e644b61c13">参考文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>echart</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-H5相关问题</title>
    <url>/2024/11/04/WeChatMini/h5%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="页面展示："><a href="#页面展示：" class="headerlink" title="页面展示："></a>页面展示：</h3><ul>
<li>使用<a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html">web-view 组件</a>包裹住</li>
</ul>
<h3 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wxml</span><br><span class="line">&lt;page-view isLoading=<span class="string">&quot;&#123;&#123;true&#125;&#125;&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">web-view</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">web-view</span>&gt;</span></span></span><br><span class="line">&lt;/page-view&gt;</span><br><span class="line">ts</span><br><span class="line"><span class="title function_">onLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> eventChannel = <span class="variable language_">this</span>.<span class="title function_">getOpenerEventChannel</span>()</span><br><span class="line">  eventChannel.<span class="title function_">once</span>(<span class="string">&#x27;webview&#x27;</span>,<span class="function">(<span class="params">url:string</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;url&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">使用</span><br><span class="line"><span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;webview的文件路径&#x27;</span>,</span><br><span class="line">  <span class="title function_">success</span>(<span class="params">res</span>)&#123;</span><br><span class="line">    res.<span class="property">eventChannel</span>.<span class="title function_">emit</span>(<span class="string">&#x27;webview&#x27;</span>, url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="配置业务域名"><a href="#配置业务域名" class="headerlink" title="配置业务域名"></a>配置业务域名</h3><ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/domain.html">如何配置业务域名的流程</a></li>
</ul>
<ol>
<li>管理员进入微信公众平台，找到开发管理添加业务域名</li>
<li>配置域名时先下载校验文件(ABC.txt)然后将文件放置在域名根目录下，后添加对应域名，如<code>https://test.com/</code></li>
<li><code>https://test.com/ABC.txt</code>确保可以访问，然后下载这个文件，上传服务器</li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/00084a350b426099ab46e0e1a50004?/blogdetail?action=get_post_info">业务域名设置–校验文件检查失败自查指引</a></li>
</ol>
<h3 id="访问公众号文章"><a href="#访问公众号文章" class="headerlink" title="访问公众号文章"></a>访问公众号文章</h3><ol>
<li>小程序要与公众号进行绑定</li>
<li>需要的是 https 请求</li>
<li>如果配置的是公众号文章地址，不需要额外配置业务域名</li>
<li>参数需要进行 encode 编码</li>
</ol>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-sku算法</title>
    <url>/2024/11/04/WeChatMini/sku/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="电商通用的选择该商品规格算法（sku最小存货）"><a href="#电商通用的选择该商品规格算法（sku最小存货）" class="headerlink" title="电商通用的选择该商品规格算法（sku最小存货）"></a>电商通用的选择该商品规格算法（sku最小存货）</h2><blockquote>
<ul>
<li>sku是会计学中的一个名词，被称为库存单元，即每一个但规格选项就是一个sku。</li>
<li>商品和sku属于一对多的关系</li>
</ul>
</blockquote>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li>没有库存的置灰</li>
<li>同一类别切换时，图片也要跟着切(<span class="desc">这个看返回的数据结构图片在哪在思考，在点击选项时处理(示例省略)</span>)</li>
<li>默认不选的话给默认图(<span class="desc">如果是有进来就要有图片的情况</span>)，没有的默认选择每个类别的第一个规格</li>
</ul>
<h3 id="返回的数据结构"><a href="#返回的数据结构" class="headerlink" title="返回的数据结构"></a>返回的数据结构</h3><ul>
<li>有两种数据结构<ul>
<li>第一种：已经分配好的选项+库存，如果没有用笛卡尔乘积算法处理，一般会有</li>
<li>第二种：类别和它的子选项，没有需要自己处理，一般会有</li>
</ul>
</li>
</ul>
<h2 id="实现思路一"><a href="#实现思路一" class="headerlink" title="实现思路一  "></a>实现思路一  <!--/p_four/component/skuAlogorithm.tsx  --></h2><ol>
<li>默认进来不选</li>
<li>初始化数据：先处理后台返回的数据，初始化到一个数组skuMap中,skuMap的数据结构示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">skuMap = [&#123;</span><br><span class="line">	<span class="attr">title</span>: 颜色, --- 大类别</span><br><span class="line">	<span class="attr">check</span>: -<span class="number">1</span>, --- 类别选中的item索引</span><br><span class="line">	<span class="attr">sub</span>: [&#123;</span><br><span class="line">		<span class="attr">name</span>: 绿色,	--- 大类别下的item名称</span><br><span class="line">		<span class="attr">disabled</span>: <span class="literal">false</span>, 对应item的置灰情况</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li>
<li>页面的加载：处理数组的过程让页面加载，数组处理完成再显示页面</li>
<li>初始化库存stock，默认为0</li>
<li>列举规格组合：写一个函数groupSku将所有可排列的规格一一列举出来，包括库存, groupSku的数据结构示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	[<span class="string">&quot;绿色&quot;</span>，<span class="string">&quot;xl&quot;</span>,<span class="string">&quot;7天内发货&quot;</span>, <span class="number">23</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>处理点击当前选项函数handleCurrentChose：点击该规格的时候需要传递外层索引，内层索引和内层名称<ul>
<li>选项置灰处理：当前选项置灰时，同一大类初始化不选中并返回</li>
<li>同一大类的选项切换判断：直接修改check值</li>
<li>判断当前选项无库存的组合元素，并把对应的名称置灰</li>
<li>判断是否选择完毕：查看每一个大类的check是否都不为-1</li>
<li>选择完毕则通过groupSku找到对应组合获取最后一个选项库存并设置库存</li>
</ul>
</li>
<li>获取当前选项置灰的元素：<ul>
<li>先找到groupSku中所有库存为0且包含当前元素名称的组合noStockList</li>
<li>初始化置灰元素列表</li>
<li>遍历noStockList，去重并去除当前元素名称，最后其余元素存储到置灰元素列表中</li>
<li>最后返回这个列表</li>
</ul>
</li>
</ol>
<h2 id="实现思路二优化"><a href="#实现思路二优化" class="headerlink" title="实现思路二优化 "></a>实现思路二优化 <!-- p_two/src/pages/sku/sku.tsx --></h2><blockquote>
<p>已知两种数据结构，先把规格的结构处理了，展示在页面上，分配好的选项+库存不处理(其实可以通过id定位会更方便，不过这里没有)</p>
</blockquote>
<ol>
<li>定义一个数组来存储处理好的规格</li>
</ol>
<ul>
<li>由于处理好的结构是Qbject,所以遍历使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(<span class="title class_">Object</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">key: string</span>)=&gt;</span> &#123;<span class="comment">/* 使用shop[key]拿到这个键的值*/</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>由于定义的时候键为英文，而展示时是中文,则使用<span class="key_words">『枚举映射元组』</sapn>的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shopMapTitle = &#123;</span><br><span class="line">  <span class="string">&#x27;colors&#x27;</span>: <span class="string">&#x27;颜色&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sizes&#x27;</span>: <span class="string">&#x27;尺寸&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;styles&#x27;</span>: <span class="string">&#x27;款式&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;delivery&#x27;</span>: <span class="string">&#x27;配送方式&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">使用：shopMapTitle[key]</span><br></pre></td></tr></table></figure></li>
<li><p>选项要使用radio组件来实现,值得数组类型要根据radio的数据结构来定</p>
</li>
<li><p>定义变量: 全局map, 存储选择选项得Object</p>
</li>
<li><p>处理点击函数: 点击时传递当前选项的类别和选项, 并遍历已处理好的选项库存获取并判断库存</p>
<ul>
<li>获取选择结果:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">map.<span class="title function_">set</span>(<span class="string">`<span class="subst">$&#123;类别&#125;</span>`</span>, 当前选项)</span><br></pre></td></tr></table></figure></li>
<li>map转Object<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map)</span><br></pre></td></tr></table></figure></li>
<li>Object转Array<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(_selectListObj)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>处理初始化</p>
<ul>
<li>初始化的时候要先把遍历规格的格式处理好</li>
<li>初始化置灰不可取，应该是选择一项后发现这一项的其它类别有库存为0 在置灰，点击其它恢复<ul>
<li>先把要判断的存到一个数组A，通过数组判断当前元素是否在这个数组A里，存在就将除这个类别的这一项item排除，其它数组A里的元素找到位置然后置灰，否则就全部不置灰</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-生成二维码scene问题</title>
    <url>/2024/11/04/WeChatMini/scene%E5%A4%AA%E9%95%BF%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="问题：scene-太长-参数少但长-，生成不了小程序码"><a href="#问题：scene-太长-参数少但长-，生成不了小程序码" class="headerlink" title="问题：scene 太长(参数少但长)，生成不了小程序码"></a>问题：scene 太长(参数少但长)，生成不了小程序码</h2><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ul>
<li>使用getUnlimitedQRCode获取无限制的小程序码时，可接受页面参数scene的长度不能超过32位字符</li>
</ul>
<h3 id="使用-JSBI-插件"><a href="#使用-JSBI-插件" class="headerlink" title="使用 JSBI 插件"></a><a href="https://github.com/GoogleChromeLabs/jsbi">使用 JSBI 插件</a></h3><ul>
<li>安装：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install jsbi --save</span><br></pre></td></tr></table></figure></li>
<li>用法：JSBI.BigInt()</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>先把scene的<span class="key_words">『每个参数用JSBI.BigInt()』</span>包裹住，防止在转格式的时候丢失精度</li>
<li>然后调用<span class="key_words">『.toString(36)』</span>转为36进制<ul>
<li>因为scene为32位的十进制，所以先转为36进制的,如果不满足可以考虑其他进制</li>
</ul>
</li>
<li>然后使用<span class="key_words">『encodeURIComponent()』</span>,生成二维码</li>
<li>按照分隔符解码和解构赋值得到参数(此时拿到的参数是36进制)：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[a,b,c,d] = <span class="built_in">decodeURIComponent</span>(params.<span class="property">scene</span>).<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>转为十进制即可</li>
</ol>
<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/qrcode-link/qr-code/getUnlimitedQRCode.html">获取不限制的小程序码</a></li>
</ul>
<h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><h3 id="了解BigInt"><a href="#了解BigInt" class="headerlink" title="了解BigInt"></a>了解BigInt</h3><ul>
<li>JS 中的 NUmber 类型只能安全地表示-(2^53-1)和(2^53-1)之间的整数</li>
<li>任何超过这个范围的整数值都会丢失精度（四舍五入）</li>
<li>而使用<span class="key_words">『BigInt就不会丢失精度』</span>，可以运算大整数</li>
</ul>
<h3 id="定义一个BigInt"><a href="#定义一个BigInt" class="headerlink" title="定义一个BigInt"></a>定义一个BigInt</h3><ul>
<li>在一个整数后面加n，例如: 10n</li>
<li>调用函数BigInt()并传递一个整数值或字符串值，例如: BigInt(10)</li>
</ul>
<h3 id="BigInt特点"><a href="#BigInt特点" class="headerlink" title="BigInt特点"></a>BigInt特点</h3><ul>
<li>不能用于 Math 对象中的方法</li>
<li>不能与任何 Number 实例混合运算，两者必须转换成同一种类型。但是需要注意，<span class="key_words">『BigInt 在转换成 Number 时可能会丢失精度』</span></li>
<li>当使用 BigInt 时，带小数的运算会被向下取整</li>
<li>BigInt 和 Number 不是严格相等，但是宽松相等<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0n</span> === <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0n</span> == <span class="number">0</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt; <span class="number">2</span>   <span class="comment">// false</span></span><br><span class="line"><span class="number">2n</span> &gt; <span class="number">1</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mixed = [<span class="number">4n</span>, <span class="number">6</span>, -<span class="number">12n</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0n</span>];</span><br><span class="line">mixed.<span class="title function_">sort</span>();  <span class="comment">// [-12n, 0, 0n, 10, 4n, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 Object 包装的 BigInt, 使用 object 的比较规则进行比较，只用同一个对象比较时才相等</span></span><br><span class="line"><span class="number">0n</span> === <span class="title class_">Object</span>(<span class="number">0n</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>(<span class="number">0n</span>) === <span class="title class_">Object</span>(<span class="number">0n</span>); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="title class_">Object</span>(<span class="number">0n</span>);</span><br><span class="line">o === o <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="BigInt的方法"><a href="#BigInt的方法" class="headerlink" title="BigInt的方法"></a>BigInt的方法</h3><ul>
<li>Bigint.asIntN()<ul>
<li>将 BigInt 值转换为一个 -2^(width-1) 与 2^(width-1) - 1 之间的有符号整数。</li>
</ul>
</li>
<li>BigInt.asUintN()<ul>
<li>将一个 BigInt 值转换为 0 与 2^(width) - 1 之间的无符号整数。</li>
</ul>
</li>
<li>BigInt.prototype.toLocaleString()<ul>
<li>返回此数字的 language-sensitive 形式的字符串。覆盖 Object.prototype.toLocaleString() 方法。</li>
</ul>
</li>
<li>BigInt.prototype.toString()<ul>
<li>返回以指定基数 (base) 表示指定数字的字符串。覆盖 Object.prototype.toString() 方法。</li>
</ul>
</li>
<li>BigInt.prototype.valueOf()<ul>
<li>返回指定对象的基元值。覆盖 Object.prototype.valueOf() 方法。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-事件和生命周期</title>
    <url>/2024/11/04/WeChatMini/xcx-%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote>
<p>事件分为冒泡事件和非冒泡事件</p>
</blockquote>
<h3 id="冒泡事件"><a href="#冒泡事件" class="headerlink" title="冒泡事件"></a>冒泡事件</h3><ul>
<li>当一个组件上的事件被触发后，<span class="key_words">『事件会向父节点传递』</span></li>
<li>WXML的冒泡事件列表：即在触摸&#x2F;动画开始结束等动作时发生的事件</li>
</ul>
<h3 id="非冒泡事件"><a href="#非冒泡事件" class="headerlink" title="非冒泡事件"></a>非冒泡事件</h3><ul>
<li>当一个组件上的事件被触发后，<span class="key_words">事件不会向父节点传递』</span></li>
<li>除冒泡事件列表，且无特殊生命的都是非冒泡事件</li>
</ul>
<h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><ul>
<li>bind：普通事件绑定</li>
<li>catch: 会阻止事件向上冒泡</li>
<li>mut-bind：互斥事件绑定</li>
<li>触发后，只会有其中一个绑定函数被触发。且不影响bind和catch的绑定效果</li>
</ul>
<h3 id="事件的捕获阶段"><a href="#事件的捕获阶段" class="headerlink" title="事件的捕获阶段"></a>事件的捕获阶段</h3><ul>
<li>触摸类事件支持捕获阶段。</li>
<li>捕获位于冒泡之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反</li>
<li>捕获阶段监听事件：<ul>
<li>capture-bind</li>
<li>capture-catch：中断捕获阶段和取消冒泡阶段</li>
</ul>
</li>
</ul>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><h3 id="基础事件对象属性列表"><a href="#基础事件对象属性列表" class="headerlink" title="基础事件对象属性列表"></a>基础事件对象属性列表</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>事件类型</td>
<td></td>
</tr>
<tr>
<td>timeStamp</td>
<td>事件生成时的时间戳</td>
<td></td>
</tr>
<tr>
<td>target</td>
<td>触发事件的源组件</td>
<td></td>
</tr>
<tr>
<td>target</td>
<td>触发事件的源组件</td>
<td></td>
</tr>
<tr>
<td></td>
<td>id</td>
<td>事件源组件的</td>
</tr>
<tr>
<td></td>
<td>dataset</td>
<td>事件源组件上由data-开头的自定义属性组成的集合</td>
</tr>
<tr>
<td>currentTarget</td>
<td>当前组件的一些属性值集合</td>
<td></td>
</tr>
<tr>
<td>mark</td>
<td>事件标记数据</td>
<td></td>
</tr>
</tbody></table>
<h3 id="自定义事件对象属性列表"><a href="#自定义事件对象属性列表" class="headerlink" title="自定义事件对象属性列表"></a>自定义事件对象属性列表</h3><ul>
<li>detail	Object	额外的信息</li>
</ul>
<h3 id="触摸事件对象属性列表"><a href="#触摸事件对象属性列表" class="headerlink" title="触摸事件对象属性列表"></a>触摸事件对象属性列表</h3><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>touches</td>
<td>Array</td>
<td>触摸事件，当前停留在屏幕中的触摸点信息的数组</td>
</tr>
<tr>
<td>changedTouches</td>
<td>Array</td>
<td>触摸事件，当前变化的触摸点信息的数组</td>
</tr>
</tbody></table>
<h3 id="特殊事件"><a href="#特殊事件" class="headerlink" title="特殊事件"></a>特殊事件</h3><ul>
<li>canvas 中的触摸事件不可冒泡，所以没有 currentTarget。</li>
</ul>
<h3 id="dataset"><a href="#dataset" class="headerlink" title="dataset:"></a>dataset:</h3><ul>
<li>在 WXML 中，这些自定义数据以 data- 开头，多个单词由连字符 - 连接。</li>
<li>data-element-type，最终会呈现为 event.currentTarget.dataset.elementType (转驼峰)</li>
<li>data-elementType，最终会呈现为 event.currentTarget.dataset.elementtype （大写转小写）</li>
</ul>
<h3 id="mark"><a href="#mark" class="headerlink" title="mark:"></a>mark:</h3><ul>
<li>mark 会包含从触发事件的节点到根节点上所有的 mark: 属性值</li>
<li>Touch 对象</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>identifier</td>
<td>Number</td>
<td>触摸点的标识符</td>
</tr>
<tr>
<td>pageX,pageY</td>
<td>Number</td>
<td>距离文档左上角的距离，文档的左上角为原点</td>
</tr>
<tr>
<td>clientX,clientY</td>
<td>Number</td>
<td>距离页面可显示区域(除去导航条)左上角距离</td>
</tr>
</tbody></table>
<ul>
<li>CanvasTouch 对象</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>identifier</td>
<td>Number</td>
<td>触摸点的标识符</td>
</tr>
<tr>
<td>x,y</td>
<td>Number</td>
<td>距离 Canvas 左上角的距离，Canvas 的左上角为原点</td>
</tr>
</tbody></table>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="App-生命周期"><a href="#App-生命周期" class="headerlink" title="App 生命周期"></a>App 生命周期</h3><ul>
<li>在App({})函数中定义<ul>
<li>onLaunch：小程序初始化时触发，<span class="key_words">『全局只触发一次』</span>。通常用于初始化操作。</li>
<li>onShow：小程序启动或从后台进入前台显示时触发。通常用于获取用户信息、判断是否登录。</li>
<li>onHide：小程序从前台进入后台隐藏时触发。通常用于保存用户数据、暂停音乐播放。</li>
<li>onError：小程序发生脚本错误或API调用失败时触发。通常用于对错误进行处理，如记录错误日志等操作。</li>
</ul>
</li>
<li>注意<ul>
<li><span class="key_words">『异步操作』</span>：生命周期函数可能包含异步操作，如网络请求、定时器.在这种情况上下，需要使用回调函数或Promise对象等方式来保证异步操作的正确执行。</li>
<li><span class="key_words">『页面传参』</span>：在小程序中跳转到其他页面时，可以通过 URL 参数传递数据。开发者需要在 onLoad 函数中获取参数并进行处理。</li>
<li><span class="key_words">『数据缓存』</span>：在小程序中，可以使用 wx.setStorage 和 wx.getStorage 等 API 将数据保存到本地缓存中。这些数据可以在小程序的不同页面中共享和访问，可以用于存储用户信息、配置项等数据。</li>
</ul>
</li>
</ul>
<h3 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h3><ul>
<li>在Page({})函数中定义<ul>
<li>onLoad：页面<span class="key_words">『加载时』</span>触发。通常用于获取页面参数、初始化数据等操作。</li>
<li>onShow：页面<span class="key_words">『显示时』</span>触发。通常用于刷新页面数据、重新加载组件等操作。</li>
<li>onReady：页面<span class="key_words">『初次渲染完成时』</span>触发。通常用于获取 DOM 节点、创建动画等操作。</li>
<li>onHide：页面<span class="key_words">『隐藏时』</span>触发。可以保存页面数据等操作。</li>
<li>onUnload：页面<span class="key_words">『卸载时』</span>触发，如 wx.redirectTo 或 wx.navigateBack 到其他页面时。通常用于保存页面数据、取消订阅事件等操作。</li>
</ul>
</li>
</ul>
<h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><ul>
<li>在Component({})函数中的lifetimes对象中定义<ul>
<li>created：组件实例被创建时触发，此时this.data是Component构造器中的data，<span class="key_words">『不能调用setData』</span>。</li>
<li>attached：初始化完毕后，组件被加入到父组件中时触发，此时this.data为组件当前值。</li>
<li>ready：组件在视图层布局完成后触发。</li>
<li>moved：组件被移动到另一个节点时触发。</li>
<li>detached：组件实例被从页面节点树中移除时触发。</li>
<li>error：每当组件方法抛出错误时执行，参数Object Error</li>
</ul>
</li>
</ul>
<h3 id="组件所在页面生命周期"><a href="#组件所在页面生命周期" class="headerlink" title="组件所在页面生命周期"></a>组件所在页面生命周期</h3><ul>
<li>在组件的pageLifetimes对象中定义<ul>
<li>show：组件所在的页面<span class="key_words">『被展示时』</span>执行</li>
<li>hide：组件所在的页面<span class="key_words">『被隐藏时』</span>执行</li>
<li>resize：组件所在的页面<span class="key_words">『尺寸变化』</span>时执行，参数Object Size</li>
<li>routeDone：组件所在页面<span class="key_words">『路由动画完成时』</span>执行</li>
<li>注：自定义的tabBar的pageLifetime不会触发</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-二次封装组件和自定义组件</title>
    <url>/2024/11/04/WeChatMini/xcx-%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="npm-二次封装基础组件"><a href="#npm-二次封装基础组件" class="headerlink" title="npm&#x2F;二次封装基础组件"></a>npm&#x2F;二次封装基础组件</h2><h3 id="安装npm"><a href="#安装npm" class="headerlink" title="安装npm"></a>安装npm</h3><ol>
<li>进入小程序根目录，运行 cmd ，输入：npm init</li>
<li>输入命令之后一直点回车。</li>
<li>输入安装的组件命令：</li>
<li>执行命令完之后，再去微信开发者中点工具-构建npm，就成功了。</li>
</ol>
<h3 id="使用Vant-Weapp组件库"><a href="#使用Vant-Weapp组件库" class="headerlink" title="使用Vant Weapp组件库"></a>使用<a href="https://vant-ui.github.io/vant-weapp/#/home">Vant Weapp组件库</a></h3><ol>
<li>进入官网</li>
<li>按照官网的介绍选择对应的工具安装，npm使用前四步就行</li>
</ol>
<h3 id="二次封装组件"><a href="#二次封装组件" class="headerlink" title="二次封装组件"></a>二次封装组件</h3><ol>
<li>新建一个components文件夹</li>
<li>在components文件夹下在新建一个文件夹base，用来存放基础组件</li>
<li>如果是存放业务组件用business，看component文件夹的位置决定组件是全局还是局部</li>
<li>在base中新建文件夹a用来封装组件(<span class="desc">原生小程序里面有4-5个文件,后缀分别为json,js,wxml,wxss,ts</span>)</li>
<li>把要封装的组件路径和名字以键值对的形式存放在json文件的usingComponents<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;usingComponents&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;van-button&quot;</span>: <span class="string">&quot;@vant/weapp/button/index&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>将封装的组件路径和名字写在对应文件的app.json中的usingComponents中(<span class="desc">名字最好与文件名一样，但要采用aa-bbb的形式</span>)</li>
<li><span class="key_words">『从原来』</span>组件的js文件下将props中的内容<span class="key_words">『复制到封装的组件』</span>的js文件中的properties中</li>
<li>在封装的组件的wxml文件下写原来组件的组件名及它的方法和插槽，以vant的button为例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;van-button</span><br><span class="line">  type=<span class="string">&quot;&#123;&#123; type &#125;&#125;&quot;</span></span><br><span class="line">  formType=<span class="string">&quot;&#123;&#123; formType &#125;&#125;&quot;</span></span><br><span class="line">  round=<span class="string">&quot;&#123;&#123; round &#125;&#125;&quot;</span></span><br><span class="line">  loading=<span class="string">&quot;&#123;&#123; loading &#125;&#125;&quot;</span></span><br><span class="line">  loading-text=<span class="string">&quot;&#123;&#123; loadingText &#125;&#125;&quot;</span></span><br><span class="line">  icon=<span class="string">&quot;&#123;&#123; icon &#125;&#125;&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span> /&gt;</span></span></span><br><span class="line">&lt;/van-button&gt;</span><br></pre></td></tr></table></figure></li>
<li>默认组件样式隔离, 要想让组件的样式页面可以使用,在二次封装的组件的json文件下加上<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;styleIsolation&quot;</span>: <span class="string">&quot;shared&quot;</span></span><br><span class="line"><span class="string">&quot;component&quot;</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>更改组件的样式，可以在app.wxss中更改，常用的样式可以封装起来<ul>
<li>使用: var(样式名)</li>
</ul>
</li>
</ol>
<h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><ol>
<li>按照模板将存放自定义组件的文件夹及其内容生成后</li>
<li>如果是局部使用：就在对应的页面的json的usingComponents中加上 “组件名”: “组件路径”（组件名可自定义）</li>
<li>如果是全局使用的：就在app.json中加上</li>
<li>页面使用对应的组件名作为标签，显示组件内容</li>
</ol>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>组件封装</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-动态tabbar(底部菜单)</title>
    <url>/2024/11/04/WeChatMini/xcx-%E5%8A%A8%E6%80%81tabbar/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>测试和正式环境的 icon 配置不同，且一静一动，通过 api 的数据在静默登陆时去更改 tabbar 的 iconPath。<br>更改的文件app.json 和 miniprogram\custom-tab-bar\index.ts</p>
</blockquote>
<h3 id="自定义-tabbar-步骤"><a href="#自定义-tabbar-步骤" class="headerlink" title="自定义 tabbar 步骤"></a>自定义 tabbar 步骤</h3><ol>
<li>首先 app.json 中 custom 设置为 true</li>
<li>根据微信开发文档在根目录创建 custom-tab-bar 文件夹，写好自定义 tabbar 的样式</li>
<li>tabbar 跳转使用switchTab</li>
<li>在 ready 中初始化 tab 选择点击的交互行为</li>
<li>可以先把 tabbar 的几个页面名字存储到数组中，通过 some 判断,如果存在当前页面路由的 endsWith(tabbar 的名字),使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">getTabBar</span>().<span class="title function_">setData</span>(&#123; <span class="attr">selected</span>: tabbar 的选中情况 &#125;)</span><br></pre></td></tr></table></figure></li>
<li>当前页面路由<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pages = <span class="title function_">getCurrentPages</span>()</span><br><span class="line"><span class="keyword">const</span> length = pages.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> currentPageName = page[length - <span class="number">1</span>]?.<span class="property">route</span></span><br></pre></td></tr></table></figure></li>
<li>页面通过遍历自定义的 tabbar 数组，和 selected 来判断当前页面切换的路径和选择的图标</li>
</ol>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://juejin.cn/post/6844904110957789192">参考一：vant 有缺陷可参考</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html">官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>tabbar</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-动态展示图片，高度不一致</title>
    <url>/2024/11/04/WeChatMini/xcx-%E5%A4%9A%E4%B8%AA%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E9%AB%98%E5%BA%A6%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%9C%80%E9%AB%98%E7%9A%84%E9%AB%98%E5%BA%A6%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="获取最高的高度展示"><a href="#获取最高的高度展示" class="headerlink" title="获取最高的高度展示"></a>获取最高的高度展示</h2><ul>
<li>使用swiper组件将图片的框架搭建好(使用image标签最好加个<span class="key_words">『mode &#x3D;”widthFix”』</span>)</li>
</ul>
<h3 id="如果图片是动态生成的的，按以下步骤走"><a href="#如果图片是动态生成的的，按以下步骤走" class="headerlink" title="如果图片是动态生成的的，按以下步骤走"></a>如果图片是动态生成的的，按以下步骤走</h3><ol>
<li>由于高度不一致，通过<span class="key_words">『wx.createSelectorQuery()』</span>获取每一张图片的属性（<span class="desc">重点是高度</span>）</li>
<li>因为框架初始要渲染，所以代码要写在onReady钩子里</li>
<li>定义一个存放图片节点的空数组，因为要全局使用，需放在page上方</li>
<li>要获取图片存储的选择器，获取图片的属性(<span class="key_words">id 选择器是一对一，类选择器是选全部</span>)</li>
<li>swiper本身有一个current属性，需在data中初始化</li>
<li>定义一个数组，将获取到的图片节点信息res[0]存放在里面，为防止报错最好 <span class="key_words">『或一个初始值（数组[],对象 null）』</span></li>
<li>current 要动态获取</li>
<li>判断是否有图片，有的话就将定义的数组赋值给图片节点存放的数组</li>
<li>获取到图片的高度，首先要在data初始化，然后然后动态传递给初始化变量</li>
<li>查看显示的长度是否异常（<span class="desc">从执行的函数开始往下找</span>）</li>
<li>异步，使用延时器加载</li>
</ol>
<h3 id="图片非动态的直接使用css样式和mode来控制"><a href="#图片非动态的直接使用css样式和mode来控制" class="headerlink" title="图片非动态的直接使用css样式和mode来控制"></a>图片非动态的直接使用css样式和mode来控制</h3>]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-封装日历组件与组件传值</title>
    <url>/2024/11/04/WeChatMini/xcx-%E5%B0%81%E8%A3%85%E6%97%A5%E5%8E%86%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%9A%E5%8A%A1%E7%BB%84%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="封装日历组件"><a href="#封装日历组件" class="headerlink" title="封装日历组件"></a>封装日历组件</h2><blockquote>
<p>基于封装日历组件，学会封装业务组件到使用的流程</p>
</blockquote>
<ol>
<li>新建baseCalendar文件夹(具体步骤👉<a href="/2024/11/04/WeChatMini/xcx-%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/" title="微信小程序-二次封装组件和自定义组件">微信小程序-二次封装组件和自定义组件</a>)</li>
<li>在该文件夹下的json文件中添加<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;component&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;styleIsolation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shared&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;van-calendar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@vant/weapp/calendar/index&quot;</span> <span class="comment">// 要封装组件的路径</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>从原组件的js文件中将props中需要的内容复制到封装组件的js文件中的properties中</li>
<li>在封装组件的wxml文件下使用原组件和添加插槽</li>
<li>在app.json中的usingComponents定义的封装组件标签名和路径</li>
<li>页面通过使用封装组件的标签来使用原组件加自定义的方法和样式</li>
<li>更改组件的样式，通过官方的文档找到对应组件的样式和属性进行更改</li>
</ol>
<h2 id="组件的传值"><a href="#组件的传值" class="headerlink" title="组件的传值"></a>组件的传值</h2><ol>
<li><p>页面使用: 页面中的组件要使用这个属性或方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">minDate=<span class="string">&quot;&#123;&#123; minTimestamp &#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>页面数据初始化: 在js文件中的data定义变量,并给一个默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">minTimestamp</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>组件类型初始化:  在js文件中的properties中写上属性名及其类型, 两种写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">方式一：<span class="attr">minDate</span>: <span class="title class_">Number</span></span><br><span class="line">方式二：<span class="attr">minDate</span>:&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件使用: wxml中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">minDate=<span class="string">&quot;&#123;&#123; minDate &#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>页面更改: js文件的函数去更改minTimestamp的值，以此更新页面数据 — 完成传值（简单类型）</p>
</li>
</ol>
<h2 id="调接口获取数据后-页面向组件传值（以动态显示该日期是否约满为例）"><a href="#调接口获取数据后-页面向组件传值（以动态显示该日期是否约满为例）" class="headerlink" title="调接口获取数据后 页面向组件传值（以动态显示该日期是否约满为例）"></a>调接口获取数据后 页面向组件传值（以动态显示该日期是否约满为例）</h2><ol>
<li><p>页面请求并获取约满的数据，fullTimes要初始化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">fullTimes</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getFullTimes</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="variable constant_">API</span>.<span class="title function_">getFullTimes</span>()</span><br><span class="line">	<span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">fullTimes</span>: result.<span class="property">result</span>.<span class="property">list</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>页面在onLoad()中调用并初始化请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getFullTimes</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>页面组件使用这个属性或方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fullTimes=<span class="string">&quot;&#123;&#123; fullTimes &#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义组件在js文件中的properties中定义属性名及其类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties</span>:&#123;</span><br><span class="line">  <span class="attr">fullTimes</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">    <span class="attr">value</span>: [],</span><br><span class="line">    <span class="comment">// 监听这边是否接收到fullTimes，有数据才初始化，防止二次初始化</span></span><br><span class="line">    <span class="title function_">observer</span>(<span class="params">newFullTimes</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newFullTimes.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">initCalendarDateFormat</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">formatter</span>: <span class="literal">null</span> <span class="comment">// 初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义组件在wxml文件中使用该变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">formatter=<span class="string">&quot;&#123;&#123; formatter &#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义组件中初始化日历的状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods：&#123;</span><br><span class="line">  <span class="title function_">initCalendarDateFormat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fullTimes = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">fullTimes</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">formatter</span> = (<span class="params">day</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 此处使用了封装的函数</span></span><br><span class="line">      <span class="keyword">const</span> today = <span class="title function_">isTodday</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>(), day.<span class="property">date</span>.<span class="title function_">valueOf</span>())</span><br><span class="line">      <span class="comment">// includes() 方法:判断fullTimes是否包含一个day.date.valueOf()值</span></span><br><span class="line">      <span class="keyword">if</span> (fullTimes.<span class="title function_">includes</span>(day.<span class="property">date</span>.<span class="title function_">valueOf</span>())) &#123;</span><br><span class="line">        day.<span class="property">type</span> = <span class="string">&#x27;disabled&#x27;</span></span><br><span class="line">        day.<span class="property">bottomInfo</span> = <span class="string">&#x27;约满&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (today) &#123;</span><br><span class="line">        day.<span class="property">type</span> = <span class="string">&#x27;disabled&#x27;</span></span><br><span class="line">        day.<span class="property">bottomInfo</span> = <span class="string">&#x27;今天&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> day</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      formatter</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义组件在lifetimes中的ready再次初始化 — 完成传值（复杂类型）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>组件封装</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-封装api到使用的一系列总结</title>
    <url>/2024/11/04/WeChatMini/xcx-%E6%8E%A5%E6%94%B6api/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="封装api到调用"><a href="#封装api到调用" class="headerlink" title="封装api到调用"></a>封装api到调用</h3><ol>
<li>先封装好网络请求（要记得把成功的失败的回调中返回数据）</li>
<li>将需要请求的参数返回给对应函数</li>
<li>需要使用到的页面调用接口<ul>
<li>在onLoad () {this.调用的函数}</li>
<li>用async,await将参数传递过来，定义一个变量接收</li>
<li>在data中定义初始化变量来接收数据this.setData({空数组(或对象)：接收的变量})</li>
</ul>
</li>
<li>跳转页面传参：可以用e.mark，将参数传进来，然后直接在url上携带参数传到另一个页面，另一个页面接收对应的参数，获取对应的数据</li>
</ol>
<h4 id="注意点：-mark（事件系统）-navigateTo-路径传参"><a href="#注意点：-mark（事件系统）-navigateTo-路径传参" class="headerlink" title="注意点： mark（事件系统） | navigateTo (路径传参)"></a>注意点： mark（事件系统） | navigateTo (路径传参)</h4><h3 id="获取api数据中二层数组的数据（-拼接字符串）"><a href="#获取api数据中二层数组的数据（-拼接字符串）" class="headerlink" title="获取api数据中二层数组的数据（+拼接字符串）"></a>获取api数据中二层数组的数据（+拼接字符串）</h3><ol>
<li>重新处理数据，用map遍历获取第一层数组中的值，然后存到一个空数组</li>
<li>定义好一个空的字符串，用来接收拼接的字符串</li>
<li>判断二层列表的空数组是否存在，有无长度</li>
<li>利用累加器reduce将列表的值拼接后返回给空字符串</li>
</ol>
<h4 id="注意点：-map（返回一个新数组），reduce（pre，cur，idx）累加器"><a href="#注意点：-map（返回一个新数组），reduce（pre，cur，idx）累加器" class="headerlink" title="注意点： map（返回一个新数组），reduce（pre，cur，idx）累加器"></a>注意点： map（返回一个新数组），reduce（pre，cur，idx）累加器</h4><h3 id="距离发布时间过了多久"><a href="#距离发布时间过了多久" class="headerlink" title="距离发布时间过了多久"></a>距离发布时间过了多久</h3><ol>
<li>获取当前时间</li>
<li>获取发布的时间</li>
<li>二者相减</li>
<li>将年月日 时分秒 处理好后</li>
</ol>
<ul>
<li>秒  &#x3D; 毫秒 &#x2F; 1000</li>
<li>分  &#x3D; 秒 &#x2F; 60</li>
<li>时  &#x3D; 分 &#x2F; 60</li>
<li>日  &#x3D; 时 &#x2F; 24</li>
<li>月  &#x3D; 日 &#x2F; 30</li>
<li>年  &#x3D; 月 &#x2F; 12</li>
<li>Math.floor(): 向下取整</li>
<li>Math.ceil(): 向上取整</li>
<li>Math.round(): 四舍五入</li>
</ul>
<ol start="5">
<li>嵌套判断</li>
</ol>
<h3 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a>请求分页</h3><ol>
<li>路径要动态传参</li>
<li>页面通过调用函数将参数传进来getListByTypeId({ page: curPage })</li>
<li>判断数据是否大于每页展示的数据，是的话直接显示；不是就将当前的数据和下一个数据拼接起来 </li>
<li>在上拉触底函数哪里判断页数是不是小于总的页数，是进入循环，当前页数加一；不是，提示无数据</li>
<li>加个是否加载成功：加载成功提示，继续滚动框架在新数据，加载中不能加载，等待数据加载完成才能继续操作（默认第一页为加载完成）</li>
</ol>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol>
<li>当api传入的数据有问题，应仔细查看一下路径是否写错</li>
<li>动态传参：       <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getListByTypeId : <span class="function">(<span class="params">data = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> param = &#123;</span><br><span class="line">    ...data,</span><br><span class="line">    <span class="attr">typeId</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">cross</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(<span class="string">&#x27;/pc/index/getListByTypeId&#x27;</span>, param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-自定义导航栏</title>
    <url>/2024/11/04/WeChatMini/xcx-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E8%88%AA%E6%A0%8F/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ol>
<li>app.json的window配置项中设置”nativationStyle”:”custom”</li>
<li>在组件目录中新建一个文件夹用来存放页面布局组件，</li>
<li>在app.ts中的使用wx.getSystemInfoSync()和wx.getMenuButtonBoundingClientRect()分别获取系统信息中状态栏的高度和胶囊的信息<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">globalData</span>: &#123;</span><br><span class="line">  <span class="attr">navBarHeight</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">menuWidth</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">menuHeigth</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">menuTop</span>: <span class="number">0</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">onLaunch</span> () &#123;</span><br><span class="line">  <span class="keyword">const</span> res = wx.<span class="title function_">getMenuButtonBoundingClientRect</span>() <span class="comment">// 获取胶囊信息</span></span><br><span class="line">  <span class="keyword">const</span> windowInfo = wx.<span class="title function_">getSystemInfoSync</span>() <span class="comment">// 获取系统信息</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">globalData</span>.<span class="property">navBarHeight</span> = systemInfo.<span class="property">statusBarHeight</span> + <span class="number">44</span> <span class="comment">// 状态栏高度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">globalData</span>.<span class="property">menuWidth</span> = res.<span class="property">width</span>,  <span class="comment">// 胶囊宽度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">globalData</span>.<span class="property">menuHeigth</span> = res.<span class="property">height</span>, <span class="comment">// 胶囊高度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">globalData</span>.<span class="property">menuTop</span> = res.<span class="property">top</span>,  <span class="comment">//较难离顶部的距离</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>先完成自定义导航的页面布局<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*wxml*/</span></span><br><span class="line">&lt;view <span class="keyword">class</span>=<span class="string">&quot;top&quot;</span> style=<span class="string">&quot;height: &#123;&#123;topBarHeight&#125;&#125;px; background-color:&#123;&#123;backgroundColor&#125;&#125;;&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;height: &#123;&#123;menuHeight&#125;&#125;px; padding-top: &#123;&#123;top&#125;&#125;px&quot;</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;isHome&#125;&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top:&#123;&#123;top&#125;&#125;px;height:&#123;&#123;menuHeight - 2&#125;&#125;px;width:&#123;&#123;menuWidth - 2&#125;&#125;px&quot;</span> <span class="attr">class</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">van-icon</span> <span class="attr">name</span>=<span class="string">&quot;arrow-left&quot;</span> <span class="attr">size</span>=<span class="string">&quot;24px&quot;</span> <span class="attr">color</span>=<span class="string">&quot;#fff&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;onBack&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;divide&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">van-icon</span> <span class="attr">name</span>=<span class="string">&quot;wap-home-o&quot;</span> <span class="attr">size</span>=<span class="string">&quot;24px&quot;</span> <span class="attr">custom-class</span>=<span class="string">&quot;home&quot;</span> <span class="attr">color</span>=<span class="string">&quot;#fff&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;onHome&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;!-- 占位 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;height: &#123;&#123;topBarHeight&#125;&#125;px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;body&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background: &#123;&#123;background&#125;&#125;;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">slot</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*scss*/</span></span><br><span class="line">.<span class="property">top</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: fixed;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">100</span>%;</span><br><span class="line">  <span class="attr">top</span>:<span class="number">0</span>;</span><br><span class="line">  .<span class="property">menu</span> &#123;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    border-<span class="attr">radius</span>: 20px; </span><br><span class="line">    <span class="attr">border</span>: 1px solid transparent;</span><br><span class="line">    box-<span class="attr">shadow</span>: inset 0px 1px 0px 0px <span class="title function_">rgba</span>(<span class="number">114</span>, <span class="number">114</span>, <span class="number">114</span>, <span class="number">0.178</span>);</span><br><span class="line">    background-<span class="attr">color</span>: <span class="title function_">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.178</span>);</span><br><span class="line">    margin-<span class="attr">left</span>: 20rpx;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    align-<span class="attr">items</span>: center;</span><br><span class="line">    justify-<span class="attr">content</span>: center;</span><br><span class="line">  &#125;</span><br><span class="line">  .<span class="property">home</span> &#123;</span><br><span class="line">    margin-<span class="attr">right</span>: 5px;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .<span class="property">divide</span> &#123;</span><br><span class="line">    <span class="attr">height</span>: 18px;</span><br><span class="line">    margin-<span class="attr">left</span>: 5px;</span><br><span class="line">    border-<span class="attr">right</span>: 1px solid <span class="title function_">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>);</span><br><span class="line">    margin-<span class="attr">right</span>: 10px;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .<span class="property">title</span> &#123;</span><br><span class="line">    <span class="attr">position</span>: absolute; </span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>%;</span><br><span class="line">    <span class="attr">display</span>: flex; </span><br><span class="line">    justify-<span class="attr">content</span>: center; </span><br><span class="line">    align-<span class="attr">items</span>: center; </span><br><span class="line">    font-<span class="attr">size</span>: 20px; </span><br><span class="line">    font-<span class="attr">weight</span>: bold;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*json*/</span></span><br><span class="line"><span class="string">&quot;usingComponents&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;van-icon&quot;</span>: <span class="string">&quot;@vant/weapp/icon/index&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>在ts文件中完成获取对应的页面信息<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取应用实例，间接获取globalData的数据</span></span><br><span class="line"><span class="keyword">const</span> app = getApp&lt;<span class="title class_">IAppOption</span>&gt;()</span><br><span class="line"><span class="comment">/* 组件的属性列表 */</span></span><br><span class="line"><span class="attr">properties</span>: &#123;</span><br><span class="line">  <span class="attr">title</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">backgroundColor</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;rgb(90 ,100 ,90)&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">background</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">/* 组件的初始数据 */</span></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">navBarHeight</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">top</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">menuHeight</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">menuWidth</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">isHome</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">/* 组件内生命周期 */</span></span><br><span class="line"><span class="attr">lifetimes</span>: &#123;</span><br><span class="line">  <span class="title function_">attached</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> pages = <span class="title function_">getCurrentPages</span>(); <span class="comment">// 获取页面指针数组</span></span><br><span class="line">    <span class="keyword">const</span> currentPage = pages[pages.<span class="property">length</span> - <span class="number">1</span>]; <span class="comment">// 获取当前页</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">navBarHeight</span>: app.<span class="property">globalData</span>.<span class="property">navBarHeight</span>, <span class="comment">// 获取顶部栏的高度</span></span><br><span class="line">      <span class="attr">top</span>: appData.<span class="property">globalData</span>.<span class="property">menuTop</span>,  <span class="comment">// 获取胶囊与顶部的距离</span></span><br><span class="line">      <span class="attr">menuHeight</span>: appData.<span class="property">globalData</span>.<span class="property">menuHeigth</span>, <span class="comment">// 获取胶囊高度</span></span><br><span class="line">      <span class="attr">menuWidth</span>: appData.<span class="property">globalData</span>.<span class="property">menuWidth</span>, <span class="comment">// 获取胶囊宽度</span></span><br><span class="line">      <span class="attr">isHome</span>: currentPage.<span class="property">route</span> === <span class="string">&quot;pages/index/index&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 组件的方法列表 */</span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">goHome</span>(<span class="params"></span>)&#123;</span><br><span class="line">    wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>:<span class="string">&quot;pages/index/inedx&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">goBack</span>(<span class="params"></span>)&#123;</span><br><span class="line">    wx.<span class="title function_">navigateBack</span>(&#123;</span><br><span class="line">      <span class="attr">delta</span>: <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>保证了导航栏的文本必定居中</li>
<li>保证了当出现安全区域与页面主体颜色不同时可以更改</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>导航栏</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-代码优化方式</title>
    <url>/2024/11/04/WeChatMini/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="三目运算场景-、-、-—-ES11"><a href="#三目运算场景-、-、-—-ES11" class="headerlink" title="三目运算场景(||、&amp;&amp;、??) — ES11"></a>三目运算场景(||、&amp;&amp;、??) — ES11</h2><h3 id="逻辑或操作符"><a href="#逻辑或操作符" class="headerlink" title="逻辑或操作符 ||:"></a>逻辑或操作符 ||:</h3><ul>
<li>含义：判断问号左边是否有值，即会使用Boolean将左边进行转化，<span class="key_words">『若为true，返回左值，若为false，返回右值』</span></li>
<li>原语句：leftData ? leftData : rightData</li>
<li>简化：leftData || rightData</li>
<li>适合场景：isClick ? ‘’ : ‘hidden’</li>
</ul>
<h3 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符 &amp;&amp;:"></a>空值合并运算符 &amp;&amp;:</h3><ul>
<li>含义：判断问号左边是否有值，即会使用Boolean将左边进行转化，<span class="key_words">『若为false，返回左值，若为true，返回右值』</span></li>
<li>原语句：leftData ? rightData : leftData</li>
<li>简化：leftData &amp;&amp; rightData</li>
</ul>
<h3 id="空值合并操作符"><a href="#空值合并操作符" class="headerlink" title="空值合并操作符 ??:"></a>空值合并操作符 ??:</h3><ul>
<li>含义：ES2020 新增，当左侧的操作数为 null 或者 undefined时，返回其右侧操作数，否则返回左侧操作数</li>
<li>关键：<span class="key_words">『只要leftData不为undefined或null 就返回leftData』</span></li>
<li>原语句：leftData !&#x3D;&#x3D; null &amp;&amp; leftData !&#x3D;&#x3D; undefined ? leftData : rightData</li>
<li>简化：leftData ?? rightData</li>
</ul>
<h2 id="逻辑运算符和赋值表达式-，-，-ES12"><a href="#逻辑运算符和赋值表达式-，-，-ES12" class="headerlink" title="逻辑运算符和赋值表达式(&amp;&amp;&#x3D;，||&#x3D;，??&#x3D;) ES12"></a>逻辑运算符和赋值表达式(&amp;&amp;&#x3D;，||&#x3D;，??&#x3D;) <span class="desc">ES12</span></h2><h3 id=""><a href="#" class="headerlink" title="&amp;&amp;&#x3D;"></a>&amp;&amp;&#x3D;</h3><ul>
<li>含义：x &amp;&amp;&#x3D; y 等价于 x &amp;&amp;(x&#x3D;y): 意思是<span class="key_words">『当 x 为 true 时，x &#x3D; y』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a &amp;&amp;= <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">b &amp;&amp;= <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="-1"><a href="#-1" class="headerlink" title="||&#x3D;"></a>||&#x3D;</h3><ul>
<li>含义： x ||&#x3D; y 等价于 x || (x &#x3D; y)：意思是<span class="key_words">『当 x 为 false 的时，x &#x3D; y』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">duration</span>: <span class="number">50</span>, <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="property">duration</span> ||= <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">duration</span>);  <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">title</span> ||= <span class="string">&#x27;title is empty.&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">title</span>);  <span class="comment">// &quot;title is empty&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="-2"><a href="#-2" class="headerlink" title="??&#x3D;"></a>??&#x3D;</h3><ul>
<li>含义：x ??&#x3D; y 等价于 x ?? (x &#x3D; y)：意思是<span class="key_words">『当 x 为 null 或 undefined 的时，x &#x3D; y』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">duration</span>: <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="property">duration</span> ??= <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">duration</span>);  <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">speed</span> ??= <span class="number">25</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">speed</span>);  <span class="comment">// 25</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="代码优化方式"><a href="#代码优化方式" class="headerlink" title="代码优化方式"></a>代码优化方式</h2><h3 id="场景一：页面使用复杂的表达式，可以在函数中返回结果，直接调用函数"><a href="#场景一：页面使用复杂的表达式，可以在函数中返回结果，直接调用函数" class="headerlink" title="场景一：页面使用复杂的表达式，可以在函数中返回结果，直接调用函数"></a>场景一：页面使用复杂的表达式，可以在函数中返回结果，直接调用函数</h3><ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">disabled</span>: !a &amp;&amp; b &amp;&amp; c &amp;&amp; d</span><br></pre></td></tr></table></figure></li>
<li>解决： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">disabled</span>: isDisabled</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isDisabled</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> !a &amp;&amp; b &amp;&amp; c &amp;&amp; d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="场景二：页面存在重复节点，一般存在表单页面"><a href="#场景二：页面存在重复节点，一般存在表单页面" class="headerlink" title="场景二：页面存在重复节点，一般存在表单页面"></a>场景二：页面存在重复节点，一般存在表单页面</h3><ul>
<li>解决：将数据存在数组中，遍历出来</li>
</ul>
<h3 id="场景三：if-else-switch-要校验，表单"><a href="#场景三：if-else-switch-要校验，表单" class="headerlink" title="场景三：if else switch + 要校验，表单"></a>场景三：if else switch + 要校验，表单</h3><ul>
<li>将提示信息，校验的key值，和是否必填(可以通过ts的类型校验忽略或排除)写成一个数组对象</li>
<li>通过判断这个key对应的value的布尔类型时候为undefined，是就提示并返回</li>
<li>注意点： <ul>
<li><span class="key_words">数组一存放key和value的数组对象，数组二存放要检验的key和提示信息』</span></li>
<li><span class="key_words">这个校验方式是按顺序的，所以数组的顺序要和页面的表单顺序一致』</span></li>
</ul>
</li>
</ul>
<h3 id="场景三：从后端获取参数存进对象中，但有几个数据要单独处理"><a href="#场景三：从后端获取参数存进对象中，但有几个数据要单独处理" class="headerlink" title="场景三：从后端获取参数存进对象中，但有几个数据要单独处理"></a>场景三：从后端获取参数存进对象中，但有几个数据要单独处理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123;&#125;</span><br><span class="line">params.<span class="property">id</span> = <span class="variable language_">this</span>.<span class="property">formItem</span>.<span class="property">id</span></span><br><span class="line">params.<span class="property">time</span> = <span class="variable language_">this</span>.<span class="property">formItem</span>.<span class="property">time</span>.<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>)</span><br><span class="line">...次数省略多个重复代码</span><br></pre></td></tr></table></figure>
<ul>
<li>解决：使用解构，不处理的直接存，处理的拎出来处理<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;time,...params&#125; = <span class="variable language_">this</span>.<span class="property">formItem</span>   <span class="comment">// 这里输出params就可以得到params对象</span></span><br><span class="line">params.<span class="property">time</span> = <span class="variable language_">this</span>.<span class="property">formItem</span>.<span class="property">time</span>.<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="场景四：常量使用枚举保存好"><a href="#场景四：常量使用枚举保存好" class="headerlink" title="场景四：常量使用枚举保存好"></a>场景四：常量使用枚举保存好</h3><h3 id="场景五：css用BEM命名法"><a href="#场景五：css用BEM命名法" class="headerlink" title="场景五：css用BEM命名法"></a>场景五：css用BEM命名法</h3><ul>
<li><a href="https://www.infoq.cn/article/vfnfwdle0zmga9psvbug">BEM命名法</a></li>
</ul>
<h3 id="场景六：switch-比-if-else在-执行效率高"><a href="#场景六：switch-比-if-else在-执行效率高" class="headerlink" title="场景六：switch 比 if&#x2F;else在 执行效率高"></a>场景六：switch 比 if&#x2F;else在 执行效率高</h3><h3 id="场景七：优化switch"><a href="#场景七：优化switch" class="headerlink" title="场景七：优化switch"></a>场景七：优化switch</h3><blockquote>
<p>策略模式：简单理解一个函数对应一个方法</p>
</blockquote>
<ul>
<li>解决：使用对象存储，然后在函数中返回</li>
<li>本质：在工厂函数中使用策略模式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">weekFun</span> = (<span class="params">opt: number</span>) =&gt; &#123;</span><br><span class="line">	<span class="comment">// 使用对象字面量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="attr">status</span>: <span class="title class_">Record</span>&lt;number, string&gt; = &#123;</span><br><span class="line">		<span class="number">0</span>: <span class="string">&#x27;周日&#x27;</span>,  <span class="comment">// value可以是函数</span></span><br><span class="line">		<span class="number">1</span>: <span class="string">&#x27;周一&#x27;</span>,</span><br><span class="line">		<span class="number">2</span>: <span class="string">&#x27;周二&#x27;</span>,</span><br><span class="line">		<span class="number">3</span>: <span class="string">&#x27;周三&#x27;</span>,</span><br><span class="line">		<span class="number">4</span>: <span class="string">&#x27;周四&#x27;</span>,</span><br><span class="line">		<span class="number">5</span>: <span class="string">&#x27;周五&#x27;</span>,</span><br><span class="line">		<span class="number">6</span>: <span class="string">&#x27;周六&#x27;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> status[opt] ?? <span class="string">&#x27;weekFun is not get useful num&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="场景八：优化if-else代码块"><a href="#场景八：优化if-else代码块" class="headerlink" title="场景八：优化if&#x2F;else代码块"></a>场景八：优化if&#x2F;else代码块</h3><ul>
<li>Map写法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> opt = &#123;</span><br><span class="line">	<span class="number">0</span>: <span class="string">&quot;add&quot;</span>,</span><br><span class="line">	<span class="number">1</span>: <span class="string">&quot;even&quot;</span>,</span><br><span class="line">	<span class="number">2</span>: <span class="string">&quot;divided&quot;</span>,</span><br><span class="line">	<span class="number">3</span>: <span class="string">&quot;multi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line"> [<span class="string">&quot;add&quot;</span>, <span class="string">&quot;成功,444444444444&quot;</span>],</span><br><span class="line"> [<span class="string">&quot;even&quot;</span>, <span class="string">&quot;失败,44444444&quot;</span>],</span><br><span class="line"> [<span class="string">&quot;divided&quot;</span>, <span class="string">&quot;进行中,11111111&quot;</span>],</span><br><span class="line"> [<span class="string">&quot;multi&quot;</span>, <span class="string">&quot;未开始&quot;</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">actions.<span class="title function_">get</span>(opt[<span class="number">0</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(actions.<span class="title function_">get</span>(opt[<span class="number">0</span>])) <span class="comment">// &quot;成功,444444444444&quot; </span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-复杂组件的应用</title>
    <url>/2024/11/04/WeChatMini/%E5%A4%8D%E6%9D%82%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="复杂组件—日历组件的多页面不同应用解决方案"><a href="#复杂组件—日历组件的多页面不同应用解决方案" class="headerlink" title="复杂组件—日历组件的多页面不同应用解决方案"></a>复杂组件—日历组件的多页面不同应用解决方案</h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><ul>
<li>已经封装完的日历组件且已经应用与多个页面(此时仅有一套组件方案)</li>
</ul>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li>该日历组件要应用与其它页面(两个)但展示的效果和功能与原方案不同</li>
</ul>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><ul>
<li>应用该组件新方案的两个页面之间,一个需要初始化数据,一个不需要,存在冲突</li>
</ul>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点:"></a>难点:</h3><ol>
<li>原来的日历组件使用的formatter,与现在页面使用的formatter不同</li>
<li>选择的文字字段展示与原先不同</li>
<li>可选择日期,选择之后不能在选择同一天(不可重叠)</li>
<li>选择预约页面:一开始空,打开后点击任意日期,没有点击确定时,关闭弹窗,在打开弹窗后,原先选中的数据要保留,选中的那天日期,选中文本,上下午状态和确定按钮,都要保留被选中的状态,和可以确定的状态</li>
<li>更改预约页面的弹窗: 一打开为预约的那个时间(不管当天且上下午状态是否已经约满),状态都为选中的状态,点击其它可选择日期,原先的预约时间约满的禁止不可选</li>
<li>点击更改预约时间后,在点击其它时间,不确定,关掉弹窗,在点击弹窗,状态应默认为对应预约时间的选择状态</li>
</ol>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决:"></a>解决:</h3><ul>
<li>保险起见可以先把原formatter存起来,然后写新formatter,确保满足需求后把新formatter存起来,然后还原旧formatter</li>
<li>新formatter在页面中,通过组件传值的方式传给组件</li>
<li>组件初始化时通过this.data判断是否存在formatter(formatter类型为null)</li>
<li>页面中通过按钮状态判断并传递给组件</li>
<li>组件要判断字段是否存在,以此添加到原来的选择文本字段(原来 +&#x3D; 新的), 需要监听文本字段的变化,日期不变</li>
<li>在组件处理选择日期的函数中判断,如果是同一天就返回<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> calendarComponent = <span class="variable language_">this</span>.<span class="title function_">selectComponent</span>(<span class="string">&#x27;#calendar&#x27;</span>)</span><br><span class="line">calendarComponent.<span class="title function_">reset</span>() <span class="comment">// 重置日历组件</span></span><br></pre></td></tr></table></figure></li>
<li>在组件关闭弹窗处,不能初始化数据,再点开时要把需要拿到的状态获取到</li>
<li>在组件properties中的初始化时间函数要监听数据,重新获取已经处理的文本字段,日期仍然时预约那天(date)</li>
</ul>
<h2 id="checkbox样式问题"><a href="#checkbox样式问题" class="headerlink" title="checkbox样式问题"></a>checkbox样式问题</h2><p><img src="/../../img/WeChatMini/btn%E6%A0%B7%E5%BC%8F1.png" alt="btn样式"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>当伪类的三角形随着机型,位置浮动时,可在checkbox那添加overflow:hiddden</p>
<h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checkbox</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;checkbox &#123;&#123; isCheckAm &amp;&amp; isAm === amType.MORNING ? &#x27;is_checked_am&#x27; : &#x27;&#x27; &#125;&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; isAm === amType.MORNING &#125;&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">mark:isAm</span>=<span class="string">&quot;&#123;&#123; amType.MORNING &#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-checkgou tick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;car-subscribe-form-grid-view-daybtn&quot;</span>&gt;</span>上午<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">checkbox &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">200</span>rpx;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">88</span>rpx;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">4</span>rpx;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2</span>rpx solid <span class="built_in">var</span>(--border-line-color);</span><br><span class="line">	<span class="attribute">margin-top</span>: <span class="number">24</span>rpx;</span><br><span class="line">	<span class="attribute">color</span>: <span class="built_in">var</span>(--text-<span class="number">1</span>-color);</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">var</span>(--white);</span><br><span class="line">&#125;</span><br><span class="line">checkbox<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>rpx;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">60</span>rpx solid <span class="built_in">var</span>(--border-line-color);</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">60</span>rpx solid transparent;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">47</span>rpx;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">30</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line">checkbox<span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">22</span>rpx;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">40</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line">checkbox <span class="selector-class">.wx-checkbox-input</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">checkbox <span class="selector-class">.wx-checkbox-input</span><span class="selector-class">.wx-checkbox-input-checked</span> &#123;</span><br><span class="line">  <span class="comment">/* checkbox 被选中后前面选项框的背景样式 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">checkbox <span class="selector-class">.wx-checkbox-input</span><span class="selector-class">.wx-checkbox-input-checked</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>rpx;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.is_checked_am</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2</span>rpx solid <span class="built_in">var</span>(--primary-color) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.is_checked_am</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>rpx;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">60</span>rpx solid <span class="built_in">var</span>(--primary-color);</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">60</span>rpx solid transparent;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">47</span>rpx;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">30</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.icon-checkgou</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">157</span>rpx;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">100</span>rpx;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tick</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">56</span>rpx <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.car-subscribe-form-grid-view-daybtn</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">20</span>rpx;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">24</span>rpx;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">160</span>rpx;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">26</span>rpx;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="calendar的reset"><a href="#calendar的reset" class="headerlink" title="calendar的reset()"></a>calendar的reset()</h2><p>选中日历的某个日期，重置选中的日期到默认值</p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>checkbox样式修改</tag>
        <tag>问题与方案</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-富文本</title>
    <url>/2024/11/04/WeChatMini/%E5%AF%8C%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>使用已封装好的<a href="https://gitee.com/jin-yufeng/mp-html/#/overview/quickstart">mp-html 组件</a>,方便处理图片、视频，便于高效地开发</li>
<li>在要使用的页面的 json 文件中引入该组件</li>
<li>在 wxml 文件中使用，id 作为标识该组件的唯一标识， content 则是将 html 代码渲染出来的容器</li>
<li>使用 selectComponent(‘id’)获取组件实例</li>
<li>如果要处理富文本的而其中一个标签则需要有匹配规则</li>
<li>获取单个标签的，然后统一处理，在然后再替换回原来的 html 中</li>
</ol>
<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><ul>
<li>图片的匹配规则： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">\/&lt;(img)[^&gt;]*&gt;/gi</span><br></pre></td></tr></table></figure></li>
<li>匹配标签之间的文本: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(?&lt;=&gt;)[^&gt;]+(?=&lt;[\/]?\w+.*&gt;)/g</span><br></pre></td></tr></table></figure></li>
<li>视频的匹配规则: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/&lt;(video)[^&gt;]*&gt;/gi</span><br></pre></td></tr></table></figure></li>
<li>空字符串的匹配规则: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(\s)/g</span><br></pre></td></tr></table></figure></li>
<li>过滤并做替换处理:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(html.<span class="title function_">match</span>(reg) <span class="keyword">as</span> <span class="title class_">RegExpMatchArray</span>).<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="string">&#x27;,&#x27;</span> , <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>遍历实例上的图片数组&#x2F;视频数组，进行处理:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.<span class="property">imgList</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">src: string, i: number ,array: any </span>) =&gt;</span> &#123;</span><br><span class="line">  array[i] = src.<span class="title function_">replace</span>(<span class="string">&#x27;thumb&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="文字换行"><a href="#文字换行" class="headerlink" title="文字换行"></a>文字换行</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> statuslist = _buyCarList.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//有逗号分隔的情况</span></span><br><span class="line">  <span class="keyword">return</span> item.<span class="property">status</span>.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">	<span class="comment">//无逗号分隔的情况</span></span><br><span class="line">  <span class="comment">// if (item.status.length &gt; 5) &#123;</span></span><br><span class="line">  <span class="comment">//   const status1 = item.status.slice(0, 3)</span></span><br><span class="line">  <span class="comment">//   const status2 = item.status.slice(3)</span></span><br><span class="line">  <span class="comment">//   const status = status1.concat(&#x27;,&#x27;, status2).split(&#x27;,&#x27;)</span></span><br><span class="line">  <span class="comment">//   return status</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// return [item.status]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="去掉字符串文本的空格"><a href="#去掉字符串文本的空格" class="headerlink" title="去掉字符串文本的空格"></a>去掉字符串文本的空格</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/(\s)/g</span></span><br><span class="line"><span class="keyword">let</span> title = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (carModelName) &#123;</span><br><span class="line">  title = (carModelName).<span class="title function_">replaceAll</span>(reg, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>富文本</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-小程序优化 | 学习笔记</title>
    <url>/2024/11/04/WeChatMini/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>小程序运行进程及运行环境的准备</li>
<li>代码包下载、校验及初始化</li>
<li>视图层系统组件、webview容器和原生组件的初始化</li>
<li>逻辑层JS引擎初始化及域创建</li>
</ul>
<h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><ul>
<li>框架及第三方基础代码的初始化 — <span class="desc">小程序基础库、扩展库、插件，自定义组件</span></li>
<li>开发者代码注入<ul>
<li>开发者逻辑层代码 — <span class="desc">派发App.onLaunch还有App.onShow这些事件</span></li>
<li>开发者视图层代码 — <span class="desc">公共代码以及页面代码的注入</span></li>
</ul>
</li>
</ul>
<h3 id="首屏渲染"><a href="#首屏渲染" class="headerlink" title="首屏渲染"></a>首屏渲染</h3><ul>
<li>逻辑层页面的初始化，这个时间点是initDataSendTime的一个触发时机，会派发Page.onLoad事件</li>
<li>视图层时间点走到viewLayerReaderStartTime，会派发Page.onShow事件</li>
<li>开发者代码从后端拉取数据，准备data数据</li>
<li>页面的整体的渲染</li>
<li>视图层时间点走到viewLayerReaderEndTime，会派发Page.onReady事件，标志着首屏渲染的完成</li>
</ul>
<h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><h3 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h3><ul>
<li>用户设备上第一次打开或销毁后再打开小程序，进入后台<span class="key_words">『30分钟以后』</span>再次进入前台冷启动</li>
</ul>
<h3 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h3><ul>
<li>小程序启动的一种优化机制，小程序进入后台<span class="key_words">『30分钟以内』</span>再次进入前台，可以直接从后台状态然后恢复到前台，前面的启动流程都不会执行</li>
</ul>
<h2 id="小程序性能的优化"><a href="#小程序性能的优化" class="headerlink" title="小程序性能的优化"></a>小程序性能的优化</h2><h3 id="冷启动性能的优化"><a href="#冷启动性能的优化" class="headerlink" title="冷启动性能的优化"></a>冷启动性能的优化</h3><h4 id="涉及的生命周期函数"><a href="#涉及的生命周期函数" class="headerlink" title="涉及的生命周期函数"></a>涉及的生命周期函数</h4><ul>
<li>App.onLaunch: 监听小程序初始化 — <span class="desc">启动流程，一次性</span></li>
<li>App.onHide：监听小程序切后台 — <span class="desc">运行时性能</span></li>
<li>App.onShow：监听小程序启动或切前台 — <span class="desc">视图显示时派发，重复派发与启动流程相关的事件,运行时性能</span></li>
</ul>
<h4 id="涉及的页面生命周期函数"><a href="#涉及的页面生命周期函数" class="headerlink" title="涉及的页面生命周期函数"></a>涉及的页面生命周期函数</h4><ul>
<li>Page.onLoad：监听页面加载 — <span class="desc">启动流程，一次性</span></li>
<li>Page.onShow：监听页面显示 — <span class="desc">视图显示时派发，重复派发与启动流程优化相关的一次性事件</span></li>
<li>Page.onHide：监听页面隐藏 — <span class="desc">运行时性能</span></li>
<li>Page.onReady：监听页面初次渲染完成 — <span class="desc">启动流程，一次性</span></li>
<li>Page.onUnload：监听页面卸载 — <span class="desc">运行时性能</span></li>
</ul>
<h4 id="顺着整个过程和涉及的生命周期函数的可优化节点"><a href="#顺着整个过程和涉及的生命周期函数的可优化节点" class="headerlink" title="顺着整个过程和涉及的生命周期函数的可优化节点"></a>顺着整个过程和涉及的生命周期函数的可优化节点</h4><ul>
<li>环境准备阶段、拉取小程序基本信息阶段 — <span class="desc">拉取信息是同步(用户使用越多启动性能越好，提高轮询机制的命中率)</span></li>
<li>紧跟小程序基础库更新 — <span class="desc">提高预加载环境的命中率</span></li>
<li>代码注入阶段 — <span class="desc">减少代码的注入量和复杂度，以期减少启动时间</span></li>
<li>合适的生命周期函数节点 — <span class="desc">首屏渲染要从后端拉取数据并在首页进行渲染时，使用异步转同步的编程范式以及使用并发复合命令，在多个文件里边对齐这个代码的执行点</span></li>
<li>Page.onReady时间派发、首屏渲染完成阶段 — <span class="desc">使用动态数据加载的，使用骨架屏技巧、压缩图片、提高服务器接口响应效率和数据传输效率</span></li>
<li>数据预拉去和周期性更新机制 — <span class="desc">微信提供了数据预加载周期性更新机制</span></li>
<li>低端机首次渲染需要较长时间的情况下 — <span class="desc">微信提供了初始渲染缓存机制</span></li>
</ul>
<h3 id="运行时渲染性能的优化"><a href="#运行时渲染性能的优化" class="headerlink" title="运行时渲染性能的优化"></a>运行时渲染性能的优化</h3><h4 id="双线程运行机制"><a href="#双线程运行机制" class="headerlink" title="双线程运行机制"></a>双线程运行机制</h4><ul>
<li>微信小程序可以看作是由逻辑层、视图层两个线程协同完成运行的</li>
<li><span class="key_words">『逻辑层负责执行JS代码，视图层负责渲染UI页面。』</span>逻辑层与视图层之间的事件触发以及数据传递，即<span class="key_words">『setData方法的调用全是由底层的Native层负责中转完成的』</span>。</li>
<li><span class="key_words">『setData函数用于更新视图数据』</span>，按照微信小程序的性能评判标准，setData每次传递的数据大小不能超过256KB，超过这个限制页面就容易卡顿。在页面或者是列表组件scroll事件里面，频繁地调用setData,视图层来不及渲染也会出现明显的卡顿现象。</li>
</ul>
<h4 id="冷启动时以及运行时可以使用的性能优化技巧"><a href="#冷启动时以及运行时可以使用的性能优化技巧" class="headerlink" title="冷启动时以及运行时可以使用的性能优化技巧"></a>冷启动时以及运行时可以使用的性能优化技巧</h4><ul>
<li>使用WXS脚本，在视图层完成事件处理</li>
<li>重渲染机制</li>
<li>支持WXWebAssembly</li>
<li>允许开发者另开Worker线程 — <span class="desc">针对JS是单线程执行</span></li>
<li>分页渲染、使用虚拟DOM — <span class="desc">针对长列表页面setData单次传递的数据不能超过256KB限制</span></li>
<li>使用LocalStorange接口数据缓存于本地 — <span class="desc">针对每次拉取动态数据需要时间</span></li>
<li>5s的“挂起”状态 — <span class="desc">进入后台后有5秒挂起状态，在这种状态下setData没有必要执行</span></li>
<li>启用Http2、Quic协议 — <span class="desc">与后台进行数据交互的时候可以启用Http2 Quic等协议</span></li>
<li>getCurrentPages()接口 — <span class="desc">在page.Unload中将定时器以及wx.onxx的全局监听和与全局对象有关的事件监听全部移除</span></li>
<li>原生的Context节点 — <span class="desc">原生组件，可以通过SelectorQuery查询到这个原生节点，然后再利用这个原生节点直接操作和更新视图</span></li>
<li>本地图片上传到云</li>
</ul>
<h2 id="骨架屏"><a href="#骨架屏" class="headerlink" title="骨架屏"></a>骨架屏</h2><ul>
<li>优缺点：<span class="key_words">『不能使首屏渲染加快』</span>，但在白屏时给用户提供反馈，<span class="key_words">『减缓用户焦虑』</span>等待的情绪</li>
<li>在data中默认设置loading:true，在数据加载完成后设置loading:false，在页面中可以通过wx:if 和 wx:else来避免数据先加载出来导致和骨架屏页面<span class="key_words">『重叠』</span></li>
<li>不要直接修改生成的骨架屏代码<ul>
<li>修改配置以后要重新生成骨架屏代码，wxml或js代码后续有修改也要重新生成骨架屏</li>
</ul>
</li>
<li>骨架屏只给主页使用</li>
</ul>
<h2 id="使用虚拟DOM，优化长列表内容"><a href="#使用虚拟DOM，优化长列表内容" class="headerlink" title="使用虚拟DOM，优化长列表内容"></a>使用虚拟DOM，优化长列表内容</h2><ul>
<li>使用recycle-view组件(平台能力-&gt;扩展能力-&gt;扩展组件)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save miniprogram-recycle-view</span><br></pre></td></tr></table></figure></li>
<li>安装完成后，构建npm</li>
<li>在页面的json文件中将recycle-view和recycle-item引用到usingComponent</li>
<li>很好的实现了虚拟DMOM</li>
<li>结合滚动事件scrolltolower，还可以实现逐页加载与更新列表数据</li>
<li>本身已经<span class="key_words">『默认开启throttle函数』</span>节流机制</li>
<li>预留了插槽，方便开发者添加个性业务</li>
</ul>
<h2 id="页面容器page-container"><a href="#页面容器page-container" class="headerlink" title="页面容器page-container"></a>页面容器page-container</h2><ul>
<li>做弹窗</li>
</ul>
<h2 id="优化视图页动画效果"><a href="#优化视图页动画效果" class="headerlink" title="优化视图页动画效果"></a>优化视图页动画效果</h2><ul>
<li>使用Animation对象实现的CSS动画 — <span class="desc">效率最低</span></li>
<li>使用页面或组件对象拥有的animate，实现<span class="key_words">『关键帧』</span>动画 — <span class="desc">第一推荐,效率非最高</span></li>
<li>滚动事件驱动的响应式动画 — <span class="desc">推荐的低成本创建响应式页面效果的方式</span><ul>
<li><span class="key_words">『本质上响应式动画也是通过animation接口实现的』</span></li>
<li>依据scroller这个组件的滚动而变化</li>
<li>通过wx.createSelectorQuery().select(‘#id’).fields()去查询scroller组件</li>
<li>然后再回调里面调用animate去设置它的对象，然后再onReady中调用</li>
</ul>
</li>
<li>通过WXS脚本实现的样式动画 —  <span class="desc">效率最高，适用高频动画，但目前只支持es5</span><ul>
<li>由.wxs脚本实现，事件绑定再一个WXS脚本导出的事件句柄函数</li>
<li>通过<span class="key_words">『事件句柄函数的ownerInstance』</span>调用的selectAllComponents或者selectComponent去查询页面上的组件，查询后通过setStyle设置组件的样式</li>
</ul>
</li>
</ul>
<h2 id="重渲染与自定义组件优化"><a href="#重渲染与自定义组件优化" class="headerlink" title="重渲染与自定义组件优化"></a>重渲染与自定义组件优化</h2><blockquote>
<p>重渲染： 使用新的节点树，有目标地将原节点树上需要更新的节点一一更新的过程</p>
</blockquote>
<ul>
<li>将界面功能组件化 — <span class="desc">频繁改动的功能</span></li>
<li>去掉不必要的数据设置，减少每次setData设置的数据量</li>
<li>通过wxs脚本改写组件，可以在视图层完成的代码逻辑<ul>
<li>wxml增加了wxs模块的引入，并且在view中添加,wxs脚本中通过函数判断mode来调用对应模式的函数或代码<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">change</span>:mode=<span class="string">&quot;&#123;&#123;index.modeObserver&#125;&#125;&quot;</span> mode=<span class="string">&quot;&#123;&#123;mode&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>使用page.requestAnimationFrame()可以防止跟不上渲染造成卡顿</li>
</ul>
</li>
</ul>
<h2 id="代码按需注入与初始渲染缓存"><a href="#代码按需注入与初始渲染缓存" class="headerlink" title="代码按需注入与初始渲染缓存"></a>代码按需注入与初始渲染缓存</h2><ul>
<li>按需注入<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;lazyCodeLoading&quot;</span>: <span class="string">&quot;requiredComponents&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>使视图层不需要等待逻辑层初始化完毕<ul>
<li>参数：static 静态初始渲染缓存 | dynamic 动态缓存<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;initialRenderingCache&quot;</span>:<span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="comment">// 设置需要动态缓存的数据</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setInitialRenderingCache</span>(&#123;<span class="attr">swiperlist</span>: swipers&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>静态导航页用初始渲染缓存，动态详情页用骨架屏</li>
</ul>
<h2 id="使用独立分包和分包预加载"><a href="#使用独立分包和分包预加载" class="headerlink" title="使用独立分包和分包预加载"></a>使用独立分包和分包预加载</h2><ul>
<li>指定tarbar默认选中那个索引<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">selectComponent</span>(<span class="string">&#x27;#id&#x27;</span>).<span class="title function_">select</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>tarbar最好使用自定的组件</li>
<li>独立分包<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">getApp(<span class="punctuation">&#123;</span>allowDefault <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span>)</span><br><span class="line"><span class="attr">&quot;preloadRule&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;页面路径&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;nrework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;packages&quot;</span><span class="punctuation">:</span> <span class="string">&quot;__APP__&quot;</span> <span class="comment">//代表主包</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="独立分包使用占位组件-—-分包异步化"><a href="#独立分包使用占位组件-—-分包异步化" class="headerlink" title="独立分包使用占位组件 — 分包异步化"></a>独立分包使用占位组件 — 分包异步化</h2><ul>
<li>前提项目已经启用懒加载机制，代码是按需加载注入的，使用占位组件，给自定义组件安排一个替身，在真实的自定义组件加载并注入之前先用替身展示，进一步优化启动的性能</li>
</ul>
<h3 id="组件的分包异步化及主页中占位组件的使用"><a href="#组件的分包异步化及主页中占位组件的使用" class="headerlink" title="组件的分包异步化及主页中占位组件的使用"></a>组件的分包异步化及主页中占位组件的使用</h3><ul>
<li>将首页使用的所有自定义组件移动到分包中，然后再使用占位组件延迟加载它们</li>
<li>app.json创建组件分包,可以没有页面，把组件放在该分包中</li>
<li>修改主页配置，将组件由全局用用改为页面引用，并进行占位的组件声明，</li>
<li>在页面的componentPlaceholder选项下设置组件替身{“原组件名”：”自定义组件|标准组件view”}， 使用自定义组件的话要先引入，然后使用自定义组件名即可</li>
</ul>
<h3 id="使用封面页"><a href="#使用封面页" class="headerlink" title="使用封面页"></a>使用封面页</h3><ul>
<li>创建一个空白效果的页面，作为伪首页只放一个logo和名称，在onReady中添加跳转到真首页代码，作用加载主包中的所有基础内容，加载完成后跳转真首页</li>
<li>封面页位于主包内，真首页移到分包中，同时preloadRule开启最该分包的预加载</li>
<li><span class="key_words">『非独立分包中的页面被访问时主包同时也会被下载，但其他普通分包不会被下载。』</span></li>
<li><span class="key_words">『独立分包它并不加载主包，放在主包里边的共享代码，在独立分包里无法直接使用』</span></li>
</ul>
<h2 id="JS代码的分包异步化"><a href="#JS代码的分包异步化" class="headerlink" title="JS代码的分包异步化"></a>JS代码的分包异步化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="title function_">async</span> () =&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">default</span>:getNavList&#125; = <span class="keyword">await</span> <span class="built_in">require</span>.<span class="title function_">async</span>(<span class="string">&quot;../相对路径&quot;</span>)&#125;)&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">default</span>:getNavList&#125; = <span class="keyword">await</span> getApp.<span class="title function_">requireAsync</span>(<span class="string">&quot;/绝对地址&quot;</span>)&#125;)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在app.js文件中定义两个支持绝对路径的方法，代替默认的require以及require.async(少用)</li>
</ul>
<h3 id="项目插件化"><a href="#项目插件化" class="headerlink" title="项目插件化"></a>项目插件化</h3><ul>
<li>在插件模式下，静态依赖分析工作不了</li>
<li>使用插件模式，创建plugin目录，在app.json中给使用的分包配置plugin选项，在app.json中添加pluginRoot选项，配置plugin的放置位置</li>
<li>在onReady中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">requirePlugin</span>(<span class="string">&#x27;myPlugin&#x27;</span>,<span class="function"><span class="params">plugin</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">或 </span><br><span class="line">requirePlugin.<span class="title function_">async</span>(<span class="string">&quot;myPlugin&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">plugin</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>使用立即执行函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="title function_">requirePlugin</span>(<span class="string">&#x27;myPlugin&#x27;</span>,<span class="function"><span class="params">plugin</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  <span class="comment">// 或 let plugin = await requirePlugin.async(&quot;myPlugin&quot;).catch()</span></span><br><span class="line">&#125;)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用WXWebAssembly优化运算性能"><a href="#使用WXWebAssembly优化运算性能" class="headerlink" title="使用WXWebAssembly优化运算性能"></a>使用WXWebAssembly优化运算性能</h2><blockquote>
<p>允许开发者使用Go、C、C++等后端强类型语言编写代码，然后将其编译为一种类似于汇编代码的二进制代码，弥补解析新语言JS在执行性能上的不足</p>
</blockquote>
<ul>
<li>编写go语言 –&gt; 编译压缩为wasm文件 –&gt; 从Go语言源码里面拷贝并且修改wasm_exec.js文件(必不可少),同时也需要一个text_encoder.js文件</li>
<li>在项目的根目录创建一个目录，放置Go语言代码（<span class="desc">Go版本和文件想对应，所以版本安装要谨慎&lt;&#x2F;span）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">关闭环境变量: go env -w <span class="title class_">GO111MODULE</span>=off</span><br><span class="line">调用: ./build.<span class="property">sh</span> (<span class="title class_">GO111MODULE</span>=off <span class="variable constant_">GOOS</span>-js <span class="variable constant_">GOARCH</span>=wasm go build -o 编译后的名字.<span class="property">wasm</span> 编译的文件.<span class="property">go</span>)</span><br><span class="line">安装: brew install brotli </span><br><span class="line">目标位置删除: rm -f 目标路径/xx.<span class="property">wasm</span>.<span class="property">br</span>,</span><br><span class="line">压缩文件: brotli -o 文件的位置/xxx.<span class="property">wasm</span>.<span class="property">br</span> xxx.<span class="property">wasm</span></span><br></pre></td></tr></table></figure></li>
<li>将相关的js文件、wasm文件全部拷贝至对应的目录，并在次目录下依照原组件的代码，创建新组件</li>
</ul>
<h2 id="使用异步转同步的编程范式"><a href="#使用异步转同步的编程范式" class="headerlink" title="使用异步转同步的编程范式"></a>使用异步转同步的编程范式</h2><blockquote>
<p>异步编程： 除了主线程以外还有一个或者多个异步线程，异步线程处理worker timer定时器、网络请求、用户输入监听、事件派发等任务,<span class="key_words">『当异步线程有回调函数代码需要执行的时候，异步代码将这些代码推入到主线程的执行队列里面去，由主线程在不是很忙碌的时候尽快将这些代码进行执行。』</span></p>
</blockquote>
<ul>
<li>编写异步转同步函数:promisify替代request，文件放在公共的位置</li>
<li>require不支持绝对路径，但在app.js文件中可以使用绝对路径<ul>
<li>全局的全部示例app可以通过getApp()取到，app.js文件位于项目的根目录下方便标记</li>
<li>函数调用时为了避免程序报错，在后面一定要加上一个默认的catch设置。</li>
<li>使用promisify函数的父函数，由于添加了async关键字，已经是同步函数，要避免在主线程上以阻塞的方式，即<span class="key_words">『添加await关键字的方式调用函数』</span></li>
</ul>
</li>
</ul>
<h2 id="使用复合命令模式对齐代码的执行点"><a href="#使用复合命令模式对齐代码的执行点" class="headerlink" title="使用复合命令模式对齐代码的执行点"></a>使用复合命令模式对齐代码的执行点</h2><blockquote>
<p>复合命令模式是一个设计模式，它和异步转同步的编程范式一样主要作用在于使我们这个代码结构变得更加清晰,易于维护，其次它还可以优化代码的调用逻辑，统筹安排代码的一个执行时机。</p>
</blockquote>
<ul>
<li>在App.onLaunch事件在开始拉取动态数据，将App.onLaunch和首页的Page.onLoad这两个时间节点使用并发的复合命令模式管理起来，让它们可以并发执行</li>
</ul>
<h2 id="使用worker开启新线程进行耗时运算"><a href="#使用worker开启新线程进行耗时运算" class="headerlink" title="使用worker开启新线程进行耗时运算"></a>使用worker开启新线程进行耗时运算</h2><blockquote>
<p>worker：依托于寄主的环境而存在的，可以在后台并行执行JS代码，不影响页面渲染的技术，将worker看作异步线程，可以在异步线程中执行一些比较耗时的计算代码，在计算代码执行完成以后再将执行结果同步给主线程使用</p>
</blockquote>
<ul>
<li>创建worker线程<ul>
<li>在app.json文件中配置workers:workers”</li>
</ul>
</li>
<li>创建组件，只有js改动，在使用后主动销毁worker<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">worker</span>=wx.<span class="title function_">createWorker</span>(</span><br><span class="line">  <span class="string">&quot;目录位置&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">useExperimentalworker</span>:<span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>worker和wxs都是异步执行worker比wxs的限制<ul>
<li>不能使用wx开头的小程序接口</li>
<li>workers目录下面可以有很多的worker文件，但同时只能有一个worker线程在开启，如果想要开新的线程，需要将原来的先给停掉，销毁掉，并且如果系统资源紧张，worker线程还有可能被系统回收掉</li>
<li>worker只能放在特定的已经配置好的目录下面，不能随意地放置在其他目录下</li>
<li>通讯不方便，worker线程和主线程之间的通讯只能使用postMessage和onMessage进行相互通讯，这是相当于观察者模式的一种通讯机制</li>
</ul>
</li>
</ul>
<h2 id="在后端使用Go语言异步执行逻辑运算代码（如何将前端工作后移）"><a href="#在后端使用Go语言异步执行逻辑运算代码（如何将前端工作后移）" class="headerlink" title="在后端使用Go语言异步执行逻辑运算代码（如何将前端工作后移）"></a>在后端使用Go语言异步执行逻辑运算代码（如何将前端工作后移）</h2><ul>
<li>创建后端计算接口，存放在server目录</li>
<li>main.go 会有启动代码，在终端中使用: npm dev，要先启用go语言模块化</li>
<li>扩展接口，将go代码的要扩展的接口主要的代码和相关变量，函数拷贝的项目中要使用页面的其他代码上方</li>
<li>用curl测试api地址: curl api地址</li>
</ul>
<h2 id="使用串发命令模式延迟同步请求-如何使用数据缓存"><a href="#使用串发命令模式延迟同步请求-如何使用数据缓存" class="headerlink" title="使用串发命令模式延迟同步请求(如何使用数据缓存)"></a>使用串发命令模式延迟同步请求(如何使用数据缓存)</h2><blockquote>
<p>同步会阻塞主流线程<br>有些接口虽然名称上由Sync结尾，但实际却仍是同步接口，如wx.getSystemInfo、wx.getStorage、wx.setStorage这三个接口经常在App.onLaunch还有Page.onLoad中用到</p>
</blockquote>
<ul>
<li><h3 id="用分接口获取系统信息"><a href="#用分接口获取系统信息" class="headerlink" title="用分接口获取系统信息"></a>用分接口获取系统信息</h3><ul>
<li>wx.getSystemSetting 获取设备设置</li>
<li>wx.getAppAuthorizeSetting 获取微信APP授权设置</li>
<li>wx.getDeviceInfo 获取设备基础信息</li>
<li>wx.getWindowInfo 获取窗口信息</li>
<li>wx.getAppBaseInfo 获取微信APP基础信息</li>
</ul>
</li>
<li><h3 id="启动过程先使用默认参数，启动完成后-即Page-onReady事件派发后-再进行相关接口的调用和缓存后端接口数据的本地缓存存取代码"><a href="#启动过程先使用默认参数，启动完成后-即Page-onReady事件派发后-再进行相关接口的调用和缓存后端接口数据的本地缓存存取代码" class="headerlink" title="启动过程先使用默认参数，启动完成后(即Page.onReady事件派发后)再进行相关接口的调用和缓存后端接口数据的本地缓存存取代码"></a>启动过程先使用默认参数，启动完成后(即Page.onReady事件派发后)再进行相关接口的调用和缓存后端接口数据的本地缓存存取代码</h3></li>
<li><h3 id="创建SystemInfoManager模块，这样系统信息的获取在首屏渲染后"><a href="#创建SystemInfoManager模块，这样系统信息的获取在首屏渲染后" class="headerlink" title="创建SystemInfoManager模块，这样系统信息的获取在首屏渲染后"></a>创建SystemInfoManager模块，这样系统信息的获取在首屏渲染后</h3><ul>
<li>global.asyncRetrieveSystemInfo.getCommand(0).markComplete()允许异步拉取系统信息 </li>
<li>拉去系统信息的代码卸载onLaunch</li>
<li>分页拉取数据，默认page&#x3D;1</li>
</ul>
</li>
</ul>
<h2 id="首页动态数据的优化"><a href="#首页动态数据的优化" class="headerlink" title="首页动态数据的优化"></a>首页动态数据的优化</h2><ul>
<li>在App.onLaunch节点开始加载数据</li>
<li>只加载首页首次渲染所需的一页数据</li>
</ul>
<h2 id="小程序切换后台后，关闭对setData的一个调用（监听App进入后台）"><a href="#小程序切换后台后，关闭对setData的一个调用（监听App进入后台）" class="headerlink" title="小程序切换后台后，关闭对setData的一个调用（监听App进入后台）"></a>小程序切换后台后，关闭对setData的一个调用（监听App进入后台）</h2><ul>
<li>wx.onAppHide监听小程序进入后台事件或者 App.onHide捕捉小程序进入后台的时机</li>
<li>劫持Page对象，再page.js文件中先劫持onLoad和setData，在onLoad中获得setData的引用，然后在app.js文件里面调用page.js文件</li>
<li>定义工具函数mySetData，在原来所有调用setData的地方改为调用mySetData，<span class="desc">不建议</span></li>
<li>如果必须要发生劫持的话一定要把劫持代码同意放在程序的入口处</li>
</ul>
<h2 id="在项目外使用数据预拉取与周期性更新（弱网情况）"><a href="#在项目外使用数据预拉取与周期性更新（弱网情况）" class="headerlink" title="在项目外使用数据预拉取与周期性更新（弱网情况）"></a>在项目外使用数据预拉取与周期性更新（弱网情况）</h2><ul>
<li>数据预拉取：在小程序启动时，由微信异步调用开发者设置的原函数或数据接口，待拿到数据后，在传递给小程序使用</li>
<li>周期性更新：微信每隔12小时轮询开发者设置的云函数或数据接口，由开发者在小程序中取用</li>
<li>在微信小程序平台开启</li>
<li>使用并发复合命令的竞赛模式拉取数据<ul>
<li>wx.onBackgroundFetchData: 微信在拿到预拉取数据的时候设置一个回调函数</li>
<li>wx.getBackgroundFetchData: 主动获取微信在本地缓存的预拉取数据，本地没有则拉取失败</li>
</ul>
</li>
</ul>
<h2 id="优化后端接口及网络请求参数-wx-request"><a href="#优化后端接口及网络请求参数-wx-request" class="headerlink" title="优化后端接口及网络请求参数(wx.request)"></a>优化后端接口及网络请求参数(wx.request)</h2><ul>
<li>enableCache，开启cache</li>
<li>enableHttp2，开启http2 — <span class="desc">后端需要开启相关支持</span></li>
<li>enableQuic，开启quic — <span class="desc">第三代网络，后端需要开启相关支持</span></li>
</ul>
<h2 id="视图代码优化技巧"><a href="#视图代码优化技巧" class="headerlink" title="视图代码优化技巧"></a>视图代码优化技巧</h2><h3 id="在动态列表渲染优化wx-key使用"><a href="#在动态列表渲染优化wx-key使用" class="headerlink" title="在动态列表渲染优化wx:key使用"></a>在动态列表渲染优化wx:key使用</h3><ul>
<li>如果列表元素是<span class="key_words">『单一』</span>的基本数据类型，并且是唯一的，直接写成<em>this，</em>this就代表当前数据列表中的元素item</li>
<li>如果列表元素是<span class="key_words">『对象』</span>类型，可以填写列表元素对象中的一个<span class="key_words">『字段名』</span>，这个字段名在整个数据列表中必须是唯一的</li>
<li>列表<span class="key_words">『不是动态』</span>的，只渲染一次，wx:key设置为index</li>
</ul>
<h3 id="绑定视图事件"><a href="#绑定视图事件" class="headerlink" title="绑定视图事件"></a>绑定视图事件</h3><ul>
<li>使用catch代替bind，不需要冒泡只在特定节点监听事件</li>
<li>回传额外信息用data-的形式</li>
</ul>
<h3 id="使用节流函数和防抖函数，防止按钮误单击与scroll事件函数频繁触发"><a href="#使用节流函数和防抖函数，防止按钮误单击与scroll事件函数频繁触发" class="headerlink" title="使用节流函数和防抖函数，防止按钮误单击与scroll事件函数频繁触发"></a>使用节流函数和防抖函数，防止按钮误单击与scroll事件函数频繁触发</h3><ul>
<li>节流：控制某段JS代码的执行频率</li>
<li>防抖：避免一次事件当作多次处理</li>
<li>对于scroll高频事件要节流，使用节流函数throttle</li>
<li>对于用户的<span class="key_words">『单击』</span>事件，可以适当使用防抖函数debounce</li>
</ul>
<h3 id="重渲染与使用wxml标签要克制"><a href="#重渲染与使用wxml标签要克制" class="headerlink" title="重渲染与使用wxml标签要克制"></a>重渲染与使用wxml标签要克制</h3><ul>
<li>减少wxml节点的数量,总页面节点数少于1000个，节点数深度层级少于30层，子节点数不大于60个</li>
<li>控制setData每次传递的数据量</li>
<li>能不用容器标签就不用</li>
</ul>
<h2 id="WXSS优化技巧"><a href="#WXSS优化技巧" class="headerlink" title="WXSS优化技巧"></a>WXSS优化技巧</h2><ul>
<li>给滚动组件开启惯性滚动<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-webkit-<span class="attribute">overflow</span>-scrolling: touch;</span><br></pre></td></tr></table></figure></li>
<li>使用hover-class实现按钮的单击态<ul>
<li>代替:active伪类</li>
</ul>
</li>
<li>使用gulp工具删除无用wxss样式 — <span class="desc">只能静态甄别不能动态</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install gulp -g</span><br><span class="line">npm install --save-dev gulp gulp-cleanwxss</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个gulpfile.js文件并执行 gulp<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gulpfile.js文件</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&quot;gulp&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> cleanwxss = <span class="built_in">require</span>(<span class="string">&quot;gulp-cleanwxss&quot;</span>)</span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;default&quot;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123; <span class="comment">// 默认执行</span></span><br><span class="line">  gulp.<span class="title function_">arc</span>(<span class="string">&quot;../miniprogram/index/page/*/*.wxss&quot;</span>) <span class="comment">// 处理的文件</span></span><br><span class="line">      .<span class="title function_">pipe</span>(<span class="title function_">cleanwxss</span>(&#123;<span class="attr">log</span>: <span class="literal">true</span>&#125;))</span><br><span class="line">      .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;./dist&quot;</span>))  <span class="comment">//处理结果放在该目录下</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="UI交互技巧"><a href="#UI交互技巧" class="headerlink" title="UI交互技巧"></a>UI交互技巧</h2><ul>
<li>使用<span class="key_words">『padding改变单击区域大小』</span></li>
<li>使用<span class="key_words">『伪元素改变点击区域大小』</span><ul>
<li>给父元素reletive，伪类为absolute，且top、left、right、bottom设置为负值，扩大点击区域</li>
</ul>
</li>
</ul>
<h2 id="脚本优化技巧"><a href="#脚本优化技巧" class="headerlink" title="脚本优化技巧"></a>脚本优化技巧</h2><ul>
<li>如果对象被异步线程引用，或者是被全局对象引用，会造成内存泄漏</li>
<li>定时器是异步线程里的东西，离开页面一定要记得销毁</li>
<li><span class="key_words">『使用wx.onXXX全局绑定一定要小心，有一个监听必须有一个反监听，在onUnload事件销毁』</span></li>
<li>主题切换事件在模拟器可以通过在app.json配置”darkmode”:true</li>
<li>使用全局对象要小心<ul>
<li>所有在global上或者在app上定义的全局数据，或者在上面添加的事件监听</li>
<li>要及时清理，自定义对象要定义一个dispose方法</li>
</ul>
</li>
<li>使用this对象要谨慎（在周期性发生的异步回调函数里面）</li>
</ul>
<h2 id="setData调用优化"><a href="#setData调用优化" class="headerlink" title="setData调用优化"></a>setData调用优化</h2><ul>
<li>小程序切换到后台后，setData不再调用，可以结合小程序的双线程运行机制和重渲染机制</li>
<li>不要多次分开调用setData，尽量要合并调用</li>
<li>不准备渲染的数据不要放在data数据对象里边<ul>
<li><span class="key_words">『只有需要触发视图更新的数据才需要放在data对象』</span></li>
<li>不需要触发的，可以放在data对象外面（即当前页面对象上），通过this直接取用</li>
</ul>
</li>
<li>通过index局部更新长列表数据<ul>
<li>使用索引或计算属性更新局部数据</li>
<li>直接使用当前组件上下文对象的update方法</li>
</ul>
</li>
</ul>
<h2 id="网络请求优化之使用本地缓存-并发请求的优先级不一致"><a href="#网络请求优化之使用本地缓存-并发请求的优先级不一致" class="headerlink" title="网络请求优化之使用本地缓存 并发请求的优先级不一致"></a>网络请求优化之使用本地缓存 并发请求的优先级不一致</h2><h3 id="减少不必要的网络请求，使用本地缓存的数据代替从后端接口拉取的数据"><a href="#减少不必要的网络请求，使用本地缓存的数据代替从后端接口拉取的数据" class="headerlink" title="减少不必要的网络请求，使用本地缓存的数据代替从后端接口拉取的数据"></a>减少不必要的网络请求，使用本地缓存的数据代替从后端接口拉取的数据</h3><ul>
<li>在首页的JS文件里边有加载小程序导航数据的代码，可以再这里尝试使用本地缓存技术</li>
<li>首先从本地缓存中尝试取出缓存数据，然后向后端发起网络请求，拿到最新的导航数据以后再调用setData重新设置一下数据，并把本地数据也刷新一遍，避免本地缓存过时（<span class="desc">优化：改用并发复合命令或两个异步函数</span>）</li>
</ul>
<h3 id="优化网络请求参数，提高网络请求的通讯效率-—-前面讲wx-request参数已讲"><a href="#优化网络请求参数，提高网络请求的通讯效率-—-前面讲wx-request参数已讲" class="headerlink" title="优化网络请求参数，提高网络请求的通讯效率 — 前面讲wx.request参数已讲"></a>优化网络请求参数，提高网络请求的通讯效率 — <span class="desc">前面讲wx.request参数已讲</span></h3><h3 id="优化网络请求的并发数，让优先级高的请求先执行"><a href="#优化网络请求的并发数，让优先级高的请求先执行" class="headerlink" title="优化网络请求的并发数，让优先级高的请求先执行"></a>优化网络请求的并发数，让优先级高的请求先执行</h3><ul>
<li>因为有由wx.request发出的请求有最大10个的并发限制（限基础库1.4.0以下）</li>
<li>改造request工具函数<ul>
<li>安装并构建npm<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add priority-<span class="keyword">async</span>-queue</span><br></pre></td></tr></table></figure></li>
<li>使用自定义的request方法时，在重要的网络请求添加priority选项<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">request</span>(&#123;<span class="attr">url</span>:<span class="string">&quot;&quot;</span>,<span class="attr">priority</span>:<span class="string">&quot;urgent&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>在自定义的request方法中引入<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PriorityAsyncQueue</span> = <span class="built_in">require</span> <span class="string">&quot;priority-async-queue&quot;</span></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">PriorityAsyncQueue</span>(<span class="number">10</span>) <span class="comment">// default 10</span></span><br><span class="line"><span class="keyword">const</span> low=<span class="string">&quot;low&quot;</span>,normal=<span class="string">&quot;normal&quot;</span>,mid=<span class="string">&quot;mid&quot;</span>,high=<span class="string">&quot;high&quot;</span>,urgent=<span class="string">&quot;urgent&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> priority = &#123;low , normal, mid, high, urgent&#125;</span><br><span class="line"><span class="keyword">const</span> priority = args.<span class="property">priority</span> ? args.<span class="property">priority</span> : normal</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  queue.<span class="title function_">addTask</span>(&#123;prority&#125;, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    wx.<span class="title function_">request</span>(</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(args,&#123;<span class="attr">success</span>:resolve,<span class="attr">fail</span>:reject&#125;)</span><br><span class="line">  )&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="图片优化技巧"><a href="#图片优化技巧" class="headerlink" title="图片优化技巧"></a>图片优化技巧</h2><ul>
<li>尽量减少图片的请求参数</li>
<li>尽量压缩图片的大小</li>
<li>尽量使用带有cdn加速的网络图片链接</li>
<li>尽可能使用高压缩比图片，例如webp格式的图片</li>
<li>生成雪碧图<ul>
<li>多张图片合成一张图片，通过background-image来使用的图片<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install libpng</span><br><span class="line">npm -g install miniprogram-slim</span><br><span class="line">生成的脚本: generate_sprite.<span class="property">sh</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>图片压缩<ul>
<li>在线 <a href="https://tinypng.com/">https://tinypng.com/</a></li>
<li>离线 将图片存放的文件夹拷贝在tools文件夹下，然后执行cpmpress.sh脚本<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install libpng</span><br><span class="line">miniprogram-slim imagemin -o ./生成的文件夹 --png-quality <span class="string">&quot;0.65,0.8&quot;</span> ./存放图片的文件夹<span class="comment">/**/</span>*.<span class="property">png</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>使用腾讯云cos存储本地图片<ul>
<li>上传本地图片到cos的方法: uploadImageToCos() </li>
<li>安装<a href="https://github.com/tencentyun/cos-nodejs-sdk-v5">cos-nodejs-sdk-v5</a><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install cos-nodejs-sdk-v5</span><br></pre></td></tr></table></figure></li>
<li>然后登录腾讯云官方网站开通对象存储服务并创建一个默认的存储桶</li>
<li>创建一个upload.js文件，实现uploadImageToCos函数</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>知识</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-归纳总结</title>
    <url>/2024/11/04/WeChatMini/%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="当前页面对某个选项进行切换，同步更新全局更新"><a href="#当前页面对某个选项进行切换，同步更新全局更新" class="headerlink" title="当前页面对某个选项进行切换，同步更新全局更新"></a>当前页面对某个选项进行切换，同步更新全局更新</h2><blockquote>
<p>该问题使用的技术栈是 React + Taro搭建的微信小程序</p>
</blockquote>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ul>
<li>既然是全局更新就要在全局store中设置好存储的变量，方便统一管理</li>
<li>在首页将页面要获取的共同内容存到对应变量中</li>
<li>在对应的页面拿取这个变量的内容</li>
<li>然后就处理事件即可</li>
</ul>
<h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><ul>
<li>代码写完后，页面没有变化，通过打印发现变量有更新，但是没有重新调用请求</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>存在分页? 检查<span class="key_words">『数据顺序』</span></li>
<li>查看要调用的<span class="key_words">『请求依赖的变量对象是否更新』</span></li>
<li>编辑和查看接口使用useQuery来获取，且通过选项切换接口发现只有一个有问题，查看这个接口useQuery的enabled<ul>
<li><span class="key_words">『enabled:false, 数据不会重新更新』</span>，即enabled:true，或去掉enabled都行</li>
</ul>
</li>
<li>创建和编辑在同一个页面，编辑页不需要切换，且要带着已经编辑过的数据<ul>
<li>编辑页用enabled:false，记录数据，不轻易更新，查看页用true</li>
<li>传参判断页面类型，enabled: type !&#x3D;&#x3D; ‘edit’，其中type是当前页面状态</li>
</ul>
</li>
</ul>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><blockquote>
<p>该问题使用的技术栈是 React + Taro搭建的微信小程序</p>
</blockquote>
<h3 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h3><ul>
<li>在静默登录时判断用户是否第一次进入小程序，如果是第一次进入小程序，或者卸载了小程序后再次进入小程序，需要弹窗来让用户填写昵称和头像</li>
</ul>
<h3 id="分析和解决方案"><a href="#分析和解决方案" class="headerlink" title="分析和解决方案"></a>分析和解决方案</h3><ul>
<li>翻阅小程序文档可了解到setStorageSync，getStorageSync这个操作</li>
<li>理清好业务逻辑</li>
<li>首先第一次进入时虽然静默登录了，但是storage并没有存储，所以可以在useEffect中先调用wx.getStorageSync()来获取我们要存储的key，由于只需要获取第一次的情况，所以useEffect(()&#x3D;&gt; {}, []),不需要依赖</li>
<li>没有获取到对应的key就弹窗，有就不弹窗</li>
<li>在弹窗的取消、确认按钮和直接关闭弹窗的逻辑中调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;key&#x27;</span>, value)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><span class="key_words">『缓存只能存储字符串』</span>，所以如果要存储的值不是字符串类型的话，请用JSON.stringify将值序列化一下</li>
<li>最好设置storage时放在try{}catch(e){}中方便捕获错误</li>
<li>按项目要求，点跳过拿的数据最好是直接拿到静默登录时服务器给的数据的信息，点确认则是要判断是否两个都有获取新数据，没有就禁用，有就存储。</li>
<li>不管拿到的数据是什么都要注意是否要更新该项目中的用户信息接口和store<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;userInfo&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(e.<span class="property">detail</span>.<span class="property">userInfo</span>))</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;headImg&#x27;</span>,value)</span><br><span class="line">  wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;nickname&#x27;</span>,value)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> headImgValue = wx.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;headImg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> nicknameValue = wx.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;nickname&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (headImagValue &amp;&amp; nicknameValue) &#123;</span><br><span class="line">  <span class="comment">// 不弹窗</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 弹窗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Taro-的消息机制-–-全局消息中心-evenCenter"><a href="#Taro-的消息机制-–-全局消息中心-evenCenter" class="headerlink" title="Taro 的消息机制 – 全局消息中心 evenCenter"></a>Taro 的消息机制 – 全局消息中心 evenCenter</h2><blockquote>
<p>eventCenter的使用场景一般用作于事件的传递，例如跨页面、跨组件做一些操作。</p>
</blockquote>
<h3 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h3><ul>
<li>使用evenCenter.trigger(key)来触发事件</li>
<li>使用evenCenter.on(key,() &#x3D;&gt; {})来监听事件</li>
<li>在useUnLoad中要evenCenter.off(key)卸载事件</li>
</ul>
<h3 id="需要获取触发事件页面的数据给监听事件这边"><a href="#需要获取触发事件页面的数据给监听事件这边" class="headerlink" title="需要获取触发事件页面的数据给监听事件这边"></a>需要获取触发事件页面的数据给监听事件这边</h3><ul>
<li>使用evenCenter.trigger(key, arg)来触发事件</li>
<li>使用evenCenter.on(key,() &#x3D;&gt; {setArg(arg)})来监听事件和触发当页的实时刷新</li>
<li>在useUnLoad中要evenCenter.off(key)卸载事件</li>
</ul>
<h3 id="发送数据给页面"><a href="#发送数据给页面" class="headerlink" title="发送数据给页面"></a>发送数据给页面</h3><ul>
<li>使用evenCenter.on(key,() &#x3D;&gt; {fn(arg)})来发送数据</li>
<li>使用evenCenter.trigger(key, fn(arg))来接收数据</li>
</ul>
<h3 id="切换参数，然后返回"><a href="#切换参数，然后返回" class="headerlink" title="切换参数，然后返回"></a>切换参数，然后返回</h3><ul>
<li>在useUnload中<span class="key_words">『卸载的时候触发事件和传参』</span></li>
<li>或<span class="key_words">『在受影响的页面中』</span>从store中拿到全局变量xxx并且<span class="key_words">『实时监听全局变量』</span>xxx的改变</li>
</ul>
<h2 id="Taro-页面跳转的消息机制-–-eventChannel"><a href="#Taro-页面跳转的消息机制-–-eventChannel" class="headerlink" title="Taro 页面跳转的消息机制 – eventChannel"></a>Taro 页面跳转的消息机制 – eventChannel</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul>
<li>A页面使用navigateTo等跳转方法直接触发事件res.eventChannel.emit(key,data)</li>
<li>B页面首先需要获取当前页面的实例，然后调用getOpenerEventChannel()获取eventChannel对象</li>
<li>B页面使用eventChannel.on(key,callbackFn)</li>
<li>A页面也可以通过跳转时的events中的创建的事件来获取B页面传输过来的数据</li>
<li>B页面通过eventChannel.emit(events中的事件名,data)来触发事件</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li>A页面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Taro</span>.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">	<span class="attr">url</span>: <span class="string">&quot;/pages/test/index&quot;</span>, <span class="comment">// 跳到页面B</span></span><br><span class="line">	events： &#123;</span><br><span class="line">		<span class="attr">acceptB</span>: (data) &#123;&#125; <span class="comment">// 获取B页面传送到当前页面的数据</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 向sendB发送数据</span></span><br><span class="line">		res.<span class="property">eventChannel</span>.<span class="title function_">emit</span>(<span class="string">&quot;sendB&quot;</span>, &#123;<span class="attr">data</span>: 要传递的数据&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>B页面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pages = <span class="title class_">Taro</span>.<span class="title function_">getCurrentPages</span>()</span><br><span class="line"><span class="keyword">const</span> current = pages[pages.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> eventChannel = current.<span class="title function_">getOpenerEventChannel</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发A页面events的事件</span></span><br><span class="line">eventChannel.<span class="title function_">emit</span>(<span class="string">&#x27;acceptB&#x27;</span>, &#123;要传给A的数据&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受A页面对应事件传递的数据</span></span><br><span class="line">eventChannel.<span class="title function_">on</span>(<span class="string">&quot;sendB&quot;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(res)&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/EventChannel.html">API-EventChannel</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html">API-wx.navigateTo</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#%E9%A1%B5%E9%9D%A2%E9%97%B4%E9%80%9A%E4%BF%A1">官方示例</a></li>
</ul>
<h2 id="在-input-标签中使用-useState-和-useRef-的影响"><a href="#在-input-标签中使用-useState-和-useRef-的影响" class="headerlink" title="在 input 标签中使用 useState 和 useRef 的影响"></a>在 input 标签中使用 useState 和 useRef 的影响</h2><blockquote>
<p>该问题使用的技术栈是 React + Taro搭建的微信小程序</p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>Q1：使用input 标签，需要动态获取输入框中输入的value的值来更新数据时，存在使用useState来获取value时，当value已有值，要完全删除旧值，输入新值时，<span class="key_words">『删到旧值的最后一个字符时输入框会一直循环重复』</span>旧值，删不掉</li>
<li>Q2：当使用useRef获取的数据作为其他数据的依赖时，对应的数据不会随着useRef获取新数据的更新而更新</li>
<li><h3 id="分析存在的原因"><a href="#分析存在的原因" class="headerlink" title="分析存在的原因"></a>分析存在的原因</h3><ul>
<li><span class="key_words">『useRef直接操作dom』</span>，返回的ref对象在组件的整个生命周期内保持不变，当<span class="key_words">『更新时不会触发组件的重新渲染』</span>，而useState会存放组件中包含的各种数据(状态)，并且当<span class="key_words">『组件更新state时会触发组件的重新渲染』</span></li>
</ul>
</li>
<li><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>A1：将变量的存储和获取方式从useState换成useRef</li>
<li>A2：通过设置一个用useState存储的常量，当useRef更新时，让常量更新，常量存储更新后的useRef的数据，并作为其他数据的依赖，保证了useRef的数据更新时其他数据也能随着更新。</li>
</ul>
</li>
</ul>
<h2 id="scroll-view-隐藏滚动条问题"><a href="#scroll-view-隐藏滚动条问题" class="headerlink" title="scroll-view 隐藏滚动条问题"></a>scroll-view 隐藏滚动条问题</h2><blockquote>
<p>该问题适用于任何使用小程序 scroll-view 组件或直接使用或二次封装等</p>
</blockquote>
<ul>
<li>根据小程序官方文档，show-scrollbar默认为true即显示滚动条。</li>
</ul>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li>当想要<span class="key_words">『隐藏滚动条』</span>时，需要enhanced&#x3D;”true”和show-scrollbar&#x3D;”false”,但是实践会发现滚动条依然存在</li>
</ul>
<h3 id="存在的原因"><a href="#存在的原因" class="headerlink" title="存在的原因"></a>存在的原因</h3><ul>
<li>show-scrollbar&#x3D;””,直接赋值时，因为字符串里面有值就是true</li>
</ul>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>根据不同框架，给show-scrollbar赋值为false时，添加{}，和enhanced<ul>
<li>react 使用 {false}</li>
<li>原生微信小程序 使用 “false“</li>
</ul>
</li>
</ul>
<h2 id="解决滚动禁止穿透页面"><a href="#解决滚动禁止穿透页面" class="headerlink" title="解决滚动禁止穿透页面"></a>解决滚动禁止穿透页面</h2><blockquote>
<p>该问题适用于微信小程序</p>
</blockquote>
<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><ul>
<li>弹窗界面滚动(<span class="desc">存不存在scroll-view无所谓，只要能滚动</span>)带动下层的页面跟着滚动</li>
</ul>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><ol>
<li>在弹窗组件的插槽中用一个view包裹住该弹窗要展示的内容，然后给这个view添加catch:touchmove&#x3D;”noop”</li>
<li>然后在ts&#x2F;js文件中直接添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">noop</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="复制大段文本，文本丢失问题"><a href="#复制大段文本，文本丢失问题" class="headerlink" title="复制大段文本，文本丢失问题"></a>复制大段文本，文本丢失问题</h2><blockquote>
<p>微信小程序的原生组件 textarea</p>
</blockquote>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>小程序的textare组件默认了maxlength &#x3D; 140</li>
</ul>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>设置maxlength &#x3D; -1</li>
</ul>
<h2 id="单选框radio除了可以传value可以传其他的值"><a href="#单选框radio除了可以传value可以传其他的值" class="headerlink" title="单选框radio除了可以传value可以传其他的值"></a>单选框radio除了可以传value可以传其他的值</h2><blockquote>
<p>微信小程序的 radio-group 组件和 radio 组件，该问题收集于微信开放社区</p>
</blockquote>
<p><img src="/../../img/WeChatMini/question-radio.png" alt="单选框radio除了可以传value可以传其他的值"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ul>
<li>data-传值在bindChange事件里接收不到，只能获取到value的值 &#x3D;&#x3D;&#x3D; 向value传其他的值</li>
</ul>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>使用wxs处理<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*wxml*/</span></span><br><span class="line">&lt;wxs <span class="variable language_">module</span>=<span class="string">&quot;JSON&quot;</span>&gt;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  stringify : <span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/wxs&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">radio-group</span> <span class="attr">...</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">....</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">radio</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;JSON.stringify(item)&#125;&#125;&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;&#123;&#123;item.checked&#125;&#125;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">radio-group</span>&gt;</span></span></span><br><span class="line"><span class="comment">/*ts*/</span></span><br><span class="line"><span class="attr">radioChange</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> d = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">detail</span>.<span class="property">value</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;radio发生change事件，携带value值为：&#x27;</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="关于微信昵称中Emoji表情乱码问题"><a href="#关于微信昵称中Emoji表情乱码问题" class="headerlink" title="关于微信昵称中Emoji表情乱码问题"></a>关于微信昵称中Emoji表情乱码问题</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><ul>
<li>昵称带Emoji表情，保存到数据库里，页面显示就乱码</li>
</ul>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>将包含该Emoji表情的信息encodeURIComponent编码，在使用的地方，在decodeURIComponent解码</li>
<li>在数据库连接的时候采用utf8mb4，数据库编码和表格编码以及对应的存储字段都采用utf8mb4编码</li>
</ul>
<h2 id="小程序分享"><a href="#小程序分享" class="headerlink" title="小程序分享"></a>小程序分享</h2><blockquote>
<p>该方法使用的时vue3 + taro</p>
</blockquote>
<h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123; useShareAppMessage &#125; <span class="keyword">from</span> <span class="string">&#x27;@tarojs/taro&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useShareAppMessage</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">from</span> === <span class="string">&#x27;button&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 来自页面内转发按钮</span></span><br><span class="line">			<span class="comment">// 弹出分享图片的菜单，包括图片和发送等</span></span><br><span class="line">			wx.<span class="title function_">showShareImageMenu</span>(&#123;</span><br><span class="line">				<span class="attr">path</span>: res.<span class="property">tempFilePath</span></span><br><span class="line">			&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 小程序菜单分享</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;自定义转发标题&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/page/user?id=123&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="点击查看更多，展示更多数据"><a href="#点击查看更多，展示更多数据" class="headerlink" title="点击查看更多，展示更多数据"></a>点击查看更多，展示更多数据</h2><blockquote>
<p>该方法使用微信小程序</p>
</blockquote>
<h3 id="分析和解决方案-1"><a href="#分析和解决方案-1" class="headerlink" title="分析和解决方案"></a>分析和解决方案</h3><ul>
<li>先把框架写好</li>
<li>然后通过数据判断，是否超过一定数量total，和是否点击checked来判断展示更所数据的展示</li>
<li>然后通过服务端给的数据来展示<ul>
<li>方案一：通过对应API的参数来控制点击前和点击后的数据，如点击前给两条，点击后给全部，这个要记得初始化checked，list和api对应参数</li>
<li>方案二：每次点击更多就加载2条数据甚至更多，checked要等到所有数据都加载完才为false，一般这样服务端给的数据应该是点击以下增加一页，给两条数据</li>
</ul>
</li>
</ul>
<h2 id="服务端给的文本有回车换行-或者-空格等特殊字符"><a href="#服务端给的文本有回车换行-或者-空格等特殊字符" class="headerlink" title="服务端给的文本有回车换行 或者 空格等特殊字符"></a>服务端给的文本有回车换行 或者 空格等特殊字符</h2><blockquote>
<p>微信小程序</p>
</blockquote>
<ul>
<li><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ul>
<li>用view标签识别不了文本的回车的标签</li>
</ul>
</li>
<li><h3 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h3><ul>
<li>直接用text标签</li>
<li>text标签添加属性decode&#x3D;”true“时可以识别<code>&amp;nbsp;</code> ,<code>&amp;gt;</code>等特殊字符</li>
</ul>
</li>
</ul>
<h2 id="vant-checkbox-group-注意点"><a href="#vant-checkbox-group-注意点" class="headerlink" title="vant-checkbox-group 注意点"></a>vant-checkbox-group 注意点</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul>
<li>为什么点击没有勾选</li>
</ul>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ul>
<li>checkbox组下面的checkbox都要有name属性</li>
<li>使用checkbox组的方法，onChange，直接给checkbox组的value属性赋值，类型为字符串数组，值为：event.detail</li>
</ul>
<h2 id="switch用法"><a href="#switch用法" class="headerlink" title="switch用法"></a>switch用法</h2><ul>
<li>优化: 当有多个键指向的内容一致时</li>
</ul>
<h3 id="用法示例："><a href="#用法示例：" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(key)&#123;</span><br><span class="line">	<span class="keyword">case</span> key === <span class="number">1</span>:</span><br><span class="line">	<span class="keyword">case</span> key === <span class="number">2</span>:</span><br><span class="line">	<span class="keyword">case</span> key === <span class="number">3</span>:</span><br><span class="line">	  <span class="variable language_">console</span>.<span class="title function_">log</span>(key === <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>, content is same)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"> <span class="keyword">default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Array-filter-Boolean"><a href="#Array-filter-Boolean" class="headerlink" title="Array.filter(Boolean)"></a>Array.filter(Boolean)</h2><blockquote>
<p>本质上是将元素强制转换为布尔型并判断是否为false，以此来进行校验，适用于需要检验多个表单信息</p>
</blockquote>
<h3 id="移除数组中所有的”false”类型元素-false-null-undefined-0-NaN-空字符串"><a href="#移除数组中所有的”false”类型元素-false-null-undefined-0-NaN-空字符串" class="headerlink" title="移除数组中所有的”false”类型元素(false,null,undefined,0,NaN,空字符串)"></a>移除数组中所有的”false”类型元素(false,null,undefined,0,NaN,空字符串)</h3><ul>
<li>得到的是过滤后的值数组</li>
<li>注意：不检验对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">eg</span>:a simple explame</span><br><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="title class_">NaN</span>,&#123;&#125;,<span class="literal">false</span>, <span class="literal">true</span>,<span class="literal">null</span>,<span class="literal">undefined</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">filter</span>(<span class="title class_">Boolean</span>)</span><br><span class="line"><span class="attr">eg</span>: a advanced explame</span><br><span class="line"><span class="comment">// 定义要查找的关键字类型</span></span><br><span class="line">type keyType = <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;hobit&#x27;</span> | <span class="string">&#x27;remark&#x27;</span> | <span class="string">&#x27;position&#x27;</span> | <span class="string">&#x27;show&#x27;</span></span><br><span class="line"><span class="comment">// 定义当key为false类型时，提示的文本</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">validateText</span>: <span class="title class_">Record</span>&lt;keyType, string&gt; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;name is not empty!&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="string">&#x27;age is not zero!&#x27;</span>,</span><br><span class="line">    <span class="attr">hobit</span>: <span class="string">&#x27;hobit is not empty!&#x27;</span>,</span><br><span class="line">    <span class="attr">remark</span>: <span class="string">&#x27;remark is not empty!&#x27;</span>,</span><br><span class="line">    <span class="attr">position</span>: <span class="string">&#x27;position is not empty!&#x27;</span>,</span><br><span class="line">    <span class="attr">show</span>: <span class="string">&#x27;show is not false!&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InfoData</span>: <span class="title class_">Record</span>&lt;keyType, string | number | boolean&gt; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">hobit</span>: <span class="string">&#x27;打球&#x27;</span>,</span><br><span class="line">    <span class="attr">remark</span>: <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">    <span class="attr">position</span>: <span class="string">&#x27;学生&#x27;</span>,</span><br><span class="line">    <span class="attr">show</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 顶一个数组，用来存放要校验的key，按顺序校验</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">keyInfo</span>: keyType[] = [</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;hobit&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;remark&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;position&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;show&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 校验是否存在false类型，返回检验没有false类型的字段，并且返回不存在数组的第一个字段</span></span><br><span class="line"><span class="keyword">const</span> validate = keyInfo</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="title class_">Boolean</span>)</span><br><span class="line">    .<span class="title function_">find</span>(<span class="function">(<span class="params">key: keyType</span>) =&gt;</span> !<span class="title class_">InfoData</span>[key])</span><br><span class="line"><span class="comment">// 判断当返回的值不为undefined时，则提示对应的文本</span></span><br><span class="line"><span class="keyword">if</span> (validate) &#123;</span><br><span class="line">	wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">	  <span class="attr">title</span>: <span class="string">&#x27;提示&#x27;</span>,</span><br><span class="line">	  <span class="attr">content</span>: validateText[validate],</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="编辑与查看为同一页时，处理方式（无缓存）"><a href="#编辑与查看为同一页时，处理方式（无缓存）" class="headerlink" title="编辑与查看为同一页时，处理方式（无缓存）"></a>编辑与查看为同一页时，处理方式（无缓存）</h2><blockquote>
<p>本次项目实战使用微信小程序 + ts</p>
</blockquote>
<h3 id="问题的描述："><a href="#问题的描述：" class="headerlink" title="问题的描述："></a>问题的描述：</h3><ul>
<li>第一次进入页面是编辑状态，保存了数据后，不管是否清除缓存，都展示最新的数据（只读）</li>
<li>只有在只读页面中点击对应的按钮，才能进入编辑状态页，并且编辑页只要没有按下保存按钮，则刷新后仍然回到点击前的只读页面，即接口返回的最新数据</li>
<li>只有当保存后，才会重新进入新的只读页</li>
</ul>
<h3 id="问题的解决："><a href="#问题的解决：" class="headerlink" title="问题的解决："></a>问题的解决：</h3><ul>
<li>首先需要将要编辑的数据及相关变量保存在同一个初始化函数中</li>
<li>之后通过接口返回的数据，如果失败，则为第一次进入预约页面的状态，标识编辑，然后初始化函数并且，设置变量来标识为编辑页</li>
<li>当内容编辑完成后，点击保存，进行校验，保存成功后，将变量标识为只读状态，并且调用接口获取最新的数据和状态，并存到初始化函数中的变量中，保持数据的统一性</li>
<li>当点击页面的按钮，调用初始化函数，并将变量设置为编辑状态，即可回到编辑页，</li>
<li>此时只有当在这个页面保存数据，才会产生新的页面，不然不管清缓存还是重新进入该页面，都应回到点击前的只读页面。</li>
</ul>
<h3 id="问题的总结："><a href="#问题的总结：" class="headerlink" title="问题的总结："></a>问题的总结：</h3><ul>
<li>此次遇到编辑和查看页面为同一页面时，要通过接口的数据返回，来判断并设置对应的标识以区分当前页是编辑还是查看状态</li>
</ul>
<h2 id="单个表单数据要存入一个对象"><a href="#单个表单数据要存入一个对象" class="headerlink" title="单个表单数据要存入一个对象"></a>单个表单数据要存入一个对象</h2><blockquote>
<p>该问题使用微信小程序 + ts</p>
</blockquote>
<h3 id="问题的描述"><a href="#问题的描述" class="headerlink" title="问题的描述"></a>问题的描述</h3><ul>
<li>当页面存在多个input标签，并需要保存提交</li>
<li>一般都会存储在同一个对象中，方便校验</li>
<li>校验使用上面的Array.filter(Boolean)里面有示例</li>
</ul>
<h3 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h3><ul>
<li>多个input标签功能一致，则可以使用同一个函数来操作</li>
<li>至于具体存进那个key，则可以通过在wxml页面给每一个input添加mark:key&#x3D;”定义的键”</li>
<li>然后每次调用函数时，可以获取key并存进对应的key中，或清除</li>
</ul>
<h3 id="问题的总结"><a href="#问题的总结" class="headerlink" title="问题的总结"></a>问题的总结</h3><ul>
<li>当存在多个标签一致时，观察功能&#x2F;样式是否相同，然后通过给一个区分的标签来实现调用同一个函数实现不同的功能，以减少代码量</li>
</ul>
<h2 id="setData第二参数"><a href="#setData第二参数" class="headerlink" title="setData第二参数"></a>setData第二参数</h2><blockquote>
<p>微信小程序中setData方法用于设置数据，更改数据</p>
</blockquote>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>第一个参数：Object data， 必传， 代表这次要改变的数据</li>
<li>第二个参数：Function callback， 选填， 代表setData引起的界面更新渲染完毕后的回调函数</li>
</ul>
<h3 id="浅薄理解："><a href="#浅薄理解：" class="headerlink" title="浅薄理解："></a>浅薄理解：</h3><ul>
<li>参数一就是主要用来更新数据，设置数据，参数二则是延时器的作用，渲染完在调用回调函数</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ul>
<li>第一个参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; val, <span class="attr">b</span>:a &#125;)</span><br></pre></td></tr></table></figure></li>
<li>第二个参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(</span><br><span class="line">  &#123;val&#125;, </span><br><span class="line">  <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="picker-view的value赋值问题"><a href="#picker-view的value赋值问题" class="headerlink" title="picker-view的value赋值问题"></a>picker-view的value赋值问题</h2><blockquote>
<p>picker-view时微信小程序的原生组件，用于自定义picker</p>
</blockquote>
<ul>
<li>已知picker-view的value属性值为每一个picker-view-column默认选中的索引数组，存在有多少个picker-view-column，数组长度就为多少</li>
</ul>
<h3 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h3><ul>
<li>给value赋值时，不管是不是第一项没成功赋值，定位到对应的索引，还是其他项，都显示为在索引0的位置和索引0的值，与所求相异</li>
</ul>
<h3 id="原因：-1"><a href="#原因：-1" class="headerlink" title="原因："></a>原因：</h3><ul>
<li>初始化函数时没有成功赋值进去，存在延时</li>
</ul>
<h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><ul>
<li>建议用setData的第二参数赋值，<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(</span><br><span class="line">  &#123;val&#125;, </span><br><span class="line">  <span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="title function_">setData</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多行文本溢出省略号"><a href="#多行文本溢出省略号" class="headerlink" title="多行文本溢出省略号"></a>多行文本溢出省略号</h2><ul>
<li>核心代码<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">-webkit-<span class="selector-tag">line</span>-clamp: <span class="number">6</span>;</span><br><span class="line"><span class="attribute">word-break</span>: break-all;</span><br><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure></li>
<li>注意：如果无效可以限制宽高</li>
<li>单行文本溢出省略：只要前两行</li>
</ul>
<h2 id="跳转返回上一页面并传递参数"><a href="#跳转返回上一页面并传递参数" class="headerlink" title="跳转返回上一页面并传递参数"></a>跳转返回上一页面并传递参数</h2><blockquote>
<p>微信小程序</p>
</blockquote>
<h3 id="方法一：使用wx-navigateBack"><a href="#方法一：使用wx-navigateBack" class="headerlink" title="方法一：使用wx.navigateBack"></a>方法一：使用wx.navigateBack</h3><ol>
<li>在子页面中首先获取上一页面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pages = <span class="title function_">getCurrentPages</span>()</span><br><span class="line"><span class="keyword">const</span> prePages = pages[pages.<span class="property">length</span> -<span class="number">2</span>] <span class="comment">//上一级页面</span></span><br></pre></td></tr></table></figure></li>
<li>调用上一页面的setData方法，将数据存到上一页面，存储的变量要现在上一页面的data中声明<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">prePages.<span class="title function_">setData</span>(&#123;存储的变量：这个页面要存储的值&#125;)</span><br></pre></td></tr></table></figure></li>
<li>返回上一页面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">navigateBack</span>(&#123; <span class="attr">delta</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure></li>
<li>上一页面接收子页面的参数可在onLoad或onShow中执行，onShow每次页面加载都会执行，并保存<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pages = <span class="title function_">getCurrentPages</span>()</span><br><span class="line"><span class="keyword">const</span> currentPages = pages[pages.<span class="property">length</span>-<span class="number">1</span>]</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;存储的变量：这个页面要存储的值&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="方法二：使用wx-navigateTo"><a href="#方法二：使用wx-navigateTo" class="headerlink" title="方法二：使用wx.navigateTo"></a>方法二：使用wx.navigateTo</h3><ol>
<li>子页面通过路径传递参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">navigateTo</span>(&#123; <span class="attr">url</span>: <span class="string">`/xxx/xxx/xxx?params=<span class="subst">$&#123;params&#125;</span>&amp;params1=<span class="subst">$&#123;params&#125;</span>`</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>父页面通过onLoad(options)方法获取参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onLoad</span>(<span class="params">options</span>)&#123; </span><br><span class="line">  <span class="keyword">const</span> params = options.<span class="property">params</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="如何避免输入中文拼音时触发input事件"><a href="#如何避免输入中文拼音时触发input事件" class="headerlink" title="如何避免输入中文拼音时触发input事件"></a>如何避免输入中文拼音时触发input事件</h2><blockquote>
<p>原生html+js</p>
</blockquote>
<ul>
<li>监听compositionstart 、 compositionend</li>
<li>定义isComposite 为false，在start中设置为true，在end中设置为false</li>
<li>然后在input事件中判断，当isComposite为false时就进行输入搜索事件</li>
<li>之后在end事件中在调用输入搜索事件</li>
</ul>
<h2 id="实现防纂改的水印"><a href="#实现防纂改的水印" class="headerlink" title="实现防纂改的水印"></a>实现防纂改的水印</h2><ul>
<li>react框架使用ant design，有一个watermark组件</li>
</ul>
<h2 id="一个布局存在多个点击事件，先后触发问题"><a href="#一个布局存在多个点击事件，先后触发问题" class="headerlink" title="一个布局存在多个点击事件，先后触发问题"></a>一个布局存在多个点击事件，先后触发问题</h2><blockquote>
<p>本质：微信小程序 bindtap 和 catchtap 的区别</p>
</blockquote>
<ol>
<li>事件冒泡:<ul>
<li>bindtap会将事件传递给父节点进行处理，而catchtap会阻止事件继续冒泡到父节点。</li>
<li>即<span class="key_words">『当一个元素上的bindtap事件被触发，如果该元素的父节点又有bindtap事件，则父节点的事件也会执行；而catchtap则只会触发当前元素的事件处理函数』</span></li>
</ul>
</li>
<li>绑定顺序:<ul>
<li>bindtap的触发顺序是由子元素向父元素冒泡的顺序(由内向外)</li>
<li>catchtap的触发顺序是由父元素向子元素铺捕获的顺序(由外到内)</li>
</ul>
</li>
<li>阻止默认:<ul>
<li>bindtap可以通过返回false来阻止默认行为的触发，而catchtap无法阻止</li>
</ul>
</li>
<li>通常情况下使用bindtap，不想触发父元素使用catchtap</li>
</ol>
<h2 id="小红点单数圆形，双数圆矩形"><a href="#小红点单数圆形，双数圆矩形" class="headerlink" title="小红点单数圆形，双数圆矩形"></a>小红点单数圆形，双数圆矩形</h2><blockquote>
<p>参考vant-icon</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">dot</span> &#123;</span><br><span class="line">	font-<span class="attr">size</span>: 20rpx</span><br><span class="line">  <span class="attr">background</span>: red;</span><br><span class="line">  border-<span class="attr">radius</span>: 16rpx;</span><br><span class="line">  <span class="attr">padding</span>:4rpx 8rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="微信小程序中使用font-weight来加粗字体的，"><a href="#微信小程序中使用font-weight来加粗字体的，" class="headerlink" title="微信小程序中使用font-weight来加粗字体的，"></a>微信小程序中使用font-weight来加粗字体的，</h2><ul>
<li>部分机型使用数字如600，手机上不显示加粗效果。</li>
<li>使用bold，适配所有机型。但比较粗<!-- # 视频：流量限制 --></li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>问题与方案</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-海报生成</title>
    <url>/2024/11/04/WeChatMini/%E6%B5%B7%E6%8A%A5%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>应用场景：一般是需要生成海报时跳转到新页面，先看一下海报整体预览的效果，然后在点击这个页面的保存来保存海报</p>
</blockquote>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>点击海报生成,跳转页面</li>
<li>进入该海报页面要有一个加载效果</li>
<li>加载数据,显示图片效果，用canvas生成海报<ol>
<li>使用canvas在wxml页面占位</li>
<li>给canvas添加一个id，类型选择2d，宽高都要自适应</li>
<li>在函数中使用wx.createSelectorQuery()来初始化canvas</li>
<li>在ready函数中使用该函数，并且保存canvas到data中</li>
</ol>
</li>
<li>通过页面中的按钮来触发wx.canvasToTempFilePath把生成后的数据及形状绘制成图片</li>
<li>点击保存弹出一个加载效果</li>
<li>成功保存就地址给手机的地址,失败提示</li>
<li>涉及到获取二维码<ul>
<li>可以先生成二维码，然后通过数据传递到canvas中对应的位置</li>
</ul>
</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*wxml*/</span></span><br><span class="line">&lt;view <span class="keyword">class</span>=<span class="string">&quot;cantainer&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;Canvasbg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;2d&quot;</span> <span class="attr">style</span>=<span class="string">&quot; width: 100%; height: 100vh;&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;poster&quot;</span>/&gt;</span></span></span><br><span class="line">  &lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">type</span>=<span class="string">&quot;2d&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid; width: 300px; height: 150px;&quot;</span> /&gt;</span></span> --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;cantainer-bottom&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">text</span> &gt;</span>图片已生成,保存发布出来让朋友点赞吧!<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">size</span>=<span class="string">&quot;default&quot;</span> <span class="attr">bind:tap</span>=<span class="string">&quot;saveImage&quot;</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&lt;/view&gt;</span><br><span class="line"><span class="comment">/*sass*/</span></span><br><span class="line">.<span class="property">cantainer</span>&#123;</span><br><span class="line">  <span class="attr">display</span>: flex;</span><br><span class="line">  flex-<span class="attr">direction</span>: column;</span><br><span class="line">  flex-<span class="attr">grow</span>: <span class="number">1</span>;</span><br><span class="line">  background-<span class="attr">color</span>: skyblue;</span><br><span class="line">  <span class="attr">height</span>: inherit;</span><br><span class="line">  &amp;-bottom &#123;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    flex-<span class="attr">direction</span>: column;</span><br><span class="line">    <span class="attr">height</span>: 600rpx;</span><br><span class="line">    background-<span class="attr">color</span>: white;</span><br><span class="line">    justify-<span class="attr">content</span>: center;</span><br><span class="line">    align-<span class="attr">items</span>: center;</span><br><span class="line"></span><br><span class="line">    .<span class="property">info</span> &#123;</span><br><span class="line">      <span class="attr">height</span>: 100rpx;</span><br><span class="line">      font-<span class="attr">size</span>: 32rpx;</span><br><span class="line">      line-<span class="attr">height</span>: 32rpx;</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="property">btn</span>&#123; </span><br><span class="line">      background-<span class="attr">color</span>: <span class="title function_">var</span>(--primary-color);</span><br><span class="line">      <span class="attr">width</span>: 240rpx;</span><br><span class="line">      <span class="attr">height</span>: 80rpx;</span><br><span class="line">      <span class="attr">color</span>: white;</span><br><span class="line">      border-<span class="attr">radius</span>: 40rpx;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ts*/</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">photo</span>:<span class="string">&quot;../../../asset/squase.jpg&quot;</span>,</span><br><span class="line">    <span class="attr">imgUrl</span>:<span class="string">&quot;../../../asset/squase.jpg&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;一个海报的demo&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&#x27;小行星&#x27;</span>,</span><br><span class="line">    <span class="attr">canvas</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">onReady</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">draw</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">    wx.<span class="title function_">createSelectorQuery</span>()</span><br><span class="line">    .<span class="title function_">select</span>(<span class="string">&#x27;#Canvasbg&#x27;</span>)</span><br><span class="line">    .<span class="title function_">fields</span>(&#123; <span class="attr">node</span>: <span class="literal">true</span> ,<span class="attr">size</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    .<span class="title function_">exec</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> canvas = res[<span class="number">0</span>].<span class="property">node</span></span><br><span class="line">      <span class="keyword">const</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">      <span class="keyword">const</span> dpr = wx.<span class="title function_">getSystemInfoSync</span>().<span class="property">pixelRatio</span></span><br><span class="line">      <span class="keyword">const</span> width = res[<span class="number">0</span>].<span class="property">width</span></span><br><span class="line">      <span class="keyword">const</span> height = res[<span class="number">0</span>].<span class="property">height</span></span><br><span class="line">      canvas.<span class="property">width</span> = width * dpr</span><br><span class="line">      canvas.<span class="property">height</span> = height * dpr</span><br><span class="line">      ctx.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line">      <span class="comment">// 绘制底部白色背景</span></span><br><span class="line">      ctx.<span class="title function_">save</span>()</span><br><span class="line">      ctx.<span class="property">fillStyle</span>= <span class="string">&#x27;white&#x27;</span></span><br><span class="line">      ctx.<span class="title function_">fillRect</span>(<span class="number">150</span>,<span class="number">200</span>,<span class="number">800</span>,<span class="number">1000</span>)</span><br><span class="line">      ctx.<span class="title function_">restore</span>()</span><br><span class="line">      <span class="comment">// 绘制图片 rect 矩形路径,fillRect 绘制矩形填充颜色</span></span><br><span class="line">      <span class="comment">// drawImage(图,图的x,图的y,图的宽,图的高)</span></span><br><span class="line">      <span class="keyword">let</span> img = canvas.<span class="title function_">createImage</span>()</span><br><span class="line">      img.<span class="property">src</span>= <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">imgUrl</span>      </span><br><span class="line">      img.<span class="property">onload</span> =<span class="function">() =&gt;</span>&#123;</span><br><span class="line">        ctx.<span class="title function_">save</span>()</span><br><span class="line">        ctx.<span class="title function_">beginPath</span>()</span><br><span class="line">        ctx.<span class="title function_">rect</span>(<span class="number">150</span>,<span class="number">200</span>,<span class="number">800</span>,<span class="number">1000</span>)          </span><br><span class="line">        ctx.<span class="title function_">clip</span>()</span><br><span class="line">        ctx.<span class="title function_">drawImage</span>(img,<span class="number">0</span>,<span class="number">150</span>,<span class="number">1000</span>,<span class="number">550</span>)</span><br><span class="line">        ctx.<span class="title function_">closePath</span>()</span><br><span class="line">        ctx.<span class="title function_">restore</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 绘制文本</span></span><br><span class="line">      ctx.<span class="property">font</span>=<span class="string">&quot;40px Arial&quot;</span></span><br><span class="line">      ctx.<span class="title function_">fillText</span>(<span class="string">`N A M E: <span class="subst">$&#123;<span class="variable language_">this</span>.data.name&#125;</span>`</span>,<span class="number">200</span>,<span class="number">900</span>)</span><br><span class="line">      ctx.<span class="title function_">fillText</span>(<span class="string">`A D D R E S S: <span class="subst">$&#123;<span class="variable language_">this</span>.data.address&#125;</span>`</span>,<span class="number">200</span>,<span class="number">980</span>)</span><br><span class="line">      ctx.<span class="title function_">fillText</span>(<span class="string">`D E S C R I P T I O N: <span class="subst">$&#123;<span class="variable language_">this</span>.data.desc&#125;</span>`</span>,<span class="number">200</span>,<span class="number">1060</span>)</span><br><span class="line">      <span class="comment">// 绘制头像 bug</span></span><br><span class="line">      <span class="keyword">let</span> photo =  canvas.<span class="title function_">createImage</span>()</span><br><span class="line">      photo.<span class="property">src</span>= <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">photo</span> <span class="comment">// 绘制图片一定要加上这个</span></span><br><span class="line">      photo.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        ctx.<span class="title function_">save</span>()</span><br><span class="line">        ctx.<span class="title function_">beginPath</span>()</span><br><span class="line">        ctx.<span class="title function_">arc</span>(<span class="number">830</span>,<span class="number">900</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>)        </span><br><span class="line">        ctx.<span class="title function_">clip</span>()</span><br><span class="line">        ctx.<span class="title function_">drawImage</span>(photo,<span class="number">710</span>,<span class="number">800</span>,<span class="number">400</span>,<span class="number">400</span>)</span><br><span class="line">        ctx.<span class="title function_">closePath</span>()</span><br><span class="line">        ctx.<span class="title function_">restore</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        canvas</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">saveImage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 生成图片</span></span><br><span class="line">    <span class="keyword">const</span> canvas =  <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">    wx.<span class="title function_">showLoading</span>(&#123;<span class="attr">title</span>:<span class="string">&#x27;海报生成中...&#x27;</span>&#125;),</span><br><span class="line">    wx.<span class="title function_">canvasToTempFilePath</span>(&#123;</span><br><span class="line">      canvas,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 生成的图片临时文件路径</span></span><br><span class="line">      <span class="keyword">const</span> tempFilePath = res.<span class="property">tempFilePath</span></span><br><span class="line">      wx.<span class="title function_">hideLoading</span>()</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        wx.<span class="title function_">hideLoading</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;保存失败，请重试!&#x27;</span>,err)</span><br><span class="line">      &#125;</span><br><span class="line">		&#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-登录流程</title>
    <url>/2024/11/04/WeChatMini/%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、定义token的类型和初始化token</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> token = &#123;</span><br><span class="line">  <span class="comment">// token是由后端服务在用户登录时生成并返回给小程序，所以小程序端定义时需要了解后端需要传输什么在定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// token管理器</span></span><br><span class="line"><span class="keyword">const</span> tokenManager = &#123;</span><br><span class="line">  <span class="title function_">getToken</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setToken</span>(<span class="params">tokenData</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (token = &#123;...token,...tokenData&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、封装好请求处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">_request</span> = (<span class="params">url,data,method</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">      url,</span><br><span class="line">      data,</span><br><span class="line">      <span class="attr">header</span>: tokenManager.<span class="title function_">getToken</span>(),</span><br><span class="line">      method,</span><br><span class="line">      <span class="title function_">succes</span>(<span class="params">resp</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(resp.<span class="property">status</span>.<span class="property">code</span> === <span class="number">502</span> || resp.<span class="property">statusCode</span> === <span class="number">500</span>) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(&#123;<span class="attr">errMsg</span>: <span class="string">&#x27;请求失败&#x27;</span>&#125;)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> data = resp.<span class="property">data</span></span><br><span class="line">        <span class="keyword">if</span>(data.<span class="property">err</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; result &#125; = data</span><br><span class="line">          <span class="keyword">const</span> msg = result.<span class="property">state</span>.<span class="property">msg</span></span><br><span class="line">          <span class="title function_">reject</span>(&#123;<span class="attr">errMsg</span>:msg || data.<span class="property">msg</span>,<span class="attr">data</span>:result&#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> result = resp.<span class="property">data</span></span><br><span class="line">          <span class="title function_">resolve</span>(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">fail</span>(<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、继续封装网络请求和处理返回的数据格式,然后在登录的接口中调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">httpRequest</span> = <span class="keyword">async</span>(<span class="params">link,data=&#123;&#125;,method: <span class="string">&#x27;GET&#x27;</span>,showLoading=<span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(showLoading) &#123;</span><br><span class="line">    wx.<span class="title function_">showLoading</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>:<span class="string">&quot;请求中&quot;</span>,</span><br><span class="line">      <span class="attr">mask</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> handleData = &#123;...data&#125;</span><br><span class="line">  <span class="keyword">if</span>(link.<span class="property">cross</span>)&#123;</span><br><span class="line">    handleData.<span class="property">cross</span> = link.<span class="property">cross</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [error,response] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">_request</span>(link.<span class="property">url</span>,handleData, method))</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(link.<span class="property">text</span>, respone, error)</span><br><span class="line">  <span class="keyword">if</span>(showLoading)&#123;</span><br><span class="line">    wx.<span class="title function_">hideLoading</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([error,response])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、统一封装和写好api请求，页面中直接调用请求和传参即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getApi</span> = <span class="keyword">async</span>(<span class="params">pramas</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [err,res] = <span class="keyword">await</span> <span class="title function_">httpRequest</span>(apiurl,&#123;pramas&#125;)</span><br><span class="line">  <span class="keyword">if</span>(!err &amp;&amp; res) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="property">result</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、处理登录模块，定义一个判断登录状态的变量，默认为null<br>6、处理静默登录的逻辑并通过wx.login()从微信服务端获取code</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">_handleDefaultLogin</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> systemInfo = wx.<span class="title function_">getDeviceInfo</span>() <span class="comment">// 获取设备信息</span></span><br><span class="line">  <span class="keyword">const</span> [networkErr,networkRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(wx.<span class="title function_">getNetworkType</span>()) <span class="comment">// 获取网络类型</span></span><br><span class="line">  <span class="keyword">if</span>(networkErr) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;获取网络失败&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [wxLoginErr, wxLoginRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(wx.<span class="title function_">login</span>())</span><br><span class="line">  <span class="keyword">if</span>(wxLoginErr) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;微信登录失败&#x27;</span>)</span><br><span class="line">  <span class="comment">// 设置token</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 调用业务登录接口</span></span><br><span class="line">  <span class="keyword">const</span> [loginErr,loginRes] = awiat <span class="title function_">httpRequest</span>(loginlink,&#123;<span class="attr">code</span>: wxLoginRes.<span class="property">code</span> || <span class="string">&#x27;&#x27;</span>, ...token&#125;)</span><br><span class="line">  <span class="keyword">const</span> loginData = loginRes.<span class="property">result</span></span><br><span class="line">  <span class="keyword">if</span>(loginErr || !loginData) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(loginErr.<span class="property">errMsg</span>)</span><br><span class="line">  <span class="comment">// 从loginData中拿到服务端传来的token数据，sessionId 或sid二者一样，看服务断校验使用哪一个</span></span><br><span class="line">  <span class="comment">// 继续设置token</span></span><br><span class="line">  <span class="comment">// 全局存储用户信息</span></span><br><span class="line">  <span class="comment">// 返回用户信息  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、防止重复调用静默登录，处理静默登录判断，使用之前定义好的登录状态判断变量，因为静默登录每个页面都会触发才这样处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!_loginRecoed) &#123;</span><br><span class="line">  _loginRecord = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">_handleDefaultLogin</span>()</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;<span class="title function_">resolve</span>(res)&#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        _loginRecord = <span class="literal">null</span></span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果全局只调用一次设置完token之后使用wx.setStorageSync()存储在缓存中，然后根据token的存在判断是否需要重新登录</li>
</ul>
<p>8、在全局组件中去调用静默登录这个方法</p>
<!-- ### 跳过,不需要
优化: 在页面重复调用两次及以上时,只执行一次调用
step 1: 再写一个函数,然后在该函数中判断是否调用过,调用过就不执行,没有则执行---框架
step 2: 定义一个标签,用来判断是否已经调用过 --- 2
step 3: 在该函数传的参数是调用的函数 ---1
step 4: 返回一个函数,要携带参数返回 ---3
step 5: 已经调用返回不执行 ---4
step 6: 没有调用,重置标签,返回要调用的函数 ---5
step 7: 将这个函数赋值给一个变量,然后export ---6
step 8: 在页面就可以多次调用,但只执行一次 ---7 -->

<h2 id="优化"><a href="#优化" class="headerlink" title="优化:"></a>优化:</h2><h3 id="判断promise的登录状态-并行请求-先获取先展示"><a href="#判断promise的登录状态-并行请求-先获取先展示" class="headerlink" title="判断promise的登录状态(并行请求,先获取先展示)"></a>判断promise的登录状态(并行请求,先获取先展示)</h3><ol>
<li>在全局封装一个登录状态,调用时如果没有登录状态就将静态登录的状态赋值给它</li>
<li>然后await等待事件成功才继续执行下面的语句,没有成功不执行,最后完成重置状态</li>
</ol>
<h3 id="重复登录问题"><a href="#重复登录问题" class="headerlink" title="重复登录问题:"></a>重复登录问题:</h3><ol>
<li>在统一在登录逻辑哪里处理</li>
<li>在默认登录时设置登陆后缓存,缓存数据最好使用序列化,把类型变为string</li>
<li>写一个函数用来判断是否登录,获取缓存,判断有缓存,将数据反序列化后在设置token返回true</li>
<li>完成后在整个登录逻辑那里去调用该函数,判断是否为true,返回</li>
</ol>
<h3 id="登录校验问题"><a href="#登录校验问题" class="headerlink" title="登录校验问题:"></a>登录校验问题:</h3><ol>
<li>在不需要登录的路径上传参数cross,然后到请求页面中返回时从路径拿到cross</li>
<li>有cross时需与之前的data的合并</li>
<li>之后在请求方法中判断不存在cross则进行原先判断静默登录状态是否登录,存在则请求结果返回</li>
</ol>
<h3 id="解决路径调用api时无提示-不报错问题"><a href="#解决路径调用api时无提示-不报错问题" class="headerlink" title="解决路径调用api时无提示,不报错问题:"></a>解决路径调用api时无提示,不报错问题:</h3><ol>
<li>在全局中使用函数和简单索引类型</li>
<li>通过泛型让K遍历T中的每一项,返回T时拿到K</li>
<li>使用时就有提示</li>
</ol>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>登录流程</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-解决滚动到对应试图标签也随着动</title>
    <url>/2024/11/04/WeChatMini/%E8%A7%A3%E5%86%B3%E6%BB%9A%E5%8A%A8%E5%88%B0%E5%AF%B9%E5%BA%94%E8%A7%86%E5%9B%BE%E6%A0%87%E7%AD%BE%E4%B9%9F%E9%9A%8F%E7%9D%80%E5%8A%A8/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="点击对应标签-滚到到对应位置"><a href="#点击对应标签-滚到到对应位置" class="headerlink" title="点击对应标签,滚到到对应位置"></a>点击对应标签,滚到到对应位置</h2><blockquote>
<p>用于制作侧边导航栏，滚动到下一栏，左边title也跟着动</p>
</blockquote>
<p><img src="/../../img/WeChatMini/%E5%88%86%E7%B1%BB%E6%A0%8F%E7%9B%AE.png" alt="侧边分类栏目"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>scroll-view中的scroll-into-view</li>
<li>容器必须有<span class="key_words">『固定高度』</span>,子容器使用id</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>左边的侧边使用van-sidebar,使用它的activeKey,来动态将index传进函数中(不使用van-sidebar则需要使用mark:index来传递当前索引)</li>
<li>左边通过函数和传递的对应索引来修改scroll-into-view的索引</li>
<li>右边的scroll-view容器设置scroll-into-view，因为scroll-into-view的值时动态的，要在data中初始化为0</li>
<li>右边的子容器中id要跟scroll-into-view格式保持一致，确保跳转时能跳转到对应子容器上</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view <span class="keyword">class</span>=<span class="string">&quot;index-list-layout&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;index-list-refer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span> <span class="comment">// 参照物</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">class</span>=<span class="string">&quot;index-list index-list-sidebar&quot;</span> <span class="attr">scroll-y</span>&gt;</span> // 左边的标题栏</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">van-sidebar</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">custom-class</span>=<span class="string">&quot;sidebar-class&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">active-key</span>=<span class="string">&quot;&#123;&#123;sidebarIndex&#125;&#125;&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">bind:change</span>=<span class="string">&quot;onChangeSidebar&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;商品列表&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">van-sidebar-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">view</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span> <span class="attr">class</span>=<span class="string">&quot;van-multi-ellipsis--l2&quot;</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">van-sidebar-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">van-sidebar</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">scroll-view</span>  // <span class="attr">右边的内容商品栏</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">class</span>=<span class="string">&quot;index-list index-list-category&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">scroll-y</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">scroll-with-animation</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">scroll-into-view</span>=<span class="string">&quot;index-item-&#123;&#123;selectIndex&#125;&#125;&quot;</span> // <span class="attr">用来定位点击左边标题栏时定位右边容器</span>，<span class="attr">当知道selectIndex的数值</span>，<span class="attr">也会跳到对应item的columnIndex数值</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">block</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;商品列表&#125;&#125;&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">wx:for-item</span>=<span class="string">&quot;column&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">wx:for-index</span>=<span class="string">&quot;columnIndex&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">view</span> // <span class="attr">被参照物</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">id</span>=<span class="string">&quot;index-item-&#123;&#123;columnIndex&#125;&#125;&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">class</span>=<span class="string">&quot;index-list-item&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">data-index</span>=<span class="string">&quot;&#123;&#123;columnIndex&#125;&#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">view</span>&gt;</span> 商品内容省略<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span></span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="获取滚动时的节点信息"><a href="#获取滚动时的节点信息" class="headerlink" title="获取滚动时的节点信息"></a>获取滚动时的节点信息</h2><h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>创建一个监听器createIntersectionObserver</li>
<li>oberserveAll:true   监听所有节点</li>
<li>.relativeTo(参照物)  </li>
<li>.observe(被参照物)</li>
</ul>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>当左边侧边栏布局形成时,需要有一个参照物,可以在滚动布局上创建一个空的view,样式设置高1px,相对上一个位置绝对定位,左高为0</li>
<li>由于获取到被参照物中没有index,而我们需要index,在view中手动设置一个data-index<ul>
<li>也可以使用到van-sidebar,使用它的activeKey,来动态将index传进来,实现滚动到对应地方,标签也跟着改变(<span class="desc">例子使用van-sidebar</span>)</li>
</ul>
</li>
<li>左边有参照物，右边的整个商品滚动布局就作为被参照物</li>
<li>然后监听索引列表滚动的函数通过监听参照物与被参照物是否相交将对应的索引值传到dada中</li>
<li>该函数在商品列表渲染完成后使用nextTick调用</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">changeIndexListScroll</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> intersectionObserver = <span class="variable language_">this</span>.<span class="title function_">createIntersectionObserver</span>(&#123;</span><br><span class="line">    <span class="attr">observeAll</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  intersectionObserver</span><br><span class="line">    .<span class="title function_">relativeTo</span>(<span class="string">&#x27;.index-list-refer&#x27;</span>)</span><br><span class="line">    .<span class="title function_">observe</span>(<span class="string">&#x27;.index-list-item&#x27;</span>, <span class="function">(<span class="params">e: any</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> index = e.<span class="property">dataset</span>.<span class="property">index</span></span><br><span class="line">      <span class="keyword">const</span> intersectionRatio = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(e.<span class="property">intersectionRatio</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (intersectionRatio &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">          <span class="attr">sidebarIndex</span>: index,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>scroll-view</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-项目遇到的问题合集</title>
    <url>/2024/11/04/WeChatMini/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul>
<li>重复调用请求影响服务器性能尤其是全局调用时要多检查		</li>
<li>微信小程序的三目运算格式中冒号前后如果是字符串的一定要用双引号或单引号包起来，否则不生效。示例：a ? ‘b’ : ‘c’</li>
</ul>
<p>		</p>
<h2 id="tailwind-、taro-、小程序之间的问题"><a href="#tailwind-、taro-、小程序之间的问题" class="headerlink" title="tailwind 、taro 、小程序之间的问题"></a>tailwind 、taro 、小程序之间的问题</h2><h3 id="解决构建后生成的miniprogram-npm包太大，主包超过2M"><a href="#解决构建后生成的miniprogram-npm包太大，主包超过2M" class="headerlink" title="解决构建后生成的miniprogram_npm包太大，主包超过2M"></a>解决构建后生成的miniprogram_npm包太大，主包超过2M</h3><ul>
<li>在project.config.json中的setting设置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;ignoreDevUnusedFiles&quot;</span>: <span class="literal">true</span>, <span class="comment">// 预览、真机调试和本地模拟器等开发阶段是否过滤无依赖文件，默认为true</span></span><br><span class="line"><span class="string">&quot;ignoreUploadUnusedFiles&quot;</span>: <span class="literal">true</span> <span class="comment">// 上传时过滤无依赖文件</span></span><br></pre></td></tr></table></figure></li>
<li>其他配置参考<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html">微信小程序项目配置文件</a></li>
</ul>
<h3 id="解决vscode中ts插件与小程序的api的飘红线问题"><a href="#解决vscode中ts插件与小程序的api的飘红线问题" class="headerlink" title="解决vscode中ts插件与小程序的api的飘红线问题"></a>解决vscode中ts插件与小程序的api的飘红线问题</h3><ul>
<li>在typings&#x2F;index上添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;../node_modules/miniprogram-api-typings/index.d.ts&quot; /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解决tsconfig-json报错【找不到“sass”的类型定义文件。程序包含该文件是因为-隐式类型库-“sass”-的入口点】"><a href="#解决tsconfig-json报错【找不到“sass”的类型定义文件。程序包含该文件是因为-隐式类型库-“sass”-的入口点】" class="headerlink" title="解决tsconfig.json报错【找不到“sass”的类型定义文件。程序包含该文件是因为:隐式类型库 “sass” 的入口点】"></a>解决tsconfig.json报错【找不到“sass”的类型定义文件。程序包含该文件是因为:隐式类型库 “sass” 的入口点】</h3><ol>
<li>安装<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @types/sass@<span class="number">1.43</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></li>
<li>然后重启vscode</li>
<li>如果还飘红，则在tsconfig.json中添加以下配置项<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: [<span class="string">&quot;sass&quot;</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="解决tailwindcss和小程序的结合后-tailwind-base-之类的增加到app-scss中微信小程序报错【app-wxss-unexpected-token-“-”】"><a href="#解决tailwindcss和小程序的结合后-tailwind-base-之类的增加到app-scss中微信小程序报错【app-wxss-unexpected-token-“-”】" class="headerlink" title="解决tailwindcss和小程序的结合后 @tailwind base;之类的增加到app.scss中微信小程序报错【app.wxss unexpected token “;”】"></a>解决tailwindcss和小程序的结合后 @tailwind base;之类的增加到app.scss中微信小程序报错【app.wxss unexpected token “;”】</h3><ol>
<li>执行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx tailwindcss -o ./src/style/tailwind.<span class="property">css</span></span><br></pre></td></tr></table></figure></li>
<li>在index.html中的head标签添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link href=<span class="string">&quot;./style/tailwind.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="解决发现tailwind的样式在小程序中不生效"><a href="#解决发现tailwind的样式在小程序中不生效" class="headerlink" title="解决发现tailwind的样式在小程序中不生效"></a>解决发现tailwind的样式在小程序中不生效</h3><ul>
<li>参考文档：<a href="https://juejin.cn/post/7246328828838510653">Taro项目引入Tailwindcss的几种方式</a></li>
</ul>
<ol>
<li>安装<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -D tailwindcss postcss autoprefixer weapp-tailwindcss</span><br></pre></td></tr></table></figure></li>
<li>初始化配置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx tailwindcss init</span><br></pre></td></tr></table></figure></li>
<li>在tailwindcss.config.js增加配置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;tailwindcss&#x27;).Config</span>&#125; */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 不在 content 包括的文件内编写的 class，不会生成对应的工具类</span></span><br><span class="line">  <span class="attr">content</span>: [<span class="string">&#x27;./public/index.html&#x27;</span>, <span class="string">&#x27;./src/**/*.&#123;html,js,ts,jsx,tsx,vue&#125;&#x27;</span>],</span><br><span class="line">  <span class="comment">// 其他配置项</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">corePlugins</span>: &#123;</span><br><span class="line">    <span class="comment">// 不需要 preflight，因为这主要是给 h5 的，如果你要同时开发小程序和 h5 端，你应该使用环境变量来控制它</span></span><br><span class="line">    <span class="attr">preflight</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建postcss.config.js,并注册tailwindcss<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="comment">// 假如你使用的框架/工具不支持 postcss.config.js，则可以使用内联的写法</span></span><br><span class="line"><span class="comment">// 其中 `autoprefixer` 有可能已经内置了，假如框架内置了可以去除</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: &#123;</span><br><span class="line">    <span class="attr">tailwindcss</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">autoprefixer</span>: &#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在项目的配置文件 config&#x2F;index中注册weapp-tailwindcss:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/index.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">UnifiedWebpackPluginV5</span> &#125; = <span class="title function_">require</span>(<span class="params"><span class="string">&#x27;weapp-tailwindcss/webpack&#x27;</span></span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">mini</span>: &#123;</span><br><span class="line">    <span class="title function_">webpackChain</span>(<span class="params">chain, webpack</span>) &#123;</span><br><span class="line">      chain.<span class="title function_">merge</span>(&#123;</span><br><span class="line">        <span class="attr">plugin</span>: &#123;</span><br><span class="line">          <span class="attr">install</span>: &#123;</span><br><span class="line">            <span class="attr">plugin</span>: <span class="title class_">UnifiedWebpackPluginV5</span>,</span><br><span class="line">            <span class="attr">args</span>: [&#123;</span><br><span class="line">              <span class="attr">appType</span>: <span class="string">&#x27;taro&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>和@tarojs&#x2F;plugin-html 一起使用时，需要配置下 postcss-html-transform 这个插件，不然它会移除整个 Tailwindcss 注入的  css var 区域块，造成所有 tw-* 相关变量找不到。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/index.js</span></span><br><span class="line">config = &#123;</span><br><span class="line">  <span class="attr">mini</span>: &#123;</span><br><span class="line">    <span class="attr">postcss</span>: &#123;</span><br><span class="line">      <span class="attr">htmltransform</span>: &#123;</span><br><span class="line">        <span class="attr">enable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 设置成 false 表示 不去除 * 相关的选择器区块</span></span><br><span class="line">        <span class="comment">// 假如开启这个配置，它会把 tailwindcss 整个 css var 的区域块直接去除掉</span></span><br><span class="line">        <span class="comment">// 需要用 config 套一层，官方文档上是错的</span></span><br><span class="line">        <span class="attr">config</span>: &#123;</span><br><span class="line">          <span class="attr">removeCursorStyle</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在项目入口(app.scss)引入tailwindcss<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">&quot;tailwindcss/base&quot;</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">&quot;tailwindcss/utilities&quot;</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">&quot;tailwindcss/components&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="关于js、node配置的问题"><a href="#关于js、node配置的问题" class="headerlink" title="关于js、node配置的问题"></a>关于js、node配置的问题</h2><h3 id="运行js文件时"><a href="#运行js文件时" class="headerlink" title="运行js文件时"></a>运行js文件时</h3><ul>
<li>解决提示<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【Warning: To load an ES module, set &quot;type&quot; - &quot;module&quot; in JS】</span><br></pre></td></tr></table></figure></li>
<li>在package.json中配置type:”module”</li>
</ul>
<h3 id="运行js文件时-1"><a href="#运行js文件时-1" class="headerlink" title="运行js文件时"></a>运行js文件时</h3><ul>
<li>解决提示<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【Invalid package config E:\practice\p-four\node_modules\iconv-lite\package.json while importing &quot;iconv-lite&quot; from xxxx.js. Unexpected token &lt; in JSON at position 101】</span><br></pre></td></tr></table></figure></li>
<li>运行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><ul>
<li>解决提示<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【Error [ERR_MODULE_NOT_FOUND]: Cannot find module &#x27;xxx\config\webpack.common&#x27; imported from xxx\config\webpack.dev.js】</span><br></pre></td></tr></table></figure></li>
<li>把package.json的type去掉</li>
</ul>
<h3 id="运行项目网页"><a href="#运行项目网页" class="headerlink" title="运行项目网页"></a>运行项目网页</h3><ul>
<li>解决提示<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【Refused to apply style from &#x27;http://localhost:9000/comp/asset/main.css&#x27; because its MIME type (&#x27;text/html&#x27;) is not a supported stylesheet MIME type, and strict MIME checking is enabled.】</span><br></pre></td></tr></table></figure></li>
<li>webpack.config.js 添加 publicPath 属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;build.[contenthash:10].js&quot;</span>,</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>参考文章：<a href="https://juejin.cn/post/6979855519490474021">该文章最后一个问题</a></li>
</ul>
<h3 id="项目运行后"><a href="#项目运行后" class="headerlink" title="项目运行后"></a>项目运行后</h3><ul>
<li>解决刷新就会提示<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【GET http://localhost:9000/comp/asset/image/gongzuotai.png 404 (Not Found)】</span><br></pre></td></tr></table></figure></li>
<li>图片的路径不对，在所有使用图片的路径中使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">✔ /asset/image/xxx.<span class="property">jpg</span></span><br><span class="line">❌ asset/image.<span class="property">xxx</span>.<span class="property">jpg</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="遇到提示"><a href="#遇到提示" class="headerlink" title="遇到提示"></a>遇到提示</h3><ul>
<li>解决view…之类的标签报错问题或者template_v0_p1之类的问题，大概率是项目中不支持该标签</li>
<li>排查标签使用是否正确。例如：遇到页面使用div标签，然后用来小程序使用的view标签</li>
</ul>
<h3 id="npm报错"><a href="#npm报错" class="headerlink" title="npm报错"></a>npm报错</h3><ul>
<li>解决提示淘宝镜像过期<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request to <span class="attr">https</span>:<span class="comment">//registry.npm.taobao.org failed, reason certificate has expired&lt;/span&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>重新配置淘宝镜像<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">查看当前的npm镜像: npm config list</span><br><span class="line">清空缓存: npm cache clean --force</span><br><span class="line">修改镜像: </span><br><span class="line">  [推荐]npm config set registry <span class="attr">https</span>:<span class="comment">//registry.npmmirror.com</span></span><br><span class="line">  npm config set registry <span class="attr">https</span>:<span class="comment">//registry.npmjs.org/</span></span><br><span class="line">  npm config <span class="keyword">delete</span> registry</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="npm构建报错"><a href="#npm构建报错" class="headerlink" title="npm构建报错"></a>npm构建报错</h3><ul>
<li>解决构建不出miniprogram_npm</li>
<li>在project.config.json中添加配置   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;packNpmManually&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;packNpmRelationList&quot;</span>: [</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;packageJsonPath&quot;</span>: <span class="string">&quot;./package.json&quot;</span>,</span><br><span class="line">		<span class="string">&quot;miniprogramNpmDistDir&quot;</span>: <span class="string">&quot;./&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>问题与方案</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Worker</title>
    <url>/2024/10/31/network/Web%20Worker/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>是 HTML5 标准中提供的一项技术，可以让 JavaScript 脚本在后台线程运行，从而避免阻塞 UI 线程。</p>
</blockquote>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li>独立线程：可以创建一个独立的线程来执行JavaScript代码，从而避免在主线程中运行耗时任务的风险,使得主线程可以专注于用户交互和响应</li>
<li>沙箱环境：运行的JavaScript代码在一个受限的沙箱环境中，不能访问与主线程共享的DOM、全局变量等资源，从而保证了数据安全性和代码稳定性</li>
<li>事件通信：可以通过事件来与主线程进行通信，从而实现线程间的数据传递和同步操作</li>
<li>提高性能：可以改善因大量JS计算导致的卡顿问题，增强页面的稳定性和用户体验。</li>
<li>应用广泛：不仅可以在浏览器中运行，还可以在Node.js中运行</li>
</ul>
]]></content>
      <categories>
        <category>网络与数据结构</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Http请求-响应模式</title>
    <url>/2024/10/31/network/http%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="HTTP-协议规定"><a href="#HTTP-协议规定" class="headerlink" title="HTTP 协议规定"></a>HTTP 协议规定</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>B&#x2F;S：“Browser&#x2F;Server”的缩写，即“浏览器&#x2F;服务器”模式，在这种结构下，用户操作与交互的界面是通过浏览器来实现。</li>
<li>C&#x2F;S：“Client&#x2F;Server”的缩写，即“客户端&#x2F;服务器”模式。</li>
<li>DOM：文档对象模型。是 HTML 文档的对象表示同时也是外部内容(如 js)与 HTML 元素之间的接口</li>
<li>BOM：浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。BOM 比 DOM 更大，它包含 DOM。</li>
<li>GPU：图形处理器，擅长处理简单的任务，但同时跨多个内核。</li>
<li>CPU：中央处理器，计算机的大脑</li>
</ul>
<h3 id="缓存部分的术语"><a href="#缓存部分的术语" class="headerlink" title="缓存部分的术语"></a>缓存部分的术语</h3><ul>
<li>Expires：<ul>
<li>是<span class="key_words">『HTTP&#x2F;1.0控制网页缓存』</span>的字段，其值为服务器返回该请求<span class="key_words">『结果缓存的到期时间』</span>，即再次发起该请求时，如果客户端的时间小于 Expires 的值时，直接使用缓存结果。</li>
</ul>
</li>
<li>Cache-Control：在<span class="key_words">『HTTP&#x2F;1.1控制网页缓存』</span>中，主要取值：<ul>
<li>public：所有内容都将被缓存(客户端和代理服务器都可缓存)</li>
<li>private：所有内容只有客户端可以缓存，默认值</li>
<li>no-cache：客户端缓存内容，但是是否使用需经过协商缓存来验证决定</li>
<li>no-store：所有内容都不会被缓存，即不使用强制缓存和协商缓存</li>
<li>max-age&#x3D;xxx：缓存内容将在 xxx 秒后失效</li>
</ul>
</li>
<li>Last-Modified：<ul>
<li>服务器响应请求时，返回该资源文件在服务器<span class="key_words">『最后被修改的时间』</span></li>
</ul>
</li>
<li>If-Modified-Since：<ul>
<li>客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。</li>
<li>服务器收到该请求，根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，<span class="key_words">『若服务器的资源最后被修改时间大于If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则返回304，代表资源无更新，可继续使用缓存文件』</span></li>
</ul>
</li>
<li>Etag：<ul>
<li>服务器响应请求时，返回<span class="key_words">『当前资源文件的一个唯一标识』</span>(由服务器生成)</li>
</ul>
</li>
<li>If-None-Match：<ul>
<li>客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。</li>
<li>服务器收到该请求后，<span class="key_words">『根据If-None-Match的字段值与该资源在服务器Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件』</span>，状态码为 200</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Http-与-Https"><a href="#Http-与-Https" class="headerlink" title="Http 与 Https"></a>Http 与 Https</h2><ul>
<li>http：<ul>
<li>是一个客服端和服务端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议</li>
</ul>
</li>
<li>https：<ul>
<li>是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</li>
</ul>
</li>
</ul>
<h3 id="区别与优缺点"><a href="#区别与优缺点" class="headerlink" title="区别与优缺点"></a>区别与优缺点</h3><ul>
<li>从安全性能看：<ul>
<li>http 是<span class="key_words">『超文本传输协议，信息是明文传输』</span></li>
<li>https 是具有安全型的<span class="key_words">『ssl加密传输协议』</span>，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</li>
</ul>
</li>
<li>从端口上看：<ul>
<li>http 协议的默认端口是<span class="key_words">『80』</span></li>
<li>https 的默认端口是<span class="key_words">『43』</span></li>
</ul>
</li>
<li>从性能上看：<ul>
<li>https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li>
</ul>
</li>
<li>从缓存上看：<ul>
<li>https 缓存不如 http 高效，会增加数据开销</li>
</ul>
</li>
<li>从证书上看：<ul>
<li>https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高，SSL 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗</li>
</ul>
</li>
<li>总结：<span class="key_words">『https相对与http，耗电、高开销、有限制，但安全。』</span></li>
</ul>
<h3 id="http-工作原理"><a href="#http-工作原理" class="headerlink" title="http 工作原理"></a>http 工作原理</h3><ul>
<li>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。客户端向服务器发送一个请求报文，服务器以一个状态行作为响应。</li>
</ul>
<h3 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a>https 协议的工作原理</h3><ul>
<li>客户端在使用 https 方式与 Web 服务器通信时经历以下几个步骤：</li>
</ul>
<ol>
<li>客户端使用<span class="key_words">『https url 访问服务器』</span>，则要求 web 服务器建立 ssl 链接</li>
<li><span class="key_words">『web服务器</span>收到客户端的请求后，会将<span class="key_words">『网站的证书(证书中包含了公钥)，传输给客户端』</span></li>
<li>客户端和 web 服务器开始协商 SSL 链接的安全等级，即<span class="key_words">『加密等级』</span></li>
<li>客户端浏览器通过上方协商一致的安全等级，<span class="key_words">『建立会话密钥』</span>，然后通过<span class="key_words">『网站的公钥来加密会话密钥』</span>，并传送给网站</li>
<li>web 服务器通过自己的<span class="key_words">『私钥解密出会话密钥』</span></li>
<li>web 服务器通过<span class="key_words">『会话密钥加密』</span>与客户端之间的<span class="key_words">『通信』</span></li>
</ol>
<hr>
<h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><ul>
<li>注：<span class="desc">SYN：同步序列编号</span></li>
<li>第一次握手：<ul>
<li>建立连接时，<span class="key_words">『客户端发送syn包(syn&#x3D;j)到服务器』</span>，并进入SYN_SENT状态，等待服务器确认;</li>
</ul>
</li>
<li>第二次握手：<ul>
<li><span class="key_words">『服务器收到syn包并确认』</span>客户的SYN(ack&#x3D;j+1),同时也<span class="key_words">『发送』</span>一个自己的SYN包(syn&#x3D;k),即<span class="key_words">『SYN+ACK』</span> 包，此时服务器进入SYN_RECV状态</li>
</ul>
</li>
<li>第三次握手：<ul>
<li><span class="key_words">『客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK</span>(ack&#x3D;k+1),此包发送完毕，客户端和服务器进入ESTABLISHED(TCP 连接成功)状态，<span class="key_words">『完成三次握手』</span></li>
</ul>
</li>
<li>注：<span class="desc">三次握手完成后，客户端与服务器才正式开始传送数据</span></li>
</ul>
<hr>
<h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><ol>
<li><span class="key_words">『客户端进程发出连接释放报文，并停止发送数据。释放数据报文首部』</span><ul>
<li>FIN&#x3D;1，其序列号 seq&#x3D;u(<span class="desc">&#x3D;前面已经传送过来的数据的最后一个字节的序号+1</span>)，<span class="key_words">『客户端进入 FIN-WAIT-1』</span>(终止等待 1)状态。</li>
<li><span class="desc">TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号</span></li>
</ul>
</li>
<li><span class="key_words">『服务器收到连接释放报文，发出确认报文』</span><ul>
<li>ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号 seq&#x3D;v，<span class="key_words">『服务端进入 CLOSE-WAIT 状态』</span>（关闭等待）</li>
<li>TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即<span class="desc">客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受</span>。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</li>
</ul>
</li>
<li><span class="key_words">『客户端收到服务器的确认请求后，客户端就进入 FIN-WAIT-2』</span>（终止等待 2）状态，等待服务器发送连接释放报文（<span class="desc">在这之前还需要接受服务器发送的最后的数据</span>）</li>
<li><span class="key_words">『服务器将最后的数据发送完毕后，就向客户端发送连接释放报文』</span><ul>
<li>FIN&#x3D;1，ack&#x3D;u+1，</li>
<li>由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq&#x3D;w，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
</ul>
</li>
<li><span class="key_words">『客户端收到服务器的连接释放报文后，必须发出确认』</span><ul>
<li>ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是 seq&#x3D;u+1，客户端就进入了 TIME-WAIT（时间等待）状态。</li>
<li>注意<span class="desc">此时 TCP 连接还没有释放</span>，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</li>
</ul>
</li>
<li><span class="key_words">『服务器只要收到客户端发出的确认，立即进入CLOSED状态』</span>。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，<span class="desc">服务器结束 TCP 连接的时间要比客户端早一些。</span><br><img src="/../../img/network/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="tcp四次挥手"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<hr>
<h2 id="TCP-IP-如何保证数据包传输的有序可靠"><a href="#TCP-IP-如何保证数据包传输的有序可靠" class="headerlink" title="TCP&#x2F;IP 如何保证数据包传输的有序可靠"></a>TCP&#x2F;IP 如何保证数据包传输的有序可靠</h2><blockquote>
<p>对字节流分段并进行编号然后通过 <span class="key_words">『ACK 回复』</span>和<span class="key_words">『超时重发』</span>这两个机制来保证。</p>
</blockquote>
<ol>
<li>为了保证数据包的可靠传递，<span class="key_words">『发送方必须把已发送的数据包保留在缓冲区』</span></li>
<li>为<span class="key_words">『每个已发送的数据包启动一个超时定时器』</span></li>
<li>如在定时器<span class="key_words">『超时之前收到了对方发来的应答』</span>信息（<span class="desc">可能是对本包的应答，也可以是对本包后续包的应答</span>），则<span class="key_words">『释放该数据包占用的缓冲区』</span></li>
<li><span class="key_words">『否则，重传』</span>该数据包，<span class="key_words">『直到收到应答或重传次数超过规定的最大次数』</span>为止。</li>
<li><span class="key_words">『接收方收到数据包后，先进行CRC校验，如果正确』</span>则把数据交给上层协议，然后给<span class="key_words">『发送方发送一个累计应答包』</span>，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</li>
</ol>
<hr>
<h2 id="OSI-模型与-TCP-IP-协议"><a href="#OSI-模型与-TCP-IP-协议" class="headerlink" title="OSI 模型与 TCP&#x2F;IP 协议"></a>OSI 模型与 TCP&#x2F;IP 协议</h2><blockquote>
<p>国际标准化组织（ISO）在 1978 年提出了“开放系统互联参考模型”，即著名的 OSI&#x2F;RM 模型（Open System Interconnection&#x2F;Reference Model）<br><img src="/../../img/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%9B%BE.webp" alt="计算机网络体系结构的通信协议图"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</blockquote>
<hr>
<h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文，有单播，多播，广播的功能</td>
<td>面向字节流，仅支持单播传输</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅 8 字节</td>
<td>首部最小 20 字节，最大 60 字节</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能一对一通信</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用</td>
<td>适用于要求可靠传输的应用</td>
</tr>
</tbody></table>
<hr>
<h2 id="HTTP-请求与响应"><a href="#HTTP-请求与响应" class="headerlink" title="HTTP 请求与响应"></a>HTTP 请求与响应</h2><ul>
<li>应答模式，分为七阶段</li>
</ul>
<h3 id="1-建立-TCP-连接"><a href="#1-建立-TCP-连接" class="headerlink" title="1. 建立 TCP 连接"></a>1. 建立 TCP 连接</h3><ul>
<li><span class="key_words">『HTTP工作开始之前』</span>，Web 浏览器首先要通过<span class="key_words">『网络与Web服务器建立连接』</span></li>
<li><span class="key_words">『通过TCP连接』</span>，该协议与 IP 协议共同构建 Internet，即著名的 TCP&#x2F;IP 协议，因此 Internet 又被称作是 TCP&#x2F;IP 网络。</li>
<li>HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要<span class="key_words">『三次握手建立TCP连接』</span>（<span class="desc">一般 TCP 连接的端口号是 80</span>），之后才<span class="key_words">『开始http请求』</span></li>
</ul>
<h3 id="2-Web-浏览器向-Web-服务器发送请求行命令"><a href="#2-Web-浏览器向-Web-服务器发送请求行命令" class="headerlink" title="2. Web 浏览器向 Web 服务器发送请求行命令"></a>2. Web 浏览器向 Web 服务器发送请求行命令</h3><ul>
<li>一旦建立了 TCP 连接，<span class="key_words">『Web浏览器就会向Web服务器发送请求』</span>命令，</li>
<li>例如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> / <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Web-浏览器发送请求头信息"><a href="#3-Web-浏览器发送请求头信息" class="headerlink" title="3. Web 浏览器发送请求头信息"></a>3. Web 浏览器发送请求头信息</h3><ul>
<li>浏览器发送其请求命令之后，还要<span class="key_words">『以头信息的形式向Web服务器发送一些别的信息』</span></li>
<li>之后浏览器发送了<span class="key_words">『一空白行来通知服务器，头信息的发送已经结束』</span>。</li>
</ul>
<h3 id="4-Web-服务器回送响应行"><a href="#4-Web-服务器回送响应行" class="headerlink" title="4. Web 服务器回送响应行"></a>4. Web 服务器回送响应行</h3><ul>
<li><span class="key_words">『客户机向服务器发出请求后，服务器向客户机回送应答信息』</span></li>
<li>例如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-Web-服务器回送响应头"><a href="#5-Web-服务器回送响应头" class="headerlink" title="5. Web 服务器回送响应头"></a>5. Web 服务器回送响应头</h3><ul>
<li>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送信息</li>
</ul>
<h3 id="6-Web-服务器回送响应体"><a href="#6-Web-服务器回送响应体" class="headerlink" title="6. Web 服务器回送响应体"></a>6. Web 服务器回送响应体</h3><ul>
<li>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就<span class="key_words">『以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据』</span>，即响应体 。</li>
</ul>
<h3 id="7-Web-服务器关闭-TCP-连接"><a href="#7-Web-服务器关闭-TCP-连接" class="headerlink" title="7. Web 服务器关闭 TCP 连接"></a>7. Web 服务器关闭 TCP 连接</h3><ul>
<li>一般情况下，一旦<span class="key_words">『Web服务器向浏览器发送了请求数据，它就要关闭TCP连接』</span>，然后如果浏览器或者服务器在其<span class="key_words">『头信息加入Connection:keep-alive，TCP连接在发送后将仍然保持打开状态』</span>，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。<ul>
<li>每一次请求-响应都是<span class="key_words">『独立的，互不干扰』</span>，这种模式的协议称之为无状态协议</li>
<li>每次请求-响应传递的<span class="key_words">『消息都是纯文本』</span>（字符串），而且文本格式必须按照 HTTP 协议规定的格式书写</li>
</ul>
</li>
</ul>
<hr>
<h2 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h2><h3 id="跨域的原理"><a href="#跨域的原理" class="headerlink" title="跨域的原理"></a>跨域的原理</h3><ul>
<li>跨域：是指浏览器不能执行其他网站的脚本。它是由浏览器的<span class="key_words">『同源策略』</span>造成的</li>
<li><span class="key_words">『同源策略』</span>：<ul>
<li>是指浏览器对 js 实施的安全限制，只要<span class="key_words">『协议、域名、端口有任何一个不同，都被当作是不同的域』</span></li>
</ul>
</li>
<li>跨域原理：通过各种方式，避开浏览器的安全限制</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><ul>
<li>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的连接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，以此实现跨域。</li>
<li><span class="key_words">『缺点：只支持get』</span>，因为 script 标签只能适用 get 请求；JSONP 需要后端配合返回指定格式的数据。</li>
<li>步骤：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 动态创建script</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个自定义函数，来接受返回的数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 设置script的src属性，并设置接口请求地址,接口参数一定要带一个自定义函数名</span></span><br><span class="line">script.<span class="property">src</span> = <span class="attr">http</span>:<span class="string">&#x27;localhost:3000/?callback=getData&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><ul>
<li>基础域名相同，子域名不同</li>
</ul>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><ul>
<li>利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name</li>
</ul>
<h3 id="CORS-跨资源共享"><a href="#CORS-跨资源共享" class="headerlink" title="CORS 跨资源共享"></a>CORS 跨资源共享</h3><ul>
<li>服务器设置对 CORS 的支持原理：服务器设置 Access-Control-Allow-Origin HTTP 响应头之后，浏览器将会允许跨域请求</li>
</ul>
<h3 id="proxy-代理"><a href="#proxy-代理" class="headerlink" title="proxy 代理"></a>proxy 代理</h3><ul>
<li>目前常用方式，通过服务器设置代理</li>
</ul>
<h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage()"></a>window.postMessage()</h3><ul>
<li>利用 h5 新特性</li>
</ul>
<hr>
<h2 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h2><blockquote>
<p>TCP 粘包是指<span class="key_words">『发送方』</span>发送的若干包数据到<span class="key_words">『接收方』</span>接收时粘成一包，从接收缓冲区看，后一包数据的<span class="key_words">『头紧接』</span>着前一包数据的<span class="key_words">『尾』</span>。UDP 不会出现粘包，因为它有消息边界</p>
</blockquote>
<h3 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h3><ul>
<li>粘在一起的包都是完整的数据包</li>
<li>粘在一起的包有不完整的包</li>
</ul>
<h3 id="避免措施"><a href="#避免措施" class="headerlink" title="避免措施"></a>避免措施</h3><ul>
<li>对于<span class="key_words">『发送方』</span>引起的粘包现象，用户可通过编程设置来避免，<ul>
<li><span class="key_words">『TCP提供强制数据立即传送的操作指令push』</span>，TCP 软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</li>
<li>缺点：关闭了优化算法，降低了网络发送效率，影响应用程序性能，不建议使用</li>
</ul>
</li>
<li>对于<span class="key_words">『接收方』</span>引起的粘包，则可通过优化程序设计、精简接收进程工作量、<span class="key_words">『提高接收进程优先级』</span>等措施，使其及时接收数据，从而尽量避免出现粘包现象；<ul>
<li>缺点：只能减少不能避免，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包</li>
</ul>
</li>
<li><span class="key_words">『由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并』</span>，通过这种手段来避免粘包。分包多发。<ul>
<li>缺点：应用程序效率较低，不适合实时应用的场合</li>
</ul>
</li>
<li><span class="key_words">『接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开』</span> (<span class="desc">高效可行</span>)</li>
</ul>
<hr>
<h2 id="HTTP-请求和响应格式"><a href="#HTTP-请求和响应格式" class="headerlink" title="HTTP 请求和响应格式"></a>HTTP 请求和响应格式</h2><ul>
<li>在任意页面中F12的控制面板点击网络，点击对应 api 可观测</li>
</ul>
<h3 id="http-请求格式由四部分组成：请求行、请求头、空行、消息体"><a href="#http-请求格式由四部分组成：请求行、请求头、空行、消息体" class="headerlink" title="http 请求格式由四部分组成：请求行、请求头、空行、消息体"></a>http 请求格式由四部分组成：请求行、请求头、空行、消息体</h3><ul>
<li>请求行：<span class="desc">高度概括了客户端想要干什么</span><ul>
<li>整个 HTTP 报文的第一行字符串，由请求方式（GET&#x2F;POST&#x2F;DELETE&#x2F;PUT）、请求路径+参数+hash、http&#x2F;版本号组成</li>
<li>GET 和 DELETE 不能有请求体，而 POST 和 PUT 请求可以有请求体</li>
</ul>
</li>
<li>请求头：<span class="desc">以键值对的方式描述了请求的一些额外信息,下面列举几个主要关注的</span><ul>
<li>Host：url 地址中的主机，也就是域名+端口</li>
<li>User-Agent：客户端的信息描述</li>
<li>Content-Type：<ul>
<li>application&#x2F;x-www-form-urlencoded：表示请求体的数据和 url 地址中参数的格式一样</li>
<li>application&#x2F;json：表示请求体的数据是 json 格式</li>
<li>multipart&#x2F;form-data：一种特殊的请求体格式，上传文件一般选择该格式</li>
<li>text&#x2F;plain：表示纯文本</li>
</ul>
</li>
</ul>
</li>
<li>请求体：<span class="desc">包含了要</span>给服务器传递的正文数据，请求体是可以省略的，要与请求头里的 Content-Type 字段一致<ul>
<li>application&#x2F;x-www-form-urlencoded：属性名&#x3D;属性值&amp;属性名&#x3D;属性值…</li>
<li>application&#x2F;json：{“属性名”:”属性值”, “属性名”:”属性值”}</li>
<li>multipart&#x2F;form-data：使用某个随机字符作为属性之间的分隔符，通常用于文件上传</li>
</ul>
</li>
</ul>
<h3 id="http-响应格式由四部分组成：状态行、响应头、空行、消息体"><a href="#http-响应格式由四部分组成：状态行、响应头、空行、消息体" class="headerlink" title="http 响应格式由四部分组成：状态行、响应头、空行、消息体"></a>http 响应格式由四部分组成：状态行、响应头、空行、消息体</h3><ul>
<li>状态行：整个响应字符串的第一行，由 http 版本号、状态码、状态说明组成</li>
<li>响应头：响应头是服务器传递给客户端用于说明服务器的一些信息，由多个键值对组成</li>
<li>在 B&#x2F;S 模式中，浏览器会自动根据响应头中的 Content-Type 的取值，决定如何处理响应体<ul>
<li>text&#x2F;plain：普通的文本，浏览器通常会将响应体原封不动的显示到页面上</li>
<li>text&#x2F;html：HTML 文档，浏览器会将响应体作为页面进行渲染</li>
<li>text&#x2F;javascript 或 application&#x2F;javascript：js 代码，浏览器会使用 JS 引擎将它解析执行</li>
<li>text&#x2F;css：css 代码，浏览器会将其视为样式</li>
<li>image&#x2F;jpeg：浏览器会将其视为 jpg 图片</li>
<li>attachment：附件，浏览器看到整个类型，会触发下载功能</li>
<li>其他 MIME 类型</li>
</ul>
</li>
<li>响应体：就是服务器返回的数据信息</li>
</ul>
<hr>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><table>
<thead>
<tr>
<th>分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2xx</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<ul>
<li>通常认为 0-399 之间的状态码时正常的</li>
<li>301 Moved Permanently：资源已被永久重定向，<span class="key_words">『有缓存』</span>，新的地址在请求头的 Location，请求新地址</li>
<li>302 Found：资源已被临时重定向，<span class="key_words">『无缓存』</span>，新的地址在请求头的 Location，请求新地址</li>
<li>304 Not Modified：文档内容未被修改，内容未更改，不提供新数据，仍继续使用旧数据，协商缓存生效</li>
<li>400 Bad Request：语义有误，当前请求无法被服务器理解</li>
<li>403 Forbidden：服务器拒绝执行</li>
<li>404 Not Found：资源不存在</li>
<li>500 Internal Server Error：服务器内部错误</li>
</ul>
<hr>
<h2 id="服务器的-http-超时"><a href="#服务器的-http-超时" class="headerlink" title="服务器的 http 超时"></a>服务器的 http 超时</h2><ul>
<li><h3 id="请求超时"><a href="#请求超时" class="headerlink" title="请求超时"></a>请求超时</h3><ul>
<li>客户端发起一个请求，通信层开始请求与服务器建立连接（包括在重试），如果 5S 之内还没有连接到服务器，那么认为超时</li>
</ul>
</li>
<li><h3 id="响应超时"><a href="#响应超时" class="headerlink" title="响应超时"></a>响应超时</h3><ul>
<li>URLConnection 类常见的超时处理就是调用其 setConnectTimeout 和 setReadTimeout 方法：<ul>
<li>setConnectTimeout：设置连接主机超时（单位：毫秒）</li>
<li>setReadTimeout：设置从主机读取数据超时（单位：毫秒）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="用户请求页面的完整过程-简"><a href="#用户请求页面的完整过程-简" class="headerlink" title="用户请求页面的完整过程(简)"></a>用户请求页面的完整过程(简)</h2><ul>
<li>dns 解析，获取 ip 地址及端口；</li>
<li>建立 TCP 连接，3 次握手；</li>
<li>发送 HTTP 请求报文；</li>
<li>服务器接收请求并作处理；</li>
<li>服务器发送 HTTP 响应报文；</li>
<li>断开 TCP 连接，4 次挥手</li>
<li>浏览器解析返回数据，并渲染 html 页面</li>
</ul>
<hr>
<h2 id="从输入-URL-到页面加载的全过程-全"><a href="#从输入-URL-到页面加载的全过程-全" class="headerlink" title="从输入 URL 到页面加载的全过程(全)"></a>从输入 URL 到页面加载的全过程(全)</h2><blockquote>
<p><img src="/../../img/network/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B.jpg" alt="从输入URL到页面加载的全过程"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</blockquote>
<h3 id="1-在浏览器中输入-URL"><a href="#1-在浏览器中输入-URL" class="headerlink" title="1.在浏览器中输入 URL"></a>1.在浏览器中输入 URL</h3><h3 id="2-查找缓存："><a href="#2-查找缓存：" class="headerlink" title="2.查找缓存："></a>2.查找缓存：</h3><ul>
<li>浏览器会从以下几个缓存中查找是否有该地址页面，有则显示页面内容。没有下一步。<ul>
<li>浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求；</li>
<li>系统缓存：如果浏览器缓存中没找到，则调用操作系统，获取操作系统的记录(保存最近的 DNS 查询缓存)</li>
<li>路由器缓存：上面没有获取到 DNS 记录，从路由器缓存找</li>
<li>ISP 缓存：都失败，找 ISP 缓存</li>
</ul>
</li>
</ul>
<h3 id="3-DNS-域名解析："><a href="#3-DNS-域名解析：" class="headerlink" title="3.DNS 域名解析："></a>3.DNS 域名解析：</h3><ul>
<li>浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址。DNS 服务器是基于 UDP 的，因此会用到 UDP 协议。</li>
</ul>
<h3 id="4-建立-TCP-连接："><a href="#4-建立-TCP-连接：" class="headerlink" title="4.建立 TCP 连接："></a>4.建立 TCP 连接：</h3><ul>
<li>解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接</li>
</ul>
<h3 id="5-发起-HTTP-请求："><a href="#5-发起-HTTP-请求：" class="headerlink" title="5.发起 HTTP 请求："></a>5.发起 HTTP 请求：</h3><ul>
<li>浏览器发起读取文件的 HTTP 请求，该请求报文作为 TCP 三次握手的第三次数据发送给服务器</li>
</ul>
<h3 id="6-服务器响应请求并返回结果："><a href="#6-服务器响应请求并返回结果：" class="headerlink" title="6.服务器响应请求并返回结果："></a>6.服务器响应请求并返回结果：</h3><ul>
<li>服务器对浏览器请求做出响应，并把对应的 html 文件发送给浏览器</li>
</ul>
<h3 id="7-关闭-TCP-连接："><a href="#7-关闭-TCP-连接：" class="headerlink" title="7.关闭 TCP 连接："></a>7.关闭 TCP 连接：</h3><ul>
<li>通过四次挥手释放 TCP 连接</li>
</ul>
<h3 id="8-浏览器渲染："><a href="#8-浏览器渲染：" class="headerlink" title="8.浏览器渲染："></a>8.浏览器渲染：</h3><ul>
<li>客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后的解析流程为： <ul>
<li>构建 DOM 树：<ul>
<li>HTML 解析器将 HTML 标记解析成 DOM Tree，它是由 dom 元素及属性节点构成，树的根节点是 document 对象</li>
</ul>
</li>
<li>构建 CSS 规则树：生成 CSS 规则树 </li>
<li>构建 render 树：<ul>
<li>DOM 树构建的同时构建渲染树，由可视化元素按照其显示顺序而组成。处理 html 和 body 标记就会构建渲染树根节点</li>
</ul>
</li>
<li>布局：计算出每个节点在屏幕中的位置和大小信息</li>
<li>绘制：遍历 render 树，并使用 UI 后端层绘制每个节点<br><img src="/../../img/network/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93.jpg" alt="浏览器渲染"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="9-JS-引擎解析过程："><a href="#9-JS-引擎解析过程：" class="headerlink" title="9.JS 引擎解析过程："></a>9.JS 引擎解析过程：</h3><ul>
<li>调用 JS 引擎执行 JS 代码（<span class="desc">JS 的解释阶段，预处理阶段，执行阶段生成执行上下文，VO(View Object)，作用域链、回收机制等</span>）<ul>
<li>创建 window 对象：<ul>
<li>window 对象也叫全局执行环境，当<span class="key_words">『页面产生时就被创建』</span>，所有的全局变量和函数都属于 window 的属性和方法，而 DOM Tree 也会映射在 window 的 doucment 对象上。</li>
<li>当<span class="key_words">『关闭网页或关闭浏览器时，全局执行环境会被销毁』</span>。</li>
</ul>
</li>
<li>加载文件：<ul>
<li>完成 js 引擎分析它的语法与词法是否合法，如果合法进入预编译</li>
</ul>
</li>
<li>预编译：<ul>
<li>在预编译的过程中，浏览器会寻找全局变量声明，把它作为 window 的属性加入到 window 对象中，并给变量赋值为’undefined’；</li>
<li>寻找全局函数声明，把它作为 window 的方法加入到 window 对象中，并将函数体赋值给他（<span class="desc">匿名函数是不参与预编译的，因为它是变量</span>）。</li>
<li>而变量提升作为不合理的地方在 ES6 中已经解决了，函数提升还存在。</li>
</ul>
</li>
<li>解释执行：<ul>
<li>执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在 ES5 非严格模式下这个变量会成为 window 的一个属性，也就是成为全局变量。</li>
<li>string、int 这样的值就是直接把值放在变量的存储空间里，object 对象就是把指针指向变量的存储空间。</li>
<li>函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS 作用域其实就是这样的执行流机制实现的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="重绘和重排"><a href="#重绘和重排" class="headerlink" title="重绘和重排"></a>重绘和重排</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>重排&#x2F;回流（Reflow）：当 DOM 的变化影响了元素的几何信息，浏览器需要<span class="key_words">『重新计算元素的几何属性』</span>，将其安放在界面中的正确位置，这个过程叫做重排。<span class="key_words">『表现为重新生成布局，重新排列元素』</span>。</li>
<li>重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。<span class="key_words">『表现为某些元素的外观被改变』</span></li>
<li>注：<span class="desc">重绘不一定会出现重排，重排必然会出现重绘</span></li>
</ul>
<h3 id="如何触发"><a href="#如何触发" class="headerlink" title="如何触发"></a>如何触发</h3><ul>
<li>添加、删除、更新 DOM 节点</li>
<li>通过 display: none 隐藏一个 DOM 节点 (<span class="desc">触发重排和重绘</span>)</li>
<li>通过 visibility: hidden 隐藏一个 DOM 节点 (<span class="desc">只触发重绘，因为没有几何变化</span>)</li>
<li>移动或者给页面中的 DOM 节点添加动画</li>
<li>添加一个样式表，调整样式属性</li>
<li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li>
</ul>
<h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><ul>
<li>集中改变样式，不要一条修改</li>
<li>不要把 DOM 结点的属性值放在循环里当成循环里的变量</li>
<li>为动画的 HTML 元件使用 fixed 或 absolute 的 position，那么修改他们的 CSS 是不会 reflow 的</li>
<li>不使用 table 布局</li>
<li>尽量只修改 position：absolute 或 fixed 元素</li>
<li>动画开始 GPU 加速，translate 使用 3D 变化</li>
<li>提升为合成层<ul>
<li>优点：<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理快</li>
<li>当需要重绘时，只重绘本身，不影响其他</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
</li>
<li>方式：使用 css 的 will-change 属性，例<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#target</span>&#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h2><blockquote>
<p><img src="/../../img/network/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.jpg" alt="缓存机制"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</blockquote>
<ul>
<li>关键点+结论<ul>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>
</ul>
</li>
</ul>
<h3 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h3><blockquote>
<p>根据是否需要向服务器重新发起 HTTP 请求</p>
</blockquote>
<h3 id="强制缓存-—-不需要向服务器发起请求"><a href="#强制缓存-—-不需要向服务器发起请求" class="headerlink" title="强制缓存 — 不需要向服务器发起请求"></a>强制缓存 — <span class="desc">不需要向服务器发起请求</span></h3><blockquote>
<p>向浏览器缓存查找请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</p>
</blockquote>
<ul>
<li>规则：浏览器向服务器发起请求，服务器会将缓存规则放入 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别时 Expires 和 Cache-Control，其中 ache-Control 优先级高</li>
<li>三种情况：<ul>
<li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li>
<li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li>
<li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li>
</ul>
</li>
</ul>
<h3 id="协商缓存-—-需要向服务器发起请求"><a href="#协商缓存-—-需要向服务器发起请求" class="headerlink" title="协商缓存 — 需要向服务器发起请求"></a>协商缓存 — <span class="desc">需要向服务器发起请求</span></h3><blockquote>
<p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</p>
</blockquote>
<ul>
<li>规则：协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<ul>
<li>Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match</li>
<li>其中 Etag &#x2F; If-None-Match 的优先级比 Last-Modified &#x2F; If-Modified-Since 高。</li>
</ul>
</li>
<li>两种情况<ul>
<li>协商缓存生效，返回 304</li>
<li>协商缓存失效，返回 200 和请求结果</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>浏览器缓存分为强制缓存和协商缓存，<span class="key">强制缓存优先于协商缓存』</span>进行。</li>
<li>若<span class="key_words">『强制缓存』</span>(Expires 和 Cache-Control,Cache-Control优先级高)<span class="key_words">『生效则直接使用缓存』</span></li>
<li>若<span class="key_words">『不生效则进行协商缓存』</span>(Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match，其中Etag &#x2F; If-None-Match的优先级高)，协商缓存由服务器决定是否使用缓存</li>
<li>若<span class="key_words">『协商缓存失效』</span>，那么代表该请求的缓存失效，<span class="key_words">『重新获取请求结果，再存入浏览器缓存』</span>中；生效则返回304，继续使用缓存</li>
</ul>
<hr>
<h2 id="304-过程"><a href="#304-过程" class="headerlink" title="304 过程"></a>304 过程</h2><ul>
<li>浏览器请求资源时首先进行强制缓存，命中 Expires 和 Cache-Control，Expires 受限于本地时间，<ul>
<li>如果修改本地时间会造成缓存失效，可以通过 Cache-control: max-age 指定最大生命周期，状态仍然返回 200，但不会请求数据，在浏览器中能明显看到 from cache 字样。</li>
</ul>
</li>
<li>强缓存失效，进入协商缓存阶段，首先验证 ETag&#x2F;If-None-Match。<ul>
<li>服务器根据客户端发送的的 If-None-Match 值和 ETag 来判断是否命中缓存。</li>
</ul>
</li>
<li>协商缓存 Last-Modify&#x2F;If-Modify-Since 阶段，<ul>
<li>客户端第一次请求资源时，服务服返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。</li>
<li>再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。</li>
<li>服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><ul>
<li>一个具有一定独立功能的程序在一个数据集上的一次动态<span class="key_words">『执行的过程』</span>，是操作系统进行资源分配和调度的一个<span class="key_words">『独立单位』</span>，是应用程序运行的<span class="key_words">『载体』</span>。进程由内存空间和一个或多个线程组成</li>
</ul>
<h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><ul>
<li>程序执行中一个单一的顺序控制流程，是程序执行流的<span class="key_words">『最小单位』</span>，是处理调度和分派的<span class="key_words">『基本单位』</span>。一个进程可以由一个或多个线程，各个线程之间共享程序的内存空间。一个标准的线程由线程 ID、当前指令指针、寄存器和堆栈组成。</li>
</ul>
<h3 id="协程："><a href="#协程：" class="headerlink" title="协程："></a>协程：</h3><ul>
<li>是一种基于线程之上，但又<span class="key_words">『比线程更加轻量级的存在』</span>，这种由程序员自己写程序来管理的轻量级线程叫做<span class="key_words">『用户空间线程』</span>，具有对内核来说不可见的特性。</li>
</ul>
<h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><ul>
<li>调度：<ul>
<li>线程作为调度和分配的基本单位</li>
<li>进程作为拥有资源的基本单位</li>
</ul>
</li>
<li>并发性：<ul>
<li>不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</li>
</ul>
</li>
<li>拥有资源：<ul>
<li>进程是拥有资源的一个独立单位</li>
<li>线程不拥有系统资源，但可以访问隶属于进程的资源</li>
</ul>
</li>
<li>系统开销：<ul>
<li>在创建或撤消进程时，系统的开销明显大于创建或撤消线程时的开销。</li>
<li>进程有独立的地址空间，一个进程崩溃后，不会影响其它进程，而线程只是一个进程中的不同执行路径。</li>
<li>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉</li>
<li>多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率较差。</li>
</ul>
</li>
</ul>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ul>
<li>一个线程只能属于一个进程，而一个进程可以由多个线程，但至少有一个线程</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源</li>
<li>处理及分给线程，即真正在处理机上运行的是线程</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li>
</ul>
<hr>
<h2 id="CDN-—-Content-Ddistribute-Network，即内容分发网络"><a href="#CDN-—-Content-Ddistribute-Network，即内容分发网络" class="headerlink" title="CDN — Content Ddistribute Network，即内容分发网络"></a>CDN — <span class="desc">Content Ddistribute Network，即内容分发网络</span></h2><ul>
<li>目的：<ul>
<li>解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。</li>
<li>使用户可就近取得所需内容，解决 Internet 网络拥挤的状况，提高用户访问网站的响应速度和成功率</li>
<li>尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性</li>
</ul>
</li>
<li>优势<ul>
<li>加速网站的访问</li>
</ul>
</li>
</ul>
<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><blockquote>
<p><a href="https://juejin.cn/post/7005468491067162655">DNS 域名解析</a><br><a href="https://juejin.cn/post/6992597760935460901">浏览器工作原理</a><br><a href="https://juejin.cn/post/6992843117963509791">浏览器缓存机制</a><br><a href="https://juejin.cn/post/7016593221815910408#heading-12">八股文含以上知识</a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络与数据结构</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket</title>
    <url>/2024/10/31/network/WebSocket%20%E5%92%8C%20HTTP%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="WebSocket-和-HTTP-的区别及原理"><a href="#WebSocket-和-HTTP-的区别及原理" class="headerlink" title="WebSocket 和 HTTP 的区别及原理"></a>WebSocket 和 HTTP 的区别及原理</h2><ul>
<li>HTTP 协议有一个缺陷：<span class="key_words">『通信只能由客户端发起』</span>。</li>
<li>这种单向请求的特点只能使用”轮询”,每隔一段时候，就发出一个询问，了解服务器有没有新的信息。但是效率低，非常浪费资源</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><blockquote>
<p>最大特点：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</p>
</blockquote>
<ul>
<li>2008 年诞生，2011 年成功国际标准，所有浏览器支持</li>
</ul>
<h3 id="其他特点："><a href="#其他特点：" class="headerlink" title="其他特点："></a>其他特点：</h3><ul>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是 ws(<span class="desc">如果加密，则为wss</span>)，服务器网址就是 URL。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">如 <span class="attr">ws</span>:<span class="comment">//example.com:80/some/path</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul>
<li><p>创建一个WebSocket实例: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;wss://echo.websocket.org&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用onopen，用于指定连接成功后的回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">evt</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection open ...&#x27;</span>)</span><br><span class="line">	ws.<span class="title function_">send</span>(<span class="string">&#x27;Hello WebSockets!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用onmessage，用于指定收到服务器数据后的回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">evt</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received Message: &#x27;</span> + evt.<span class="property">data</span>)</span><br><span class="line">	ws.<span class="title function_">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用onclose，用于指定连接关闭后的回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params">evt</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection closed.&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="客户端-API"><a href="#客户端-API" class="headerlink" title="客户端 API"></a>客户端 API</h3><ul>
<li><p>WebSocket 对象作为一个构造函数，用于创建 WebSocket 实例</p>
<ul>
<li>作用：执行后客户端就会与服务端进行连接</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">Websockett</span>(<span class="string">&#x27;ws://localhost:8080&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>webSocket.readyState</p>
<ul>
<li>作用：返回实例对象的当前状态</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.<span class="property">readyState</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="title class_">WebSocket</span>.<span class="property">CONNECTING</span>: <span class="comment">// 值为0，表示正在连接</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">case</span> <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>: <span class="comment">// 值为1，表示连接成功，可以通信了</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">case</span> <span class="title class_">WebSocket</span>.<span class="property">CLOSING</span>: <span class="comment">// 值为2，表示连接正在关闭</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">case</span> <span class="title class_">WebSocket</span>.<span class="property">CLOSED</span>: <span class="comment">// 值为3，表示连接已经关闭，或者打开连接失败</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="attr">default</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>webSocket.onopen</p>
<ul>
<li>作用：用于指定连接成功后的回调函数</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;ws.<span class="title function_">send</span>(<span class="string">&#x27;message&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果要指定多个回调函数，可以使用 addEventListener 方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;open&#x27;</span>,<span class="keyword">function</span> (<span class="params">event</span>) &#123;ws.<span class="title function_">send</span>(<span class="string">&#x27;message&#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>webSocket.onclose</p>
<ul>
<li>作用：用于指定连接关闭后的回调函数</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果要指定多个回调函数，可以使用 addEventListener 方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;close&#x27;</span>,<span class="keyword">function</span> (<span class="params">event</span>) &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>webSocket.onmessage</p>
<ul>
<li>作用：用于指定收到服务器数据后的回调函数</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.<span class="property">data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果要指定多个回调函数，可以使用 addEventListener 方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>,<span class="keyword">function</span> (<span class="params">event</span>) &#123;<span class="keyword">var</span> data = event.<span class="property">data</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>如果服务器数据时文本或者二进制数据（<span class="desc">blob 对象或 Arraybuffer 对象</span>）</li>
<li>除了动态判断收到的数据类型，也可以使用 binaryType 属性，显式指定收到的二进制数据类型。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> event.<span class="property">data</span> === <span class="title class_">String</span>) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (event.<span class="property">data</span> <span class="keyword">instanceof</span> <span class="title class_">ArrayBuffer</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> buffer = event.<span class="property">data</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 收到的是blob数据</span></span><br><span class="line">	ws.<span class="property">binaryType</span> = <span class="string">&#x27;blob&#x27;</span></span><br><span class="line">	ws.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;&#125;</span><br><span class="line">	<span class="comment">// 收到的是ArrayBuffer数据</span></span><br><span class="line">	ws.<span class="property">binaryType</span> = <span class="string">&#x27;arraybuffer&#x27;</span></span><br><span class="line">	ws.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>webSocket.send()</p>
<ul>
<li>作用：用于向服务器发送数据。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送文本</span></span><br><span class="line">ws.<span class="title function_">send</span>(<span class="string">&#x27;meaage&#x27;</span>)</span><br><span class="line"><span class="comment">// 发送Blob对象</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[type=&quot;file&quot;]&#x27;</span>).<span class="property">files</span>[<span class="number">0</span>]</span><br><span class="line">ws.<span class="title function_">send</span>(file)</span><br><span class="line"><span class="comment">// 发送ArrayBuffer 对象</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>)</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(img.<span class="property">data</span>.<span class="property">length</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.<span class="property">data</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	binary[i] = img.<span class="property">data</span>[i]</span><br><span class="line">&#125;</span><br><span class="line">ws.<span class="title function_">send</span>(binary.<span class="property">buffer</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>webSocket.bufferedAmount</p>
<ul>
<li>作用：表示还有多少字节的二进制数据没有发送出去，可以用来判断发送是否结束</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">10000000</span>)</span><br><span class="line">ws.<span class="title function_">send</span>(data)</span><br><span class="line"><span class="keyword">if</span> (ws.<span class="property">bufferedAmount</span> === <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>webSocket.onerror</p>
<ul>
<li>作用：用于指定报错时的回调函数。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果要指定多个回调函数，可以使用 addEventListener 方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>,<span class="keyword">function</span> (<span class="params">event</span>) &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><h3 id="常用的-Node-实现有以下三种"><a href="#常用的-Node-实现有以下三种" class="headerlink" title="常用的 Node 实现有以下三种"></a>常用的 Node 实现有以下三种</h3><ul>
<li><a href="https://github.com/uWebSockets/uWebSockets">µWebSockets</a></li>
<li><a href="http://socket.io/">Socket.IO</a></li>
<li><a href="https://blog.csdn.net/wulong710/article/details/115005960#:~:text=Socket.IO-,WebSocket%2DNode,-%E5%85%B7%E4%BD%93%E7%9A%84%E7%94%A8%E6%B3%95">WebSocket-Node</a></li>
</ul>
<h3 id="WebSocketd-—-WebSocket-服务器"><a href="#WebSocketd-—-WebSocket-服务器" class="headerlink" title="WebSocketd — WebSocket 服务器"></a>WebSocketd — WebSocket 服务器</h3><ul>
<li>最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出</li>
</ul>
]]></content>
      <categories>
        <category>网络与数据结构</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title>时/空间复杂度</title>
    <url>/2024/10/31/network/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><blockquote>
<p>含义：若存在函数 f(n)，使得当 n 趋近于无穷大时，T(n)&#x2F; f(n)）的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。记作 T(n)&#x3D; O(f(n))，称 O(f(n))为算法的渐进时间复杂度，简称时间复杂度。</p>
</blockquote>
<ul>
<li>通过观察一个方法在执行不同的输入情况时，所呈现的结果，并以线段表示趋势而得到线性时间复杂度</li>
<li>简单理解：<span class="key_words">『一个算法或是一个程序在运行时，所消耗的时间（或者代码被执行的总次数）』</span></li>
<li>大 O 表示法：算法的时间复杂度通常用大 O 来表示，其中 T 表示时间，称为 O(f(n))为算法的渐进时间复杂度<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">T</span>(n) = <span class="title function_">O</span>(<span class="title function_">f</span>(n))</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度的数量级，其原则是：<ul>
<li><span class="key_words">『省略常数』</span>，如果运行时间是常数量级，用常数 1 表示</li>
<li><span class="key_words">『保留最高阶的项』</span></li>
<li><span class="key_words">『变最高阶项的系数为 1』</span></li>
<li>示例：2n<sup>3</sup> + 3n<sup>2</sup> +7 变成 O(n<sup>3</sup>)</li>
</ul>
</li>
</ul>
<h2 id="时间复杂度的阶"><a href="#时间复杂度的阶" class="headerlink" title="时间复杂度的阶"></a>时间复杂度的阶</h2><h3 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶: O(1)"></a>常数阶: O(1)</h3><ul>
<li>看代码： 每次调用方法时，里面的语句执行的次数(如有循环，次数多)，其它语句只执行一次所以为 O(1)</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不管n为多少，只执行一遍</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sumUp</span>(<span class="params">n</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> (n / <span class="number">2</span>) * (<span class="number">1</span> + n) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="对数阶-O-logn"><a href="#对数阶-O-logn" class="headerlink" title="对数阶: O(logn)"></a>对数阶: O(log<sup>n</sup>)</h3><ul>
<li>i 的值随 n 成对数增长，即为 log<sub>2</sub> <sup>n</sup>,时间复杂度 T(n) &#x3D; O(log<sup>n</sup>)</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n = 32 则 i=1,2,4,8,16,32</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i = i * <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;对数阶：&#x27;</span> + n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线性阶-O-n"><a href="#线性阶-O-n" class="headerlink" title="线性阶: O(n)"></a>线性阶: O(n)</h3><ul>
<li>y &#x3D; f(x),即 T(n) &#x3D; O(n)</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线性对数阶-O-nlogn"><a href="#线性对数阶-O-nlogn" class="headerlink" title="线性对数阶:O(nlogn)"></a>线性对数阶:O(nlog<sup>n</sup>)</h3><ul>
<li>归并排序的复杂度就是这样，将对数阶的代码循环 n 遍，即两层循环,但内层循环是外层循环的次数于外层循环形成对数阶。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">1</span>; m &lt;= n; m++) &#123;</span><br><span class="line">	<span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">		i = i * <span class="number">2</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="平方阶-O-n2"><a href="#平方阶-O-n2" class="headerlink" title="平方阶: O(n2)"></a>平方阶: O(n<sup>2</sup>)</h3><ul>
<li>也是两层循环</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>当 x 轴 n 的值越来越大时，y 轴耗时的时长为：O(1) &lt; O(log<sup>n</sup>) &lt; O(n) &lt; O(nlog<sup>n</sup>) &lt; O(n<sup>2</sup>)</li>
</ul>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><blockquote>
<p>一般指额外空间复杂度。看的是定义的变量，<span class="key_words">『输入数组不算额外空间，输出空间不算额外空间。』</span>使用的额外空间与数据量没有关系就称为 O(1),表示使用常数量级别的额外空间</p>
</blockquote>
<ul>
<li>表示的是算法的存储空间和数据之间的关系，即一个算法在运行时，所消耗的空间</li>
<li>所有值都存储在内存中，而这些值在内存的占用情况，内存泄漏与空间复杂度无关</li>
<li>创建一个变量存储值，在每次循环迭代的过程中，这个值会改变，每次改变都是新值，并且随着迭代变大变小。 画线看图的整体趋势得出结果<table>
<thead>
<tr>
<th>算法</th>
<th>空间复杂度</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>循环</td>
<td>O(1)</td>
<td>操作一个或相同的数，没有‘永久’新值产生的迭代</td>
</tr>
<tr>
<td>递归</td>
<td>O(n)</td>
<td>为每个嵌套函数调用创建一个新值(接收的参数)</td>
</tr>
<tr>
<td>线性搜索</td>
<td>O(1)</td>
<td>迭代期间没有产生‘永久’新值</td>
</tr>
<tr>
<td>二分查找</td>
<td>O(1)</td>
<td>迭代期间产生‘永久’的新值</td>
</tr>
<tr>
<td>冒泡搜索</td>
<td>O(1)</td>
<td>迭代期间产生‘永久’的新值</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n)</td>
<td>嵌套函数调用将创建新值</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n)</td>
<td>嵌套函数调用将创建新值</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="空间复杂度的阶"><a href="#空间复杂度的阶" class="headerlink" title="空间复杂度的阶"></a>空间复杂度的阶</h2><ul>
<li>常数阶 O(1): int i;</li>
<li>线性阶 O(n): int [] arr;</li>
<li>平方阶 O(n<sup>2</sup>): int [][] arr;</li>
</ul>
]]></content>
      <categories>
        <category>网络与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2024/10/31/network/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h2><blockquote>
<p>在前端路由中，常用的存储方式是栈(Stack)数据结构。<br>属于线性数据结构，具有<span class="key_words">『先进后出，后进先出』</span>(LIFO)的特点。<br>只允许在一端进行插入或删除的线性表</p>
</blockquote>
<h3 id="使用栈数据结构来存储前端路由信息具有的优点："><a href="#使用栈数据结构来存储前端路由信息具有的优点：" class="headerlink" title="使用栈数据结构来存储前端路由信息具有的优点："></a>使用栈数据结构来存储前端路由信息具有的优点：</h3><ul>
<li>快速分配和释放内存：由于栈的数据结构特点，分配和释放栈内存的操作非常高效，不会出现内存碎片问题。</li>
<li>快速访问：由于栈是一种简单的数据结构，访问和操作栈的速度非常快。</li>
<li>可扩展性：栈数据结构可以很容易地扩展到支持浏览器的前进和后退按钮</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>有限大小：栈的大小是有限的，当栈空间不够用时会发生栈溢出。</li>
<li>局部性：栈上存储的数据只能在局部作用域中访问，不适合存储大量的数据或长期保存的数据。</li>
</ul>
<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><ul>
<li>初始化一个空栈： 创建一个空数组</li>
<li>判断栈：为空返回true，否则返回false</li>
<li>进栈(push或unshift)：是元素成为新栈顶</li>
<li>出栈(pop或shift)：删除栈顶元素并返回删除的元素</li>
</ul>
<h3 id="示例：leetcode-503"><a href="#示例：leetcode-503" class="headerlink" title="示例：leetcode 503"></a>示例：leetcode 503</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nextGreaterElements</span>(<span class="params">nums: number[]</span>): number[] &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [] </span><br><span class="line">  <span class="keyword">const</span> len = nums.<span class="property">length</span></span><br><span class="line">  <span class="keyword">let</span> i=<span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span>(i&lt; len)&#123;</span><br><span class="line">    <span class="keyword">const</span> num = nums.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;nums[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">const</span> val = num === -<span class="number">1</span> ? -<span class="number">1</span> : nums[num]</span><br><span class="line">    res.<span class="title function_">push</span>(val) </span><br><span class="line">    nums.<span class="title function_">push</span>(nums.<span class="title function_">shift</span>()) <span class="comment">// 符合条件就不断把栈顶的元素放在栈底</span></span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><blockquote>
<p>用于动态内存分配的数据结构，用于存储复杂的数据结构和对象。在堆中分配的内存需要手动进行释放，否则会导致内存泄漏（memory leak）</p>
</blockquote>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>无序存储：堆中存储的数据是无序的，数据之间的关系由指针来表示</li>
<li>动态分配：内存大小是动态分配的，不受限于栈的大小限制，可以存储大量的数据和复杂的数据结构</li>
<li>全局性：堆内存中的数据可以在全局作用域中访问，适合存储长期保存的数据和共享数据</li>
</ul>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>内存泄露：堆内存需要手动管理，如果忘记释放堆内存，会导致内存泄漏</li>
<li>分配和释放速度相对较慢：由于堆内存的动态分配和释放需要进行复杂的内存管理操作，分配和释放速度相对较慢。</li>
</ul>
<h3 id="在-JavaScript-的应用中"><a href="#在-JavaScript-的应用中" class="headerlink" title="在 JavaScript 的应用中"></a>在 JavaScript 的应用中</h3><ul>
<li>栈和堆的概念对于理解内存管理和变量存储非常重要。JavaScript 中的基本数据类型（如数字、字符串、布尔值等）通常存储在栈内存中，而复杂的数据结构和对象则存储在堆内存中。在实际开发中，合理地利用栈和堆内存，可以提高程序的性能和内存利用率。</li>
</ul>
<h2 id="队列（queue）"><a href="#队列（queue）" class="headerlink" title="队列（queue）"></a>队列（queue）</h2><blockquote>
<p>线性表，具有<span class="key_words">『先进先出』</span>(FIFO)<br>只允许在一端进行插入操作(队尾)，而在另一端进行删除操作的线性表(队头)。</p>
</blockquote>
<h3 id="常见操作-1"><a href="#常见操作-1" class="headerlink" title="常见操作"></a>常见操作</h3><ul>
<li>初始化队列：构造一个空队列Q</li>
<li>判断队列： 为空返回true， 否则位false</li>
<li>入队(enqueue): 使元素称为新队尾</li>
<li>出队(dequeue): 删除对头元素，并返回删除的元素</li>
</ul>
<h2 id="宏-微任务"><a href="#宏-微任务" class="headerlink" title="宏&#x2F;微任务"></a>宏&#x2F;微任务</h2><blockquote>
<p>宏任务和微任务的区分主要是为了<span class="key_words">『解决js引擎中不同任务之间的执行优先级问题』</span></p>
</blockquote>
<h3 id="宏任务-macrotask"><a href="#宏任务-macrotask" class="headerlink" title="宏任务(macrotask)"></a>宏任务(macrotask)</h3><ul>
<li>setTimeout 和 setInterval 定时器</li>
<li>DOM 事件处理程序</li>
<li>AJAX 请求的回调函数</li>
<li>script 标签的加载和执行</li>
</ul>
<h3 id="微任务-microtask"><a href="#微任务-microtask" class="headerlink" title="微任务(microtask)"></a>微任务(microtask)</h3><ul>
<li>Promise 的 then 方法和 catch 方法</li>
<li>async&#x2F;await 中的 await 表达式</li>
<li>MutationObserver 监听器</li>
<li>js 引擎会将微任务和宏任务添加到任务队列中，但是<span class="key_words">『微任务的执行在当前宏任务执行结束后立即进行』</span>，也就是说<span class="key_words">『微任务具有更高的执行优先级，可以优先于下一个宏任务。宏任务的执行是当前任务执行完毕后按照顺序执行』</span></li>
</ul>
]]></content>
      <categories>
        <category>网络与数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX-orther</title>
    <url>/2024/10/31/ajax/AJAX-orther/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="JQuery-AJAX"><a href="#JQuery-AJAX" class="headerlink" title="JQuery + AJAX"></a>JQuery + AJAX</h3><ul>
<li>Query用法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;tag&#x27;</span>).<span class="title function_">eq</span>(index).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果是同一个tag的需要使用index来定位那个DOM元素</li>
</ul>
</li>
<li>以下方法是在DOM事件回调内部使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">get</span>(请求地址，&#123;参数&#125;，callback,响应体类型)</span><br><span class="line">$.<span class="title function_">post</span>(提交地址, &#123;参数&#125;, callback &#125;);</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">	<span class="attr">url</span>:地址,</span><br><span class="line">	<span class="attr">data</span>:&#123;参数&#125;,</span><br><span class="line">	<span class="attr">type</span>:请求类型, </span><br><span class="line">	<span class="attr">dataType</span>:响应体类型,</span><br><span class="line">	<span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;&#125;,</span><br><span class="line">	<span class="attr">error</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;, </span><br><span class="line">	<span class="attr">timeout</span>: 超时时间number类型,</span><br><span class="line">	<span class="attr">headers</span>: &#123;头信息&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>响应体类型：<ul>
<li>json</li>
<li>不加：是字符串</li>
</ul>
</li>
</ul>
<h3 id="Axios-AJAX"><a href="#Axios-AJAX" class="headerlink" title="Axios + AJAX"></a>Axios + AJAX</h3><ul>
<li>获取全部tag的DOM，然后通过索引去指定对应的DOM<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;tag&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>配置axios的baseURL：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&quot;地址&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>以下事件在DOM的事件回调中执行</li>
<li>对象内使用key: value的形式</li>
<li>GET请求：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/路径&#x27;</span>,&#123;<span class="attr">params</span>:&#123;url参数&#125;,<span class="attr">headers</span>:&#123;请求头信息&#125;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>POST请求：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/路径&#x27;</span>, &#123;提交的数据&#125;, &#123;<span class="attr">params</span>: &#123;参数&#125;,<span class="attr">headers</span>: &#123;请求头参数&#125;&#125;);</span><br></pre></td></tr></table></figure></li>
<li>统一的方法：<ul>
<li>response.status：响应状态码</li>
<li>response.statusText：响应状态字符串</li>
<li>response.headers：响应头信息</li>
<li>response.data：响应体<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">	<span class="attr">method</span>:<span class="string">&#x27;请求方法&#x27;</span>,</span><br><span class="line">	<span class="attr">url</span>:<span class="string">&#x27;/路径&#x27;</span>,</span><br><span class="line">	<span class="attr">params</span>:&#123;url参数&#125;,</span><br><span class="line">	<span class="attr">headers</span>:&#123;头信息&#125;,</span><br><span class="line">	<span class="attr">data</span>:&#123;请求体参数&#125;</span><br><span class="line">	&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Fetch-AJAX"><a href="#Fetch-AJAX" class="headerlink" title="Fetch + AJAX"></a>Fetch + AJAX</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;路径&#x27;</span>, &#123;<span class="attr">method</span>:<span class="string">&#x27;请求方法&#x27;</span>,<span class="attr">headers</span>:&#123;请求头&#125;,<span class="attr">body</span>: <span class="string">&#x27;请求体&#x27;</span>&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function"><span class="params">response</span>=&gt;</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>原生AJAX</title>
    <url>/2024/10/31/ajax/%E5%8E%9F%E7%94%9FAjax/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>前提：存在DOM元素</li>
<li>获取DOM元素： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;DOM ID&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;DOM Tag&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;DOM Class&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Get操作"><a href="#Get操作" class="headerlink" title="Get操作"></a>Get操作</h3><ul>
<li>绑定事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dom.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>在DOM点击事件内部创建AJAX对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure></li>
<li>在DOM点击事件内部初始化AJAX对象，并设置请求方法和url<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>在DOM点击事件内部发送信息<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure></li>
<li>在DOM点击事件内部，给AJAX对象绑定事件，处理服务端返回的结果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>以下为AJAX对象绑定事件内可用的方法<ul>
<li>xhr.readystate：是 xhr 对象中的属性, 表示状态 0 1 2 3 4<ul>
<li>0：表示未初始化 </li>
<li>1：表示open方法调用完毕 </li>
<li>2：表示send方法调用完毕 </li>
<li>3：表示服务端返回部分的结果 </li>
<li>4：表示服务端返回所有的结果</li>
</ul>
</li>
<li>xhr.status：判断响应状态码，200 成功</li>
<li>xhr.getAllResponseHeaders()：所有响应头</li>
<li>xhr.statusText：状态字符串</li>
<li>xhr.response：响应体</li>
</ul>
</li>
</ul>
<h3 id="POST操作"><a href="#POST操作" class="headerlink" title="POST操作"></a>POST操作</h3><ul>
<li>绑定事件： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dom.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseover&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>在DOM点击事件内部创建AJAX对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure></li>
<li>在DOM点击事件内部初始化AJAX对象，并设置请求方法和url<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>在DOM点击事件内部给AJAX对象设置请求头<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>在DOM点击事件内部发送信息<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&#x27;一些参数，用&amp;分隔&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>在DOM点击事件内部，给AJAX对象绑定事件，处理服务端返回的结果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="JSON响应"><a href="#JSON响应" class="headerlink" title="JSON响应"></a>JSON响应</h3><ul>
<li>绑定键盘按下事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onkeydown</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>在键盘按下事件内部创建AJAX对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure></li>
<li>在键盘按下事件内部给AJAX对象设置响应体数据的类型<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;json&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>在键盘按下事件内部初始化AJAX对象，并设置请求方法和url<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000/json-server&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>在DOM点击事件内部发送信息<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure></li>
<li>在DOM点击事件内部，给AJAX对象绑定事件，处理服务端返回的结果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>手动对数据转化：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">response</span>);</span><br><span class="line">dom.<span class="property">innerHTML</span> = data.<span class="property">name</span>;</span><br></pre></td></tr></table></figure></li>
<li>自动转换<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>.<span class="property">name</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="处理IE缓存问题"><a href="#处理IE缓存问题" class="headerlink" title="处理IE缓存问题"></a>处理IE缓存问题</h3><ul>
<li>Date.now()：获取当前的时间戳</li>
<li>解决IE缓存：在GET请求路径上添加<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;?t=&#x27; + Date.now()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="请求超时与网络异常"><a href="#请求超时与网络异常" class="headerlink" title="请求超时与网络异常"></a>请求超时与网络异常</h3><ul>
<li>给AJAX对象配置超时设置 2s 设置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">timeout</span> = <span class="number">2000</span>;</span><br></pre></td></tr></table></figure></li>
<li>给AJAX对象配置超时回调<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>给AJAX对象配置网络异常回调<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><ul>
<li>定义一个值为null的变量cancel</li>
<li>在取消的dom事件回调中设置 cancel.abort()</li>
</ul>
<h3 id="重复请求问题"><a href="#重复请求问题" class="headerlink" title="重复请求问题"></a>重复请求问题</h3><ul>
<li>结合取消请求</li>
<li>定义一个标识变量用来判断是否正在发送AJAX请求<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isSending = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li>
<li>在DOM事件回调中，先判断标识变量是否正在发送，<ul>
<li>是就取消请求</li>
<li>否则就按流程执行，并设置标识变量为true，然后在 xhr.readystate为4时设置为false</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>认识express</title>
    <url>/2024/10/31/ajax/%E8%AE%A4%E8%AF%86express/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="前期知道的知识点："><a href="#前期知道的知识点：" class="headerlink" title="前期知道的知识点："></a>前期知道的知识点：<a href="/2024/10/31/network/http%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%A8%A1%E5%BC%8F/" title="Http请求-响应模式">http请求-响应</a></h3><h3 id="express的基本使用"><a href="#express的基本使用" class="headerlink" title="express的基本使用"></a>express的基本使用</h3><ol>
<li>安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure></li>
<li>引入express	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; request, response &#125; = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>创建应用对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br></pre></td></tr></table></figure></li>
<li>创建路由规则<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">reuqest：是对请求报文的封装</span><br><span class="line">response：是对响应报文的封装</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/路径&#x27;</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;&#125;);</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/路径&#x27;</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;&#125;);</span><br><span class="line">可接受任意类型的请求：app.<span class="title function_">all</span>(<span class="string">&#x27;/路径&#x27;</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;&#125;);</span><br></pre></td></tr></table></figure></li>
<li>监听端口启动服务<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="app-all-内部的一些设置"><a href="#app-all-内部的一些设置" class="headerlink" title="app.all 内部的一些设置"></a>app.all 内部的一些设置</h3><ul>
<li>设置响应头，设置允许跨域：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>设置响应体：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.<span class="title function_">send</span>(<span class="string">&#x27;HELLO AJAX - 2&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>设置响应头：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>JSON 响应： 使用JSON.stringify()将对象转为字符串，然后通过response.send()设置到响应体</li>
<li>延时响应：设置个延时器</li>
</ul>
]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>Node基础</title>
    <url>/2024/10/31/node/1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="命令行窗口-小黑屏-、CMD窗口、终端、shell-的常用指令："><a href="#命令行窗口-小黑屏-、CMD窗口、终端、shell-的常用指令：" class="headerlink" title="命令行窗口(小黑屏)、CMD窗口、终端、shell 的常用指令："></a>命令行窗口(小黑屏)、CMD窗口、终端、shell 的常用指令：</h2><ul>
<li>dir: 列出当前目录下的所有文件</li>
<li>cd 目录名: 进入到指定的目录</li>
<li>md 目录名: 创建一个文件夹</li>
<li>rd 目录名: 删除一个文件夹</li>
</ul>
<p>	</p>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><ul>
<li>一门后端语言(服务器端的程序语言)，能够连接数据库存取数据，能够接受和处理网络请求(<span class="desc">服务器的响应，发送请求去获取数据</span>)，单线程事件驱动，异步执行，不等待，提高IO(Input&#x2F;output)的处理速度和效率</li>
<li>Node是一款对ES标准实现的JS引擎</li>
<li>Node的中js引擎使用的chrome的v8引擎</li>
<li>Node仅仅对ES标准进行了实现，所以在Node中不包含DOM 和 BOM	</li>
<li>Node的特点：<ol>
<li>非阻塞、异步的I&#x2F;O</li>
<li>事件和回调函数</li>
<li>单线程（<span class="desc">主线程单线程，后台I&#x2F;O线程池</span>）</li>
<li>跨平台</li>
</ol>
</li>
</ul>
<h2 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h2><ul>
<li>将多个模块组合为一个完整的功能，就是一个包</li>
</ul>
<h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><ul>
<li>bin: 二进制的可执行文件，一般都是一些工具包中才有</li>
<li>lib: js文件</li>
<li>doc: 文档</li>
<li>test: 测试代码</li>
<li>package.json: 包的描述文件，json格式<ul>
<li>name：包名</li>
<li>version：版本</li>
<li>dependencies：依赖</li>
<li>main：包的主要的文件</li>
<li>bin：可执行文件</li>
</ul>
</li>
</ul>
<p>	</p>
<h2 id="npm（Node-Package-Manager-node的包管理器）"><a href="#npm（Node-Package-Manager-node的包管理器）" class="headerlink" title="npm（Node Package Manager node的包管理器）"></a>npm（Node Package Manager node的包管理器）</h2><ul>
<li>npm会在安装完node以后，自动安装</li>
<li>通过npm下载的包都放到node_modules文件夹中，可以直接通过包名引入即可</li>
<li>npm的常用指令<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm -v <span class="comment">// 查看npm的版本</span></span><br><span class="line">npm version <span class="comment">// 查看所有模块的版本</span></span><br><span class="line">npm init <span class="comment">// 初始化项目（创建package.json）</span></span><br><span class="line">npm i/install 包名 <span class="comment">// 安装指定的包</span></span><br><span class="line">npm i/install 包名 --save <span class="comment">// 安装指定的包并添加依赖</span></span><br><span class="line">npm i/install 包名 --save-dev <span class="comment">// 安装的包只用于开发环境</span></span><br><span class="line">npm i/install 包名 -g <span class="comment">// 全局安装（一般都是一些工具）</span></span><br><span class="line">npm i <span class="comment">// 安装当前项目所依赖的包</span></span><br><span class="line">npm s/search 包名 <span class="comment">// 搜索包	</span></span><br><span class="line">npm r/remove 包名 <span class="comment">// 删除一个包</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="node的全局对象-—-global"><a href="#node的全局对象-—-global" class="headerlink" title="node的全局对象 — global"></a>node的全局对象 — global</h2><ul>
<li>在全局中创建的变量或函数都会作为global的属性或方法保存</li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul>
<li>ES5中没有原生支持模块化，我们只能通过script标签引入js文件来实现模块化</li>
<li>在Node中为了对模块管理，引入了CommonJS规范</li>
</ul>
<h3 id="模块的定义"><a href="#模块的定义" class="headerlink" title="模块的定义"></a>模块的定义</h3><ul>
<li>在Node中一个js文件就是一个模块</li>
<li>默认情况下在js文件中编写的内容，都是运行在一个独立的函数中，外部的模块无法访问</li>
</ul>
<h3 id="模块的引用-require-函数"><a href="#模块的引用-require-函数" class="headerlink" title="模块的引用: require()函数"></a>模块的引用: require()函数</h3><ul>
<li>可以传递一个文件的路径作为参数，Node将会自动根据该路径来引入外部模块<ul>
<li>相对路径的引入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./math&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>绝对路径的引入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块</li>
<li>引入模块时，使用的就是模块标识，可以通过模块标识来找到指定的模块</li>
</ul>
<h3 id="暴露变量或方法-exports-module-exports"><a href="#暴露变量或方法-exports-module-exports" class="headerlink" title="暴露变量或方法: exports &#x2F; module.exports"></a>暴露变量或方法: exports &#x2F; module.exports</h3><blockquote>
<p>系统默认设置了 exports &#x3D; modules.exports</p>
</blockquote>
<ul>
<li>   exports<ul>
<li>只需要将需要暴露给外部的变量或方法设置为exports的属性即可</li>
<li>只能设置单个属性来向外暴露</li>
<li>向外部暴露属性：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.属性 = 属性值;</span><br></pre></td></tr></table></figure></li>
<li>向外部暴露方法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.方法名 = 函数;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>module.exports<ul>
<li>module.exports既可以单个设置属性也可以整个赋值，一切以module.exports为准<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.属性 = 属性值</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.方法名 = 函数</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;&#125;		</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">存在</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">b</span> = <span class="number">2</span></span><br><span class="line">已知</span><br><span class="line"><span class="built_in">exports</span> = <span class="variable language_">module</span>.<span class="property">exports</span></span><br><span class="line">因此</span><br><span class="line"><span class="built_in">exports</span> = &#123;<span class="attr">c</span>:<span class="number">3</span>&#125; </span><br><span class="line">不成立，输出时仍显示a，b</span><br><span class="line">但</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;<span class="attr">c</span>:<span class="number">3</span>&#125;</span><br><span class="line">成立， 输出为&#123;<span class="attr">c</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模块的初始化"><a href="#模块的初始化" class="headerlink" title="模块的初始化"></a>模块的初始化</h3><ul>
<li>一个模块中的js代码仅在模块第一次使用时执行一次</li>
</ul>
<h3 id="模块的类型"><a href="#模块的类型" class="headerlink" title="模块的类型"></a>模块的类型</h3><ul>
<li><p>核心模块</p>
<ul>
<li>由node引擎提供的模块</li>
<li>核心模块的标识就是，模块的名字</li>
</ul>
</li>
<li><p>文件模块</p>
<ul>
<li>由用户自己创建的模块</li>
</ul>
</li>
<li><p>路径模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>获取路径信息扩展名: path.extname<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> info = path.<span class="title function_">extname</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回后缀名.com</li>
</ul>
</li>
<li>将数组的元素自动拼接成一个路径: path.resolve()<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;/sxt&#x27;</span>,<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;ppp&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> info1 = path.<span class="title function_">resolve</span>(...arr)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回：当前文件在的系统盘:\sxt\xxx\ppp</li>
</ul>
</li>
<li>获取当前执行目录并拼接: path.join()<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> info2 = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;sxt&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;ppp&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>解析网址: str.split(‘&#x2F;‘)</li>
<li>解析路径(根路径、目录、扩展名、文件名称、文件名): path.parse(__filename)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line">url.<span class="title function_">parse</span>(httpUrl) --- 解析路径</span><br><span class="line">url.<span class="title function_">resolve</span>(targetUrl, httpUrl) --- 将两个路径合理拼接在一起</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>查看cpu信息: os.cpus()</li>
<li>查看整个内存大小: os.totalmem()</li>
<li>查看系统架构: os.arch()</li>
</ul>
<h3 id="模块的标识-模块的名字或路径"><a href="#模块的标识-模块的名字或路径" class="headerlink" title="模块的标识(模块的名字或路径)"></a>模块的标识(<span class="desc">模块的名字或路径</span>)</h3><ul>
<li>通过模块的标识来寻找模块的</li>
<li>对于核心模块（<span class="desc">npm中下载的模块</span>），直接使用模块的名字对其进行引入</li>
<li>对于自定义的文件模块，需要通过文件的路径来对模块进行引入<ul>
<li>路径可以是绝对路径，如果是相对路径必须以.&#x2F;或 ..&#x2F;开头</li>
</ul>
</li>
</ul>
<h3 id="模块的运行规则"><a href="#模块的运行规则" class="headerlink" title="模块的运行规则"></a>模块的运行规则</h3><ul>
<li>当node在执行模块中的代码时，它会将代码放进以下函数中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="variable language_">module</span>, __filename, __dirname</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参<ul>
<li>exports: 该对象用来将变量或函数暴露到外部</li>
<li>require: 函数，用来引入外部的模块</li>
<li>module: module代表的是当前模块本身</li>
<li><code>__filename</code>: 获取当前执行文件的完整路径</li>
<li><code>__dirname</code>: 当前执行文件的目录的完整路径</li>
</ul>
</li>
</ul>
<h3 id="模块的查找规则"><a href="#模块的查找规则" class="headerlink" title="模块的查找规则"></a>模块的查找规则</h3><ul>
<li>node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否含有该模块<ul>
<li>如果有则直接使用，如果没有则去上一级目录的node_modules中寻找</li>
<li>如果有则直接使用，如果没有则再去上一级目录寻找，直到找到为止</li>
<li>直到找到磁盘的根目录，如果依然没有，则报错</li>
</ul>
</li>
<li>arguments.callee<ul>
<li>这个属性保存的是当前执行的函数对象</li>
</ul>
</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="发送和接受事件"><a href="#发送和接受事件" class="headerlink" title="发送和接受事件"></a>发送和接受事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> ee = <span class="keyword">new</span> event.<span class="title function_">eventEmitter</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>监听事件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ee.<span class="title function_">on</span>(<span class="string">&#x27;事件名&#x27;</span>, <span class="function">()=&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>触发事件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ee.<span class="title function_">emit</span>(<span class="string">&#x27;事件名&#x27;</span>,事件的数据data)</span><br></pre></td></tr></table></figure></li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> events = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> ee = <span class="keyword">new</span> events.<span class="title class_">EventEmitter</span>()</span><br><span class="line"></span><br><span class="line">ee.<span class="title function_">on</span>(<span class="string">&quot;test&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;输出test&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line">fsReadDir = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	fs.<span class="title function_">readdir</span>(<span class="string">&quot;./&quot;</span>, <span class="function">(<span class="params">err, files</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// files 是一个包含该目录所有文件的数组</span></span><br><span class="line">		<span class="keyword">if</span>(!err) &#123;</span><br><span class="line">			ee.<span class="title function_">emit</span>(<span class="string">&quot;test&quot;</span>,files)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fsReadDir</span>()</span><br><span class="line"><span class="comment">// 异步写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fsRead</span> = (<span class="params">url: string</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(url, &#123;<span class="attr">flag</span>: <span class="string">&#x27;r&#x27;</span>, <span class="attr">encoding</span>: <span class="string">&quot;utf-8&quot;</span>&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(!err) &#123;</span><br><span class="line">				<span class="title function_">resolve</span>(data)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="title function_">reject</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">fsRead</span>(path).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	ee.<span class="title function_">emit</span>(<span class="string">&quot;test&quot;</span>,res)</span><br><span class="line">&#125;)</span><br><span class="line">|| 两者差不多，但下面少一个回调函数</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Test</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">fsRead</span>()</span><br><span class="line">	ee.<span class="title function_">emit</span>(<span class="string">&quot;test&quot;</span>,res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Test</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老式写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Event</span> = &#123;</span><br><span class="line">	<span class="attr">event</span>: &#123;&#125;,</span><br><span class="line">	<span class="attr">on</span>: <span class="function">(<span class="params">eventName, eventFn</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 如果数组中存在这个事件，就及那个对应事件的函数赋给它，不存在则先添加事件名在赋值事件函数</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">event</span>.<span class="property">eventName</span>) &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">event</span>[eventName].<span class="title function_">push</span>(eventFn)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">event</span>[eventName] = []</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">event</span>[eventName].<span class="title function_">push</span>(eventFn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">emit</span>: <span class="function">(<span class="params">eventName, data</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 数组存在这个事件就调用事件函数并返回数据</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">event</span>[eventName])&#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">event</span>[eventName].<span class="title function_">forEach</span>(<span class="function"><span class="params">itemFn</span> =&gt;</span> &#123;</span><br><span class="line">				<span class="title function_">itemFn</span>(data)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">eventEmitter.<span class="title function_">on</span>(<span class="string">&quot;event1&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ... 一些事件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Node的文件系统（File System）</title>
    <url>/2024/10/31/node/2node%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>通过Node来操作系统中的文件<br>使用文件系统，需要先引入fs模块，fs是核心模块，直接引入不需要下载<br>运行文件: node 文件名带后缀</p>
</blockquote>
<h2 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer(缓冲区)"></a>Buffer(缓冲区)</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>专门存储二进制的数据</li>
<li>在内存空间开辟出固定大小的内存，一旦确定，则不能修改</li>
<li>效率高</li>
</ul>
<h3 id="结构存储"><a href="#结构存储" class="headerlink" title="结构存储"></a>结构存储</h3><ul>
<li>Buffer的结构和数组很像，操作的方法也和数组类似</li>
<li>在buffer中存储的都是二进制数据，但是在显示时都是以16进制的形式显示</li>
<li>buffer中每一个元素的范围是从00 - ff，一个元素，占用内存的一个字节<ul>
<li>8bit &#x3D; 1Byte（字节）</li>
<li>1024Byte &#x3D; 1KB</li>
<li>1024KB &#x3D; 1MB</li>
<li>1024MB &#x3D; 1GB</li>
<li>1024GB &#x3D; 1TB</li>
</ul>
</li>
</ul>
<h3 id="Buffer的方法"><a href="#Buffer的方法" class="headerlink" title="Buffer的方法"></a>Buffer的方法</h3><ul>
<li>Buffer.from(str): 将字符串转成buffer对象<ul>
<li>buf.toString(): 将buffer对象转成字符串</li>
<li>buf.length: 占用内存的大小</li>
<li>str.length: 字符串的长度</li>
</ul>
</li>
<li>Buffer.alloc(size): 创建一个指定大小的buffer</li>
<li>Buffer.allocUnsafe(size): 创建一个指定大小的buffer，但是可能含有敏感数据，效率高，内存泄漏</li>
<li>通过索引，来操作buf中的元素: buf2[1] &#x3D; 255;</li>
</ul>
<h2 id="fs模块-用来操作系统中的文件"><a href="#fs模块-用来操作系统中的文件" class="headerlink" title="fs模块: 用来操作系统中的文件"></a>fs模块: 用来操作系统中的文件</h2><blockquote>
<p>fs模块中的大部分操作都提供了两种方法，同步(带sync)和异步(有回调)</p>
</blockquote>
<ul>
<li><p>引入fs: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="string">``</span><span class="string">`			</span></span><br><span class="line"><span class="string">### 同步文件的读写</span></span><br><span class="line"><span class="string">- 打开文件</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">fs.<span class="title function_">openSync</span>(path, flags)</span><br></pre></td></tr></table></figure>
<ul>
<li>path：要打开文件的路径</li>
<li>flags：打开文件要做的操作的类型<ul>
<li>r(只读)、w(可写)、a(追加)</li>
</ul>
</li>
<li>返回值：返回一个文件的描述符作为结果</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fd = fs.<span class="title function_">openSync</span>(<span class="string">&quot;hello.txt&quot;</span> , <span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>向文件中写入内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">writeFileSync</span>(file, data[, options])</span><br></pre></td></tr></table></figure>
<ul>
<li>fd：文件的描述符，需要传递要写入的文件的描述符</li>
<li>string：要写入的内容</li>
<li>position：写入的起始位置</li>
<li>encoding：写入的编码，默认utf-8(不传)</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">writeSync</span>(fd , <span class="string">&quot;今天天气真不错&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>读取文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFileSync</span>(path[, options])</span><br></pre></td></tr></table></figure>
<ul>
<li>readFileSync: read的高度封装</li>
<li>path: 文件地址</li>
<li>options: 配置参数，传对象</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;文件地址&quot;</span>, &#123;<span class="attr">flag</span>: <span class="string">&#x27;r&#x27;</span>, <span class="attr">encoding</span>: <span class="string">&quot;utf-8&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>保存并关闭文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">closeSync</span>(fd)</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">closeSync</span>(fd);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">unlink</span>(<span class="string">&#x27;路径&#x27;</span>, callback)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="异步文件读写-推荐"><a href="#异步文件读写-推荐" class="headerlink" title="异步文件读写(推荐)"></a>异步文件读写(推荐)</h3><ul>
<li><p>打开文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">open</span>(path, flags, callback)</span><br></pre></td></tr></table></figure>
<ul>
<li>callback：当写入完成以后执行的函数<ul>
<li>err：错误对象，如果没有错误则为null</li>
<li>data：文件内容</li>
</ul>
</li>
</ul>
</li>
<li><p>写入文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">writeFile</span>(file, data[, options], callback)</span><br></pre></td></tr></table></figure></li>
<li><p>读取文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(path[, options], callback)</span><br></pre></td></tr></table></figure></li>
<li><p>关闭文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">close</span>(fd, callback)</span><br></pre></td></tr></table></figure>
<ul>
<li>想要直接使用读取文件返回的文件名字来打开相同名字的文件，需要去除左右两边的空白符 trim()</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装读取的操作</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fsRead</span> = (<span class="params">url: string</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(url, &#123;<span class="attr">flag</span>: <span class="string">&#x27;r&#x27;</span>, <span class="attr">encoding</span>: <span class="string">&quot;utf-8&quot;</span>&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(!err) &#123;</span><br><span class="line">				<span class="title function_">resolve</span>(data)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="title function_">reject</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">fsRead</span>(<span class="string">&quot;文件地址&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"><span class="comment">// 封装写入的操作</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fsWrite</span> = (<span class="params">url: string, data: any</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		fs.<span class="title function_">writeFile</span>(url, data, &#123;<span class="attr">flag</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span> &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(!err) &#123;</span><br><span class="line">				<span class="title function_">resolve</span>()</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="title function_">reject</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;fsRead, fsWrite&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="流式文件读写"><a href="#流式文件读写" class="headerlink" title="流式文件读写"></a>流式文件读写</h3><blockquote>
<p>适用于一些比较大的文件</p>
</blockquote>
<ul>
<li><p>创建一个写入流</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">createWriteStream</span>(path[, options])</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&quot;hello3.txt&quot;</span>, &#123;<span class="attr">flag</span>: <span class="string">&quot;w&quot;</span>, <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建一个读取流</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">createReadStream</span>(path[, options])</span><br></pre></td></tr></table></figure>
<ul>
<li>监听流的关闭中，当数据读取完要先调用关闭流ws.end();</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;hello3.txt&quot;</span>, &#123;<span class="attr">flag</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过监听流的open、ready和close事件来监听流的打开、准备和关闭状态</p>
<ul>
<li>on(事件字符串,回调函数)<ul>
<li>可以为对象绑定一个事件</li>
</ul>
</li>
<li>once(事件字符串,回调函数)<ul>
<li>可以为对象绑定一个一次性的事件，该事件将会在触发一次以后自动失效</li>
</ul>
</li>
<li>流打开<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="title function_">once</span>(<span class="string">&quot;open&quot;</span>,<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;);</span><br></pre></td></tr></table></figure></li>
<li>流关闭<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="title function_">once</span>(<span class="string">&quot;close&quot;</span>,<span class="keyword">function</span> (<span class="params"></span>) &#123;ws.<span class="title function_">end</span>()&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>向文件中写入内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="title function_">write</span>(<span class="string">&quot;内容&quot;</span>，callback)</span><br></pre></td></tr></table></figure></li>
<li><p>关闭流</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="title function_">end</span>(callback)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据</li>
<li>示例： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">	<span class="comment">// 读取数据</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">	<span class="comment">//将读取到的数据写入到可写流中,相当于复制文件，写入的文件要和读取的文件类型一样</span></span><br><span class="line">	ws.<span class="title function_">write</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>pipe()可以将可读流中的内容，直接输出到可写流中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rs.<span class="title function_">pipe</span>(ws)</span><br></pre></td></tr></table></figure>
<ul>
<li>是上面代码的封装</li>
</ul>
</li>
</ul>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>读取目录<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readdir</span>(path,callback)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fsReadDir = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	fs.<span class="title function_">readdir</span>(<span class="string">&quot;..../fs&quot;</span>, <span class="function">(<span class="params">err, files</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// files 是一个包含该目录所有文件的数组</span></span><br><span class="line">		<span class="keyword">if</span>(!err) &#123;</span><br><span class="line">			<span class="comment">// 通过循环将该命令下的文件全部追加到txtPath文件下</span></span><br><span class="line">			files.<span class="title function_">forEach</span>(<span class="title function_">async</span> (filename,i) =&gt; &#123;</span><br><span class="line">				<span class="keyword">let</span> content = <span class="keyword">await</span> <span class="title function_">fsRead</span>(<span class="string">&#x27;目录的路径/&#x27;</span> + filename)</span><br><span class="line">				<span class="keyword">await</span> <span class="title function_">fsWrite</span> (txtPath, content)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除目录<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">rmdir</span>(path,callback)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul>
<li>引入readline<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>创建readline接口实例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">	<span class="attr">output</span>: process.<span class="property">stdout</span>,</span><br><span class="line">	<span class="attr">input</span>: process.<span class="property">stdin</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置r1，提问事件</span></span><br><span class="line">r1.<span class="title function_">question</span>(<span class="string">&quot;问题：&quot;</span>, <span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;答复：&quot;</span>+ answer)</span><br><span class="line">	r1.<span class="title function_">close</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r1.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	process.<span class="title function_">exit</span>(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>封装一个函数，用于初始化和创建package.json的程序<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> &#123; fsWrite &#125; = <span class="built_in">require</span>(<span class="string">&#x27;路径&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> r1 = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">	<span class="attr">output</span>: process.<span class="property">stdout</span>,</span><br><span class="line">	<span class="attr">input</span>: process.<span class="property">stdin</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 封装一个提问函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">lxQuestion</span> = (<span class="params">question: string</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		r1.<span class="title function_">question</span>(question + <span class="string">&quot;：&quot;</span>, <span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="title function_">resolve</span>(answer)</span><br><span class="line">			r1.<span class="title function_">close</span>()</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建包的提问问题函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createPackage</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> name = <span class="keyword">await</span> <span class="title function_">lxQuestion</span>(<span class="string">&quot;你的包名是什么？&quot;</span>)</span><br><span class="line">	<span class="keyword">let</span> anthor = <span class="keyword">await</span> <span class="title function_">lxQuestion</span>(<span class="string">&quot;你的作者是什么？&quot;</span>)</span><br><span class="line">	<span class="keyword">let</span> main = <span class="keyword">await</span> <span class="title function_">lxQuestion</span>(<span class="string">&quot;你的主文件是什么？&quot;</span>)</span><br><span class="line">	<span class="keyword">let</span> desc = <span class="keyword">await</span> <span class="title function_">lxQuestion</span>(<span class="string">&quot;你的描述是什么？&quot;</span>)</span><br><span class="line">	<span class="keyword">let</span> version = <span class="keyword">await</span> <span class="title function_">lxQuestion</span>(<span class="string">&quot;你的版本是什么？&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将内容写入package.json文件中</span></span><br><span class="line">	<span class="keyword">let</span> content = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">		&quot;name&quot;: &quot;<span class="subst">$&#123;name&#125;</span>&quot;,</span></span><br><span class="line"><span class="string">		&quot;version&quot;: &quot;<span class="subst">$&#123;version&#125;</span>&quot;,</span></span><br><span class="line"><span class="string">		&quot;description&quot;: &quot;<span class="subst">$&#123;desc&#125;</span>&quot;,</span></span><br><span class="line"><span class="string">		&quot;scripts&quot;: &#123;</span></span><br><span class="line"><span class="string">		  &quot;dev&quot;: &quot;webpack serve --config config/webpack.dev.js&quot;,</span></span><br><span class="line"><span class="string">		  &quot;build&quot;: &quot;webpack --config config/webpack.prd.js&quot;,</span></span><br><span class="line"><span class="string">		  &quot;test&quot;: &quot;echo Error: no test specified &amp;&amp; exit 1&quot;</span></span><br><span class="line"><span class="string">		&#125;,</span></span><br><span class="line"><span class="string">		&quot;keywords&quot;: [],</span></span><br><span class="line"><span class="string">		&quot;author&quot;: &quot;<span class="subst">$&#123;main&#125;</span>&quot;,</span></span><br><span class="line"><span class="string">		&quot;license&quot;: &quot;ISC&quot;,</span></span><br><span class="line"><span class="string">		&quot;dependencies&quot;: &#123;&#125;,</span></span><br><span class="line"><span class="string">		&quot;devDependencies&quot;: &#123;&#125;</span></span><br><span class="line"><span class="string">	&#125;`</span></span><br><span class="line">	<span class="keyword">await</span> <span class="title function_">fsWrite</span>(<span class="string">&#x27;package.json&#x27;</span>,content)</span><br><span class="line">	r1.<span class="title function_">close</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createPackage</span>()</span><br><span class="line">r1.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	process.<span class="title function_">exit</span>(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫总结</title>
    <url>/2024/10/31/node/3%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="爬虫介绍"><a href="#爬虫介绍" class="headerlink" title="爬虫介绍"></a>爬虫介绍</h2><ul>
<li>通过模拟浏览器的请求，服务器就会根据我们的请求返回我们想要的数据，将数据解析出来，并且进行保存</li>
</ul>
<h2 id="node文件执行命令：-node-文件名"><a href="#node文件执行命令：-node-文件名" class="headerlink" title="node文件执行命令： node . 文件名"></a>node文件执行命令： node . 文件名</h2><h2 id="爬虫流程"><a href="#爬虫流程" class="headerlink" title="爬虫流程"></a>爬虫流程</h2><h3 id="目标：确认想要获取的数据"><a href="#目标：确认想要获取的数据" class="headerlink" title="目标：确认想要获取的数据"></a>目标：确认想要获取的数据</h3><ul>
<li>1.确定想要的数据在什么页面上(一般详细的数据会在详情页)</li>
<li>2.确定在那些页面可以链接到这些页面(一般分类列表页面会有详情页的链接数据)</li>
<li>3.寻找页面之间和数据之间的规律</li>
</ul>
<h3 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h3><ul>
<li>1.获取数据的方式(正则，cherrio)</li>
<li>2.分析数据是通过ajax请求的数据，还是html里自带的数据</li>
<li>3.如果是通过AJAX请求的数据，那么需要获取ajax请求的链接，一般请求到的数据都为JSON格式数据，那么就会比较容易解析</li>
<li>4.如过数据在HTML里面，那么就用cherrio通过选择器将内容选中</li>
</ul>
<h3 id="编写单个数据获取的案例"><a href="#编写单个数据获取的案例" class="headerlink" title="编写单个数据获取的案例"></a>编写单个数据获取的案例</h3><ul>
<li>1.解析出分类页的链接地址</li>
<li>2.解析出列表页的链接地址</li>
<li>3.解析出详情页的链接地址</li>
<li>4.解析详情页里面想要获取的数据</li>
<li>5.将数据进行保存到本地或者数据库</li>
</ul>
<h3 id="如果遇到阻碍进行反爬虫对抗"><a href="#如果遇到阻碍进行反爬虫对抗" class="headerlink" title="如果遇到阻碍进行反爬虫对抗"></a>如果遇到阻碍进行反爬虫对抗</h3><ul>
<li>1.User-Agent是否为正常浏览器的信息(如果时axios者只为header)</li>
<li>2.将请求头设置为跟浏览器一样的内容</li>
<li>3.因为爬虫的爬取速度过快，会导致封号。(1.降低速度解决 2. 使用代理解决)</li>
<li>4.如果设置需要凭证，那么可以采用无界浏览器真实模拟</li>
</ul>
<h2 id="请求的数据的库"><a href="#请求的数据的库" class="headerlink" title="请求的数据的库"></a>请求的数据的库</h2><ul>
<li>request：通过库，帮助我们快速实现HTTP请求包的打包<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.<span class="title function_">get</span>(<span class="string">&#x27;请求地址&#x27;</span>, &#123;</span><br><span class="line">	<span class="string">&#x27;请求头字段&#x27;</span>:<span class="string">&#x27;请求头的value值&#x27;</span></span><br><span class="line">&#125;,<span class="function">(<span class="params">res</span>)=&gt;</span> &#123;处理返回的内容&#125;)</span><br></pre></td></tr></table></figure></li>
<li>axios：通过库，帮助我们快速实现HTTP请求包的打包,比request更好，前后端通杀，前后端调用方式一致<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">	<span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">	<span class="attr">url</span>: <span class="string">&#x27;请求地址&#x27;</span>,</span><br><span class="line">	<span class="attr">resposeType</span>: <span class="string">&#x27;stream&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">	response.<span class="property">data</span>.<span class="title function_">pipe</span>(fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;写入的文件名&#x27;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>puppeteer: 完全模拟浏览器<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开浏览器</span></span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">	<span class="attr">defaultViewport</span>: &#123;</span><br><span class="line">		<span class="attr">width</span>: <span class="number">1400</span>,<span class="comment">// 设置视窗宽高</span></span><br><span class="line">		<span class="attr">height</span>:<span class="number">800</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">headless</span>: <span class="literal">true</span>,<span class="comment">// 设置为无界面</span></span><br><span class="line">	<span class="attr">slowMo</span>: <span class="number">250</span>,<span class="comment">// 调试时设置放慢每个步骤的毫秒数</span></span><br><span class="line">	timeout：<span class="number">3000</span>, <span class="comment">// 默认超时3秒钟</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>(options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开新标签页</span></span><br><span class="line"><span class="keyword">let</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取多有浏览器的页面</span></span><br><span class="line"><span class="keyword">let</span> pages = <span class="keyword">await</span> browser.<span class="title function_">pages</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭浏览器</span></span><br><span class="line">browser.<span class="title function_">close</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将页面跳转至</span></span><br><span class="line"><span class="keyword">await</span> page.<span class="title function_">goto</span>(url)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页面的对象，并进行操作</span></span><br><span class="line"><span class="keyword">let</span> btn = <span class="keyword">await</span> page.$(selector)</span><br><span class="line"><span class="keyword">let</span> input = <span class="keyword">await</span>.<span class="property">page</span>.$(selector)</span><br><span class="line"><span class="comment">// 点击按钮</span></span><br><span class="line">btn.<span class="title function_">click</span>()</span><br><span class="line"><span class="comment">// 聚焦到输入框</span></span><br><span class="line">input.<span class="title function_">focus</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在页面上写入内容或者键盘按键</span></span><br><span class="line"><span class="keyword">await</span> page.<span class="property">keyboard</span>.<span class="title function_">type</span>(<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line"><span class="keyword">await</span> page.<span class="property">keyboard</span>.<span class="title function_">press</span>(<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line"><span class="keyword">await</span> page.<span class="property">keyboard</span>.<span class="title function_">tdown</span>(<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置鼠标的移动</span></span><br><span class="line"><span class="keyword">await</span> page.<span class="property">mouse</span>.<span class="title function_">move</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">await</span> page.<span class="property">mouse</span>.<span class="title function_">down</span>()</span><br><span class="line"><span class="keyword">await</span> page.<span class="property">mouse</span>.<span class="title function_">move</span>(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">await</span> page.<span class="property">mouse</span>.<span class="title function_">move</span>(<span class="number">100</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">await</span> page.<span class="property">mouse</span>.<span class="title function_">move</span>(<span class="number">100</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">await</span> page.<span class="property">mouse</span>.<span class="title function_">up</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 截获页面请求</span></span><br><span class="line"><span class="keyword">await</span> page.<span class="title function_">setRequestInterception</span>(<span class="literal">true</span>)</span><br><span class="line">	<span class="comment">// 监听请求事件并对请求进行拦截</span></span><br><span class="line">	page.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function"><span class="params">request</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 通过url模块对请求的地址进行解析</span></span><br><span class="line">		request.<span class="title function_">url</span>() <span class="comment">// 可以获取请求的网址，request包含了所有的请求信息</span></span><br><span class="line">		<span class="keyword">if</span>(想要的条件)&#123;</span><br><span class="line">			request.<span class="title function_">continue</span>()</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			request.<span class="title function_">abort</span>([errorCode])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;) </span><br><span class="line">	</span><br><span class="line"><span class="comment">// 获取浏览器的信息和内容</span></span><br><span class="line">page.$eval(selector,<span class="function">(<span class="params">item</span>)=&gt;</span> item)</span><br><span class="line">page.$$eval(selector,<span class="function">(<span class="params">item</span>)=&gt;</span> item)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="反爬虫策略："><a href="#反爬虫策略：" class="headerlink" title="反爬虫策略："></a>反爬虫策略：</h2><ol>
<li><p>几秒钟请求的次数达到一定程度，就会发送验证码、返回其它数据等方式来检验是否有问题<br>解决方式：使用代理proxy</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">proxy</span>: &#123;</span><br><span class="line">	<span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">	<span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">	<span class="attr">auth</span>: &#123;</span><br><span class="line">		<span class="attr">username</span>: <span class="string">&#x27;mikeymike&#x27;</span>,</span><br><span class="line">		<span class="attr">password</span>: <span class="string">&#x27;rapunz3l&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>代理获取途径：花钱，或者找免费代理，但需要一个个ping ip是否响应<br>免费代理IP：117.69.201.242  端口：9999<br>免费代理IP：125.73.220.108  端口：9999<br>免费代理IP：113.124.85.162  端口：9999<br>免费代理IP：114.230.69.33   端口：9999</p>
</li>
<li><p>获取到的字体图标的数据是乱码的，需要下载它的字体图标并解码，花费时间和精力多，需要考虑清除是否一定要去解码</p>
</li>
<li><p>网页不能直接获取源代码，这种叫前端渲染网页，无法爬取。</p>
<ul>
<li>   示例：易点租网页。后端渲染的网页可以爬取</li>
<li>需要分析请求的接口对应哪些内容是<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(httpUrl,  &#123;<span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment">// 找的代理和端口</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="Puppeteer-—-无界面模式"><a href="#Puppeteer-—-无界面模式" class="headerlink" title="Puppeteer — 无界面模式"></a>Puppeteer — 无界面模式</h2><ul>
<li>不用打开 Chrome 界面就可以操作Chrome界面</li>
<li>作用：可以通过api直接控制Cheome模拟大部分用户操作来进行UI Test或者作为爬虫访问页面来收集数据<ul>
<li>生成页面PDF</li>
<li>抓取SPA并生成预渲染内容（SSR）</li>
<li>自动提交表单，进行UI测试，键盘输入</li>
</ul>
</li>
<li>解决了网页为前端渲染，无法直接爬取的问题。直接将页面直接渲染到源码</li>
<li>使用方式：<ul>
<li>使用Chrome打开这个网页打开F12就可以看到详细的网页源代码</li>
<li>然后直接在控制台中输入,就可以直接获取对应信息<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;选择器&quot;</span>).<span class="title function_">getAttribute</span>(<span class="string">&quot;src&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>图像识别</li>
</ul>
</li>
</ul>
<h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">screenshot</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;example.png&#x27;</span>&#125;);	<span class="comment">// 打开页面的时候截屏,path为截屏的图片名字</span></span><br></pre></td></tr></table></figure>
<h3 id="跳转到新页面的方式"><a href="#跳转到新页面的方式" class="headerlink" title="跳转到新页面的方式"></a>跳转到新页面的方式</h3><ul>
<li>方式一：获取对应信息并自动打开对应链接<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取页面内容</span></span><br><span class="line"><span class="comment">// $$eval函数使得回调函数可以运行在浏览器中，并可以通过浏览器的方式进行输出</span></span><br><span class="line"><span class="keyword">let</span> eles = <span class="keyword">await</span> page.$$eval(<span class="string">&quot;#menu li a&quot;</span>, <span class="function">(<span class="params">elements</span>)=&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> eleArr = []</span><br><span class="line">	elements.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item,i</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> eleObj = &#123;</span><br><span class="line">			<span class="attr">href</span>: item.<span class="title function_">getAttribute</span>(<span class="string">&quot;herf&quot;</span>),</span><br><span class="line">			<span class="attr">text</span>: item.<span class="property">innerText</span></span><br><span class="line">		&#125;</span><br><span class="line">		eleArr.<span class="title function_">push</span>(eleObj)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> eleArr</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 自动打开国内电影的页面</span></span><br><span class="line"><span class="keyword">let</span> gnPage = <span class="keyword">await</span> browser.<span class="property">newPage</span></span><br><span class="line"><span class="keyword">await</span> gnPage.<span class="title function_">goto</span>(eles[<span class="number">2</span>].<span class="property">href</span>)	</span><br></pre></td></tr></table></figure></li>
<li>方式二：点击跳转<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过点击页面跳转的方式</span></span><br><span class="line">elementHandles = <span class="keyword">await</span> page.$$(<span class="string">&quot;menu li a&quot;</span>)</span><br><span class="line">elementHandles[<span class="number">2</span>].<span class="title function_">click</span>()</span><br></pre></td></tr></table></figure></li>
<li>方式三：自动打开搜索内容的页面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过表单输入进行搜索(看文档是否为promise对象，是+await)</span></span><br><span class="line">inputEle = <span class="keyword">await</span> page.$(<span class="string">&quot;.searchl .formhue&quot;</span>)</span><br><span class="line"><span class="comment">// 让光标进入到输入框</span></span><br><span class="line"><span class="keyword">await</span> inputEle.<span class="title function_">focus</span>()</span><br><span class="line"><span class="comment">// 往输入框输入内容</span></span><br><span class="line"><span class="keyword">await</span> page.<span class="property">keyboard</span>.<span class="title function_">type</span>(<span class="string">&quot;热烈&quot;</span>)</span><br><span class="line"><span class="comment">// 绑定事件，取消冒泡 --- 因为点击按钮，自动冒泡打开了广告</span></span><br><span class="line"><span class="keyword">await</span> page.$eval(<span class="string">&#x27;.bd3rl&gt; .searchr&#x27;</span>, <span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">	element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">		e.<span class="property">cancelBubble</span> = <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 点击按钮(找到按钮的选择器)</span></span><br><span class="line"><span class="keyword">let</span> btnEle = <span class="keyword">await</span> page.$(<span class="string">&#x27;.searchr input[name=&quot;Submit&quot;]&#x27;</span>)</span><br><span class="line"><span class="keyword">await</span> btnEle.<span class="title function_">click</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>【参考】<a href="https://blog.csdn.net/BLee_0123/article/details/131427517">爬虫基本原理</a><br>【参考】<a href="https://www.bilibili.com/video/BV1i7411G7kW/?p=13&spm_id_from=pageDriver&vd_source=7ff3c1c4d72a6d5534ee6ccf76c617ce">B站视频</a></p>
<!-- 【案例】位于练习的p_four文件夹下的utils目录的test_cherrio.js , 这个基本上是成功，出来数据多图片加载不出来
【案例】位于练习的p_four文件夹下的utils目录的test_reg.js，这个没有完成遍历所有页面
【案例】位于练习的p_four文件夹下的utils目录的test_puppeteer.js -->]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建最简单的服务器</title>
    <url>/2024/10/31/node/4%E6%90%AD%E5%BB%BA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<!-- +【案例】这是一个封装好的搭建服务器函数 simple_server.js
+【案例】这是一个应用封装的方法，并根据数据与模板动态生成页面的案例 useServer.js -->

<h2 id="搭建简单的服务器"><a href="#搭建简单的服务器" class="headerlink" title="搭建简单的服务器"></a>搭建简单的服务器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&quot;http&quot;</span></span><br><span class="line"><span class="comment">// 创建server服务器对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"><span class="comment">// 监听对当前服务器对象的请求</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// req： 请求数据都会放在请求对象里</span></span><br><span class="line">	<span class="comment">// res： 能够做出响应对象</span></span><br><span class="line">	<span class="comment">// 当服务器被请求时，会触发请求事件，并传入请求对象和响应对象</span></span><br><span class="line">	<span class="comment">// 设置响应头</span></span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;text/html;charset=utf-8;&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根据路径信息显示不同页面</span></span><br><span class="line">	<span class="keyword">if</span>(req.<span class="property">url</span> == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">		res.<span class="title function_">end</span>(<span class="string">&#x27;首页&#x27;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="property">url</span> == <span class="string">&quot;/gnxw&quot;</span>)&#123;</span><br><span class="line">		res.<span class="title function_">end</span>(<span class="string">&#x27;国内新闻首页&#x27;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="property">url</span> == <span class="string">&quot;/ylxw&quot;</span>)&#123;</span><br><span class="line">		res.<span class="title function_">end</span>(<span class="string">&#x27;娱乐新闻首页&#x27;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		res.<span class="title function_">end</span>(<span class="string">&quot;&lt;h1&gt;404页面查找不到！&lt;/h1&gt;&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(端口号,回调函数)</span><br></pre></td></tr></table></figure>

<h2 id="优化服务器性能封装服务器的方法"><a href="#优化服务器性能封装服务器的方法" class="headerlink" title="优化服务器性能封装服务器的方法"></a>优化服务器性能封装服务器的方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ServerApp</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 创建server服务器对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">server</span> = http.<span class="title function_">createServer</span>()</span><br><span class="line">		<span class="comment">// 创建请求事件的空对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reqEvent</span> = &#123;&#125;</span><br><span class="line">    <span class="comment">// 暴露目录名：可以让人修改，但实际上不管怎么改都是使用static这个目录，做到混淆他人获取信息</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">staticPath</span> = <span class="string">&quot;/static&quot;</span></span><br><span class="line">    <span class="comment">// 监听对当前服务器对象的请求</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">server</span>.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 解析路径</span></span><br><span class="line">      <span class="keyword">let</span> pathObj = path.<span class="title function_">parse</span>(req.<span class="property">url</span>)</span><br><span class="line">      <span class="keyword">if</span>( pathObj.<span class="property">dir</span> <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">reqEvent</span>) &#123;</span><br><span class="line">				<span class="comment">// 将渲染函数添加到响应对象中</span></span><br><span class="line">        res.<span class="property">render</span> = render</span><br><span class="line">        res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>)</span><br><span class="line">        req.<span class="property">pathObj</span> = pathObj</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reqEvent</span>[pathObj.<span class="property">dir</span>](req,res)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathObj.<span class="property">dir</span> == <span class="variable language_">this</span>.<span class="property">staticPath</span>)&#123;</span><br><span class="line">        <span class="comment">// 读取静态目录</span></span><br><span class="line">        res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="variable language_">this</span>.<span class="title function_">getContentType</span>(pathObj.<span class="property">ext</span>))</span><br><span class="line">        <span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./static/&#x27;</span> + pathObj.<span class="property">base</span>)</span><br><span class="line">        rs.<span class="title function_">pipe</span>(res)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>)</span><br><span class="line">        res.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;404页面找不到！&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 封装监听请求</span></span><br><span class="line">  <span class="title function_">on</span> (url, fn) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reqEvent</span>[url] = fn</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 服务器启动</span></span><br><span class="line">  <span class="title function_">run</span> (port,callback) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">server</span>.<span class="title function_">listen</span>(port,callback)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 封装对应什么后缀名返回什么头响应模式</span></span><br><span class="line">	<span class="title function_">getContentType</span>(<span class="params">extName</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span>(extName) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;.jpg&quot;</span>: </span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;image/jpeg&quot;</span></span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;.html&quot;</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;text/html;charset=utf-8&quot;</span></span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;.js&quot;</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;text/javascript;charset=utf-8&quot;</span></span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;.json&quot;</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;text/json;charset=utf-8&quot;</span></span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;.gif&quot;</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;image/gif&quot;</span></span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;.css&quot;</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;text/css&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">default</span> <span class="title class_">ServerApp</span></span><br></pre></td></tr></table></figure>

<h2 id="根据数据与模板动态生成页面"><a href="#根据数据与模板动态生成页面" class="headerlink" title="根据数据与模板动态生成页面"></a>根据数据与模板动态生成页面</h2><ol>
<li><p>根据规则去解析链接，并且获取ID或者索引值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> index = req.<span class="property">pathObj</span>.<span class="property">base</span></span><br><span class="line">请求路径： <span class="attr">localhost</span>:<span class="number">3000</span>/movices/<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据索引获取数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> movices = [&#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;长空之王&#x27;</span>,</span><br><span class="line">	<span class="attr">desc</span>: <span class="string">&#x27;试飞员的故事&#x27;</span>,</span><br><span class="line">	<span class="attr">author</span>: <span class="string">&#x27;胡军、王一博&#x27;</span>,</span><br><span class="line">	<span class="attr">list</span>: [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;热烈&#x27;</span>,</span><br><span class="line">	<span class="attr">desc</span>: <span class="string">&#x27;由街舞引申的关于梦想和青春的故事&#x27;</span>,</span><br><span class="line">	<span class="attr">author</span>: <span class="string">&#x27;王一博&#x27;</span></span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">let</span> pageData = movices[index]</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据模板渲染页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.<span class="title function_">render</span>(movices[index], <span class="string">&#x27;./template/index.html&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>底层需要实现渲染函数，通过正则匹配，找到需要修改的地方进行一一修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">options, path</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(path,&#123;<span class="attr">encoding</span>: <span class="string">&quot;utf-8&quot;</span>, <span class="attr">flag</span>: <span class="string">&quot;r&quot;</span>&#125;,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里使用箭头函数，使this指向调用的res</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">      <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/ig</span>s</span><br><span class="line">      <span class="keyword">let</span> result;</span><br><span class="line">      <span class="keyword">while</span>(result = reg.<span class="title function_">exec</span>(data)) &#123;</span><br><span class="line">        <span class="comment">// 去除key两边的空白字符，并拿到key</span></span><br><span class="line">        <span class="keyword">let</span> strKey = result[<span class="number">1</span>].<span class="title function_">trim</span>()</span><br><span class="line">        <span class="keyword">let</span> strValue = options[strKey]</span><br><span class="line">        data = data.<span class="title function_">replace</span>(result[<span class="number">0</span>],strValue)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">end</span>(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="列表的动态渲染"><a href="#列表的动态渲染" class="headerlink" title="列表的动态渲染"></a>列表的动态渲染</h2><ol>
<li><p>在html页面定义列表循环的标记</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">	&#123;%<span class="keyword">for</span> &#123;list&#125; %&#125;</span><br><span class="line">	&lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">	&#123;%endfor%&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则匹配标记</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> listreg = <span class="regexp">/\&#123;\%for \&#123;(.*?)\&#125; \%\&#125;(.*?)\&#123;\%endfor\%\&#125;/ig</span>s</span><br></pre></td></tr></table></figure>
<ul>
<li>从中匹配到两个组<ul>
<li>第一个组匹配出变量的key值</li>
<li>第二哥组匹配出需要生成的每一项的内容</li>
</ul>
</li>
</ul>
</li>
<li><p>匹配替换每一项的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(listResult = listreg.<span class="title function_">exec</span>(data)) &#123;</span><br><span class="line">  <span class="keyword">let</span> list = listResult[<span class="number">1</span>].<span class="title function_">trim</span>()</span><br><span class="line">  <span class="comment">// 通过key值获取数据内容</span></span><br><span class="line">  <span class="keyword">let</span> listValue = options[list]</span><br><span class="line">  <span class="keyword">let</span> listStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  listValue.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 替换每一项内容的变量</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">    listStr = listStr + <span class="title function_">replaceVAr</span>(listResult[<span class="number">2</span>], &#123;<span class="string">&quot;item&quot;</span>:item&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  data = data.<span class="title function_">replace</span>(listResult[<span class="number">0</span>],listStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过eval函数，将字符串的表达式计算出来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strValue = <span class="built_in">eval</span>(<span class="string">&#x27;options.&#x27;</span> + strKey)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="正则路由的设定"><a href="#正则路由的设定" class="headerlink" title="正则路由的设定"></a>正则路由的设定</h2><ul>
<li>要求：可以根据自己设定的正则匹配路径来执行想应的函数来响应用户的内容</li>
</ul>
<ol>
<li><p>设定正则的匹配路径和响应的执行函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">serverRqquest.<span class="title function_">on</span>(<span class="string">&#x27;^/$&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&quot;&lt;h1&gt;首页&lt;/h1&gt;&lt;img src=&#x27;./abc/bg-1.jpg&#x27;&gt;&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取正则路径创建正则对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(regStr, <span class="string">&#x27;igs&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配路径，并调用相对应的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(reg.<span class="title function_">test</span>(req.<span class="property">url</span>)) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">reqEvent</span>[key](req, res)</span><br><span class="line">	resState = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否正则路径响应过，如果响应过，将不在响应，会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!resState) &#123;</span><br><span class="line">	<span class="keyword">if</span> (pathObj.<span class="property">dir</span> == <span class="variable language_">this</span>.<span class="property">staticPath</span>)&#123;<span class="comment">// 静态目录</span></span><br><span class="line">		res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="variable language_">this</span>.<span class="title function_">getContentType</span>(pathObj.<span class="property">ext</span>))</span><br><span class="line">		<span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./static/&#x27;</span> + pathObj.<span class="property">base</span>)</span><br><span class="line">		rs.<span class="title function_">pipe</span>(res)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>)</span><br><span class="line">		res.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;404页面找不到！&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>梳理框架流程</title>
    <url>/2024/10/31/node/5%E6%A2%B3%E7%90%86%E6%A1%86%E6%9E%B6%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="浏览器发送请求"><a href="#浏览器发送请求" class="headerlink" title="浏览器发送请求"></a>浏览器发送请求</h2><ol>
<li>用户输入网址地址<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//127.0.0.1/ 或者 localhost:3000</span></span><br></pre></td></tr></table></figure></li>
<li>浏览器根据请求转变成HTTP的请求包</li>
</ol>
<h2 id="服务器接受到请求"><a href="#服务器接受到请求" class="headerlink" title="服务器接受到请求"></a>服务器接受到请求</h2><ol>
<li>http模块里实例化的server对象，server对象监听每一次浏览器发送的请求，每次请求都会触发request事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">server</span>.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>将http的请求包转化为req的请求对象，并且传入到请求事件触发的函数中</li>
<li>会创建生成一个res响应对象，这个对象可以帮助我们快速实现http的响应</li>
</ol>
<h2 id="解析请求路径，调用不同的页面渲染函数"><a href="#解析请求路径，调用不同的页面渲染函数" class="headerlink" title="解析请求路径，调用不同的页面渲染函数"></a>解析请求路径，调用不同的页面渲染函数</h2><ol>
<li><p>正则匹配方式进行对路径的匹配</p>
</li>
<li><p>以匹配的正则字符串作为KEY，找到需要调用执行的渲染函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环匹配正则路径</span></span><br><span class="line">res.<span class="property">render</span> = render</span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">reqEvent</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> regStr = key</span><br><span class="line">	<span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(regStr, <span class="string">&#x27;igs&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span>(reg.<span class="title function_">test</span>(req.<span class="property">url</span>)) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">reqEvent</span>[key](req, res)</span><br><span class="line">		resState = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用页面的执行函数，执行模板渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">serverRqquest.<span class="title function_">on</span>(<span class="string">&#x27;/movices&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 这里的箭头函数即为真正匹配到的页面执行的函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用模板的渲染函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.<span class="title function_">render</span>(movices[index], <span class="string">&#x27;./template/index0.html&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>执行渲染函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">options, path</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(path,&#123;<span class="attr">encoding</span>: <span class="string">&quot;utf-8&quot;</span>, <span class="attr">flag</span>: <span class="string">&quot;r&quot;</span>&#125;,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里使用箭头函数，使this指向调用的res</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="comment">// 数组变量的替换</span></span><br><span class="line">				data = <span class="title function_">replaceArr</span>(data,options)</span><br><span class="line">				<span class="comment">// 单个变量的替换</span></span><br><span class="line">				data = <span class="title function_">replaceVAr</span>(data,options)</span><br><span class="line">			&#125;<span class="keyword">catch</span>(error) &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 最终输出渲染出来的html</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">end</span>(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组变量替换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceArr</span>(<span class="params">data,options</span>) &#123;</span><br><span class="line">  <span class="comment">// 匹配循环的变量，并且替换循环的内容</span></span><br><span class="line">  <span class="keyword">let</span> listreg = <span class="regexp">/\&#123;\%for \&#123;(.*?)\&#125; \%\&#125;(.*?)\&#123;\%endfor\%\&#125;/ig</span>s</span><br><span class="line">  <span class="keyword">let</span> listResult;</span><br><span class="line">  <span class="keyword">while</span>(listResult = listreg.<span class="title function_">exec</span>(data)) &#123;</span><br><span class="line">    <span class="keyword">let</span> list = listResult[<span class="number">1</span>].<span class="title function_">trim</span>()</span><br><span class="line">    <span class="keyword">let</span> listValue = options[list]</span><br><span class="line">    <span class="keyword">let</span> listStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    listValue.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 替换每一项内容的变量</span></span><br><span class="line">      listStr = listStr + <span class="title function_">replaceVAr</span>(listResult[<span class="number">2</span>], &#123;<span class="string">&quot;item&quot;</span>:item&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    data = data.<span class="title function_">replace</span>(listResult[<span class="number">0</span>],listStr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单个变量的替换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceVAr</span>(<span class="params">data,options</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/ig</span>s</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">while</span>(result = reg.<span class="title function_">exec</span>(data)) &#123;</span><br><span class="line">    <span class="comment">// 去除key两边的空白字符，并拿到key</span></span><br><span class="line">    <span class="keyword">let</span> strKey = result[<span class="number">1</span>].<span class="title function_">trim</span>()</span><br><span class="line">    <span class="keyword">let</span> strValue = <span class="built_in">eval</span>(<span class="string">&#x27;options.&#x27;</span> + strKey) <span class="comment">// 执行字符串作为JS表达式，并将计算出来的结果返回</span></span><br><span class="line">    data = data.<span class="title function_">replace</span>(result[<span class="number">0</span>],strValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="匹配路径是否为静态路径，如果是请求静态文件，那么就按照静态文件的形式输出"><a href="#匹配路径是否为静态路径，如果是请求静态文件，那么就按照静态文件的形式输出" class="headerlink" title="匹配路径是否为静态路径，如果是请求静态文件，那么就按照静态文件的形式输出"></a>匹配路径是否为静态路径，如果是请求静态文件，那么就按照静态文件的形式输出</h2><ol>
<li>首先判断是否响应过，如未响应过，可以判断是否为静态文件，如果是静态文件就正常的输出</li>
<li>否则，就输出404<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!resState) &#123;</span><br><span class="line">	<span class="keyword">if</span> (pathObj.<span class="property">dir</span> == <span class="variable language_">this</span>.<span class="property">staticPath</span>)&#123;<span class="comment">// 静态目录</span></span><br><span class="line">		res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="variable language_">this</span>.<span class="title function_">getContentType</span>(pathObj.<span class="property">ext</span>))</span><br><span class="line">		<span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./static/&#x27;</span> + pathObj.<span class="property">base</span>)</span><br><span class="line">		rs.<span class="title function_">pipe</span>(res)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>)</span><br><span class="line">		res.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;404页面找不到！&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="RES响应对象将res设置的内容最终转化为http的响应包"><a href="#RES响应对象将res设置的内容最终转化为http的响应包" class="headerlink" title="RES响应对象将res设置的内容最终转化为http的响应包"></a>RES响应对象将res设置的内容最终转化为http的响应包</h2><h2 id="浏览器解析响应包，并将html渲染在页面上"><a href="#浏览器解析响应包，并将html渲染在页面上" class="headerlink" title="浏览器解析响应包，并将html渲染在页面上"></a>浏览器解析响应包，并将html渲染在页面上</h2>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Node总结</title>
    <url>/2024/10/31/node/6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>服务器：本质上是一台PC主机(linux系统，window系统)，部署了后端语言的执行环境，并且能够长时间提供网络服务</li>
</ul>
<h3 id="事件驱动："><a href="#事件驱动：" class="headerlink" title="事件驱动："></a>事件驱动：</h3><ul>
<li>node本身提供事件对象，帮助我们快速实现订阅者模式，或者观察者模式，或者事件模式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.<span class="title function_">on</span>(<span class="string">&#x27;事件的名称&#x27;</span>, <span class="function">() =&gt;</span> &#123;订阅的事件&#125;) <span class="comment">// 事件的订阅</span></span><br><span class="line">event.<span class="title function_">emit</span>(<span class="string">&#x27;事件的名称&#x27;</span>) <span class="comment">// 事件的触发</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="读写事件："><a href="#读写事件：" class="headerlink" title="读写事件："></a>读写事件：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">writefile</span>(<span class="string">&#x27;path&#x27;</span>,读取配置,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;path&#x27;</span>,写入数据,写入配置,<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="读写的promise封装："><a href="#读写的promise封装：" class="headerlink" title="读写的promise封装："></a>读写的promise封装：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装读取的操作</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fsRead</span> = (<span class="params">url: string</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(url, &#123;<span class="attr">flag</span>: <span class="string">&#x27;r&#x27;</span>, <span class="attr">encoding</span>: <span class="string">&quot;utf-8&quot;</span>&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(!err) &#123;</span><br><span class="line">				<span class="title function_">resolve</span>(data)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="title function_">reject</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 封装写入的操作</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fsWrite</span> = (<span class="params">url: string, data: any</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		fs.<span class="title function_">writeFile</span>(url, data, &#123;<span class="attr">flag</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span> &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(!err) &#123;</span><br><span class="line">				<span class="title function_">resolve</span>()</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="title function_">reject</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装创建目录的函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fsDir</span> = (<span class="params">url</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		fs.<span class="title function_">mkdir</span>(url, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(!err) &#123;</span><br><span class="line">				<span class="title function_">resolve</span>()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;) </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;fsDir,fsRead, fsWrite&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用方式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> data = <span class="keyword">await</span> <span class="title function_">fsRead</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="网络请求数据："><a href="#网络请求数据：" class="headerlink" title="网络请求数据："></a>网络请求数据：</h3><ul>
<li>request，axios：效率比较高，但局限性比较大</li>
<li>puppeteer：效率低，局限性比较小</li>
<li>重点掌握：页面的分析，数据存放的位置，以及响应的内容</li>
</ul>
<h3 id="网络响应数据："><a href="#网络响应数据：" class="headerlink" title="网络响应数据："></a>网络响应数据：</h3><ul>
<li>http.createServer: 就可以创建1个服务器去监听某个端口，并且通过请求事件来处理每个发送过来的请求<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="attr">req</span>: 请求数据都会放在请求对象里</span><br><span class="line">	<span class="attr">res</span>: 能够做出响应对象</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>路由：根据不同的路径响应不同的内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环匹配正则路径</span></span><br><span class="line">res.<span class="property">render</span> = render</span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">reqEvent</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> regStr = key</span><br><span class="line">	<span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(regStr, <span class="string">&#x27;igs&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span>(reg.<span class="title function_">test</span>(req.<span class="property">url</span>)) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">reqEvent</span>[key](req, res)</span><br><span class="line">		resState = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h3><ul>
<li>会有固定样式和结构的HTML模板，根据请求的数据不同，显示页面内容。例如新闻网站。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">options, path</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(path,&#123;<span class="attr">encoding</span>: <span class="string">&quot;utf-8&quot;</span>, <span class="attr">flag</span>: <span class="string">&quot;r&quot;</span>&#125;,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里使用箭头函数，使this指向调用的res</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 匹配普通的变量，并且替换内容</span></span><br><span class="line">      data = <span class="title function_">replaceArr</span>(data,options)</span><br><span class="line">      data = <span class="title function_">replaceVAr</span>(data,options)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">end</span>(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NPM上传包</title>
    <url>/2024/10/31/node/7NPM%E4%B8%8A%E4%BC%A0%E5%8C%85/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>创建文件夹<ul>
<li>写完内容</li>
</ul>
</li>
<li>在该文件夹中打开终端<ul>
<li>在地址栏中输入cmd回车即可</li>
</ul>
</li>
<li>npm包的初始化<ul>
<li>在终端中输入 npm init</li>
</ul>
</li>
<li>npm包信息的设置<ul>
<li>就是回答初始化运行的问题</li>
</ul>
</li>
<li>注册NPM官网账号</li>
<li>NPM官网账号需要邮箱验证</li>
<li>本机登录npm<ul>
<li>在终端输入 npm login</li>
<li>然后输入账号密码</li>
</ul>
</li>
<li>发布NPM包<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="私网地址"><a href="#私网地址" class="headerlink" title="私网地址"></a>私网地址</h3><p>A类地址：10.0.0.0 ~ 10.255.255.255<br>B类地址：172.16.0.0 ~ 172.31.255.255<br>C类地址：192.168.0.0 ~ 192.168.255.255</p>
<h1 id="将本地网址部署到公网上"><a href="#将本地网址部署到公网上" class="headerlink" title="将本地网址部署到公网上"></a>将本地网址部署到公网上</h1><p><a href="https://hsk.oray.com/">花生壳</a>: 可以将私网服务器地址和端口号跟公网固定的IP地址和端口绑定</p>
<ul>
<li>注册后要实名认证</li>
<li>点花生壳，体验版由免费的域名和免费的IP</li>
<li>运行自己的网站</li>
<li>然后在花生壳的体验版创建填写应用名称，内网主机的IP地址（通过ipconfig去看）和端口号，然后完成</li>
<li>下载花生壳软件，安装后打开诊断一下创建的应用确认无误后，点击提供的访问地址就部署完成</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-3D官网步骤</title>
    <url>/2024/11/01/threeJS/3d%E5%AE%98%E7%BD%91%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ol>
<li>先将官网的整体布局实现，背景使用canvas画布并置于底层</li>
<li>通过布局留出来的空白位置，等待加载模型</li>
<li>定义两个变量，将画布和控制页面展示的参数初始化，并在onMounted中赋值</li>
<li>创建环境，加载环境并渲染到画布上</li>
<li>加载模型，如想要模型能动起来就在加载的回调函数中监听鼠标的移动事件</li>
<li>当滚动鼠标滚轮时，想要不同的模型出现在不同的页面，就加载不同模型，但位置要呈一定的倍数关系，并监听滚轮事件</li>
<li>实例化创建球体，并生成多个，通过for循环和随机函数让xyz的坐标随机，并添加到矩阵中，然后设置实例化球体的每一个与该矩阵相同</li>
<li>如果想要球体大小不一致，可以设置matrix.makeScale(size,size,size),size也是随机生成</li>
<li>通过补间动画让球体移动</li>
</ol>
]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>案例</tag>
        <tag>ThreeJS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-Three+React</title>
    <url>/2024/11/01/threeJS/three+react/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>创建项目后，安装three.js</li>
<li>使用useEffect来创建代码<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入three.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 创建场景</span></span><br><span class="line">	<span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>(); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建相机 --- 遵循近大远小原则</span></span><br><span class="line">	<span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(</span><br><span class="line">	 <span class="number">75</span>, <span class="comment">// 视角 --- 在同距离情况下，视角越大（宽），看到的东西越多</span></span><br><span class="line">	 <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>, <span class="comment">// 相机的宽高比</span></span><br><span class="line">	 <span class="number">0.1</span>,  <span class="comment">// 近平面 --- 相机最近能看到的</span></span><br><span class="line">	 <span class="number">1000</span>  <span class="comment">// 远平面 --- 相机最远能看到的</span></span><br><span class="line">	); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建渲染器</span></span><br><span class="line">	<span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>(); </span><br><span class="line">	renderer.<span class="title function_">setSize</span>( <span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span> ); </span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>( renderer.<span class="property">domElement</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建几何体</span></span><br><span class="line">	<span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建材质</span></span><br><span class="line">	<span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建网格</span></span><br><span class="line">	<span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry,material)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将网格添加到场景中</span></span><br><span class="line">	scene.<span class="title function_">add</span>(cube)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置相机的位置</span></span><br><span class="line">	camera.<span class="property">position</span>.<span class="property">z</span> = <span class="number">5</span></span><br><span class="line">	camera.<span class="title function_">lookAt</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 渲染函数</span></span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	  <span class="title function_">requestAnimationFrame</span>(animate)</span><br><span class="line">	  <span class="comment">// 旋转</span></span><br><span class="line">	  cube.<span class="property">rotation</span>.<span class="property">x</span> += <span class="number">0.01</span></span><br><span class="line">	  cube.<span class="property">rotation</span>.<span class="property">y</span> += <span class="number">0.01</span></span><br><span class="line">	  <span class="comment">// 渲染</span></span><br><span class="line">	  renderer.<span class="title function_">render</span>(scene, camera)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="title function_">animate</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
css替换全局css<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">canvas</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1280px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>ThreeJS</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-Three+Vue</title>
    <url>/2024/11/01/threeJS/three+vue/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>项目搭建后，安装three.js</li>
<li>将css替换到App.vue中的style中<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">canvas</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1280px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>代码直接写在是<code>&lt;script setup&gt;</code>中即可<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入three.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建相机 --- 遵循近大远小原则</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(</span><br><span class="line"> <span class="number">75</span>, <span class="comment">// 视角 --- 在同距离情况下，视角越大（宽），看到的东西越多</span></span><br><span class="line"> <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>, <span class="comment">// 相机的宽高比</span></span><br><span class="line"> <span class="number">0.1</span>,  <span class="comment">// 近平面 --- 相机最近能看到的</span></span><br><span class="line"> <span class="number">1000</span>  <span class="comment">// 远平面 --- 相机最远能看到的</span></span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>(); </span><br><span class="line">renderer.<span class="title function_">setSize</span>( <span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span> ); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>( renderer.<span class="property">domElement</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建材质</span></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建网格</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry,material)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将网格添加到场景中</span></span><br><span class="line">scene.<span class="title function_">add</span>(cube)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机的位置</span></span><br><span class="line">camera.<span class="property">position</span>.<span class="property">z</span> = <span class="number">5</span></span><br><span class="line">camera.<span class="title function_">lookAt</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(animate)</span><br><span class="line">  <span class="comment">// 旋转</span></span><br><span class="line">  cube.<span class="property">rotation</span>.<span class="property">x</span> += <span class="number">0.01</span></span><br><span class="line">  cube.<span class="property">rotation</span>.<span class="property">y</span> += <span class="number">0.01</span></span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  renderer.<span class="title function_">render</span>(scene, camera)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">animate</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>ThreeJS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-VR看房案例</title>
    <url>/2024/11/01/threeJS/vr%E7%9C%8B%E6%88%BF%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>简单表述就是给正方形的六个面贴上不同的壁纸，而人位于正方体的中间，就会感觉到3DVR的效果，多个场景就构建多个立方体组合</p>
</blockquote>
<h3 id="创建一个div并设置宽高为整个屏幕，获取div的dom"><a href="#创建一个div并设置宽高为整个屏幕，获取div的dom" class="headerlink" title="创建一个div并设置宽高为整个屏幕，获取div的dom"></a>创建一个div并设置宽高为整个屏幕，获取div的dom</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;width:100vw;height:100vh&quot;</span> ref=<span class="string">&quot;squareDom&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个场景"><a href="#创建一个场景" class="headerlink" title="创建一个场景"></a>创建一个场景</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>()</span><br></pre></td></tr></table></figure>
<h3 id="初始化相机-并设置相机的位置"><a href="#初始化相机-并设置相机的位置" class="headerlink" title="初始化相机 并设置相机的位置"></a>初始化相机 并设置相机的位置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(<span class="number">75</span>,<span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>, <span class="number">0.1</span>, <span class="number">1000</span>)</span><br><span class="line">camera .<span class="property">position</span>.<span class="property">z</span> = <span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<h3 id="初始化渲染器-和dom"><a href="#初始化渲染器-和dom" class="headerlink" title="初始化渲染器 和dom"></a>初始化渲染器 和dom</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> squareDom = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> render = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>()</span><br><span class="line">renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br></pre></td></tr></table></figure>
<h3 id="渲染函数渲染场景并请求动画帧和实时更新控制器"><a href="#渲染函数渲染场景并请求动画帧和实时更新控制器" class="headerlink" title="渲染函数渲染场景并请求动画帧和实时更新控制器"></a>渲染函数渲染场景并请求动画帧和实时更新控制器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	controls &amp;&amp; controls.<span class="title function_">update</span>()</span><br><span class="line">	renderer.<span class="title function_">render</span>(scene, camera)</span><br><span class="line">	<span class="title function_">requestAnimationFrame</span>(render)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加轨道控制器并添加阻尼"><a href="#添加轨道控制器并添加阻尼" class="headerlink" title="添加轨道控制器并添加阻尼"></a>添加轨道控制器并添加阻尼</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> <span class="title class_">OrbitControls</span>(camera, squareDom.<span class="property">value</span>)</span><br><span class="line">controls.<span class="property">enableDamping</span> = <span class="literal">true</span></span><br><span class="line">controls.<span class="property">dampingFactor</span> = <span class="number">0.05</span></span><br></pre></td></tr></table></figure>

<h3 id="创建立方体（非hdr图）"><a href="#创建立方体（非hdr图）" class="headerlink" title="创建立方体（非hdr图）"></a>创建立方体（非hdr图）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h3 id="将六张图片加载进来"><a href="#将六张图片加载进来" class="headerlink" title="将六张图片加载进来"></a>将六张图片加载进来</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boxMaterials = [<span class="comment">/*材质加载的顺序要按照左右，上下，前后以实现更好的拼接*/</span>]</span><br><span class="line"><span class="keyword">const</span> texture = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>().<span class="title function_">load</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">boxMaterials.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">map</span>: texture&#125;))</span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry,boxMaterials)</span><br><span class="line">cube.<span class="property">geometry</span>.<span class="title function_">scale</span>(<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>) <span class="comment">/*让视角位于立方体中心*/</span></span><br><span class="line">scene.<span class="title function_">add</span>(cube)</span><br></pre></td></tr></table></figure>
<h3 id="如果有图片的位置角度对不上需要旋转，旋转后添加材料，否则直接添加材料"><a href="#如果有图片的位置角度对不上需要旋转，旋转后添加材料，否则直接添加材料" class="headerlink" title="如果有图片的位置角度对不上需要旋转，旋转后添加材料，否则直接添加材料"></a>如果有图片的位置角度对不上需要旋转，旋转后添加材料，否则直接添加材料</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">texture.<span class="property">rotation</span> = <span class="title class_">Math</span>.<span class="property">PI</span> <span class="comment">/*旋转角度*/</span></span><br><span class="line">texture.<span class="property">center</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector2</span>(<span class="number">0.5</span>, <span class="number">0.5</span>) <span class="comment">/*按照图片的中心旋转*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果是hdr后缀的全景图是球体的映射</li>
</ul>
<h3 id="创建球体（hdr图）并添加全景图"><a href="#创建球体（hdr图）并添加全景图" class="headerlink" title="创建球体（hdr图）并添加全景图"></a>创建球体（hdr图）并添加全景图</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SphereGeometry</span>(<span class="number">5</span>,<span class="number">32</span>,<span class="number">32</span>);</span><br><span class="line"><span class="keyword">const</span> rgbLoader = <span class="keyword">new</span> <span class="title class_">RGBELoader</span>()</span><br><span class="line">rgbLoader.<span class="title function_">load</span>(<span class="string">&quot;&quot;</span>, <span class="function">(<span class="params">texture</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">map</span>: texture&#125;)</span><br><span class="line">	<span class="keyword">const</span> sphere = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material)</span><br><span class="line">	sphere.<span class="property">geometry</span>.<span class="title function_">scale</span>(<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>) <span class="comment">/*让视角位于立方体中心*/</span></span><br><span class="line">	scene.<span class="title function_">add</span>(sphere)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下内容在onMounted生命周期函数中写的</p>
</blockquote>
<h3 id="挂载完毕后获取dom"><a href="#挂载完毕后获取dom" class="headerlink" title="挂载完毕后获取dom"></a>挂载完毕后获取dom</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">squareDom.<span class="property">value</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>)</span><br></pre></td></tr></table></figure>
<h3 id="调用渲染函数"><a href="#调用渲染函数" class="headerlink" title="调用渲染函数"></a>调用渲染函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>案例</tag>
        <tag>ThreeJS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-修改模型的child</title>
    <url>/2024/11/01/threeJS/%E4%BF%AE%E6%94%B9%E6%A8%A1%E5%9E%8B%E7%9A%84child/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h1 id="创建3D贺卡的案例"><a href="#创建3D贺卡的案例" class="headerlink" title="创建3D贺卡的案例"></a>创建3D贺卡的案例</h1><ul>
<li>加载模型后通过回调函数来设置模型</li>
<li>获取模型的场景<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> model = gltf.<span class="property">scene</span> </span><br></pre></td></tr></table></figure></li>
<li>模型的缩放大小<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">model.<span class="property">scale</span>.<span class="title function_">set</span>(x,y,z)</span><br></pre></td></tr></table></figure></li>
<li>遍历模型 <span class="desc">这里能拿到模型的部件</span><ul>
<li>注：<span class="desc">Mesh是由几何体和材质组成的网格，而网格才能渲染在屏幕上</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">model.<span class="title function_">traverse</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">	child.<span class="property">Mesh</span> <span class="comment">// 获取部件的网格</span></span><br><span class="line">	child.<span class="property">name</span> <span class="comment">// 获取部件的名称，可以用来控制对应部件要展示什么效果</span></span><br><span class="line">	child.<span class="property">visible</span> = <span class="literal">true</span>; <span class="comment">// 设置部件是否渲染，false不渲染</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>把模型添加到场景中 <span class="desc">最重要</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scene.<span class="title function_">add</span>(model) </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="设置模型-网格在场景的位置-position"><a href="#设置模型-网格在场景的位置-position" class="headerlink" title="设置模型&#x2F;网格在场景的位置(position)"></a>设置模型&#x2F;网格在场景的位置(position)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mesh.<span class="property">position</span>.<span class="title function_">set</span>(x,y,z) </span><br><span class="line">mesh.<span class="property">position</span>.<span class="property">x</span> = x</span><br><span class="line">mesh.<span class="property">position</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(x,y,z)</span><br></pre></td></tr></table></figure>

<h3 id="设置物体旋转-rotation"><a href="#设置物体旋转-rotation" class="headerlink" title="设置物体旋转(rotation)"></a>设置物体旋转(rotation)</h3><ul>
<li>表示的是绕x&#x2F;y&#x2F;z轴旋转的弧度<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mesh.<span class="property">rotation</span>.<span class="title function_">set</span>(x,y,z) </span><br><span class="line">mesh.<span class="property">rotation</span>.<span class="property">x</span> = x</span><br><span class="line">mesh.<span class="property">rotation</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(x,y,z) </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置模型-网格相对于原来位置的移动距离-translate-–-用法同position一样"><a href="#设置模型-网格相对于原来位置的移动距离-translate-–-用法同position一样" class="headerlink" title="设置模型&#x2F;网格相对于原来位置的移动距离(translate) – 用法同position一样"></a>设置模型&#x2F;网格相对于原来位置的移动距离(translate) – 用法同position一样</h3><h2 id="直射光-—-场景中物理材质一定要有，模拟阳光"><a href="#直射光-—-场景中物理材质一定要有，模拟阳光" class="headerlink" title="直射光 — 场景中物理材质一定要有，模拟阳光"></a>直射光 — 场景中物理材质一定要有，模拟阳光</h2><ul>
<li>创建直射光并添加到场景中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">DirectionalLight</span>(灯光颜色， 强度默认<span class="number">1</span>)</span><br><span class="line">scene.<span class="title function_">add</span>(light) </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h2><blockquote>
<p>作用类似于让屋子亮灯，屋子开了个门，门口会投射灯光</p>
</blockquote>
<ul>
<li>添加点光源<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pointlight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointLight</span>(光源的颜色, 光的强度)</span><br></pre></td></tr></table></figure></li>
<li>适当调整位置</li>
<li>设置灯光投射阴影<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pointlight.<span class="property">castShadow</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>设置渲染器允许光源有阴影<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">renderer.<span class="property">shadowMap</span>.<span class="property">enabled</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>在模型中设置允许接受阴影和投射阴影并将光源添加到场景中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child.<span class="property">Mesh</span>) &#123; </span><br><span class="line">	child.<span class="property">receiveShadow</span> = <span class="literal">true</span> </span><br><span class="line">	child.<span class="property">castShadow</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">scene.<span class="title function_">add</span>(pointlight)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="创建一个点光源组"><a href="#创建一个点光源组" class="headerlink" title="创建一个点光源组"></a>创建一个点光源组</h2><blockquote>
<p>这是一个由球转载点光源的组</p>
</blockquote>
<ul>
<li>创建一个光源组并调正光源组的位置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pointLightGroup = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Group</span>()</span><br><span class="line">pointLightGroup.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>设置球体的半径, 空数组, 并通过循环产生n个球体光源<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> radius = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> pointLightArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> sphereGeometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SphereGeometry</span>(<span class="number">0.2</span>, <span class="number">32</span>, <span class="number">32</span>) <span class="comment">// 创建球体</span></span><br><span class="line">  <span class="keyword">const</span> sphereMaterial = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshStandardMaterial</span>(&#123; <span class="comment">//  创建球体的材质 --- 物理材质（会通过周围的灯光映射颜色）</span></span><br><span class="line">    <span class="attr">color</span>: <span class="number">0xffffff</span>,  <span class="comment">// 球体的颜色</span></span><br><span class="line">    <span class="attr">emissive</span>: <span class="number">0xffffff</span>,  <span class="comment">// 光源的颜色</span></span><br><span class="line">    <span class="attr">emissiveIntensity</span>: <span class="number">10</span>  <span class="comment">// 光源的强度</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> sphere = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(sphereGeometry, sphereMaterial) <span class="comment">// 创建网格</span></span><br><span class="line">  <span class="keyword">const</span> pointLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointLight</span>(<span class="number">0xffffff</span>, <span class="number">10</span>) <span class="comment">// 创建点光源</span></span><br><span class="line">  pointLightArr.<span class="title function_">push</span>(sphere) <span class="comment">// 创建好的添加到数组中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置球体的位置, 在球体中添加点光源,然后将将球体添加到组中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sphere.<span class="property">position</span>.<span class="title function_">set</span>(</span><br><span class="line">  radius * <span class="title class_">Math</span>.<span class="title function_">cos</span>((i * <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>) /<span class="number">3</span>), <span class="comment">// x</span></span><br><span class="line">  <span class="title class_">Math</span>.<span class="title function_">cos</span>((i * <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>) / <span class="number">3</span>), <span class="comment">// y</span></span><br><span class="line">  radius * <span class="title class_">Math</span>.<span class="title function_">sin</span>((i * <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>) /<span class="number">3</span>), <span class="comment">// z</span></span><br><span class="line">)</span><br><span class="line">sphere.<span class="title function_">add</span>(pointLight)</span><br><span class="line">pointLightGroup.<span class="title function_">add</span>(sphere)</span><br></pre></td></tr></table></figure></li>
<li>在场景中添加点光源组<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scene.<span class="title function_">add</span>(pointLightGroup)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用补间动画让光源组旋转，上下移动"><a href="#使用补间动画让光源组旋转，上下移动" class="headerlink" title="使用补间动画让光源组旋转，上下移动"></a>使用补间动画让光源组旋转，上下移动</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123; <span class="attr">angle</span>: <span class="number">0</span>&#125; <span class="comment">// 从零开始</span></span><br><span class="line">gsap.<span class="title function_">to</span>(options, &#123;</span><br><span class="line">  <span class="attr">angle</span>: <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="comment">// 旋转1周</span></span><br><span class="line">  <span class="attr">duration</span>: <span class="number">10</span>, <span class="comment">// 旋转一周所花的时间</span></span><br><span class="line">  <span class="attr">repeat</span>: -<span class="number">1</span>, <span class="comment">// 重复</span></span><br><span class="line">  <span class="attr">ease</span>: <span class="string">&quot;linear&quot;</span>,</span><br><span class="line">  <span class="attr">onUpdate</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    pointLightGroup.<span class="property">rotation</span>.<span class="property">y</span> = options.<span class="property">angle</span></span><br><span class="line">    pointLightArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      item.<span class="property">position</span>.<span class="title function_">set</span>(</span><br><span class="line">        radius * <span class="title class_">Math</span>.<span class="title function_">cos</span>((index * <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>) / <span class="number">3</span>),</span><br><span class="line">        <span class="title class_">Math</span>.<span class="title function_">cos</span>((index * <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>) / <span class="number">3</span> + options.<span class="property">angle</span> *<span class="number">5</span>), <span class="comment">// 上下移动</span></span><br><span class="line">        radius * <span class="title class_">Math</span>.<span class="title function_">sin</span>((index * <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>) / <span class="number">3</span>)</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="水面"><a href="#水面" class="headerlink" title="水面"></a>水面</h2><ul>
<li>引用水的模型包<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Water</span>&#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/objects/Water2&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>创建一个圆的平面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> waterGeometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">CircleGeometry</span>(半径,分段默认<span class="number">32</span>)</span><br></pre></td></tr></table></figure></li>
<li>创建水面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> water = <span class="keyword">new</span> <span class="title class_">Water</span>(waterGeometry, &#123;</span><br><span class="line">  <span class="attr">textureWidth</span>: <span class="number">1024</span>, <span class="comment">// 画布的宽度</span></span><br><span class="line">  <span class="attr">textureHeight</span>: <span class="number">1024</span>, <span class="comment">// 画布的高度</span></span><br><span class="line">  <span class="attr">color</span>: <span class="number">0xededed</span>, <span class="comment">// 水面颜色</span></span><br><span class="line">  <span class="attr">flowDirection</span>: <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector2</span>(<span class="number">1</span>,<span class="number">1</span>), <span class="comment">// 水流动方向</span></span><br><span class="line">  <span class="attr">scale</span>:<span class="number">100</span>,	<span class="comment">// 水波方位</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>由于水面创造出来是垂直于模型，需旋转90度, 然后添加到场景中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">water.<span class="property">rotation</span>.<span class="property">x</span> = -<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span></span><br><span class="line">scene.<span class="title function_">add</span>(water)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="色调映射"><a href="#色调映射" class="headerlink" title="色调映射"></a>色调映射</h2><p>…renderer.xxx</p>
<h2 id="相机位置与文字切屏"><a href="#相机位置与文字切屏" class="headerlink" title="相机位置与文字切屏"></a>相机位置与文字切屏</h2><ul>
<li>使用补间动画移动相机<ul>
<li>调用gasp的timeline()创建两个变量</li>
</ul>
</li>
<li>封装一个相机移动函数，并使用这两个变量分别控制相机要移动的位置和聚焦，并设置xyz，duration和ease</li>
<li>写一个对象数组，其中包括文本信息和回调函数，回调函数中调用相机移动函数，并给予坐标</li>
<li>监听鼠标滚轮事件判断滚轮是否向下滚动，<ul>
<li>是，变量+1并判断只有当变量小于对象数组的长度-1时，才加一，否则为0；</li>
<li>否，直接调用对象数组的第变量对象的回调函数。</li>
<li>建议增加防抖操作，防抖变量为true返回，鼠标滚动时，延时一定时间让防抖变量为false</li>
</ul>
</li>
<li>最后在页面中通过遍历来展示文本，在最外层则通过修改 translate3d 来控制滚轮动时文本页跟着变。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:style=<span class="string">&quot;&#123;transform: &#x27;translate3d(0, $&#123;-index*100&#125;vh, 0)&#x27;&#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="创建漫天星星"><a href="#创建漫天星星" class="headerlink" title="创建漫天星星"></a>创建漫天星星</h2><ul>
<li>通过InstancedMesh来创建100个以上的球的实例</li>
<li>随机分配到天上</li>
<li>&#96;创建开始位置和结束位置的空数组</li>
<li>通过for循环，获取随机的x，y,z 并添加到开始数组中</li>
<li>创建一个矩阵，并设置位置，然后设置实例的矩阵</li>
<li>添加到场景中，</li>
<li>使用贝塞尔曲线话爱心路径</li>
<li>根据路径获取点getPoint<ul>
<li>通过for循环获取曲线的每一个点，并添加到结束数组，如果图形太大可以给x，y乘以一个小数</li>
</ul>
<p> 	</p>
</li>
<li>创建爱心动画<ul>
<li>定义一个参数，设置时间为0<ul>
<li>然后使用补间动画从0执行到1，更新时是实时获取开始数组的当前位置+ （结束位置-开始位置）* 参数的时间</li>
<li>创建一个矩阵，并设置位置，然后设置实例的矩阵</li>
</ul>
</li>
<li>设置实例的矩阵需要更新</li>
</ul>
</li>
<li>创建复原的函数<ul>
<li>与爱心动画一样，只需要把开始数组替换为结束数组，结束数组替换为开始数据即可</li>
</ul>
</li>
<li>在对象数组中需要呈现的回调函数中调用爱心动画函数</li>
<li>在监听事件中，当变量要设置为0 时添加复原函数</li>
</ul>
]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>案例</tag>
        <tag>ThreeJS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-光线投射</title>
    <url>/2024/11/01/threeJS/%E5%85%89%E7%BA%BF%E6%8A%95%E5%B0%84/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="前提：要创建几个物体和材质并添加到场景中"><a href="#前提：要创建几个物体和材质并添加到场景中" class="headerlink" title="前提：要创建几个物体和材质并添加到场景中"></a>前提：要创建几个物体和材质并添加到场景中</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建射线</span></span><br><span class="line"><span class="keyword">const</span> raycaster = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Raycaster</span>()</span><br><span class="line"><span class="comment">// 创建鼠标向量</span></span><br><span class="line"><span class="keyword">const</span> mouse = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector2</span>()</span><br><span class="line"><span class="comment">// 监听窗口的点击事件</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置鼠标向量的xy值，转化为-1 ~ 1 ,区间为2,</span></span><br><span class="line">  <span class="comment">// y轴：由于鼠标坐标是从上到下，设备坐标是从下到上，刚好相反所以要加一个负hao</span></span><br><span class="line">  mouse.<span class="property">x</span> = (event.<span class="property">clientX</span> / <span class="variable language_">window</span>.<span class="property">innerWidth</span>) *<span class="number">2</span> -<span class="number">1</span></span><br><span class="line">  mouse.<span class="property">y</span> = -((event.<span class="property">clientY</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>) *<span class="number">2</span> -<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 通过摄像机和鼠标位置更新射线</span></span><br><span class="line">  raycaster.<span class="title function_">setFromCamera</span>(mouse, camera)</span><br><span class="line">  <span class="comment">// 计算物体与射线的焦点</span></span><br><span class="line">  <span class="keyword">const</span> intersects = raycaster.<span class="title function_">intersectObjects</span>([sphere1, sphere2, sphere3])</span><br><span class="line">  <span class="keyword">if</span>(intersects.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(intersects[<span class="number">0</span>].<span class="property">object</span>.<span class="property">_isSelect</span>) &#123;</span><br><span class="line">      intersects[<span class="number">0</span>].<span class="property">object</span>.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(intersects[<span class="number">0</span>].<span class="property">object</span>.<span class="property">_originColor</span>)</span><br><span class="line">      intersects[<span class="number">0</span>].<span class="property">object</span>.<span class="property">_isSelect</span> = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义变量做判断，标识选中</span></span><br><span class="line">    intersects[<span class="number">0</span>].<span class="property">object</span>.<span class="property">_isSelect</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 记录原色,getHex()获取16进制的颜色</span></span><br><span class="line">    intersects[<span class="number">0</span>].<span class="property">object</span>.<span class="property">_originColor</span> = intersects[<span class="number">0</span>].<span class="property">object</span>.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">getHex</span>()</span><br><span class="line">    <span class="comment">// 只改点击时射线穿过的第一个元素的颜色</span></span><br><span class="line">    intersects[<span class="number">0</span>].<span class="property">object</span>.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(<span class="number">0xff00ff</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>ThreeJS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-基础知识</title>
    <url>/2024/11/01/threeJS/%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul>
<li><a href="https://www.blender.org/">Blender</a>：制作3D文字</li>
<li><a href="https://xinghuo.xfyun.cn/sparkapi">科大讯飞星火</a>：生成故事单元剧情</li>
<li><a href="https://www.blockadelabs.com/#skybox">Blockade Labs</a>: 根据故事情节生成全景图片(要使用英文单词)</li>
<li><a href="https://github.com/LokerL/tts-vue/releases/tag/1.9.15">TTS-Vue</a>:生成语音作旁白</li>
<li>将文本，图片，音频，按钮(按钮文本，跳转场景的索引值)，场景旋转的起始和结束，持续时间存放到对象数组中。按照步骤，载入图片，页面搭建，监听跳转函数等完成交互式2D故事游戏</li>
<li><a href="https://convert.leiapix.com/">leiapix</a>：将静态图片生成3D图片</li>
<li><a href="https://threejs.org/">three.js官网</a>: 官网</li>
<li>导入three.js的文件后</li>
</ul>
<h2 id="第一步-创建场景、相机和渲染器"><a href="#第一步-创建场景、相机和渲染器" class="headerlink" title="第一步: 创建场景、相机和渲染器"></a>第一步: 创建场景、相机和渲染器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入three.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建相机 --- 遵循近大远小原则</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(</span><br><span class="line"> <span class="number">75</span>, <span class="comment">// 视角 --- 在同距离情况下，视角越大（宽），看到的东西越多</span></span><br><span class="line"> <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>, <span class="comment">// 相机的宽高比</span></span><br><span class="line"> <span class="number">0.1</span>,  <span class="comment">// 近平面 --- 相机最近能看到的</span></span><br><span class="line"> <span class="number">1000</span>  <span class="comment">// 远平面 --- 相机最远能看到的</span></span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>(); </span><br><span class="line">renderer.<span class="title function_">setSize</span>( <span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span> ); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>( renderer.<span class="property">domElement</span> );</span><br></pre></td></tr></table></figure>

<h2 id="第二步-创建几何体、材质、网格-并添加到场景中"><a href="#第二步-创建几何体、材质、网格-并添加到场景中" class="headerlink" title="第二步: 创建几何体、材质、网格 并添加到场景中"></a>第二步: 创建几何体、材质、网格 并添加到场景中</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建几何体 --- 决定形状</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建材质 --- 决定外观</span></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建网格</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry,material)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将网格添加到3场景中</span></span><br><span class="line">scene.<span class="title function_">add</span>(cube)</span><br></pre></td></tr></table></figure>

<h2 id="第三步-使用世界坐标辅助器和轨道控制器"><a href="#第三步-使用世界坐标辅助器和轨道控制器" class="headerlink" title="第三步: 使用世界坐标辅助器和轨道控制器"></a>第三步: 使用世界坐标辅助器和轨道控制器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置相机的位置 --- 调整视角方便看到坐标轴</span></span><br><span class="line">camera.<span class="property">position</span>.<span class="property">z</span> = <span class="number">5</span></span><br><span class="line">camera.<span class="property">position</span>.<span class="property">y</span> = <span class="number">2</span></span><br><span class="line">camera.<span class="property">position</span>.<span class="property">x</span> = <span class="number">2</span></span><br><span class="line">camera.<span class="title function_">lookAt</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加世界坐标辅助器 --- 绿y，红x，蓝z</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AxesHelper</span>( <span class="number">5</span> );</span><br><span class="line">scene.<span class="title function_">add</span>(axesHelper)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加轨道控制器,选择要监听的dom元素</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> <span class="title class_">OrbitControls</span>( camera, renderer.<span class="property">domElement</span> );</span><br><span class="line"><span class="comment">// 设置带阻尼的惯性</span></span><br><span class="line">controls.<span class="property">enableDamping</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 设置阻尼系数</span></span><br><span class="line">controls.<span class="property">dampingFactor</span> = <span class="number">0.05</span></span><br><span class="line"><span class="comment">// 设置旋转速度 --- 自动</span></span><br><span class="line">controls.<span class="property">autoRotate</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 设置旋转速度 --- 手动旋转的速度</span></span><br><span class="line"><span class="comment">// controls.rotateSpeed = 0.05</span></span><br></pre></td></tr></table></figure>

<h2 id="倒数第二步-渲染函数"><a href="#倒数第二步-渲染函数" class="headerlink" title="倒数第二步: 渲染函数"></a>倒数第二步: 渲染函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="comment">// 更新轨道控制器</span></span><br><span class="line">  controls.<span class="title function_">update</span>()</span><br><span class="line">	<span class="comment">// 请求动画帧，每次调用渲染函数都会调用animate，即循环渲染</span></span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(animate) </span><br><span class="line">  <span class="comment">// 旋转</span></span><br><span class="line">  <span class="comment">// cube.rotation.x += 0.01</span></span><br><span class="line">  <span class="comment">// cube.rotation.y += 0.01</span></span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  renderer.<span class="title function_">render</span>(scene, camera)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">animate</span>()</span><br></pre></td></tr></table></figure>

<h2 id="最后一步-监听窗口的变化"><a href="#最后一步-监听窗口的变化" class="headerlink" title="最后一步: 监听窗口的变化"></a>最后一步: 监听窗口的变化</h2><ul>
<li>监听窗口的变化，仪表窗口缩小，物体没有跟着自适应回到视图的中心<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听窗口变化</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 重置渲染器宽高比</span></span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br><span class="line">  <span class="comment">// 重置相机宽高比</span></span><br><span class="line">  camera.<span class="property">aspect</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span></span><br><span class="line">  <span class="comment">// 更新相机投影矩阵</span></span><br><span class="line">  camera.<span class="title function_">updateProjectionMatrix</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="认识向量-Vector3-、父元素和子元素的position的关系、缩放、旋转"><a href="#认识向量-Vector3-、父元素和子元素的position的关系、缩放、旋转" class="headerlink" title="认识向量(Vector3)、父元素和子元素的position的关系、缩放、旋转"></a>认识向量(Vector3)、父元素和子元素的position的关系、缩放、旋转</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过案例来分析，首先先创建一个父元素的网格和子元素的网格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建材质</span></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> parentMaterial = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0xff0000</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建父元素的线框模式</span></span><br><span class="line">parentMaterial.<span class="property">wireframe</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建cube的父元素</span></span><br><span class="line"><span class="keyword">let</span> parentCube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry,parentMaterial)</span><br><span class="line"><span class="comment">// 创建子元素的网格</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry,material)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在父元素中添加子元素</span></span><br><span class="line">parentCube.<span class="title function_">add</span>(cube)</span><br><span class="line"><span class="comment">// 设置父元素的坐标轴</span></span><br><span class="line">parentCube.<span class="property">position</span>.<span class="title function_">set</span>(-<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 设置父元素的放大</span></span><br><span class="line">parentCube.<span class="property">scale</span>.<span class="title function_">set</span>(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 设置父元素绕着x轴旋转45du</span></span><br><span class="line">parentCube.<span class="property">rotation</span>.<span class="property">x</span> = <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置子元素在x轴的位移 ---- position可是一个三维向量</span></span><br><span class="line">cube.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 设置子元素的放大</span></span><br><span class="line">cube.<span class="property">scale</span>.<span class="title function_">set</span>(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 设置cube绕着x轴旋转</span></span><br><span class="line">cube.<span class="property">rotation</span>.<span class="property">x</span> = <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将网格的父元素添加到场景中</span></span><br><span class="line">scene.<span class="title function_">add</span>(parentCube)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><ul>
<li>子元素的坐标轴相对于父元素</li>
<li>父元素的position设置的是它的局部坐标，没有父元素，元素设置的position就是世界坐标</li>
</ul>
<h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><ul>
<li>对于缩放，不管cube原本的大小是什么，只要父元素缩放，子元素也会跟着缩放，</li>
<li>公式：父元素(x,y,z),子元素的缩放为(x1,y1,z1),最终子元素的缩放(x<em>x1,y</em>y1,z*z1)</li>
<li>所以，如果遇到与缩放有关的，只需要缩放父元素</li>
</ul>
<h3 id="rotation"><a href="#rotation" class="headerlink" title="rotation"></a>rotation</h3><ul>
<li>rotation: 欧拉角(x,y,z,xyz)，旋转的顺序不同，效果不一样，默认的旋转顺序为xyz</li>
<li>同样都是相对于父元素</li>
</ul>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ul>
<li>此时父元素的坐标为(-3,0,0),二子元素相对于父元素的坐标为(0,0,0)位于原点</li>
<li>此时父元素的大小放大2倍，子元素的大小在父元素的放大后的大小再放大2倍</li>
<li>此时父元素绕着x轴旋转45°，子元素在相对于父元素旋转45°后，变为90°</li>
</ul>
<h2 id="学习监听事件"><a href="#学习监听事件" class="headerlink" title="学习监听事件"></a>学习监听事件</h2><ul>
<li>在渲染器后区监听<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听按钮，点击触发全屏</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;button&quot;</span>)</span><br><span class="line">btn.<span class="property">innerHTML</span> = <span class="string">&quot;点击全屏&quot;</span></span><br><span class="line">btn.<span class="property">style</span>.<span class="property">position</span> =<span class="string">&quot;absolute&quot;</span></span><br><span class="line">btn.<span class="property">style</span>.<span class="property">top</span> =<span class="string">&quot;10px&quot;</span></span><br><span class="line">btn.<span class="property">style</span>.<span class="property">left</span>=<span class="string">&quot;10px&quot;</span></span><br><span class="line">btn.<span class="property">style</span>.<span class="property">zIndex</span>=<span class="string">&quot;999&quot;</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 画布全屏 -- 看不到按钮</span></span><br><span class="line">  <span class="comment">// renderer.domElement.requestFullscreen()</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">requestFullscreen</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将按钮添加到body上</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(btn)</span><br><span class="line"><span class="comment">// 经停按钮点击退出全屏</span></span><br><span class="line"><span class="keyword">const</span> escbtn = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;button&quot;</span>)</span><br><span class="line">escbtn.<span class="property">innerHTML</span> = <span class="string">&quot;退出全屏&quot;</span></span><br><span class="line">escbtn.<span class="property">style</span>.<span class="property">position</span> =<span class="string">&quot;absolute&quot;</span></span><br><span class="line">escbtn.<span class="property">style</span>.<span class="property">top</span> =<span class="string">&quot;10px&quot;</span></span><br><span class="line">escbtn.<span class="property">style</span>.<span class="property">left</span>=<span class="string">&quot;100px&quot;</span></span><br><span class="line">escbtn.<span class="property">style</span>.<span class="property">zIndex</span>=<span class="string">&quot;999&quot;</span></span><br><span class="line">escbtn.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 退出全屏</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">exitFullscreen</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(escbtn)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="属性参数的管理工具"><a href="#属性参数的管理工具" class="headerlink" title="属性参数的管理工具"></a>属性参数的管理工具</h2><ul>
<li>方便快速开发</li>
<li>lil.gui</li>
<li>能自动识别属性值是什么类型，并展示对应的样式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建GUI</span></span><br><span class="line"><span class="keyword">const</span> gui = <span class="keyword">new</span> <span class="title function_">GUI</span>()</span><br><span class="line">/ 控制事件</span><br><span class="line"><span class="comment">//添加按钮 </span></span><br><span class="line"><span class="comment">// add(事件对象，函数名)</span></span><br><span class="line"><span class="comment">// name(别名)</span></span><br><span class="line">gui.<span class="title function_">add</span>(eventObj, <span class="string">&quot;Fullscreen&quot;</span>).<span class="title function_">name</span>(<span class="string">&quot;全屏&quot;</span>)</span><br><span class="line">gui.<span class="title function_">add</span>(eventObj, <span class="string">&quot;ExitFullscreen&quot;</span>)</span><br><span class="line"><span class="comment">// 控制立方体的位置</span></span><br><span class="line"><span class="comment">// gui.add(cube.position, &quot;x&quot;, -5 ,5).name(&quot;立方体x轴位置&quot;)</span></span><br><span class="line">/ 控制一组属性，展示拖到条</span><br><span class="line"><span class="comment">// 存放在组中</span></span><br><span class="line"><span class="keyword">let</span> folder = gui.<span class="title function_">addFolder</span>(<span class="string">&quot;立方体位置&quot;</span>)</span><br><span class="line"><span class="comment">// add(元素，元素的属性)</span></span><br><span class="line"><span class="comment">// min/max()设置最小值/最大值</span></span><br><span class="line"><span class="comment">// onChange: 只要改变就会触发</span></span><br><span class="line"><span class="comment">// onFinishChange: 当拖拽结束后再触发</span></span><br><span class="line">folder.<span class="title function_">add</span>(cube.<span class="property">position</span>, <span class="string">&quot;x&quot;</span>).<span class="title function_">min</span>(-<span class="number">10</span>).<span class="title function_">max</span>(<span class="number">10</span>).<span class="title function_">step</span>(<span class="number">1</span>).<span class="title function_">name</span>(<span class="string">&quot;立方体x轴位置&quot;</span>).<span class="title function_">onChange</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;立方体x轴位置&quot;</span>,val)&#125;)</span><br><span class="line">folder.<span class="title function_">add</span>(cube.<span class="property">position</span>, <span class="string">&quot;y&quot;</span>).<span class="title function_">min</span>(-<span class="number">10</span>).<span class="title function_">max</span>(<span class="number">10</span>).<span class="title function_">step</span>(<span class="number">1</span>).<span class="title function_">name</span>(<span class="string">&quot;立方体y轴位置&quot;</span>).<span class="title function_">onFinishChange</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;立方体y轴的位置&quot;</span>,val)&#125;)</span><br><span class="line">folder.<span class="title function_">add</span>(cube.<span class="property">position</span>, <span class="string">&quot;z&quot;</span>).<span class="title function_">min</span>(-<span class="number">10</span>).<span class="title function_">max</span>(<span class="number">10</span>).<span class="title function_">step</span>(<span class="number">1</span>).<span class="title function_">name</span>(<span class="string">&quot;立方体z轴位置&quot;</span>)</span><br><span class="line">/ 控制单个属性，展示勾选框</span><br><span class="line">gui.<span class="title function_">add</span>(parentMaterial, <span class="string">&quot;wireframe&quot;</span>).<span class="title function_">name</span>(<span class="string">&quot;父元素线框模式&quot;</span>)</span><br><span class="line">/ 控制单个元素选择颜色，展示颜色选择器</span><br><span class="line"><span class="comment">// colorParams中的cubeColor相当于该元素的默认颜色，所以，如元素已经有颜色，则cubeColor最好与之相等</span></span><br><span class="line"><span class="keyword">let</span> colorParams = &#123; <span class="attr">cubeColor</span>: <span class="string">&quot;#00ff00&quot;</span>&#125;</span><br><span class="line">gui.<span class="title function_">addColor</span>(colorParams, <span class="string">&quot;cubeColor&quot;</span>).<span class="title function_">name</span>(<span class="string">&quot;立方体颜色&quot;</span>).<span class="title function_">onChange</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">  cube.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="几何体怎么来的"><a href="#几何体怎么来的" class="headerlink" title="几何体怎么来的"></a>几何体怎么来的</h2><blockquote>
<p>在js中所有的图形都是由三角形组成的</p>
</blockquote>
<ul>
<li>两种方式创建</li>
</ul>
<h3 id="第一种：-顶点需要一个一个列出来，不可共用，冗余"><a href="#第一种：-顶点需要一个一个列出来，不可共用，冗余" class="headerlink" title="第一种： 顶点需要一个一个列出来，不可共用，冗余"></a>第一种： 顶点需要一个一个列出来，不可共用，冗余</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>()</span><br><span class="line"><span class="comment">// 创建顶点数据,顶点是有顺序的，每三个为一个顶点，逆时针为正面，</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">  -<span class="number">1.0</span>,-<span class="number">1.0</span>,<span class="number">0.0</span>, <span class="comment">// 按x,y,z顺序</span></span><br><span class="line">  <span class="number">1.0</span>, -<span class="number">1.0</span>,<span class="number">0.0</span>,</span><br><span class="line">  <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">  <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">  -<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">  -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">0.0</span></span><br><span class="line">])</span><br><span class="line"><span class="comment">// 创建顶点属性</span></span><br><span class="line">geometry.<span class="title function_">setAttribute</span>(<span class="string">&quot;position&quot;</span>, <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(vertices, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// 创建材质</span></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0x00ff00</span>, <span class="comment">// 设置材质的颜色</span></span><br><span class="line">  <span class="attr">side</span>: <span class="variable constant_">THREE</span>.<span class="property">doubleSize</span>, <span class="comment">// 正面/反面都能看到</span></span><br><span class="line">  <span class="attr">wireframe</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material)</span><br><span class="line">scene.<span class="title function_">add</span>(plane)</span><br></pre></td></tr></table></figure>
<h3 id="第二种：顶点可以共用"><a href="#第二种：顶点可以共用" class="headerlink" title="第二种：顶点可以共用"></a>第二种：顶点可以共用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>()</span><br><span class="line"><span class="comment">// 这里的索引值number代表vertices中的一组数据，由x，y，z组成的数据，即0代表 -1.0,-1.0,0.0这一组数据</span></span><br><span class="line"><span class="comment">// 创建顶点数据</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">  -<span class="number">1.0</span>,-<span class="number">1.0</span>,<span class="number">0.0</span>, <span class="comment">// 按x,y,z顺序</span></span><br><span class="line">  <span class="number">1.0</span>, -<span class="number">1.0</span>,<span class="number">0.0</span>,</span><br><span class="line">  <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">  -<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span></span><br><span class="line">])</span><br><span class="line"><span class="comment">// 创建顶点属性</span></span><br><span class="line">geometry.<span class="title function_">setAttribute</span>(<span class="string">&quot;position&quot;</span>, <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(vertices, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// 创建索引</span></span><br><span class="line"><span class="keyword">const</span> indices = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 创建索引属性</span></span><br><span class="line">geometry.<span class="title function_">setIndex</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(indices,<span class="number">1</span>))</span><br><span class="line"><span class="comment">// 创建材质</span></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0x00ff00</span>, <span class="comment">// 设置材质的颜色</span></span><br><span class="line">  <span class="attr">side</span>: <span class="variable constant_">THREE</span>.<span class="property">doubleSize</span>, <span class="comment">// 正面/反面都能看到</span></span><br><span class="line">  <span class="attr">wireframe</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material)</span><br><span class="line">scene.<span class="title function_">add</span>(plane)</span><br></pre></td></tr></table></figure>

<h2 id="材质创建的两种方式"><a href="#材质创建的两种方式" class="headerlink" title="材质创建的两种方式"></a>材质创建的两种方式</h2><h3 id="第一种-创建之后单独的设置"><a href="#第一种-创建之后单独的设置" class="headerlink" title="第一种: 创建之后单独的设置"></a>第一种: 创建之后单独的设置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;)</span><br><span class="line">material.<span class="property">wireframe</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="第二种-在构造函数中定义"><a href="#第二种-在构造函数中定义" class="headerlink" title="第二种: 在构造函数中定义"></a>第二种: 在构造函数中定义</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0x00ff00</span>, <span class="comment">// 设置材质的颜色</span></span><br><span class="line">  <span class="attr">side</span>: <span class="variable constant_">THREE</span>.<span class="property">doubleSize</span>, <span class="comment">// 正面/反面都能看到</span></span><br><span class="line">  <span class="attr">wireframe</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="组的概念和创建一个立方体"><a href="#组的概念和创建一个立方体" class="headerlink" title="组的概念和创建一个立方体"></a>组的概念和创建一个立方体</h2><h3 id="组的概念-划分组"><a href="#组的概念-划分组" class="headerlink" title="组的概念(划分组)"></a>组的概念(划分组)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BufferGeometry()：用来创建由顶点组成的图形</span></span><br><span class="line"><span class="keyword">const</span> cubegeometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>()</span><br><span class="line"><span class="comment">// 使用索引绘制,这里的索引number代表vertices中的一组数据，由x，y，z组成的数据</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">  -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span></span><br><span class="line">])</span><br><span class="line"><span class="comment">// 创建顶点属性</span></span><br><span class="line">cubegeometry.<span class="title function_">setAttribute</span>(<span class="string">&quot;position&quot;</span>, <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(vertices, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// 创建索引</span></span><br><span class="line"><span class="keyword">const</span> indices = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 创建索引属性</span></span><br><span class="line">cubegeometry.<span class="title function_">setIndex</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(indices,<span class="number">1</span>))</span><br><span class="line"><span class="comment">// 设置2个顶点组，形成2个材质</span></span><br><span class="line"><span class="comment">// addGroup(从哪个顶点开始，添加几个顶点，用那个材质)</span></span><br><span class="line">cubegeometry.<span class="title function_">addGroup</span>(<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>) </span><br><span class="line">cubegeometry.<span class="title function_">addGroup</span>(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>) </span><br><span class="line"><span class="comment">// 创建材质</span></span><br><span class="line"><span class="keyword">const</span> cubematerial = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;<span class="attr">color</span>: <span class="number">0x00ff00</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> cubematerial1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;<span class="attr">color</span>: <span class="number">0x0000ff</span>&#125;)</span><br><span class="line"><span class="comment">// 设置了组，并将材质以数组的方式传递则，以对应组的材质展示；</span></span><br><span class="line"><span class="comment">// 设置了组，只传递一个材质，则全部组都使用这个材质</span></span><br><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(cubegeometry, [cubematerial, cubematerial1])</span><br><span class="line">scene.<span class="title function_">add</span>(plane)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="给几何体的每一个面添加不同的材质"><a href="#给几何体的每一个面添加不同的材质" class="headerlink" title="给几何体的每一个面添加不同的材质"></a>给几何体的每一个面添加不同的材质</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">BoxGeometry</span>(x,y,z) :可以创建几何体</span><br><span class="line"><span class="keyword">const</span> cubegeometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)  <span class="comment">// 立方体</span></span><br><span class="line"><span class="comment">// 创建六个材质然后以数组的方式添加即可</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(cubegeometry, [cubematerial, cubematerial1,cubematerial2,cubematerial3,cubematerial4,cubematerial5])</span><br><span class="line">scene.<span class="title function_">add</span>(cube)</span><br></pre></td></tr></table></figure>

<h3 id="官方提供的几何体-–-文档搜geometry"><a href="#官方提供的几何体-–-文档搜geometry" class="headerlink" title="官方提供的几何体 – 文档搜geometry"></a>官方提供的几何体 – 文档搜geometry</h3><h2 id="网格基础材料-—-上编辑器上看"><a href="#网格基础材料-—-上编辑器上看" class="headerlink" title="网格基础材料 — 上编辑器上看"></a>网格基础材料 — 上编辑器上看</h2><h3 id="贴图-Map："><a href="#贴图-Map：" class="headerlink" title="贴图&#x2F;Map："></a>贴图&#x2F;Map：</h3><ul>
<li>如果使用一张带纹理的png图片，边缘透明，贴在一个正&#x2F;长方形上，边缘也会自动生成纹理(勾选上透明性即消失)</li>
</ul>
<h3 id="透明贴图-alpha-Map："><a href="#透明贴图-alpha-Map：" class="headerlink" title="透明贴图&#x2F;alpha Map："></a>透明贴图&#x2F;alpha Map：</h3><ul>
<li>使用一张由黑色，白色和0.5白色的图片贴图，则黑色为完全透明，白色完全不透明，0.5白色为半透明。即使用贴图后在使用透明贴图，则只看得见白色区域的图和0.5白色区域的半透明图和后面的物体</li>
</ul>
<h3 id="环境贴图-env-Map："><a href="#环境贴图-env-Map：" class="headerlink" title="环境贴图&#x2F;env Map："></a>环境贴图&#x2F;env Map：</h3><ul>
<li>先在上面的背景放上一张全景图&#x2F;环境的图，环境和环境贴图页放上相同的全景图，可以调节反射率</li>
</ul>
<h3 id="高光贴图："><a href="#高光贴图：" class="headerlink" title="高光贴图："></a>高光贴图：</h3><ul>
<li>在环境中，金属的反射亮度，找一张亮一点的图</li>
</ul>
<h3 id="光照贴图："><a href="#光照贴图：" class="headerlink" title="光照贴图："></a>光照贴图：</h3><ul>
<li>贴的图，代表光照射进来的颜色，比如，光通过玻璃照进来，而玻璃贴了窗纸，窗纸就是这个图，最后呈现的光展示在物体上也要跟环境贴图搭上</li>
</ul>
<h3 id="环境光遮蔽贴图："><a href="#环境光遮蔽贴图：" class="headerlink" title="环境光遮蔽贴图："></a>环境光遮蔽贴图：</h3><ul>
<li>就是给边缘缝隙添加阴影的</li>
</ul>
<h3 id="代码实现各种贴图"><a href="#代码实现各种贴图" class="headerlink" title="代码实现各种贴图"></a>代码实现各种贴图</h3><ul>
<li><a href="/2024/11/01/threeJS/%E7%BD%91%E6%A0%BC%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9D%90%E6%96%99/" title="threeJS-网格的基础材料">实现的步骤和说明</a></li>
</ul>
<h2 id="雾"><a href="#雾" class="headerlink" title="雾"></a>雾</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建场景fog（线性雾）</span></span><br><span class="line"><span class="comment">// scene.fog = new THREE.Fog(0x999999, 0.1, 50)</span></span><br><span class="line"><span class="comment">// 创建场景指数fog</span></span><br><span class="line">scene.<span class="property">fog</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">FogExp2</span>(<span class="number">0x999999</span>, <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// 创建场景的背景（背景最好与雾的颜色相接近）</span></span><br><span class="line">scene.<span class="property">background</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0x999999</span>)</span><br></pre></td></tr></table></figure>

<h2 id="载入模型"><a href="#载入模型" class="headerlink" title="载入模型"></a>载入模型</h2><h3 id="引入相关资源"><a href="#引入相关资源" class="headerlink" title="引入相关资源"></a>引入相关资源</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入hdr加载器</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RGBELoader</span> &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/loaders/RGBELoader.js&quot;</span></span><br><span class="line"><span class="comment">// 带入gltf加载器</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GLTFLoader</span> &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/loaders/GLTFLoader.js&quot;</span></span><br><span class="line"><span class="comment">// 载入draco解压器</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DRACOLoader</span> &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/loaders/DRACOLoader.js&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建实例化"><a href="#创建实例化" class="headerlink" title="创建实例化"></a>创建实例化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化加载器gltf</span></span><br><span class="line"><span class="keyword">const</span> gltfLoader = <span class="keyword">new</span> <span class="title class_">GLTFLoader</span>()</span><br><span class="line"><span class="comment">// 创建实例化加载器draco</span></span><br><span class="line"><span class="keyword">const</span> dracoLoader = <span class="keyword">new</span> <span class="title class_">DRACOLoader</span>()</span><br><span class="line"><span class="comment">// 加载环境贴图</span></span><br><span class="line"><span class="keyword">let</span> rgbLoader = <span class="keyword">new</span> <span class="title class_">RGBELoader</span>()</span><br></pre></td></tr></table></figure>

<h3 id="设置模型路径和环境贴图"><a href="#设置模型路径和环境贴图" class="headerlink" title="设置模型路径和环境贴图"></a>设置模型路径和环境贴图</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置Draco路径</span></span><br><span class="line">dracoLoader.<span class="title function_">setDecoderPath</span>(<span class="string">&quot;../../public/draco/&quot;</span>)</span><br><span class="line"><span class="comment">// 设置gltf加载器Draco解码器</span></span><br><span class="line">gltfLoader.<span class="title function_">setDRACOLoader</span>(dracoLoader)</span><br><span class="line"></span><br><span class="line">gltfLoader.<span class="title function_">load</span>(</span><br><span class="line">  <span class="comment">// 模型路径</span></span><br><span class="line">  <span class="string">&quot;../../public/texture/module/table_chair.glb&quot;</span>,</span><br><span class="line">  <span class="comment">// 加载完成的回调</span></span><br><span class="line">  <span class="function">(<span class="params">gltf</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 添加模型到场景</span></span><br><span class="line">    scene.<span class="title function_">add</span>(gltf.<span class="property">scene</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载环境贴图</span></span><br><span class="line">rgbLoader.<span class="title function_">load</span>(<span class="string">&quot;../../public/texture/brown_photostudio_02_1k.hdr&quot;</span>, <span class="function">(<span class="params">envMap</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置球型的映射</span></span><br><span class="line">  envMap.<span class="property">mapping</span> = <span class="variable constant_">THREE</span>.<span class="property">EquirectangularReflectionMapping</span>;</span><br><span class="line">  <span class="comment">// 设置环境贴图</span></span><br><span class="line">  scene.<span class="property">environment</span> = envMap</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="光线投射"><a href="#光线投射" class="headerlink" title="光线投射"></a>光线投射</h2><a href="/2024/11/01/threeJS/%E5%85%89%E7%BA%BF%E6%8A%95%E5%B0%84/" title="threeJS-光线投射">threeJS-光线投射</a>
<h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><a href="/2024/11/01/threeJS/%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB/" title="threeJS-补间动画TWEEN">threeJS-补间动画TWEEN</a>

<h2 id="物理网格材质"><a href="#物理网格材质" class="headerlink" title="物理网格材质"></a>物理网格材质</h2><p>首先需要安装npm i gsap 动画库<br>看车模型案例</p>
]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>ThreeJS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-实现中文字体的3D效果</title>
    <url>/2024/11/01/threeJS/%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E7%9A%843D%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>官方文档的3d字体无法显示中文字体</p>
</blockquote>
<h2 id="引入库"><a href="#引入库" class="headerlink" title="引入库"></a>引入库</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&quot;three&quot;</span> <span class="comment">/*导入three库*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">OrbitControls</span> &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/controls/OrbitControls.js&quot;</span> <span class="comment">/*导入轨道控制器*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FontLoader</span> &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/loaders/FontLoader.js&quot;</span> <span class="comment">/*导入字体加载器*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TextGeometry</span> &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/geometries/TextGeometry.js&quot;</span> <span class="comment">/*导入文本缓冲几何体*/</span></span><br></pre></td></tr></table></figure>
<h2 id="创建场景"><a href="#创建场景" class="headerlink" title="创建场景"></a>创建场景</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>()</span><br></pre></td></tr></table></figure>
<h2 id="初始化相机并设置相机的位置"><a href="#初始化相机并设置相机的位置" class="headerlink" title="初始化相机并设置相机的位置"></a>初始化相机并设置相机的位置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(<span class="number">45</span>,<span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>, <span class="number">0.1</span>, <span class="number">1000</span>)</span><br><span class="line">camera .<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>)</span><br></pre></td></tr></table></figure>
<h2 id="初始化渲染器"><a href="#初始化渲染器" class="headerlink" title="初始化渲染器"></a>初始化渲染器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> render = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>(&#123; <span class="attr">antialias</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>)</span><br></pre></td></tr></table></figure>
<h2 id="添加环境纹理"><a href="#添加环境纹理" class="headerlink" title="添加环境纹理"></a>添加环境纹理</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> texture = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>().<span class="title function_">load</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">texture.<span class="property">mapping</span> = <span class="variable constant_">THREE</span>.<span class="property">EquirectangularReflectionMapping</span></span><br><span class="line">scene.<span class="property">background</span> = texture</span><br><span class="line">scene.<span class="property">backgroundBlurriness</span> = <span class="number">0.5</span> <span class="comment">/*设置场景的模糊度*/</span></span><br><span class="line">scene.<span class="property">environment</span> = texture</span><br></pre></td></tr></table></figure>
<h2 id="添加控制器"><a href="#添加控制器" class="headerlink" title="添加控制器"></a>添加控制器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> <span class="title class_">OrbitControls</span>(camera, render.<span class="property">domElement</span>)</span><br><span class="line">controls.<span class="property">enableDamping</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="title function_">requestAnimationFrame</span>(render)</span><br><span class="line">	controls.<span class="title function_">update</span>()</span><br><span class="line">	renderer.<span class="title function_">render</span>(scene,camera)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>()</span><br></pre></td></tr></table></figure>

<h2 id="加载字体"><a href="#加载字体" class="headerlink" title="加载字体"></a>加载字体</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loader = <span class="keyword">new</span> <span class="title class_">FontLoader</span>()</span><br><span class="line">loader.<span class="title function_">load</span>(<span class="string">&quot;字体文件&quot;</span>, <span class="function">(<span class="params">font</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="title class_">TextGepmetry</span>(<span class="string">&#x27;展示的字体&#x27;</span>, &#123;</span><br><span class="line">		<span class="attr">font</span>: font,</span><br><span class="line">		<span class="attr">size</span>: <span class="number">80</span>, <span class="comment">/*字体大小*/</span></span><br><span class="line">		<span class="attr">height</span>:<span class="number">5</span>, <span class="comment">/*字体厚度*/</span></span><br><span class="line">		<span class="attr">curveSegments</span>: <span class="number">12</span>,<span class="comment">/*曲线分段数*/</span></span><br><span class="line">		<span class="attr">bevelEnabled</span>: <span class="literal">true</span>,<span class="comment">/*是否启用斜角*/</span></span><br><span class="line">		<span class="attr">bevelThickness</span>: <span class="number">10</span>,<span class="comment">/*斜角厚度*/</span></span><br><span class="line">		<span class="attr">bevelSize</span>: <span class="number">3</span>,<span class="comment">/*斜角大小*/</span></span><br><span class="line">		<span class="attr">bevelSegments</span>: <span class="number">5</span><span class="comment">/*斜角分段数*/</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="设置字体的材质"><a href="#设置字体的材质" class="headerlink" title="设置字体的材质"></a>设置字体的材质</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshPhysicalMaterial</span>(&#123;</span><br><span class="line">	<span class="attr">color</span>: <span class="number">0xeeeeff</span>,</span><br><span class="line">	<span class="attr">roughness</span>: <span class="number">0</span>, <span class="comment">/*粗糙度*/</span></span><br><span class="line">	<span class="attr">reflectivity</span>: <span class="number">1</span>, <span class="comment">/*反射*/</span></span><br><span class="line">	<span class="attr">thickness</span>: <span class="number">80</span>,<span class="comment">/*玻璃的厚度*/</span></span><br><span class="line">	<span class="attr">ior</span>: <span class="number">1.2</span>, <span class="comment">/*折射率*/</span></span><br><span class="line">	<span class="attr">transmission</span>: <span class="number">1</span>, <span class="comment">/*设置透明*/</span></span><br><span class="line">	<span class="attr">side</span>: <span class="variable constant_">THREE</span>.<span class="property">DoubleSide</span><span class="comment">/*两面可看*/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="创建字体"><a href="#创建字体" class="headerlink" title="创建字体"></a>创建字体</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material)</span><br><span class="line">scene.<span class="title function_">add</span>(mesh)</span><br></pre></td></tr></table></figure>

<h2 id="文字特效"><a href="#文字特效" class="headerlink" title="文字特效"></a>文字特效</h2><ul>
<li>按照上述创景场景相机,控制器，渲染函数</li>
<li>导入字体模型展示在场景</li>
</ul>
<h2 id="加载模型并生成随机顶点"><a href="#加载模型并生成随机顶点" class="headerlink" title="加载模型并生成随机顶点"></a>加载模型并生成随机顶点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> material；</span><br><span class="line"><span class="keyword">let</span> dracoLoader = <span class="keyword">new</span> <span class="title class_">DRACOLoader</span>()</span><br><span class="line">dracoLoader.<span class="title function_">setDecoderPath</span>(<span class="string">&quot;./draco/&quot;</span>) <span class="comment">/*这个路径是从库里面赋值出来放在当前目录的*/</span></span><br><span class="line"><span class="keyword">const</span> loader = <span class="keyword">new</span> <span class="title class_">GLTFLoader</span>()</span><br><span class="line">loader.<span class="title function_">setDRACOLoader</span>(dracoLoader)</span><br><span class="line">loader.<span class="title function_">load</span>(<span class="string">&quot;字体模型路径&quot;</span>, <span class="function">(<span class="params">gltf</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> text = gltf.<span class="property">scene</span>.<span class="property">children</span>[<span class="number">0</span>]</span><br><span class="line">	scene.<span class="title function_">add</span>(text)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 随机生成顶点数据*/</span></span><br><span class="line">	<span class="keyword">let</span> geometry =  text.<span class="property">geometry</span></span><br><span class="line">	<span class="keyword">const</span> position = geometry.<span class="property">attributes</span>.<span class="property">position</span> <span class="comment">/*获取顶点位置*/</span></span><br><span class="line">	<span class="keyword">const</span> vertexCount = position.<span class="property">count</span>  <span class="comment">/*获取所有的向量数*/</span></span><br><span class="line">	<span class="keyword">const</span> triangleCount = vertexCount / <span class="number">3</span>  <span class="comment">/*获取顶点数*/</span></span><br><span class="line">	cosnt randomDirections = [] <span class="comment">// 随机方向的数组</span></span><br><span class="line">	<span class="keyword">const</span> randomStrengths = [] <span class="comment">// 生成随机强度的数组</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 生成随机顶点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; triangleCount; i++)&#123;</span><br><span class="line">		<span class="keyword">const</span> dir = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(</span><br><span class="line">		<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">2</span> -<span class="number">1</span>,</span><br><span class="line">		<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">2</span> -<span class="number">1</span>,</span><br><span class="line">		<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">2</span> -<span class="number">1</span>,</span><br><span class="line">		).<span class="title function_">normalize</span>().<span class="title function_">toArray</span>()</span><br><span class="line">		randomDirections.<span class="title function_">push</span>(dir[<span class="number">0</span>],dir[<span class="number">1</span>],dir[<span class="number">2</span>])</span><br><span class="line">		<span class="keyword">const</span> str = <span class="title class_">Math</span>.<span class="title function_">random</span>()</span><br><span class="line">		randomStrengths.<span class="title function_">push</span>(str,str,str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 随机属性</span></span><br><span class="line">	<span class="keyword">const</span> randomDirectionsAttribute = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Float32BufferAttribute</span>(</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Float32Array</span>(randomDirections),<span class="number">3</span>)</span><br><span class="line">	geometry.<span class="title function_">setAttribute</span>(<span class="string">&quot;randomDirection&quot;</span>, randomDirectionsAttribute)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 随机强度</span></span><br><span class="line">	<span class="keyword">const</span> randomStrengthsAttribute = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Float32BufferAttribute</span>(</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Float32Array</span>(randomStrengths),<span class="number">1</span>)</span><br><span class="line">	geometry.<span class="title function_">setAttribute</span>(<span class="string">&quot;randomStrength&quot;</span>, randomStrengthsAttribute)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义着色器材质</span></span><br><span class="line">	material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">ShaderMaterial</span>(&#123;</span><br><span class="line">		<span class="attr">uniforms</span>:&#123;<span class="attr">time</span>: &#123; <span class="attr">value</span>: <span class="number">0</span>&#125;&#125;,</span><br><span class="line">		<span class="attr">vertexShader</span>: <span class="string">`</span></span><br><span class="line"><span class="string">			attributr vec3 randomDirection</span></span><br><span class="line"><span class="string">			attributr float randomStrength</span></span><br><span class="line"><span class="string">			uniform float time;</span></span><br><span class="line"><span class="string">			varying vec3 vPosition</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			void main() &#123;</span></span><br><span class="line"><span class="string">				vPosition = position</span></span><br><span class="line"><span class="string">				vec3 pos = position.xyz</span></span><br><span class="line"><span class="string">				pos += randomDirection * randomStrength * sin(time)</span></span><br><span class="line"><span class="string">				gl_Position = projectionMatrix * modelViewMatrix * vec4(pos.xyz, 1.0)</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		`</span>,</span><br><span class="line">		<span class="attr">fragmentShader</span>: <span class="string">`</span></span><br><span class="line"><span class="string">			varying vec3 vPosition</span></span><br><span class="line"><span class="string">			void main() &#123;</span></span><br><span class="line"><span class="string">				vec3 color = normalize(vPosition)*0.5 +0.5</span></span><br><span class="line"><span class="string">				color.z = color.z * 0.3</span></span><br><span class="line"><span class="string">				gl_FragColor = vec4(mixedColor * color * dProd, 1.0)</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		`</span>,</span><br><span class="line">		<span class="attr">side</span>: <span class="variable constant_">THREE</span>.<span class="property">DoubleSide</span>,</span><br><span class="line">		<span class="attr">transparent</span>: <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="添加控制器-1"><a href="#添加控制器-1" class="headerlink" title="添加控制器"></a>添加控制器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> <span class="title class_">OrbitControls</span>(camera, render.<span class="property">domElement</span>)</span><br><span class="line">controls.<span class="property">enableDamping</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> showText = <span class="literal">false</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	showText = !showText</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clock = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Clock</span>()</span><br><span class="line"><span class="keyword">let</span> value = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> delta = clock.<span class="title function_">getDelta</span>()</span><br><span class="line">	<span class="keyword">if</span> (material) &#123;</span><br><span class="line">		<span class="keyword">if</span>(showText)&#123;</span><br><span class="line">			value -= delta</span><br><span class="line">			value = <span class="title class_">Math</span>.<span class="title function_">max</span>(value, <span class="number">0</span>)</span><br><span class="line">			material.<span class="property">uniforms</span>.<span class="property">time</span>.<span class="property">value</span> -= delta</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			value += delta</span><br><span class="line">			value = <span class="title class_">Math</span>.<span class="title function_">max</span>(value, <span class="number">1</span>)</span><br><span class="line">			material.<span class="property">uniforms</span>.<span class="property">time</span>.<span class="property">value</span> += delta</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">requestAnimationFrame</span>(render)</span><br><span class="line">	controls.<span class="title function_">update</span>()</span><br><span class="line">	renderer.<span class="title function_">render</span>(scene,camera)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>案例</tag>
        <tag>ThreeJS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-机器人展示案例</title>
    <url>/2024/11/01/threeJS/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B1%95%E7%A4%BA%E6%A1%88%E4%BE%8B(%E8%A7%86%E9%A2%91%E7%BA%B9%E7%90%86%EF%BC%8C%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84)/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>按基础步骤添加场景、相机、控制器、渲染函数</li>
<li>加载环境纹理，</li>
<li>加载模型</li>
<li>添加直线光</li>
</ul>
<h2 id="视频纹理-底部的圈用mp4的形式"><a href="#视频纹理-底部的圈用mp4的形式" class="headerlink" title="视频纹理(底部的圈用mp4的形式)"></a>视频纹理(底部的圈用mp4的形式)</h2><h3 id="创建视频"><a href="#创建视频" class="headerlink" title="创建视频"></a>创建视频</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> video = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;video&quot;</span>)</span><br><span class="line">video.<span class="property">src</span> = <span class="string">&quot;&quot;</span> <span class="comment">/*视频路径*/</span></span><br><span class="line">video.<span class="property">loop</span> = <span class="literal">true</span> <span class="comment">/*视频循环播放*/</span></span><br><span class="line">video.<span class="property">muted</span> = <span class="literal">true</span> <span class="comment">/*视频静音*/</span></span><br><span class="line">video.<span class="title function_">play</span>() <span class="comment">/*播放*/</span></span><br></pre></td></tr></table></figure>
<h3 id="创建视频纹理"><a href="#创建视频纹理" class="headerlink" title="创建视频纹理"></a>创建视频纹理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> videoTexture = <span class="keyword">new</span> <span class="variable constant_">THREE</span>&gt;<span class="title class_">VideoTexture</span>(video)</span><br><span class="line"><span class="keyword">const</span> videoPlane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneBufferGeometry</span>(<span class="number">8</span>, <span class="number">4.5</span>)</span><br><span class="line"><span class="keyword">const</span> videoMaterial = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;</span><br><span class="line">	<span class="attr">map</span>: videoTexture,</span><br><span class="line">	<span class="attr">transparent</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">side</span>: <span class="variable constant_">THREE</span>.<span class="property">DoubleSide</span>,</span><br><span class="line">	<span class="attr">alphaMap</span>:videoTexture, <span class="comment">// 让黑色背景透明</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="创建物体"><a href="#创建物体" class="headerlink" title="创建物体"></a>创建物体</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> videoMesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(videoPlane,videoMaterial)</span><br><span class="line">videoMesh.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0</span>)</span><br><span class="line">videoMesh.<span class="property">rotation</span>.<span class="title function_">set</span>(-<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">scene.<span class="title function_">add</span>(videoMesh)</span><br></pre></td></tr></table></figure>

<h2 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h2><h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Relfector</span> &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/objects/Reflector&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="添加反射平面"><a href="#添加反射平面" class="headerlink" title="添加反射平面"></a>添加反射平面</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reflectorGeometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneBufferGeometry</span>(<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">const</span> reflectorPlane.<span class="property">rotation</span> = <span class="keyword">new</span> <span class="title class_">Reflector</span>(reflectorGeometry, &#123;</span><br><span class="line">	<span class="attr">textureWidth</span>: <span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">	<span class="attr">textureHeight</span>: <span class="variable language_">window</span>.<span class="property">innerHeight</span>,</span><br><span class="line">	<span class="attr">color</span>: <span class="number">0xffffff</span>,</span><br><span class="line">&#125;)</span><br><span class="line">reflectorPlane.<span class="property">rotation</span>.<span class="property">x</span> = -<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span></span><br><span class="line">scene.<span class="title function_">add</span>(reflectorPlane)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>案例</tag>
        <tag>ThreeJS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-物体的水晶效果</title>
    <url>/2024/11/01/threeJS/%E7%89%A9%E4%BD%93%E7%9A%84%E6%B0%B4%E6%99%B6%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>按照步骤，创建场景，相机，控制器，渲染函数，加载背景(环境纹理)，加载模型</li>
<li>拿到物体<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> model = gltf.<span class="property">scene</span>.<span class="property">children</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
<li>设置模型的材质<ul>
<li>MeshPhongMaterial水晶材质用这个创建，MeshLambertMaterial这个是漫反射<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">model.<span class="property">material</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshPhongMaterial</span>(&#123;</span><br><span class="line">	<span class="attr">color</span>: <span class="number">0xffffff</span>,</span><br><span class="line">	<span class="attr">envMap</span>: 环境纹理加载图片的变量</span><br><span class="line">	<span class="attr">refractionRatio</span>: <span class="number">0.7</span>, <span class="comment">/*直射率*/</span> </span><br><span class="line">	<span class="attr">refectivity</span>: <span class="number">0.99</span>,<span class="comment">/*反射率*/</span> </span><br><span class="line">	<span class="comment">// opacity: 0.9, /*透明度*/ </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>添加环境光<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ambient = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AmbientLight</span>(<span class="number">0xffffff</span>, <span class="number">1</span>)</span><br><span class="line">scene.<span class="title function_">add</span>(ambient)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>案例</tag>
        <tag>ThreeJS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-结合AI将图片生成3D场景</title>
    <url>/2024/11/01/threeJS/%E7%BB%93%E5%90%88AI%E5%B0%86%E5%9B%BE%E7%89%87%E7%94%9F%E6%88%903d%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p><a href="https://convert.leiapix.com/">leiapix</a>：将静态图片生成3D图片,下载深度图</p>
</blockquote>
<h2 id="第一步-搭建three的场景"><a href="#第一步-搭建three的场景" class="headerlink" title="第一步: 搭建three的场景"></a>第一步: 搭建three的场景</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入three.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建相机 --- 遵循近大远小原则</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(</span><br><span class="line"> <span class="number">90</span></span><br><span class="line"> <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>,</span><br><span class="line"> <span class="number">0.1</span>,</span><br><span class="line"> <span class="number">1000</span></span><br><span class="line">); </span><br><span class="line">camera.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">5.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>(&#123; <span class="attr">antialias</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">renderer.<span class="title function_">setSize</span>( <span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span> ); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>( renderer.<span class="property">domElement</span> );</span><br></pre></td></tr></table></figure>
<h2 id="第二步-加载图片"><a href="#第二步-加载图片" class="headerlink" title="第二步: 加载图片"></a>第二步: 加载图片</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建纹理加载器</span></span><br><span class="line"><span class="keyword">let</span> textureLoader = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>()</span><br><span class="line"><span class="comment">// 加载纹理</span></span><br><span class="line"><span class="keyword">let</span> texture = textureLoader.<span class="title function_">load</span>(<span class="string">&quot;静态图片路径&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> depthTexture = textureLoader.<span class="title function_">load</span>(<span class="string">&quot;深度图片路径&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="第三步-创建几何体、材质、网格-并添加到场景中"><a href="#第三步-创建几何体、材质、网格-并添加到场景中" class="headerlink" title="第三步: 创建几何体、材质、网格 并添加到场景中"></a>第三步: 创建几何体、材质、网格 并添加到场景中</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(图片的宽(两位数)，图片的高(两位数));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建鼠标对象</span></span><br><span class="line"><span class="keyword">const</span> mouse = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector2</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建着色器材质</span></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">ShaderMaterial</span>(&#123; </span><br><span class="line">	<span class="attr">uniforms</span>: &#123; </span><br><span class="line">		<span class="attr">uTime</span>: &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">		<span class="attr">uTexture</span>: &#123; <span class="attr">value</span>: texture &#125;,</span><br><span class="line">		<span class="attr">uDepthTexture</span>: &#123; <span class="attr">value</span>: depthTexture &#125;,</span><br><span class="line">		<span class="attr">uMouse</span>: &#123; <span class="attr">value</span>: mouse &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 顶点着色器</span></span><br><span class="line">	<span class="attr">vertexShader</span>:<span class="string">`</span></span><br><span class="line"><span class="string">		varying vec2 vUv;</span></span><br><span class="line"><span class="string">		void main() &#123;</span></span><br><span class="line"><span class="string">			vUv = uv;</span></span><br><span class="line"><span class="string">			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0)</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	`</span>,</span><br><span class="line">	<span class="comment">// 片源着色器</span></span><br><span class="line">	<span class="attr">fragmentShader</span>:<span class="string">`</span></span><br><span class="line"><span class="string">		uniform sampler2D uTexture</span></span><br><span class="line"><span class="string">		uniform sampler2D uDepthTexture</span></span><br><span class="line"><span class="string">		uniform float uTime</span></span><br><span class="line"><span class="string">		uniform vec2 uMouse // 鼠标坐标</span></span><br><span class="line"><span class="string">		varying vec2 vUv // 图片坐标</span></span><br><span class="line"><span class="string">		void main() &#123;</span></span><br><span class="line"><span class="string">			vec4 color = texture2D(uTexture, vUv) // 采集像素颜色, 基本上也就是这张图</span></span><br><span class="line"><span class="string">			vec4 depth = texture2D(uDepthTexture, vUv)</span></span><br><span class="line"><span class="string">			float depthValue = depth.r</span></span><br><span class="line"><span class="string">			float x = vUv.x + (uMose.x + sin(uTime)) * 0.01 * depthValue</span></span><br><span class="line"><span class="string">			float y = vUv.y + (uMose.y + cons(uTime)) * 0.01 * depthValue</span></span><br><span class="line"><span class="string">			vec4 newColor = texture2D(uTexture, vec2(x,y))</span></span><br><span class="line"><span class="string">			gl_FragColor = vec4(vUv, 0.0, 1.0)</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建网格</span></span><br><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry,material)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将网格添加到3场景中</span></span><br><span class="line">scene.<span class="title function_">add</span>(cube)</span><br></pre></td></tr></table></figure>

<h2 id="第四步-渲染"><a href="#第四步-渲染" class="headerlink" title="第四步: 渲染"></a>第四步: 渲染</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  material.<span class="property">uniforms</span>.<span class="property">uMouse</span>.<span class="property">value</span> = mouse</span><br><span class="line">  material.<span class="property">uniforms</span>.<span class="property">uTime</span>.<span class="property">value</span> = performance.<span class="title function_">now</span>() / <span class="number">1000</span></span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(animate)</span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  renderer.<span class="title function_">render</span>(scene, camera)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">animate</span>()</span><br><span class="line"><span class="comment">// 监听窗口变化</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  mouse.<span class="property">x</span> = (<span class="variable language_">window</span>.<span class="property">clientX</span> / <span class="variable language_">window</span>.<span class="property">innerWidth</span>) * <span class="number">2</span> -<span class="number">1</span></span><br><span class="line">  mouse.<span class="property">y</span> = -(<span class="variable language_">window</span>.<span class="property">clientY</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>) * <span class="number">2</span> +<span class="number">1</span></span><br><span class="line">  <span class="comment">// 更新相机投影矩阵</span></span><br><span class="line">  camera.<span class="title function_">updateProjectionMatrix</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>案例</tag>
        <tag>ThreeJS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-网格的基础材料</title>
    <url>/2024/11/01/threeJS/%E7%BD%91%E6%A0%BC%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9D%90%E6%96%99/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="第一步：-导入对应的工具并将基本布局完成"><a href="#第一步：-导入对应的工具并将基本布局完成" class="headerlink" title="第一步： 导入对应的工具并将基本布局完成"></a>第一步： 导入对应的工具并将基本布局完成</h2><h3 id="导入对应的工具"><a href="#导入对应的工具" class="headerlink" title="导入对应的工具"></a>导入对应的工具</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入three.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入轨道控制器</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">OrbitControls</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three/addons/controls/OrbitControls.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入lil.gui属性管理工具</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">GUI</span> &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/libs/lil-gui.module.min.js&quot;</span></span><br><span class="line"><span class="comment">// 导入hdr加载器</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RGBELoader</span> &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/loaders/RGBELoader.js&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建场景相机和渲染器"><a href="#创建场景相机和渲染器" class="headerlink" title="创建场景相机和渲染器"></a>创建场景相机和渲染器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建相机 --- 遵循近大远小原则</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(</span><br><span class="line"> <span class="number">75</span>, <span class="comment">// 视角 --- 在同距离情况下，视角越大（宽），看到的东西越多</span></span><br><span class="line"> <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>, <span class="comment">// 相机的宽高比</span></span><br><span class="line"> <span class="number">0.1</span>,  <span class="comment">// 近平面 --- 相机最近能看到的</span></span><br><span class="line"> <span class="number">1000</span>  <span class="comment">// 远平面 --- 相机最远能看到的</span></span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>(); </span><br><span class="line">renderer.<span class="title function_">setSize</span>( <span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span> ); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>( renderer.<span class="property">domElement</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机的位置</span></span><br><span class="line">camera.<span class="property">position</span>.<span class="property">z</span> = <span class="number">5</span></span><br><span class="line">camera.<span class="property">position</span>.<span class="property">y</span> = <span class="number">2</span></span><br><span class="line">camera.<span class="property">position</span>.<span class="property">x</span> = <span class="number">2</span></span><br><span class="line">camera.<span class="title function_">lookAt</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加世界坐标辅助器 --- 绿y，红x，蓝z</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AxesHelper</span>( <span class="number">5</span> );</span><br><span class="line">scene.<span class="title function_">add</span>(axesHelper)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> <span class="title class_">OrbitControls</span>( camera, renderer.<span class="property">domElement</span> );</span><br><span class="line"><span class="comment">// 设置带阻尼的惯性</span></span><br><span class="line">controls.<span class="property">enableDamping</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 设置阻尼系数</span></span><br><span class="line">controls.<span class="property">dampingFactor</span> = <span class="number">0.05</span></span><br></pre></td></tr></table></figure>
<h3 id="监听窗口并渲染函数"><a href="#监听窗口并渲染函数" class="headerlink" title="监听窗口并渲染函数"></a>监听窗口并渲染函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  controls.<span class="title function_">update</span>()</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(animate)</span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  renderer.<span class="title function_">render</span>(scene, camera)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">animate</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听窗口变化</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 重置渲染器宽高比</span></span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br><span class="line">  <span class="comment">// 重置相机宽高比</span></span><br><span class="line">  camera.<span class="property">aspect</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span></span><br><span class="line">  <span class="comment">// 更新相机投影矩阵</span></span><br><span class="line">  camera.<span class="title function_">updateProjectionMatrix</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="第二步：-创建GUI和加载器并引入对应的资源-色彩空间"><a href="#第二步：-创建GUI和加载器并引入对应的资源-色彩空间" class="headerlink" title="第二步： 创建GUI和加载器并引入对应的资源 + 色彩空间"></a>第二步： 创建GUI和加载器并引入对应的资源 + 色彩空间</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建属性参数管理器</span></span><br><span class="line"><span class="keyword">const</span> gui = <span class="keyword">new</span> <span class="title function_">GUI</span>()</span><br><span class="line"><span class="comment">// 创建纹理加载器</span></span><br><span class="line"><span class="keyword">let</span> textureLoader = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>()</span><br><span class="line"><span class="comment">// 加载hdr加载器</span></span><br><span class="line"><span class="keyword">let</span> rgbLoader = <span class="keyword">new</span> <span class="title class_">RGBELoader</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置彩色空间（没设置前是线性的，设置后为sRGB与人眼的感知相匹配）</span></span><br><span class="line">textureLoader.<span class="property">colorSpace</span> = <span class="variable constant_">THREE</span>.<span class="property">SRGBColorSpace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载纹理 -- 原图</span></span><br><span class="line"><span class="keyword">let</span> texture = textureLoader.<span class="title function_">load</span>(<span class="string">&quot;../../public/texture/Tiles118_1K-PNG/Tiles118.png&quot;</span>)</span><br><span class="line"><span class="comment">// 加载ao贴图（环境遮挡贴图）-- 原图，但有阴影</span></span><br><span class="line"><span class="keyword">let</span> aoMap = textureLoader.<span class="title function_">load</span>(<span class="string">&quot;../../public/texture/Tiles124_1K-PNG/Tiles124.png&quot;</span>)</span><br><span class="line"><span class="comment">// 透明度贴图 ---- 黑白灰的图片</span></span><br><span class="line"><span class="keyword">let</span> alphaMap = textureLoader.<span class="title function_">load</span>(<span class="string">&quot;../../public/texture/alpha.jpg&quot;</span>)</span><br><span class="line"><span class="comment">// 加载光照贴图  -- 可以找测试用的图（颜色多且鲜明）</span></span><br><span class="line"><span class="keyword">let</span> lightMap = textureLoader.<span class="title function_">load</span>(<span class="string">&quot;../../public/texture/lightMAp.png&quot;</span>)</span><br><span class="line"><span class="comment">// 高光贴图（黑色不反射，白色反射，之间的微反）-- 原图，但黑白灰三色，区分哪里高光</span></span><br><span class="line"><span class="keyword">let</span> specularMap = textureLoader.<span class="title function_">load</span>(<span class="string">&quot;../../public/texture/Tiles118_1K-PNG/Tiles118_1K-PNG_AmbientOcclusion.png&quot;</span>)</span><br><span class="line"><span class="comment">// 加载hdr全景图 --- 找个网站区下载</span></span><br><span class="line">rgbLoader.<span class="title function_">load</span>(<span class="string">&quot;../../public/texture/brown_photostudio_02_1k.hdr&quot;</span>, <span class="function">(<span class="params">envMap</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置球型的映射</span></span><br><span class="line">  envMap.<span class="property">mapping</span> = <span class="variable constant_">THREE</span>.<span class="property">EquirectangularReflectionMapping</span>;</span><br><span class="line">  <span class="comment">// 设置环境贴图</span></span><br><span class="line">  scene.<span class="property">background</span> = envMap</span><br><span class="line">  <span class="comment">// 设置整个场景的环境贴图</span></span><br><span class="line">  planeMaterial.<span class="property">envMap</span> = envMap</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="第三步：-创建一个平面和材质"><a href="#第三步：-创建一个平面和材质" class="headerlink" title="第三步： 创建一个平面和材质"></a>第三步： 创建一个平面和材质</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个平面</span></span><br><span class="line"><span class="keyword">let</span> planeGeometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 创建材质</span></span><br><span class="line"><span class="keyword">let</span> planeMaterial = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0xffffff</span>,</span><br><span class="line">  <span class="attr">map</span>: texture, <span class="comment">// 纹理贴图</span></span><br><span class="line">  <span class="attr">transparent</span>: <span class="literal">true</span>, <span class="comment">// 设置透明度</span></span><br><span class="line">  <span class="attr">aoMap</span>: aoMap, <span class="comment">// 设置阴影（环境遮罩）</span></span><br><span class="line">  <span class="comment">// alphaMap: alphaMap, // 设置透明度</span></span><br><span class="line">  <span class="comment">// lightMap: lightMap, // 设置光照贴图</span></span><br><span class="line">  <span class="comment">// reflectivity: 0.1, // 设置反射率的强度，默认1</span></span><br><span class="line">  <span class="attr">specularMap</span>:specularMap, <span class="comment">// 设置高光贴图</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(planeGeometry, planeMaterial)</span><br><span class="line"><span class="comment">// 添加到场景</span></span><br><span class="line">scene.<span class="title function_">add</span>(plane)</span><br><span class="line">gui.<span class="title function_">add</span>(planeMaterial, <span class="string">&quot;aoMapIntensity&quot;</span>).<span class="title function_">min</span>(<span class="number">0</span>).<span class="title function_">max</span>(<span class="number">1</span>).<span class="title function_">name</span>(<span class="string">&quot;阴影&quot;</span>)</span><br><span class="line">gui.<span class="title function_">add</span>(texture, <span class="string">&quot;colorSpace&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">sRGB</span>: <span class="variable constant_">THREE</span>.<span class="property">SRGBColorSpace</span>,</span><br><span class="line">  <span class="title class_">Linear</span>: <span class="variable constant_">THREE</span>.<span class="property">LinearSRGBColorSpace</span></span><br><span class="line">&#125;).<span class="title function_">onChange</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  textureLoader.<span class="property">needUpdate</span> = <span class="literal">true</span></span><br><span class="line">&#125;).<span class="title function_">name</span>(<span class="string">&quot;色彩空间&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>ThreeJS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>threeJS-补间动画TWEEN</title>
    <url>/2024/11/01/threeJS/%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="第一步：引入补间动画的插件"><a href="#第一步：引入补间动画的插件" class="headerlink" title="第一步：引入补间动画的插件"></a>第一步：引入补间动画的插件</h3><h3 id="第二步：创建一个物体-附：前期的基本工作要做好"><a href="#第二步：创建一个物体-附：前期的基本工作要做好" class="headerlink" title="第二步：创建一个物体,附：前期的基本工作要做好"></a>第二步：创建一个物体,附：前期的基本工作要做好</h3><h3 id="第三步：创建实例和动画并调用对应的方法"><a href="#第三步：创建实例和动画并调用对应的方法" class="headerlink" title="第三步：创建实例和动画并调用对应的方法"></a>第三步：创建实例和动画并调用对应的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入tween补间动画</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">TWEEN</span> <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/libs/tween.module.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个属性管理器，这个引入看前期的文档</span></span><br><span class="line"><span class="keyword">const</span> gui = <span class="keyword">new</span> <span class="title function_">GUI</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个球</span></span><br><span class="line"><span class="keyword">const</span> sphere1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SphereGeometry</span>(<span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;<span class="attr">color</span>:<span class="number">0x00ff00</span>&#125;)</span><br><span class="line">)</span><br><span class="line">sphere1.<span class="property">position</span>.<span class="property">x</span> = -<span class="number">4</span></span><br><span class="line">scene.<span class="title function_">add</span>(sphere1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建tween</span></span><br><span class="line"><span class="keyword">const</span> tween = <span class="keyword">new</span> <span class="variable constant_">TWEEN</span>.<span class="title class_">Tween</span>(sphere1.<span class="property">position</span>)</span><br><span class="line"><span class="comment">// to(&#123;去到哪里，自动识别position的x值&#125;，花费多少时间)</span></span><br><span class="line">tween.<span class="title function_">to</span>(&#123;<span class="attr">x</span>:<span class="number">4</span>&#125;,<span class="number">1000</span>).<span class="title function_">onUpdate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sphere1.<span class="property">position</span>.<span class="property">x</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 设置循环次数</span></span><br><span class="line"><span class="comment">// tween.repeat(Infinity)</span></span><br><span class="line"><span class="comment">// 设置循环往复</span></span><br><span class="line"><span class="comment">// tween.yoyo(true)</span></span><br><span class="line"><span class="comment">// 设置延迟运行时间</span></span><br><span class="line"><span class="comment">// tween.delay(3000)</span></span><br><span class="line"><span class="comment">// 设置缓动函数</span></span><br><span class="line">tween.<span class="title function_">easing</span>(<span class="variable constant_">TWEEN</span>.<span class="property">Easing</span>.<span class="property">Quadratic</span>.<span class="property">InOut</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二个补间动画</span></span><br><span class="line"><span class="keyword">const</span> tween2 = <span class="keyword">new</span> <span class="variable constant_">TWEEN</span>.<span class="title class_">Tween</span>(sphere1.<span class="property">position</span>)</span><br><span class="line">tween2.<span class="title function_">to</span>(&#123;<span class="attr">y</span>:<span class="number">4</span>&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// x.chain(y)，第一个动画x完成后链接第二个动画执行</span></span><br><span class="line">tween.<span class="title function_">chain</span>(tween2)</span><br><span class="line"></span><br><span class="line">tween2.<span class="title function_">chain</span>(tween)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动补间动画</span></span><br><span class="line">tween.<span class="title function_">start</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画开始函数</span></span><br><span class="line">tween.<span class="title function_">onStart</span>(<span class="function">()=&gt;</span>&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始&quot;</span>)&#125;)</span><br><span class="line"><span class="comment">// 动画完成函数</span></span><br><span class="line">tween.<span class="title function_">onComplete</span>(<span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;完成&quot;</span>)&#125;)</span><br><span class="line"><span class="comment">// 动画停止函数</span></span><br><span class="line">tween.<span class="title function_">onStop</span>(<span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;停止&quot;</span>)&#125;)</span><br><span class="line"><span class="comment">// 更新函数，即移动时都会触发</span></span><br><span class="line">tween.<span class="title function_">onUpdate</span>(<span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;更新&quot;</span>)&#125;)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">let</span> params = &#123;</span><br><span class="line">  stop : <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 暂停事件</span></span><br><span class="line">    tween.<span class="title function_">stop</span>()</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 用来控制动画暂停</span></span><br><span class="line"> gui.<span class="title function_">add</span>(params, <span class="string">&quot;stop&quot;</span>).<span class="title function_">name</span>(<span class="string">&quot;暂停&quot;</span>)</span><br><span class="line"> <span class="comment">// 最后，要记得在渲染函数中更新</span></span><br><span class="line"> <span class="comment">// 渲染函数</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">animate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="title function_">requestAnimationFrame</span>(animate)</span><br><span class="line">   <span class="comment">// 渲染</span></span><br><span class="line">   renderer.<span class="title function_">render</span>(scene, camera)</span><br><span class="line">	 <span class="variable constant_">TWEEN</span>.<span class="title function_">update</span>()</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="title function_">animate</span>()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ThreeJS</category>
      </categories>
      <tags>
        <tag>ThreeJS</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>React-React与定时器</title>
    <url>/2024/11/01/react/10.react%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<ul>
<li>在React中使用定时器: 主要是要注意返回清除定时器<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; memo, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Timer</span> = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// setCount使用箭头函数只会有一个count产生</span></span><br><span class="line">			<span class="title function_">setCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">		&#125;, <span class="number">1000</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">clearInterval</span>(timer)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不设置依赖原因: 设置了会产生多个timer和销毁多次timer</span></span><br><span class="line">	&#125;, [])</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Timer</span> </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>定时器</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-动画与定时器案例</title>
    <url>/2024/11/01/react/11.%E5%8A%A8%E7%94%BB%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>以下基于react hooks + tailwindcss + scss</p>
</blockquote>
<h2 id="文字雨"><a href="#文字雨" class="headerlink" title="文字雨"></a>文字雨</h2><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><ul>
<li>先将云层在网页上定位好，并拿到云层的dom</li>
<li>设置一个随机的文字数组，让目的文字一个一个落下</li>
<li>定义随机尺寸、随机left和随机的过渡时间</li>
<li>创建一个div并向里面添加随机的文字数组，设置该div的样式、字体、动画过渡时间，</li>
<li>向云层的dom添加这个div</li>
<li>使用定时器来定时清除dom</li>
<li>定时调用这个文字雨函数</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [textlist, setTextList] = <span class="title function_">useState</span>([])</span><br><span class="line"><span class="keyword">const</span> [left, setLeft] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> [size, setSize] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> [duration, setDuration] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">randomText</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> text = <span class="string">&quot;云破星出之夜，我对星低喃：吞噬我。&quot;</span></span><br><span class="line">	<span class="keyword">const</span> letter = text[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * text.<span class="property">length</span>)]</span><br><span class="line">	<span class="keyword">return</span> letter</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虽然不丝滑，但基本无问题</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = &#123;</span><br><span class="line">      <span class="attr">value</span>:<span class="title function_">randomText</span>(),</span><br><span class="line">      <span class="attr">left</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">310</span>),</span><br><span class="line">      <span class="attr">size</span>: <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1.5</span>,</span><br><span class="line">      <span class="attr">duration</span>: <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    list=[temp, ...list]</span><br><span class="line">    <span class="title function_">setTextList</span>(list)</span><br><span class="line">  &#125;,<span class="number">900</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">clearInterval</span>(timer)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;relative h-[560px]&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;cloud&quot;</span> <span class="attr">className</span>=<span class="string">&quot;relative top-[70px] w-[300px] h-[300px] bg-cover z-30&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">backgroundImage:</span> &#x27;<span class="attr">url</span>(/<span class="attr">asset</span>/<span class="attr">image</span>/<span class="attr">cloud.png</span>)&#x27;&#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#123;textlist.length &amp;&amp; textlist.map((item,index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">    return <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;fontSize:</span>`$&#123;<span class="attr">0.5</span> + <span class="attr">item.size</span>&#125;<span class="attr">em</span>`, <span class="attr">left:</span> `$&#123;<span class="attr">item.left</span>&#125;<span class="attr">px</span>`, <span class="attr">animationDuration:</span> `$&#123;<span class="attr">1</span> + <span class="attr">item.duration</span>&#125;<span class="attr">s</span>`&#125;&#125; <span class="attr">className</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;item.value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#125;)&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//scss</span></span><br><span class="line">.<span class="property">text</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: absolute;</span><br><span class="line">  line-<span class="attr">height</span>: 20px;</span><br><span class="line">  <span class="attr">color</span>: #fff;</span><br><span class="line">  text-<span class="attr">shadow</span>: <span class="number">0</span> <span class="number">0</span> 5px #fff,</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> 15px #fff</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> 30px #fff;</span><br><span class="line">  <span class="attr">animation</span>: rain 1s linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rain &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">  <span class="attr">transform</span>: <span class="title function_">translateY</span>(<span class="number">0</span>) <span class="title function_">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">80</span>% &#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translateY</span>(230px) <span class="title function_">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使雨点落到最下面时回弹10px 后变大并透明消失</span></span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translateY</span>(220px) <span class="title function_">scale</span>(<span class="number">1.3</span>);</span><br><span class="line">    <span class="attr">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3D分层图-CSS"><a href="#3D分层图-CSS" class="headerlink" title="3D分层图(CSS)"></a>3D分层图(CSS)</h2><h3 id="思路解析-1"><a href="#思路解析-1" class="headerlink" title="思路解析"></a>思路解析</h3><ul>
<li>先整体在y轴上偏移</li>
<li>将图片放置在同一容器并设置在x轴偏移45度并设置变形的原点为top</li>
<li>将第一张图片设置为相对定位，其余两张设置为绝对定位并且top和left为0</li>
<li>最重要的是在图片的容器中添加hover样式，并给每个图片的设置偏移位置和透明度(相同类不同子元素)</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3D分层图</span></span><br><span class="line">&lt;div className=<span class="string">&quot;flex flex-col skew-y-[-20deg] mt-[100px] ml-[50px] relative cursor-pointer&quot;</span>&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;imgContainer skew-x-[45deg] origin-top grayscale&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;分层一&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/asset/image/bg-2.jpg&quot;</span> <span class="attr">className</span>=<span class="string">&quot;relative h-[200px]&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;分层一&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/asset/image/bg-2.jpg&quot;</span> <span class="attr">className</span>=<span class="string">&quot;absolute top-0 left-0 h-[200px]&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;分层一&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/asset/image/bg-2.jpg&quot;</span> <span class="attr">className</span>=<span class="string">&quot;absolute top-0 left-0 h-[200px]&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;pl-[200px] text-4xl text-white&quot;</span>&gt;</span>CSS黑白3D分层图像<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&quot;pl-[260px] text-white skew-x-[45deg]&quot;</span>&gt;</span>《二泉映月》的音符如泉眼汩汩洇漫，我们知道那流浪着的该是一种无奈;《病中吟》的曲调如泪水缓缓流出，我们知道那流浪着的分明是一种悲凉;《良宵》的节拍如思念浓浓笼罩，我们知道那流浪着的更是一种彻骨的沧桑。不是二胡的流浪、音乐的流浪，那样的流浪是一个灵魂的流浪、一方土地的流浪，那样的流浪是一个时代的流浪、一个民族的流浪。<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;ml-[320px] text-lg text-white skew-x-[-10deg] border-double border-[6px] w-fit px-[4px] hover:border-[10px]&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(&#x27;You rose to the bait.&#x27;)&#125;&gt;更多内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 3d图层scss</span></span><br><span class="line">.<span class="property">imgContainer</span>:hover &#123;</span><br><span class="line">  &amp; <span class="attr">img</span>:nth-<span class="title function_">child</span>(<span class="params"><span class="number">3</span></span>) &#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translate</span>(100px, -100px);</span><br><span class="line">  &#125;</span><br><span class="line">  &amp; <span class="attr">img</span>:nth-<span class="title function_">child</span>(<span class="params"><span class="number">2</span></span>) &#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translate</span>(50px, -50px);</span><br><span class="line">    <span class="attr">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp; <span class="attr">img</span>:nth-<span class="title function_">child</span>(<span class="params"><span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translate</span>(0px, 0px);</span><br><span class="line">    <span class="attr">opacity</span>: <span class="number">0.2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3D立体图片旋转"><a href="#3D立体图片旋转" class="headerlink" title="3D立体图片旋转"></a>3D立体图片旋转</h2><h3 id="解析思路"><a href="#解析思路" class="headerlink" title="解析思路"></a>解析思路</h3><ul>
<li>先构造圆的虚拟线，定原点，分析每一个div落在上面的位置，并结合三角函数来落实div的位置</li>
<li>通过增加弧度使div缓缓地向下移动，形成旋转的轨迹。</li>
</ul>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>链接圆的轨迹</li>
<li>参考下列文章，实现<br><a href="https://www.cnblogs.com/lufy/archive/2012/06/21/2558049.html">生成静态圆的轨迹分析</a><br><a href="https://www.cnblogs.com/lufy/archive/2012/06/22/2558694.html">使轨迹上的div动起来的运动分析</a></li>
</ul>
<h3 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; memo, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.scss&#x27;</span></span><br><span class="line"><span class="comment">// 缺陷：speed数据异常，move调用会多次调用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Log</span> = <span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; widthOuter, heightOuter, recyleNum &#125; = props</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 图片div 的数据信息</span></span><br><span class="line">  <span class="keyword">const</span> [box,setBox] = <span class="title function_">useState</span>([])</span><br><span class="line">  <span class="comment">// 用来作触发页面渲染的标识</span></span><br><span class="line">  <span class="keyword">const</span> [flag, setFlag] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 标记宽度为0 的情况</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 弧度数： 把圆平分成八个部分的每一个对应的角度数</span></span><br><span class="line">  <span class="keyword">const</span> rad = (<span class="number">360</span>/<span class="number">8</span>)*<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">180</span></span><br><span class="line">  <span class="comment">// 图片div的外围容器的大小</span></span><br><span class="line">  <span class="keyword">const</span> [outerWidth, setOuterWidth] = <span class="title function_">useState</span>(widthOuter ? widthOuter : <span class="number">600</span>)</span><br><span class="line">  <span class="keyword">const</span> [outerHeight, setOuterHeight] = <span class="title function_">useState</span>(heightOuter ? heightOuter : <span class="number">600</span>)</span><br><span class="line">  <span class="comment">// 圆的半径</span></span><br><span class="line">  <span class="keyword">const</span> radius = outerWidth/ <span class="number">2</span></span><br><span class="line">  <span class="comment">// 外围容器的top值 = Math.cos(rad * index) * 圆的半径</span></span><br><span class="line">  <span class="comment">// 外围容器的left值 = Math.sin(rad * index) * 圆的半径   ==== 求每一个圆心角的直角边</span></span><br><span class="line">  <span class="comment">// 生成原点的位置（虚拟的原点）</span></span><br><span class="line">  <span class="keyword">const</span> dotLeft = outerWidth /<span class="number">2</span></span><br><span class="line">  <span class="keyword">const</span> dotTop = outerHeight /<span class="number">2</span></span><br><span class="line">  <span class="comment">// 生成图片div 的位置信息</span></span><br><span class="line">  <span class="keyword">if</span>(!box.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    box.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">img</span>: <span class="string">`/asset/image/box<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>.jpg`</span>,</span><br><span class="line">      <span class="attr">left</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">sin</span>(rad * i) * radius + dotLeft) - <span class="number">140</span> / <span class="number">2</span>,</span><br><span class="line">      <span class="attr">top</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">cos</span>(rad * i) * radius + dotTop) - <span class="number">200</span> / <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置动起来的速度=== 设置角度  </span></span><br><span class="line">  <span class="keyword">const</span> [speed,setSpeed] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 让图片div动起来</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">move</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setSpeed</span>(speed &lt; <span class="number">360</span> ? speed + <span class="number">2</span> : <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 运动的弧度数</span></span><br><span class="line">    <span class="keyword">const</span> distance = (speed * <span class="title class_">Math</span>.<span class="property">PI</span>) / <span class="number">180</span></span><br><span class="line">    <span class="keyword">const</span> _box = box.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      item.<span class="property">img</span> = <span class="string">`/asset/image/box<span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>.jpg`</span>,</span><br><span class="line">        item.<span class="property">left</span> = <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad * index + distance) * radius + dotLeft - <span class="number">140</span> / <span class="number">2</span>,</span><br><span class="line">        item.<span class="property">top</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad * index + distance) * radius + dotTop - <span class="number">200</span> / <span class="number">2</span></span><br><span class="line">      <span class="keyword">return</span> item</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">setBox</span>(_box)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用定时器</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">move</span>()</span><br><span class="line">      <span class="title function_">setFlag</span>(flag + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [flag])</span><br><span class="line">  <span class="comment">// 缩放布局</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeWeel</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> Y = e.<span class="property">deltaY</span></span><br><span class="line">    <span class="comment">// 向下滚，放大</span></span><br><span class="line">    <span class="keyword">if</span>(Y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">setOuterWidth</span>(outerWidth + <span class="number">10</span>)</span><br><span class="line">      <span class="title function_">setOuterHeight</span>(outerHeight + <span class="number">10</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 向上滚，缩小</span></span><br><span class="line">      <span class="title function_">setOuterWidth</span>(outerWidth - <span class="number">10</span>)</span><br><span class="line">      <span class="title function_">setOuterHeight</span>(outerHeight - <span class="number">10</span>)</span><br><span class="line">      <span class="comment">// 用来标记宽高为0 </span></span><br><span class="line">      <span class="keyword">if</span>(outerHeight === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(count+<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 只有当标记不为0并且宽度小于默认的宽度时，让宽度回到默认宽度，否则清除标记，重新判断</span></span><br><span class="line">      <span class="keyword">if</span>(count &amp;&amp; outerWidth&lt; <span class="number">600</span>) &#123;</span><br><span class="line">        <span class="title function_">setOuterWidth</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(outerWidth + <span class="number">10</span>))</span><br><span class="line">        <span class="title function_">setOuterHeight</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(outerHeight + <span class="number">10</span>))</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count &amp;&amp; outerWidth &gt;=<span class="number">600</span>) &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(<span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="comment">// 可移动可旋转可收缩有倒影的圆形立体图片展览</span></span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;relative w-full h-[900px] floorboard bg-black flex justify-center items-center&#x27;</span> <span class="attr">onWheel</span>=<span class="string">&#123;(e)</span> =&gt;</span> changeWeel(e)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;relative bg-transparent z-30 circle-wrap&#x27;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> `$&#123;<span class="attr">outerWidth</span>&#125;<span class="attr">px</span>`, <span class="attr">height:</span> `$&#123;<span class="attr">outerHeight</span>&#125;<span class="attr">px</span>` &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;box.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">img</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">key</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">src</span>=<span class="string">&#123;item.img&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">alt</span>=<span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">left:</span> `$&#123;<span class="attr">item.left</span>&#125;<span class="attr">px</span>`, <span class="attr">top:</span> `$&#123;<span class="attr">item.top</span>&#125;<span class="attr">px</span>`, &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">          )</span></span><br><span class="line"><span class="language-xml">        &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;absolute ground text-white&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          3D Tiktok Carousel</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Log</span></span><br><span class="line"><span class="comment">// scss</span></span><br><span class="line">.<span class="property">floorboard</span> &#123;</span><br><span class="line">	<span class="attr">overflow</span>: hidden;</span><br><span class="line">	.<span class="property">circle</span>-wrap &#123;</span><br><span class="line">		<span class="attr">display</span>: flex;</span><br><span class="line">		justify-<span class="attr">content</span>: center;</span><br><span class="line">		align-<span class="attr">items</span>: center;</span><br><span class="line">		<span class="attr">perspective</span>: 1100px;</span><br><span class="line">		transform-<span class="attr">style</span>: preserve-3d;</span><br><span class="line"></span><br><span class="line">		img &#123;</span><br><span class="line">			<span class="attr">position</span>: absolute;</span><br><span class="line">			<span class="attr">height</span>: 200px;</span><br><span class="line">			<span class="attr">width</span>: 140px;</span><br><span class="line">			box-<span class="attr">shadow</span>: <span class="number">0</span> <span class="number">0</span> 8px #fff;</span><br><span class="line">			transform-<span class="attr">origin</span>: center;</span><br><span class="line">			-webkit-box-<span class="attr">reflect</span>: below 10px</span><br><span class="line">				linear-<span class="title function_">gradient</span>(transparent, transparent, #<span class="number">0005</span>); <span class="comment">// 倒影渐变</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="attr">img</span>:hover &#123;</span><br><span class="line">			box-<span class="attr">shadow</span>: <span class="number">0</span> <span class="number">0</span> 15px #fffd;</span><br><span class="line">			-webkit-box-<span class="attr">reflect</span>: below 10px</span><br><span class="line">				linear-<span class="title function_">gradient</span>(transparent, transparent, #<span class="number">0007</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	.<span class="property">ground</span> &#123;</span><br><span class="line">		<span class="attr">left</span>: <span class="title function_">calc</span>((<span class="number">100</span>% - 144px) / <span class="number">2</span>);</span><br><span class="line">		<span class="attr">top</span>: <span class="title function_">calc</span>((<span class="number">100</span>% - 25px) / <span class="number">2</span>);</span><br><span class="line">		<span class="attr">background</span>: -webkit-radial-<span class="title function_">gradient</span>(</span><br><span class="line">			center center,</span><br><span class="line">			farthest-side,</span><br><span class="line">			#<span class="number">9993</span>,</span><br><span class="line">			transparent</span><br><span class="line">		);</span><br><span class="line">		<span class="attr">animation</span>: spinRevert 10s infinite;</span><br><span class="line">		<span class="attr">transform</span>: <span class="title function_">rotate</span>(0deg) <span class="title function_">scale</span>(<span class="number">1.05</span>, <span class="number">0.45</span>) <span class="title function_">translate</span>(0px, 0px)</span><br><span class="line">			<span class="title function_">skew</span>(-18deg, 0deg);</span><br><span class="line">		-webkit-<span class="attr">transform</span>: <span class="title function_">rotate</span>(0deg) <span class="title function_">scale</span>(<span class="number">1.05</span>, <span class="number">0.45</span>) <span class="title function_">translate</span>(0px, 0px)</span><br><span class="line">			<span class="title function_">skew</span>(-18deg, 0deg);</span><br><span class="line">		z-<span class="attr">index</span>: -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes spinRevert &#123;</span><br><span class="line">	<span class="keyword">from</span> &#123;</span><br><span class="line">		-webkit-<span class="attr">transform</span>: <span class="title function_">rotateZ</span>(360deg);</span><br><span class="line">		<span class="attr">transform</span>: <span class="title function_">rotateZ</span>(360deg);</span><br><span class="line">	&#125;</span><br><span class="line">	to &#123;</span><br><span class="line">		-webkit-<span class="attr">transform</span>: <span class="title function_">rotateZ</span>(0deg);</span><br><span class="line">		<span class="attr">transform</span>: <span class="title function_">rotateZ</span>(0deg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="数组已经改变，但页面没有渲染"><a href="#数组已经改变，但页面没有渲染" class="headerlink" title="数组已经改变，但页面没有渲染"></a>数组已经改变，但页面没有渲染</h4><ul>
<li>使用useEffect来触发页面渲染，数组使用useState来赋值</li>
</ul>
<h4 id="move函数每次调用时，会同时触发多次，并且speed的数值异常"><a href="#move函数每次调用时，会同时触发多次，并且speed的数值异常" class="headerlink" title="move函数每次调用时，会同时触发多次，并且speed的数值异常"></a>move函数每次调用时，会同时触发多次，并且speed的数值异常</h4><ul>
<li>破解的关键在于定时器，需要清除定时器</li>
<li>在useEffect中使用无副作用,即无依赖就不会多次触发。接着将定时器赋给一个变量，然后返回返回清除定时器。定时器中要存在一个能触发的变量，即使用useState的变量，无关值，只用于触发渲染页面</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>案例</tag>
        <tag>动画</tag>
        <tag>定时器</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-鼠标移动尾效的优化与学习</title>
    <url>/2024/11/01/react/12.%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E5%B0%BE%E6%95%88%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>做鼠标移动尾效需要注意，因为尾效要占用全屏，所以当前图层不是鼠标要点击的目标，而是当前图层的下一个图层才是鼠标的点击目标,使用pointer-events</p>
</blockquote>
<h2 id="pointer-events"><a href="#pointer-events" class="headerlink" title="pointer-events"></a>pointer-events</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><ul>
<li>指针事件，指定在上面情况下某个DOM可以成为鼠标事件的target，即<span class="en">允许&#x2F;禁止DOM的鼠标事件</span>(click事件、hover事件、mouse的那个鼠标事件)</li>
</ul>
<h3 id="属性值："><a href="#属性值：" class="headerlink" title="属性值："></a>属性值：</h3><ul>
<li>auto：默认值(使用这个跟不使用该属性一样)，在svg内容中相当于visiblePainted</li>
<li>none：💚鼠标不在监听当前层，而是监听下一层中的元素<span class="en">穿透图层点击的关键</span>。当然当前层的子元素中有设置该属性的其它值，还是会监听这个子元素的。</li>
<li>visiblePainted | visibleFill | visibleStroke | visible painted | fill | stroke | all: 只使用于SVG，不介绍</li>
</ul>
<h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><ul>
<li>穿透图层，父元素中使用，其它的都随意。</li>
</ul>
<h2 id="鼠标默认样式换成自定义图案"><a href="#鼠标默认样式换成自定义图案" class="headerlink" title="鼠标默认样式换成自定义图案"></a>鼠标默认样式换成自定义图案</h2><ul>
<li>使用cursor来更换</li>
<li>路径放在asset下，图片要换成ico后缀，大小32x32<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iconUrl = <span class="string">&#x27;/asset/image/cursor/xxx.ico&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;div</span><br><span class="line">	style=&#123;&#123; <span class="attr">background</span>: <span class="string">`<span class="subst">$&#123;bg&#125;</span>`</span>, <span class="attr">cursor</span>: <span class="string">`url(<span class="subst">$&#123;iconUrl&#125;</span>),auto`</span> &#125;&#125;</span><br><span class="line">&gt;示例</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="鼠标跟宠-纯纯的react，有点繁琐"><a href="#鼠标跟宠-纯纯的react，有点繁琐" class="headerlink" title="鼠标跟宠(纯纯的react，有点繁琐)"></a>鼠标跟宠(<span class="desc">纯纯的react，有点繁琐</span>)</h2><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><ul>
<li>第一拿到跟宠的图片的dom， 使用useRef</li>
<li>第二给图片的left和top设置为动态变量</li>
<li>第三获取全局鼠标的clientX， clientY</li>
<li>第四设置图片的left和top， 鼠标偏移量减去图片的偏移量，减去图片的一般大小，然后除以图片的大小，最后加上原来的图片left或top</li>
<li>第五让鼠标不管移动到哪里，图片也要跟随到哪里 ,这要到全局的鼠标事件中处理，以上逻辑都是</li>
<li>第六设置图片的移动速度，和到达鼠标后停止</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imgRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> [mouseHDirector, setMouseHDirector] = <span class="title function_">useState</span>(<span class="literal">false</span>) <span class="comment">// 鼠标滑动方向为右边，则为true</span></span><br><span class="line"><span class="keyword">const</span> img = mouseHDirector ? <span class="string">&quot;/asset/image/bjyxback.png&quot;</span> : <span class="string">&quot;/asset/image/bjyxfront.png&quot;</span></span><br><span class="line"><span class="keyword">const</span> [imgl, setImgl] = <span class="title function_">useState</span>(<span class="number">0</span>) <span class="comment">// 图片向左移动的距离</span></span><br><span class="line"><span class="keyword">const</span> [imgt, setImgt] = <span class="title function_">useState</span>(<span class="number">0</span>) <span class="comment">// 图片向上移动的距离</span></span><br><span class="line"><span class="keyword">const</span> [currentMouseX, setCurrentMouseX] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> [currentMouseY, setCurrentMouseY] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">setCurrentMouseX</span>(e.<span class="property">clientX</span>)</span><br><span class="line">	<span class="title function_">setCurrentMouseY</span>(e.<span class="property">clientY</span>)</span><br><span class="line">	<span class="title function_">setMouseHDirector</span>(imgRef.<span class="property">current</span>.<span class="property">offsetLeft</span> &lt; currentMouseX)</span><br><span class="line">	<span class="title function_">setImgl</span>((currentMouseX - imgRef.<span class="property">current</span>.<span class="property">offsetLeft</span> - imgRef.<span class="property">current</span>.<span class="property">clientWidth</span>/<span class="number">2</span>)/<span class="number">50</span> + imgl)</span><br><span class="line">	<span class="title function_">setImgt</span>((currentMouseY - imgRef.<span class="property">current</span>.<span class="property">offsetTop</span> - imgRef.<span class="property">current</span>.<span class="property">clientHeight</span>/<span class="number">2</span>)/<span class="number">50</span> + imgt)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Layout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">img</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">ref</span>=<span class="string">&#123;imgRef&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">alt</span>=<span class="string">&quot;鼠标跟宠&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">src</span>=<span class="string">&#123;img&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">className</span>=<span class="string">&#x27;absolute bg-cover z-50&#x27;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">left:</span> `$&#123;<span class="attr">imgl</span>&#125;<span class="attr">px</span>`, <span class="attr">top:</span>`$&#123;<span class="attr">imgt</span>&#125;<span class="attr">px</span>`, <span class="attr">width:</span> &#x27;<span class="attr">60px</span>&#x27;, <span class="attr">height:</span> &#x27;<span class="attr">60px</span>&#x27; &#125;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">	&#123;component&#125;</span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="鼠标跟宠-拖尾效果-使用gsap动画库辅助，代码简洁明了"><a href="#鼠标跟宠-拖尾效果-使用gsap动画库辅助，代码简洁明了" class="headerlink" title="鼠标跟宠&#x2F;拖尾效果 (使用gsap动画库辅助，代码简洁明了)"></a>鼠标跟宠&#x2F;拖尾效果 (<span class="desc">使用gsap动画库辅助，代码简洁明了</span>)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> spirtesList = [</span><br><span class="line">	<span class="string">&#x27;h-10 w-10&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;h-8 w-8&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;h-6 w-6&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;h-2 w-2&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;h-6 w-6&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;h-8 w-8&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;h-10 w-10&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> [ismove, setIsmove] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="title function_">setIsmove</span>(!ismove)</span><br><span class="line">		<span class="keyword">let</span> sprite = gsap.<span class="property">utils</span>.<span class="title function_">toArray</span>(<span class="string">&#x27;#sprite&#x27;</span>)</span><br><span class="line">		<span class="keyword">const</span> t1 = gsap.<span class="title function_">timeline</span>()</span><br><span class="line">		t1.<span class="title function_">to</span>(sprite, &#123;</span><br><span class="line">			<span class="attr">x</span>: e.<span class="property">clientX</span>,</span><br><span class="line">			<span class="attr">y</span>: e.<span class="property">clientY</span>,</span><br><span class="line">			<span class="attr">stagger</span>: -<span class="number">1</span>,</span><br><span class="line">			<span class="attr">duration</span>: <span class="number">5</span>,</span><br><span class="line">			<span class="attr">opacity</span>: <span class="number">1</span>,</span><br><span class="line">			<span class="attr">onComplete</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="title function_">setIsmove</span>(!ismove)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;).<span class="title function_">from</span>(sprite, &#123;</span><br><span class="line">			<span class="attr">x</span>: e.<span class="property">clientX</span>,</span><br><span class="line">			<span class="attr">y</span>: e.<span class="property">clientY</span>,</span><br><span class="line">			<span class="attr">stagger</span>: -<span class="number">0.01</span>,</span><br><span class="line">			<span class="attr">duration</span>: <span class="number">5</span>,</span><br><span class="line">			<span class="attr">opacity</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">onComplete</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="title function_">setIsmove</span>(!ismove)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">	<span class="attr">id</span>=<span class="string">&#x27;bea&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">	<span class="attr">className</span>=<span class="string">&#x27;absolute z-50 flex items-center pointer-events-none&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">	&#123;spirtesList.map((item, index) =&gt; (</span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">			<span class="attr">key</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">			<span class="attr">id</span>=<span class="string">&#x27;sprite&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">			<span class="attr">className</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">item</span>&#125; <span class="attr">bg-2</span> <span class="attr">rounded-full</span> <span class="attr">shadow-9</span>`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		/&gt;</span></span></span><br><span class="line"><span class="language-xml">	))&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>

<h3 id="拖尾：在单独的文件中写好，然后全局用，动画还是使用css的-keyframe"><a href="#拖尾：在单独的文件中写好，然后全局用，动画还是使用css的-keyframe" class="headerlink" title="拖尾：在单独的文件中写好，然后全局用，动画还是使用css的@keyframe"></a>拖尾：在单独的文件中写好，然后全局用，动画还是使用css的@keyframe</h3><p>用JQuery实现会比较方便直接操作dom</p>
<!-- - 路径：E:\practice\p_four\component\layout\moveStar.tsx -->]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>案例</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-基础知识</title>
    <url>/2024/11/01/react/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">


<h2 id="组件记住被交互过-state"><a href="#组件记住被交互过-state" class="headerlink" title="组件记住被交互过(state)"></a>组件记住被交互过(state)</h2><h3 id="不使用hook"><a href="#不使用hook" class="headerlink" title="不使用hook"></a>不使用hook</h3><ul>
<li>在组件的构造函数上设置this.state来初始化state(构造函数必搭配super(props))<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">	<span class="variable language_">super</span>(props)</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">		<span class="attr">value</span>: <span class="literal">null</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将组件中要记住的值用this.props.xxx替换为this.state.xxx</li>
<li>将对应的监听事件改为 <code>onClick=&#123;() =&gt; this.setState(&#123;value: &#39;X&#39;&#125;)&#125;</code></li>
</ul>
<h3 id="💚使用hook"><a href="#💚使用hook" class="headerlink" title="💚使用hook"></a>💚使用hook</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性!!!"></a>不可变性!!!</h2><ul>
<li>用新数据替换旧数据(仍保留原数据)</li>
<li>时间旅行(撤销和恢复)</li>
<li>跟踪数据的改变</li>
<li>创建pure components,可确定不可变数据是否改变,从而确定何时重新渲染</li>
</ul>
<h2 id="时间旅行"><a href="#时间旅行" class="headerlink" title="时间旅行"></a>时间旅行</h2><ul>
<li>slice()保存副本到history — <span class="desc">保存历史记录</span></li>
<li>将state提升到顶层,把原本的state改为props</li>
<li>map() — <span class="desc">(已经记录完)展示历史步骤记录</span></li>
</ul>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><ul>
<li>语法: <code>&lt;标签&gt;文本,&#123;变量/函数&#125;&lt;/标签&gt;</code>,与js混合用</li>
<li>字符串字面量用””包裹,表达式用{}</li>
<li>JSX防止注入攻击</li>
<li>JSX转译为React.createElement()函数调用</li>
</ul>
<h2 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h2><ul>
<li>元素是构成 React 应用的最小砖块</li>
<li>React元素是不可变元素</li>
</ul>
<h2 id="组件-props"><a href="#组件-props" class="headerlink" title="组件 &amp; props"></a>组件 &amp; props</h2><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><ul>
<li>只包含一个render方法并且不包含state时使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="class组件"><a href="#class组件" class="headerlink" title="class组件"></a>class组件</h3><ul>
<li>函数组件与class组件在React中是等效</li>
<li>渲染组件(用户自定义组件) — <span class="desc">组件名称必须大写</span></li>
<li>组合组件: 在一个组件中使用组件</li>
<li>提取组件: 拆分代码,形成组合组件套娃模式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">	<span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><ul>
<li>state被称为局部或封装的原因:<ul>
<li>除了拥有并设置了它的组件，其他组件都无法访问和知道某个组件是什么状态</li>
</ul>
</li>
<li>❌不能直接修改state<ul>
<li>√ 使用this.setState,构造函数是唯一可以给state赋值的</li>
</ul>
</li>
<li>❌this.props 和 this.state 可能会异步更新<ul>
<li>√ 让setState()接收一个函数而不是一个对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="attr">counter</span>: state.<span class="property">counter</span> + props.<span class="property">increment</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>state的更新会被合并: 使用setState会浅合并</li>
<li>数据是向下流动的: <ul>
<li>组件可以选择把state作为props向下传递给它的子组件,但子组件不知道它来自的是父组件的state还是props,还是手动输入,这通常被叫做<span class="key_words">『自上而下』</span>或是<span class="key_words">『单向』</span>的数据流.</li>
</ul>
</li>
</ul>
<h2 id="浅合并-深合并"><a href="#浅合并-深合并" class="headerlink" title="浅合并 &amp; 深合并"></a>浅合并 &amp; 深合并</h2><ul>
<li><span class="key_words">浅合并</span>: 有多层嵌套的情况下,第一层合并且替换,第二层及以下直接替换不合并</li>
<li><span class="key_words">深合并</span>: 有多层嵌套的情况下,每一层合并且替换</li>
</ul>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="与DOM-元素事件处理不同"><a href="#与DOM-元素事件处理不同" class="headerlink" title="与DOM 元素事件处理不同"></a>与DOM 元素事件处理不同</h3><ul>
<li>命名采用小驼峰式(aaaBaa)</li>
<li>传入一个函数作为事件处理函数 onClick&#x3D;{ 函数名 }</li>
<li>监听器:初始渲染时添加</li>
<li>不能通过返回false的方式<span class="key_words">『阻止默认行为必须显式使用preventDefault』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ActionLink</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">		e.<span class="title function_">preventDefault</span>() <span class="comment">// 阻止默认事件</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>像onClick&#x3D;{this.handleClick}这种形式,需要绑定this,否则this为undefined<ul>
<li>解决方案1: 💚使用箭头函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onClick=&#123;<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">handleClick</span>()&#125;</span><br></pre></td></tr></table></figure></li>
<li>解决方案2: 在constructor中添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br></pre></td></tr></table></figure></li>
<li>解决方案3: 使用实验性的class fields语法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is:&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h3><ul>
<li>显式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">deleteRow</span>(id, e)&#125;&gt;<span class="title class_">Delete</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
<li>隐式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">deleteRow</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>, id)&#125;&gt;<span class="title class_">Delete</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="条件渲染-if-元素变量-三目运算符"><a href="#条件渲染-if-元素变量-三目运算符" class="headerlink" title="条件渲染 (if 元素变量 || &amp;&amp; || 三目运算符)"></a>条件渲染 (if 元素变量 || &amp;&amp; || 三目运算符)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&#123;list.<span class="property">length</span> &amp;&amp; (<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>条件成立渲染，不成立跳过<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>) &#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  					 ||</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	&#123;list.length ? (<span class="tag">&lt;<span class="name">h1</span>&gt;</span>条件成立渲染，不成立跳过<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>) : null &#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>阻止组件的渲染(隐藏组件) — <span class="desc">在想要隐藏的组件中判断,直接 return null</span></li>
</ul>
<h2 id="列表-Key"><a href="#列表-Key" class="headerlink" title="列表 &amp; Key"></a>列表 &amp; Key</h2><h3 id="渲染多个组件"><a href="#渲染多个组件" class="headerlink" title="渲染多个组件"></a>渲染多个组件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString&#125;</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h3 id="基础列表组件"><a href="#基础列表组件" class="headerlink" title="基础列表组件"></a>基础列表组件</h3><ul>
<li>将上面的方法改成一个组件,直接调用该组件</li>
<li>key: 唯一标识，在diff算法执行时更快找到对应的节点</li>
<li>key在数组的上下文中被指定,只是兄弟节点之间必须唯一(两个不同数组可以使用相同key)</li>
<li>key会传递给React,不会传递给组件.需要key属性的值,要用其它属性名显式传递</li>
<li>JSX允许大括号中前任任何表达式,可以内联map()返回的结果</li>
</ul>
<h2 id="受控组件-非受控组件"><a href="#受控组件-非受控组件" class="headerlink" title="受控组件 | 非受控组件"></a>受控组件 | 非受控组件</h2><ul>
<li><span class="key_words">受控组件</span>：将状态变化交由React处理的组件，通过props获取其当前值，并通过回调函数通知变化</li>
<li><span class="key_words">非受控组件</span>: 通过ref引用获取的组件，使用DOM节点处理(ref)</li>
</ul>
<h2 id="表单-受控组件"><a href="#表单-受控组件" class="headerlink" title="表单(受控组件)"></a>表单(受控组件)</h2><ul>
<li>表单状态发生变化时，都会通知React，通过使用 setState()来更新</li>
<li>textarea 标签(多行文本控件) — <span class="desc">与input用法相同</span></li>
<li>select标签(下拉列表标签) <ul>
<li>单选：通过value来设置默认选中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;select value=&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>&#125;&gt;</span><br></pre></td></tr></table></figure></li>
<li>多选：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;select multiple=&#123;<span class="literal">true</span>&#125; value=&#123;[<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]&#125;&gt;<span class="string">`</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>input标签<ul>
<li>input的变化没有更新节点setState,而它的变化是本身具有的功能，所以为<span class="key_words">非受控组件</span></li>
<li>处理多个input 添加name属性 根据event.target.name 的值选择要执行的操作</li>
</ul>
</li>
<li>计算属性名称更新给定输入名称对应的state<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; [name]: value &#125;);</span><br></pre></td></tr></table></figure></li>
<li>受控输入空值,可能将value指定为undefined或null</li>
</ul>
<h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><ul>
<li>将组件的共享状态提升到最近的共同父组件</li>
<li>把子组件的state数据放在它们共同的父组件中保存,然后父组件可以通过props将状态数据传给子组件中</li>
<li>组件通过this.props.xxx来接收</li>
</ul>
<h2 id="组合-vs-继承"><a href="#组合-vs-继承" class="headerlink" title="组合 vs 继承"></a>组合 vs 继承</h2><ul>
<li>包含关系 — <span class="desc">一个组件包含在另一个组件中</span></li>
<li>特例关系 — <span class="desc">组合组件,定制渲染</span></li>
<li>现在有一个组件,这个组件又包含在另一个组件,并且值都是确定好的不更改的</li>
<li>组件可以<span class="key_words">『直接引入』</span>(import)而无需通过继承(extend)</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="挂载：当组件实例被创建并插入-DOM-时，其生命周期调用顺序如下："><a href="#挂载：当组件实例被创建并插入-DOM-时，其生命周期调用顺序如下：" class="headerlink" title="挂载：当组件实例被创建并插入 DOM 时，其生命周期调用顺序如下："></a>挂载：当组件实例被创建并插入 DOM 时，其生命周期调用顺序如下：</h3><ul>
<li>constructor()</li>
<li>static getDerivedStateFromProps()</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
<h3 id="更新：当组件的props或state发生变化时会触发更新。其生命周期调用顺序如下："><a href="#更新：当组件的props或state发生变化时会触发更新。其生命周期调用顺序如下：" class="headerlink" title="更新：当组件的props或state发生变化时会触发更新。其生命周期调用顺序如下："></a>更新：当组件的props或state发生变化时会触发更新。其生命周期调用顺序如下：</h3><ul>
<li>static getDerivedStateFromProps()</li>
<li>shouldComponentUpdate()</li>
<li>render()</li>
<li>getSnapshotBeforeUpdate()</li>
<li>componentDidUpdate()</li>
</ul>
<h3 id="卸载：当组件从-DOM-中移除时会调用如下方法："><a href="#卸载：当组件从-DOM-中移除时会调用如下方法：" class="headerlink" title="卸载：当组件从 DOM 中移除时会调用如下方法："></a>卸载：当组件从 DOM 中移除时会调用如下方法：</h3><ul>
<li>componentWillUnmount()<br><img src="/../../img/react/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="React生命周期"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><ul>
<li><a href="/2024/11/01/react/2.%E9%AB%98%E9%98%B6-Hook/" title="React-高阶HOOK">React-高阶HOOK</a></li>
<li><a href="/2024/11/01/react/3.%E5%B8%B8%E7%94%A8%E7%9A%84hook/" title="React-常用的HOOK">React-常用的HOOK</a></li>
<li><a href="/2024/11/01/react/4.%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85hook/" title="React-如何封装HOOK">React-如何封装HOOK</a></li>
</ul>
<h2 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h2><ul>
<li>引入用import()<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;路径&quot;</span>)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function"><span class="params">math</span> =&gt;</span> &#123; </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">10</span>,<span class="number">9</span>))</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Refs-转发-ref-DOM内部"><a href="#Refs-转发-ref-DOM内部" class="headerlink" title="Refs 转发(ref: DOM内部)"></a>Refs 转发(ref: DOM内部)</h2><ul>
<li><span class="key_words">转发 refs 到 DOM 组件</span>: 允许某些组件接收ref,并将其传递给子组件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">FancyButton</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (  Ⅲ</span><br><span class="line">	&lt;button ref=&#123;ref&#125; className=<span class="string">&quot;FancyButton&quot;</span>&gt;  Ⅳ</span><br><span class="line">	&#123;props.<span class="property">children</span>&#125;</span><br><span class="line">	&lt;/button&gt;</span><br><span class="line">))</span><br><span class="line"><span class="comment">// forwardRef 获取ref; createRef 创建一个React ref 并将其赋值给ref变量</span></span><br><span class="line"><span class="keyword">const</span> ref = <span class="title class_">React</span>.<span class="title function_">createRef</span>()		Ⅰ</span><br><span class="line">&lt;<span class="title class_">FancyButton</span> ref=&#123;ref&#125;&gt;<span class="title class_">Click</span> me!&lt;/<span class="title class_">FancyButton</span>&gt; 	Ⅱ</span><br></pre></td></tr></table></figure></li>
<li><span class="key_words">在高阶组件中转发 refs</span>: 高阶组件ref只能传给外部的组件,内部组件可以通过从props获取forwardRef,在将它传给ref,在返回时就可以挂载到被包裹的子组件上<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;forwardedRef&#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>= <span class="string">&#123;forwardRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props,ref</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &lt;外部组件 &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="高阶组件-HOC高阶组件是参数为组件，返回值为新组件的函数"><a href="#高阶组件-HOC高阶组件是参数为组件，返回值为新组件的函数" class="headerlink" title="高阶组件(HOC高阶组件是参数为组件，返回值为新组件的函数)"></a>高阶组件<span class="desc">(HOC高阶组件是参数为组件，返回值为新组件的函数)</span></h2><ul>
<li>场景: 多个组件对同一个订阅和取消订阅的频繁调用</li>
<li>使用withSubscription(被包装组件,(订阅的组件,props)&#x3D;&gt;返回需要的数据)</li>
<li>将不相关的props传递给被包裹的组件</li>
<li>refs不会被传递,render中不要使用HOC,静态方法也要复制(使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法)</li>
</ul>
<h2 id="装饰器decorator"><a href="#装饰器decorator" class="headerlink" title="装饰器decorator"></a>装饰器decorator</h2><ol>
<li>封装一个公用的方法</li>
<li>在写组件时，如果需要使用这个方法，则在这个组件上面添加一行<span class="key_words">『@方法』</span>来使用这个公用的方法</li>
<li>这个方法可以通过参数来向这个类的原型上的构造函数添加新的属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">testDecorator</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">target: any</span>) =&gt;</span> &#123;</span><br><span class="line">		target.<span class="property">isTeatable</span> =<span class="literal">true</span>; <span class="comment">//往DecoratorTest原型上的constructor添加了isTeatable =true</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><ul>
<li>含义：不把一个组件强加在另一个组件内,而是在另一个组件被使用的<span class="key_words">『标签上使用』</span>render props </li>
<li>作用：告知组件需要渲染什么内容的函数，变量符合时渲染对应内容</li>
<li>语法: <ul>
<li>render&#x3D;{(prop) &#x3D;&gt; 要渲染的组件或内容}</li>
<li>ortherName&#x3D;{() &#x3D;&gt; 要渲染的组件或内容}</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Child</span> </span><br><span class="line">	login=&#123;<span class="function"><span class="params">userName</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>已登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125; <span class="comment">//userName 存在时就使用</span></span><br><span class="line">	nologin=&#123;<span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>请登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125; </span><br><span class="line">/&gt; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h2><ul>
<li>将子列表分组,可返回多个元素</li>
<li>形式: &lt;React.Fragment &#x2F;&gt;  或 &lt; &#x2F;&gt;</li>
<li>作用: 像vue中的template一样,在html中不影响布局</li>
</ul>
<h2 id="PropTypes-进行类型检查"><a href="#PropTypes-进行类型检查" class="headerlink" title="PropTypes 进行类型检查"></a>PropTypes 进行类型检查</h2><ul>
<li>限制单个元素 PropTypes.element</li>
<li>默认值 defaultProps </li>
<li>任意类型数据 requiredAny: PropTypes.any.isRequired,</li>
<li>枚举类型 optionalEnum: PropTypes.oneOf([‘News’, ‘Photos’]),</li>
</ul>
<h2 id="Web-Components-第三方UI组件"><a href="#Web-Components-第三方UI组件" class="headerlink" title="Web Components (第三方UI组件)"></a>Web Components (第三方UI组件)</h2><ul>
<li>使用的是class</li>
</ul>
<h2 id="多个className的模板字符串写法"><a href="#多个className的模板字符串写法" class="headerlink" title="多个className的模板字符串写法"></a>多个className的模板字符串写法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 固定的样式名stone， 需要判断的样式名floatClass</span></span><br><span class="line">&lt;div className=&#123;<span class="string">`stone <span class="subst">$&#123;变量 ? <span class="string">&#x27;floatClass&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>&#125;&gt;</span><br><span class="line">	模板字符串</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="跳转页面"><a href="#跳转页面" class="headerlink" title="跳转页面"></a>跳转页面</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span>,useNavigate &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="comment">// js写法</span></span><br><span class="line"><span class="keyword">let</span> navigate = <span class="title function_">useNavigate</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">navigate</span>(<span class="string">&quot;/home&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件写法</span></span><br><span class="line">&lt;<span class="title class_">Navigate</span> to=<span class="string">&quot;/home&quot;</span> replace state=&#123;state&#125;/&gt;</span><br><span class="line"><span class="comment">// 替代原有的goBack 和goForward</span></span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(-1)&#125;&gt;goback<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(1)&#125;&gt;goforward<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-高阶HOOK</title>
    <url>/2024/11/01/react/2.%E9%AB%98%E9%98%B6-Hook/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">


<ul>
<li>在不写class的情况下使用state以及生命周期等其它特性</li>
<li>使用useState()定义一个数组里面有一个参数和修改参数的方法,这个参数相当于state</li>
<li>优点：没有破坏性改动—<span class="desc">完全可选,100%向后兼容</span></li>
<li>动机：便于复用状态逻辑和理解</li>
</ul>
<h3 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook:"></a>State Hook:</h3><ul>
<li>声明多个state变量: 可以在一个组件中多次使用State Hook</li>
</ul>
<h3 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook:"></a>Effect Hook:</h3><ul>
<li>“副作用”: 在 React 组件中执行过数据获取、订阅或者手动修改过 DOM</li>
<li>useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力&#x3D;挂载+更新+卸载的用途</li>
<li>同一组件可以多次使用</li>
<li>通过返回一个函数来指定如何“清除”副作用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;<span class="comment">// 每次渲染都调用</span></span><br><span class="line">	<span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>,handleStatusChange) <span class="comment">//挂载+更新</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(props.<span class="property">friend</span>.<span class="property">id</span>,handleStatusChange) <span class="comment">//卸载</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ul>
<li>只能在函数最外层调用 Hook</li>
<li>只能在 React 的函数组件中调用 Hook 和 自定义的 Hook 中</li>
</ul>
<h3 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h3><ul>
<li>封装一个组件里面包含State Hook 和Effect Hook且包含了一些共同的方法</li>
<li>其它组件可以调用它来使用这个方法,每一个组件使用hook的state都是独立</li>
</ul>
<h3 id="其它Hook"><a href="#其它Hook" class="headerlink" title="其它Hook"></a>其它Hook</h3><ul>
<li>useContent(): 不使用组件嵌套就可以订阅React的Content</li>
<li>useRenduser(): 可以通过reducer来管理组件本地的复杂state</li>
</ul>
<h3 id="使用State-Hook"><a href="#使用State-Hook" class="headerlink" title="使用State Hook"></a>使用State Hook</h3><ul>
<li>Hook在class内部时不起作用的</li>
<li>存储几个state变量就要调用几次useState</li>
<li>在页面中使用: 用大括号把state变量括起来就可以使用</li>
<li>在事件函数中调用state变量的修改方法去更新state变量<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>) <span class="comment">//说明count的初始值为0</span></span><br><span class="line">onClick = &#123;<span class="function">() =&gt;</span> <span class="title function_">setCount</span>(count+<span class="number">1</span>)&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用Effect-Hook"><a href="#使用Effect-Hook" class="headerlink" title="使用Effect Hook"></a>使用Effect Hook</h3><ul>
<li><span class="key_words">不需要清除的effect</span>:<ul>
<li>在 React 更新 DOM 之后运行一些额外的代码</li>
<li>传递给 useEffect 的函数在每次渲染中都会有所不同,防止过期</li>
</ul>
</li>
<li><span class="key_words">需要清除的effect</span>:<ul>
<li>订阅外部数据源,防止内存泄露</li>
<li>在订阅的时候返回一个要取消订阅的方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span><span class="function">() =&gt;</span> &#123; 模块.<span class="property">un</span>方法(参数,方法)&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><span class="key_words">使用多个Effect实现关注点分离</span><ul>
<li>挂载和更新内容不同,挂载和卸载内容不同</li>
<li>使用多个useEffect把相同的内容放在一起</li>
</ul>
</li>
<li>每次更新的时候都要运行Effect：防止显示的还是没更新前的状态</li>
<li>订阅和清除顺序按顺序执行</li>
<li>通过跳过 Effect 进行性能优化</li>
<li>如果某些特定值在两次重渲染之间没有发生变化，跳过对 effect 的调用，只要传递数组作为useEffect 的第二个可选参数即可：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">&#125;, [count]) <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Hook规则"><a href="#Hook规则" class="headerlink" title="Hook规则"></a>Hook规则</h3><ul>
<li>只在最顶层使用 Hook：不要在循环，条件或嵌套函数中调用 Hook</li>
<li>只在 React 函数中调用 Hook</li>
</ul>
<h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><ul>
<li>在 React 中有两种流行的方式来共享组件之间的状态逻辑: render props 和高阶组件，自定义 Hook</li>
</ul>
<h3 id="useDeferredValue"><a href="#useDeferredValue" class="headerlink" title="useDeferredValue"></a>useDeferredValue</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deferredValue = <span class="title function_">useDeferredValue</span>(value)</span><br></pre></td></tr></table></figure>
<ul>
<li>作用: 在新内容加载期间显示旧内容，延迟更新 UI 的某些部分</li>
<li>如在input中流程先输入 -&gt; 开始渲染 -&gt; 渲染完成前输入 -&gt; 渲染中断 -&gt; 执行新的渲染，在渲染完前这期间可以随时中断渲染</li>
<li>这个value可以使用useState的变量</li>
</ul>
<h3 id="useOptimistic"><a href="#useOptimistic" class="headerlink" title="useOptimistic"></a>useOptimistic</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [optimisticState, addOptimistic] = <span class="title function_">useOptimistic</span>(state, updateFn);</span><br></pre></td></tr></table></figure>
<ul>
<li>接受一个状态state，以及加工函数updateFn，其中updateFn在state更新时返回你想要的乐观结果,</li>
<li>updateFn &#x3D; (currentState, optimisticValue) &#x3D;&gt; {}</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>React-常用的HOOK</title>
    <url>/2024/11/01/react/3.%E5%B8%B8%E7%94%A8%E7%9A%84hook/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>Hook 本质上就是一个函数，它简洁了组件，有自己的状态管理，生命周期管理，状态共享。<br><a href="https://zh-hans.react.dev/reference/react/hooks">Hook API 索引</a></p>
</blockquote>
<h2 id="Hook-解决了："><a href="#Hook-解决了：" class="headerlink" title="Hook 解决了："></a>Hook 解决了：</h2><ul>
<li>组件之间状态复用</li>
<li>在函数组件中可以使用生命周期</li>
<li>不区分组件时间使用场景</li>
</ul>
<h2 id="React-内置的-Hook"><a href="#React-内置的-Hook" class="headerlink" title="React 内置的 Hook"></a>React 内置的 Hook</h2><h3 id="💚useState-状态管理"><a href="#💚useState-状态管理" class="headerlink" title="💚useState(状态管理)"></a>💚useState<span class="desc">(状态管理)</span></h3><ul>
<li>作用：为组件添加state，并通过setState来更新state，避免重复创建initialState<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(initialState)</span><br></pre></td></tr></table></figure>
<ul>
<li>setState(设置变量)</li>
<li>useState(初始化变量)</li>
</ul>
</li>
<li>注意：setState()在React中<span class="key_words">『大部分是异步』</span>，但也存在同步<ul>
<li>在setTimeout 回调函数中调用会<span class="key_words">『同步』</span>修改</li>
<li>在原生DOM事件的回调函数中调用会<span class="key_words">『同步』</span>修改</li>
</ul>
</li>
</ul>
<h3 id="💚useEffect-生命周期管理"><a href="#💚useEffect-生命周期管理" class="headerlink" title="💚useEffect(生命周期管理)"></a>💚useEffect<span class="desc">(生命周期管理)</span></h3><ul>
<li>作用：处理副作用(包括网络请求、直接操作DOM，使用计时器函数等)，相当于compoentDidmount和compoentDidUpdate<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 依赖项变化时执行的语句</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">//（可选）清除useEffect,相当于compoentDidUnmount</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;, [依赖项 || <span class="string">&#x27;为空则只执行一次&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><ul>
<li>作用: 副作用会在 DOM 更新之后同步执行，会阻塞浏览器绘制</li>
<li>语法: 与useEffect一样</li>
<li>与useEffect区别：<ul>
<li>useEffect 是<span class="key_words">『异步』</span>执行，而useLayoutEffect是<span class="key_words">『同步』</span>执行</li>
<li>useEffect是会在整个页面<span class="key_words">『渲染完』</span>才会调用, 而 useLayoutEffect 是在浏览器重新<span class="key_words">『绘制屏幕之前』</span>触发</li>
</ul>
</li>
</ul>
<h3 id="💚useRef-获取-Dom-操作"><a href="#💚useRef-获取-Dom-操作" class="headerlink" title="💚useRef(获取 Dom 操作)"></a>💚useRef<span class="desc">(获取 Dom 操作)</span></h3><ul>
<li>作用：通过ref操作DOM，避免重复创建 ref 的内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = <span class="title function_">useRef</span>(initialValue)</span><br></pre></td></tr></table></figure></li>
<li>使用：ref.current &#x3D; 子组件的实例</li>
<li>注意点: <ul>
<li><span class="key_words">『改变 ref.current 属性时，React 不会重新渲染组件』</span>，而useState会触发页面的重新渲染</li>
<li>更新useRef是副作用，所以一般写在useEffect或事件处理函数里</li>
<li>使用useRef来保存不影响组件视图输出信息 — <span class="desc">清除定时器</span></li>
</ul>
</li>
<li>使用场景: 用来获取上一次的值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">usePrevious</span> = (<span class="params">value: string | number</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> ref = <span class="title function_">useRef</span>()</span><br><span class="line">	<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			ref.<span class="property">current</span> = value</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> ref.<span class="property">current</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="useImperativeHandle-组件暴露值-方法"><a href="#useImperativeHandle-组件暴露值-方法" class="headerlink" title="useImperativeHandle(组件暴露值&#x2F;方法)"></a>useImperativeHandle<span class="desc">(组件暴露值&#x2F;方法)</span></h3><ul>
<li>作用：向父组件暴露一个自定义的 ref(穿透ref)，应当与forwardRef一起使用（包在forwardRef里面）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useImperativeHandle</span>(ref,createHandle,dependencies)</span><br></pre></td></tr></table></figure>
<ul>
<li>ref：子组件向父组件暴露的实例</li>
<li>createHandle：函数，传递的父组件可操作的实例和方法</li>
<li>dependencies：监听状态，更新状态</li>
</ul>
</li>
</ul>
<h3 id="💚useMemo-缓存值"><a href="#💚useMemo-缓存值" class="headerlink" title="💚useMemo(缓存值)"></a>💚useMemo<span class="desc">(缓存值)</span></h3><ul>
<li>作用：跳过不必要的计算和渲染性能的优化，缓存每次重新渲染都需要计算的结果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newValue = <span class="title function_">useMemo</span>(callback,[dependencies])</span><br></pre></td></tr></table></figure>
<ul>
<li>只有依赖改变，才会重新执行</li>
<li>返回值：初次渲染，返回不带参数调用的计算的结果，依赖不变，返回上次缓存的值，依赖变则返回新值</li>
</ul>
</li>
</ul>
<h3 id="💚useCallback-缓存函数"><a href="#💚useCallback-缓存函数" class="headerlink" title="💚useCallback(缓存函数)"></a>💚useCallback<span class="desc">(缓存函数)</span></h3><ul>
<li>概念：useMemo的语法糖，缓存的是一个函数，返回的也是一个函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useCallback</span>(fn,[dependencies])</span><br></pre></td></tr></table></figure></li>
<li>与useMemo的区别：<ul>
<li>useCallback不会执行第一个参数函数，而是将<span class="key_words">『函数返回』</span></li>
<li>useMemo会执行第一个函数并且将<span class="key_words">『结果返回』</span></li>
</ul>
</li>
</ul>
<h3 id="useReducer-redux-相似"><a href="#useReducer-redux-相似" class="headerlink" title="useReducer(redux 相似)"></a>useReducer<span class="desc">(redux 相似)</span></h3><ul>
<li>作用：向组件添加一个管理状态的reducer，实现reducer函数，避免重新创建初始值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialArg, init?)</span><br></pre></td></tr></table></figure>
<ul>
<li>reducer：更新state的纯函数。参数为 state 和 action，返回值是更新后的state</li>
<li>initialArg：初始化state的任意值</li>
<li>init：计算初始值的函数。如果存在，使用init(initialArg)的执行结果作为初始值，否则使用initialArg</li>
<li>dispatch：更新 state 并触发组件的重新渲染<ul>
<li>用法：dispatch(newVar)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="用于请求api，并处理数据的HOOK"><a href="#用于请求api，并处理数据的HOOK" class="headerlink" title="用于请求api，并处理数据的HOOK"></a>用于请求api，并处理数据的HOOK</h2><h3 id="参考-TanStack-Query-中文文档"><a href="#参考-TanStack-Query-中文文档" class="headerlink" title="参考 TanStack Query 中文文档"></a>参考 <a href="https://cangsdarm.github.io/react-query-web-i18n/react">TanStack Query 中文文档</a></h3><h3 id="useInfiniteQuery"><a href="#useInfiniteQuery" class="headerlink" title="useInfiniteQuery"></a>useInfiniteQuery</h3><ul>
<li>作用：无限滚动翻页<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; </span><br><span class="line">	data, <span class="comment">// 包含无限查询数据的对象，data.pages数组包含已获取的分页页面，data.pageParams数组包含用于获取分页页面的参数</span></span><br><span class="line">	hasNextPage, <span class="comment">// 含义：存在下一页 值:布尔值，如果getNextPageParam返回的不是undefined的，则为true</span></span><br><span class="line">	hasPreviousPage, <span class="comment">// 含义：存在上一页 值:布尔值，如果getPreviousPageParam返回的不是undefined的，则为true</span></span><br><span class="line">	isFetchingNextPage, <span class="comment">// 值:布尔值，区分后台刷新状态和加载更多状态</span></span><br><span class="line">	isFetchingPreviousPage, <span class="comment">// 值:布尔值，区分后台刷新状态和加载更多状态</span></span><br><span class="line">	refetch  </span><br><span class="line">&#125; = <span class="title function_">useInfiniteQuery</span>(&#123;</span><br><span class="line">	<span class="attr">queryKey</span>: [<span class="string">&quot;projects&quot;</span>], <span class="comment">// 这里的key相当于useEffect的依赖，但是为了避免多个key都是同样的，最好在加个字符串，使queryKey唯一</span></span><br><span class="line">	<span class="attr">queryFn</span>: fetchProjects, <span class="comment">// async/await请求api的函数</span></span><br><span class="line">	 <span class="comment">// 以下两个方法都是用于确定是否有更多数据要加载和或用来获取它所需的信息</span></span><br><span class="line">	<span class="attr">getNextPageParam</span>: <span class="function">(<span class="params">lastPage, pages</span>) =&gt;</span> lastPage.<span class="property">nextCursor</span>,</span><br><span class="line">	<span class="attr">getPreviousPageParam</span>: <span class="function">(<span class="params">firstPage, pages</span>) =&gt;</span> firstPage.<span class="property">prevCursor</span>, </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="useQuery-useQueries"><a href="#useQuery-useQueries" class="headerlink" title="useQuery&#x2F;useQueries"></a>useQuery&#x2F;useQueries</h3><ul>
<li>作用：获取请求接口的数据（并行请求）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">	<span class="attr">queryKey</span>: [<span class="string">&#x27;issues&#x27;</span>],</span><br><span class="line">	<span class="attr">queryFn</span>: 接口的函数,</span><br><span class="line">	<span class="attr">suspense</span>: <span class="literal">true</span>, <span class="comment">// 不需要处理加载或错误的状态</span></span><br><span class="line">	<span class="attr">enabled</span>: <span class="literal">false</span> <span class="comment">// 存在才会执行</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">useQueries</span>([&#123;<span class="attr">queryKey</span>:[],<span class="attr">queryFn</span>:<span class="title class_">Fn</span>&#125;,&#123;<span class="attr">queryKey</span>:[],<span class="attr">queryFn</span>:<span class="title class_">Fn</span>&#125;]) </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="react-redux-的-hooks"><a href="#react-redux-的-hooks" class="headerlink" title="react-redux 的 hooks"></a>react-redux 的 hooks</h2><ul>
<li>引入 import { hook } from ‘react-redux’</li>
</ul>
<h3 id="useSelector"><a href="#useSelector" class="headerlink" title="useSelector()"></a>useSelector()</h3><ul>
<li>从redux的store队形中提取数据(state)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = <span class="title function_">useSelector</span>( <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">counter</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="useDispatch"><a href="#useDispatch" class="headerlink" title="useDispatch()"></a>useDispatch()</h3><ul>
<li>返回Redux store中对dispatch函数的引用, 即把dispatch方法暴露出来使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>()</span><br><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;increment-counter&#x27;</span>&#125;)&#125;&gt;</span><br><span class="line">	julie</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
<li>将dispatch传递给子组件，使用useCallback,然后暴露该组件给其它组件使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> incrementCounter = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span> </span><br><span class="line">	<span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;increment-counter&#x27;</span>&#125;</span><br><span class="line">), [dispatch])</span><br><span class="line">&lt;<span class="title class_">MyIncrementButton</span> onIncrement=&#123;incrementCounter&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="useStore"><a href="#useStore" class="headerlink" title="useStore()"></a>useStore()</h3><ul>
<li>返回redux Provider组件的store对象的引用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = useStore</span><br><span class="line">&lt;div&gt;&#123;store.<span class="property">getStore</span>&#125;&lt;/div&gt; </span><br><span class="line"><span class="comment">// 但store中的state更新，这里不会自动跟新，所以适合存放不变的数据</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>React-创建一个项目</title>
    <url>/2024/11/01/react/5.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>

<ol>
<li>安装<ul>
<li>可以先针对一个安装然后在安装其他依赖</li>
<li>重点在webpack的配置</li>
</ul>
</li>
<li>在上面的基础上，目录已经基本配置好</li>
<li>在src目录下新建各个页面</li>
<li>在component页面下存放全局的组件，比如统一的布局组件和基础的组件</li>
<li>将assets目录移动到public目录下，在页面中可以使用相对路径或绝对路径来使用本地图片</li>
<li>如果存在统一的布局，请在component文件夹下创建布局组件</li>
<li>在react中没有插槽slot，可以使用{children}来代替，<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Test</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; children &#125; = props</span><br><span class="line">	<span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建路由表，统一管理路由<ul>
<li>可以参考 <a href="/2024/11/01/react/6.%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" title="React-创建路由统一管理配置">React-创建路由统一管理配置</a></li>
</ul>
</li>
<li>编写好静态页面</li>
<li>部署后台服务器</li>
<li>连接数据库</li>
<li>设置前端跨域，前后数据联通</li>
<li>调用接口，渲染页面</li>
<li>调整样式，保证移动端的和网页段的页面布局样式响应和动画</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-如何封装HOOK</title>
    <url>/2024/11/01/react/4.%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85hook/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>

<ul>
<li>1.首先创建好react项目</li>
<li>2.封装方法，创建一个ts文件，文件名一定要使用use为开头</li>
<li>3.可以使用一些基本的hook来辅助封装，封装后暴露这个方法</li>
<li>4.在页面中使用const 变量名 &#x3D; use方法 来调用</li>
<li>5.示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态展示当期时间的示例</span></span><br><span class="line"><span class="keyword">import</span> &#123;useEffect, useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useTime</span> = (<span class="params">refreshPeriod:number = <span class="number">1000</span></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> [currentTime,setCurrentTime] = useState&lt;<span class="title class_">Date</span>&gt;()</span><br><span class="line"></span><br><span class="line">	<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 创建定时器，没1秒刷新一次</span></span><br><span class="line">		<span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="title function_">setCurrentTime</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()),refreshPeriod)</span><br><span class="line">		<span class="comment">// 每次都要清除定时器</span></span><br><span class="line">		<span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval)</span><br><span class="line">	&#125;, [refreshPeriod])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> currentTime</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useTime</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>React-创建路由统一管理配置</title>
    <url>/2024/11/01/react/6.%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ol>
<li><p>新建一个文件夹routes&#x2F;router, 并在该文件夹下新建一个index.tsx文件</p>
</li>
<li><p>明确react-router-dom的版本，每个版本写法有些不同(去package.json可看)</p>
<ul>
<li>本次以v6演示</li>
</ul>
</li>
<li><p>创建一个路由变量来存储路由表的信息，以对象的形式保存在数组中</p>
</li>
<li><p>创建一个路由器,然后把路由变量传递给该路由器</p>
<ul>
<li>createHashRouter(): 显示的路径 &#x2F;#</li>
<li>createBrowserRouter(): 显示的路径 &#x2F;</li>
</ul>
</li>
<li><p>默认暴露该路由器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes/router/index.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;../src/home/index&quot;</span> <span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Comp</span> <span class="keyword">from</span> <span class="string">&quot;@/comp&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Log</span> <span class="keyword">from</span> <span class="string">&quot;@/log&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Navigate</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createBrowserRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [ <span class="comment">// 存放路由表信息的变量</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>,	<span class="comment">// 当路径没有带 / 默认页一般右登录放登录</span></span><br><span class="line">    <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Login</span> /&gt;</span></span>,</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/comp&#x27;</span>, <span class="comment">// 该路径为显示在浏览器地址栏上</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Comp&#x27;</span>,</span><br><span class="line">    <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span>, <span class="comment">// 跳转的组件</span></span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/log/:name&#x27;</span>, <span class="comment">// useParams方式,匹配在/log/下的任意页面</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Log&#x27;</span>,</span><br><span class="line">    <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Log</span> /&gt;</span></span>,</span><br><span class="line">  &#125;]</span><br><span class="line">  <span class="comment">// 创建一个BrowserRouter</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createBrowserRouter</span>(routes) </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>在index.tsx页面中使用RouterProvider 来接受路由,进入默认第一个页面是路由配置表路径为空的那个页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouterProvider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span> <span class="comment">// 接收路由</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.scss&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(container);</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">RouterProvider</span> <span class="attr">router</span>=<span class="string">&#123;router&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录后进入系统后通过导航选择页面</p>
</li>
<li><p>路由</p>
<ul>
<li><span class="key_words">声明式导航</span>: 在组件需要跳转路径时使用Link标签, to的路径与路由表上的path(除params)要一样<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Comp</span> = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">log</span>/<span class="attr">aaa</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">UnlockOutlined</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontSize:</span> &#x27;<span class="attr">1.2em</span>&#x27;&#125;&#125; <span class="attr">className</span>=<span class="string">&quot;mr-4&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;item.name&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><span class="key_words">编程式导航</span>: 需要通过条件判断在函数中导航<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useNavigate &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Comp</span> = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>();</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> navigate(&#x27;/loginPage&#x27;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      跳转loginPage</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-路由器</title>
    <url>/2024/11/01/react/7.router/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>安装: 先安装好react的应用程序然后npm react-router-dom</p>
</blockquote>
<h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><h3 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace()"></a>router.replace()</h3><ul>
<li>replace模式是替换模式，会替换掉栈顶的路由</li>
<li>设置 replace 属性的话，当点击时，会调用 router.replace(), 导航后不会留下 history 记录。即使点击返回按钮也不会回到这个页面。</li>
</ul>
<h3 id="router-push-location"><a href="#router-push-location" class="headerlink" title="router.push(location)"></a>router.push(location)</h3><ul>
<li>会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL,当点击时，这个方法会在内部调用，即点击等同于调用 router.push()</li>
</ul>
<h2 id="使用-版本6的写法"><a href="#使用-版本6的写法" class="headerlink" title="使用(版本6的写法):"></a>使用(版本6的写法):</h2><ul>
<li>创建根路径使用creatRoot()</li>
<li>Routes代替Switch,element代替了component</li>
<li>Navigate代替Redirect</li>
<li>跳转页面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link to=<span class="string">&quot;route里面的path地址&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="React-Router-API"><a href="#React-Router-API" class="headerlink" title="React Router API"></a>React Router API</h2><ul>
<li>BrowserRouter：使用了history和React Context 实现</li>
<li>Route：用来定义一个访问路径与 React 组件之间的关系<span class="desc">(访问时加载对应页面)</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/定义的路径&quot;</span> element=&#123;&lt;组件名 /&gt;&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>Routes: 包裹一系列的 Route</li>
<li>useLocation(): 获取当前页路径 URL 的信息</li>
<li>设置默认页路径<span class="desc">(如 404 页)</span>: path&#x3D;”*” 匹配所有路径</li>
<li>Navigate标签<span class="key_words">『重定向』</span><ul>
<li>replace 属性用于控制跳转模式(push 或 replace，默认是 push)</li>
<li>页面判断:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;sum === <span class="number">1</span> </span><br><span class="line">	? <span class="language-xml"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>sum的值为&#123;sum&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line">	: <span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">replace</span>=<span class="string">&#123;true&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重定向的意义: 判断用户是否登录过了,没有重定向回登录界面</li>
</ul>
</li>
<li>NavLink标签<span class="key_words">『路由高亮』</span><ul>
<li>作用: 跳转路径, 路径选中时会高亮</li>
<li>不能直接指定高亮类名，需要通过函数返回。</li>
<li>该函数传入一个对象，类似于 {isActive: true} 标识路由是否被激活。匹配成功会高亮，end 属性可移除该效果</li>
</ul>
</li>
<li>useRoutes()路由表:<ul>
<li><a href="/2024/11/01/react/6.%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" title="React-创建路由统一管理配置">React-创建路由统一管理配置</a></li>
<li>引入到页面,使用NavLink标签</li>
</ul>
</li>
<li>Outlet标签<span class="key_words">『嵌套路由』</span><ul>
<li>设置二级路由链接时，可以是 to&#x3D;”news”、to&#x3D;”.&#x2F;news”，但不能是 to&#x3D;”&#x2F;news”</li>
<li>在路由表中定义二级路由后,父组件在<code>&lt;NavLink 子路由链接/&gt;</code>标签下使用<code>&lt;Outlet&gt;子路由出口&lt;/Outlet&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><h3 id="传递-params-参数"><a href="#传递-params-参数" class="headerlink" title="传递 params 参数"></a>传递 params 参数</h3><ul>
<li>注册路由时声明：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;detail/:id/:name/:age&quot;</span> element=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Detail</span> /&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>传递参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=&#123;<span class="string">`detail/<span class="subst">$&#123;item.id&#125;</span>/<span class="subst">$&#123;item.name&#125;</span>/<span class="subst">$&#123;item.age&#125;</span>`</span>&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>使用 useParams() 接收 params 参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;id, name, age&#125; = <span class="title function_">useParams</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="传递-search-参数"><a href="#传递-search-参数" class="headerlink" title="传递 search 参数"></a>传递 search 参数</h3><ul>
<li>传递参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=&#123;<span class="string">&#x27;detail?id=$&#123;item.id&#125;&amp;name=$&#123;item.name&#125;&#x27;</span>&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>使用useSearchParams()接收参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [searchParams, setSearchParams] = <span class="title function_">useSearchParams</span>()</span><br><span class="line"><span class="comment">// 需要调用 get() 方法获取对应的参数值</span></span><br><span class="line"><span class="keyword">const</span> id = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> name = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">setSearchParams</span>(<span class="string">&#x27;id=666&amp;name=Lily&amp;age=888&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="传递-state-参数"><a href="#传递-state-参数" class="headerlink" title="传递 state 参数"></a>传递 state 参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> </span><br><span class="line">	to=<span class="string">&quot;detail&quot;</span> </span><br><span class="line">	state=&#123;&#123; <span class="attr">id</span>: item.<span class="property">id</span>, <span class="attr">name</span>: item.<span class="property">name</span>, <span class="attr">age</span>: item.<span class="property">age</span> &#125;&#125;&gt;</span><br><span class="line">	&#123;item.<span class="property">name</span>&#125;</span><br><span class="line">&lt;/<span class="title class_">Link</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-面试题</title>
    <url>/2024/11/01/react/9.%E6%9B%B4%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%9A%84%E4%BA%86%E8%A7%A3react/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="什么是-React，它有什么好处？"><a href="#什么是-React，它有什么好处？" class="headerlink" title="什么是 React，它有什么好处？"></a>什么是 React，它有什么好处？</h3><ul>
<li>React 是一个用于构建用户界面的 JavaScript 库。它用于构建Web应用程序，因为它允许开发人员创建可重用的UI组件，并以高效和有组织的方式管理应用程序的状态。</li>
</ul>
<h3 id="什么是虚拟-DOM，它是如何工作的？"><a href="#什么是虚拟-DOM，它是如何工作的？" class="headerlink" title="什么是虚拟 DOM，它是如何工作的？"></a>什么是虚拟 DOM，它是如何工作的？</h3><ul>
<li>虚拟 DOM（文档对象模型）表示浏览器中的实际 DOM。它使 React 能够只更新网页中需要更改的特定部分，而不是重写整个页面，从而提高性能。</li>
<li>当组件的状态或 props 发生变化时，React 将首先创建一个新版本的虚拟 DOM，以反映更新的状态或 props。然后，它将此新版本与以前的版本进行比较，以确定更改的内容。</li>
<li>一旦确定了更改，React 将使用必要的最少操作数来更新实际的 DOM，以使其与新版本的虚拟 DOM 保持一致。这个过程被称为“和解”。</li>
<li>使用虚拟 DOM 可以实现更高效的更新，因为它减少了对实际 DOM 的直接操作量，这可能是一个缓慢且资源密集型的过程。通过只更新实际更改的部分，React 可以提高应用程序的性能，尤其是在速度较慢的设备上或处理大量数据时。</li>
</ul>
<h3 id="React-如何处理更新和渲染？"><a href="#React-如何处理更新和渲染？" class="headerlink" title="React 如何处理更新和渲染？"></a>React 如何处理更新和渲染？</h3><ul>
<li>React 通过虚拟 DOM 和基于组件的架构处理更新和渲染。当组件的状态或 props 发生变化时，React 会创建一个新版本的虚拟 DOM 来反映更新的状态或 props，然后将其与以前的版本进行比较以确定发生了什么变化。React 使用使其与新版本的虚拟 DOM 保持一致所需的最少操作数来更新实际的 DOM，这个过程称为“协调”。React 还使用基于组件的架构，其中每个组件都有自己的状态和渲染方法。它仅重新呈现实际更改的组件。它高效快速地做到这一点，这就是 React 以其性能而闻名的原因。</li>
</ul>
<h3 id="解释-React-中组件的概念？"><a href="#解释-React-中组件的概念？" class="headerlink" title="解释 React 中组件的概念？"></a>解释 React 中组件的概念？</h3><ul>
<li>React 组件是一个返回 React 元素的 JavaScript 函数或类，该元素描述了应用程序的一部分的 UI。组件可以接受称为“props”的输入，并管理自己的状态。</li>
</ul>
<h3 id="什么是-JSX，为什么在-React-中使用它？"><a href="#什么是-JSX，为什么在-React-中使用它？" class="headerlink" title="什么是 JSX，为什么在 React 中使用它？"></a>什么是 JSX，为什么在 React 中使用它？</h3><ul>
<li>JSX是JavaScript的语法扩展，允许在JavaScript中嵌入类似HTML的语法。它在 React 中用于描述 UI，并通过 Babel 等构建工具转换为普通的 JavaScript。</li>
</ul>
<h3 id="状态和道具有什么区别？"><a href="#状态和道具有什么区别？" class="headerlink" title="状态和道具有什么区别？"></a>状态和道具有什么区别？</h3><ul>
<li>状态和 props 都用于在 React 组件中存储数据，但它们用于不同的目的并具有不同的特征。</li>
<li>props 是一种将数据从父组件传递到子组件的方法。它们是只读的，不能由子组件修改。</li>
<li>State 是一个对象，用于保存可以随时间变化的组件的数据。它可以使用 setState() 方法进行更新，并用于控制组件的行为和呈现。</li>
</ul>
<h3 id="React-中受控组件和非受控组件有什么区别？"><a href="#React-中受控组件和非受控组件有什么区别？" class="headerlink" title="React 中受控组件和非受控组件有什么区别？"></a>React 中受控组件和非受控组件有什么区别？</h3><ul>
<li>在 React 中，受控和不受控的组件是指表单的处理方式。</li>
<li>受控组件是表单状态由 React 控制的组件，对表单输入的更新由事件处理程序处理。</li>
<li>不受控制的组件依赖于浏览器的默认行为来处理对表单输入的更新。</li>
<li>受控组件是输入字段的值由状态设置并且更改由 React 的事件处理程序管理的组件，这样可以更好地控制表单的行为和验证，并且可以轻松处理表单提交。</li>
<li>不受控制的组件是输入字段的值由默认值属性设置的组件，并且更改由浏览器的默认行为管理，此方法性能较低，并且更难处理表单提交和验证。</li>
</ul>
<h3 id="什么是-Redux，它如何与-React-配合使用？"><a href="#什么是-Redux，它如何与-React-配合使用？" class="headerlink" title="什么是 Redux，它如何与 React 配合使用？"></a>什么是 Redux，它如何与 React 配合使用？</h3><ul>
<li>Redux 是 JavaScript 应用程序的可预测状态管理库，通常与 React 一起使用。</li>
<li>它为应用程序的状态提供了一个集中存储，并使用称为 reducer 的纯函数来更新状态以响应操作。</li>
<li>在 React 应用程序中，Redux 通过 react-redux 库与 React 集成，该库提供了连接函数，用于将组件连接到 Redux 存储并调度操作。</li>
<li>组件可以从存储访问状态，并通过连接函数提供的 props 调度操作以更新状态。</li>
</ul>
<h3 id="你能解释一下-React-中高阶组件-（HOC）-的概念吗？"><a href="#你能解释一下-React-中高阶组件-（HOC）-的概念吗？" class="headerlink" title="你能解释一下 React 中高阶组件 （HOC） 的概念吗？"></a>你能解释一下 React 中高阶组件 （HOC） 的概念吗？</h3><ul>
<li>React 中的高阶组件 （HOC） 是一个函数，它接受一个组件并返回一个带有附加 props 的新组件。</li>
<li>HOC 用于跨多个组件重用逻辑，例如添加常见行为或样式。</li>
<li>HOC 通过将组件包装在 HOC 中使用，这将返回一个带有添加props的新组件。</li>
<li>原始组件作为参数传递给 HOC，并通过解构接收额外的 props。</li>
<li>HOC 是纯函数，这意味着它们不会修改原始组件，而是返回新的增强组件。</li>
<li>HOC 可用于向组件添加身份验证行为，例如在呈现组件之前检查用户是否已登录。HOC 将处理检查用户是否已登录的逻辑，并将指示登录状态的 prop 传递给包装的组件。</li>
<li>HOC 是 React 中一个强大的模式，允许代码重用和抽象，同时保持组件模块化且易于维护。</li>
</ul>
<h3 id="在-React-中，服务器端渲染和客户端渲染有什么区别？"><a href="#在-React-中，服务器端渲染和客户端渲染有什么区别？" class="headerlink" title="在 React 中，服务器端渲染和客户端渲染有什么区别？"></a>在 React 中，服务器端渲染和客户端渲染有什么区别？</h3><ul>
<li>服务器端渲染 （SSR） 和客户端渲染 （CSR） 是渲染 React 应用程序的两种不同方式。</li>
<li>在 SSR 中，初始 HTML 在服务器上生成，然后发送到客户端，在那里它被合到一个完整的 React 应用程序中。</li>
<li>这导致更快的初始加载时间，因为HTML已经存在于页面上，并且可以被搜索引擎索引。</li>
<li>在 CSR 中，初始 HTML 是一个最小的空文档，React 应用程序完全在客户端上构建和呈现。客户端进行 API 调用以获取呈现 UI 所需的数据。</li>
<li>这会导致初始加载时间变慢，但响应速度更快、更动态的体验，因为所有呈现都是在客户端上完成的。</li>
</ul>
<h3 id="什么是-React-Hooks，它们是如何工作的？"><a href="#什么是-React-Hooks，它们是如何工作的？" class="headerlink" title="什么是 React Hooks，它们是如何工作的？"></a>什么是 React Hooks，它们是如何工作的？</h3><ul>
<li>React Hooks 是 React 中的一个功能，它允许功能组件在不使用类组件的情况下具有状态和其他生命周期方法。</li>
<li>它们使跨多个组件重用状态和逻辑变得更加容易，使代码更简洁、更易于阅读。</li>
<li>钩子包括用于添加状态的 useState 和用于执行副作用以响应状态或 props 变化的 useEffect。它们使编写可重用、可维护的代码变得更加容易。</li>
</ul>
<h3 id="React-如何处理状态管理？"><a href="#React-如何处理状态管理？" class="headerlink" title="React 如何处理状态管理？"></a>React 如何处理状态管理？</h3><ul>
<li>React 通过其状态对象和 setState() 方法处理状态管理。</li>
<li>state 对象是一种数据结构，用于存储组件内更改的值，可以使用 setState() 方法进行更新。</li>
<li>状态更新会触发组件的重新呈现，使其能够动态显示更新的值。</li>
<li>React 以<span class="key_words">『异步和批处理』</span>的方式更新状态，确保将多个 setState() 调用合并到单个更新中以获得更好的性能。</li>
</ul>
<h3 id="如何在-React-中使用useEffect钩子？"><a href="#如何在-React-中使用useEffect钩子？" class="headerlink" title="如何在 React 中使用useEffect钩子？"></a>如何在 React 中使用useEffect钩子？</h3><ul>
<li>React 中的 useEffect 钩子允许开发人员在功能组件中执行副作用，例如数据获取、订阅和设置&#x2F;清理计时器。</li>
<li>它在每次渲染（包括第一次渲染）之后以及渲染提交到屏幕后运行。</li>
<li>useEffect 挂钩有两个参数 - 一个在每次渲染后运行的函数和一个确定何时运行效果的依赖项数组。如果依赖项数组为空或不存在，则效果将在每次渲染后运行。</li>
</ul>
<h3 id="你能解释一下-React-中服务器端渲染的概念吗？"><a href="#你能解释一下-React-中服务器端渲染的概念吗？" class="headerlink" title="你能解释一下 React 中服务器端渲染的概念吗？"></a>你能解释一下 React 中服务器端渲染的概念吗？</h3><ul>
<li>React 中的服务器端渲染 （SSR） 是在服务器上渲染组件并将完全渲染的 HTML 发送到浏览器的过程。</li>
<li>SSR 通过向浏览器提供完全渲染的 HTML、减少需要在客户端上解析和执行的 JavaScript 数量以及改进搜索引擎对网页的索引来提高 React 应用程序的初始加载性能和 SEO。</li>
<li>在 SSR 中，React 组件呈现在服务器上，并作为完全格式的 HTML 字符串发送到客户端，从而缩短了初始加载时间并提供对 SEO 更友好的网页。</li>
</ul>
<h3 id="React-如何处理事件，有哪些常见的事件处理程序？"><a href="#React-如何处理事件，有哪些常见的事件处理程序？" class="headerlink" title="React 如何处理事件，有哪些常见的事件处理程序？"></a>React 如何处理事件，有哪些常见的事件处理程序？</h3><ul>
<li>React 通过其事件处理系统处理事件，其中事件处理程序作为 props 传递给组件。</li>
<li>React 中常见的事件处理程序包括 onClick、onChange、onSubmit 等。</li>
<li>事件处理程序接收一个事件对象，该对象包含有关事件的信息，例如目标元素、事件类型以及与事件关联的任何数据。</li>
<li>React 事件处理程序应作为 props 传递给组件，并且事件处理程序应在组件中或单独的帮助程序函数中定义。</li>
</ul>
<h3 id="你能解释一下-React-上下文的概念吗？"><a href="#你能解释一下-React-上下文的概念吗？" class="headerlink" title="你能解释一下 React 上下文的概念吗？"></a>你能解释一下 React 上下文的概念吗？</h3><ul>
<li>React 上下文是一种在组件之间<code>共享数据</code>的方法，而无需手动通过组件树的每个级别传递 props。上下文是使用提供程序创建的，并由多个组件使用 useContext 挂钩使用。</li>
</ul>
<h3 id="React-如何处理路由，React-有哪些流行的路由库？"><a href="#React-如何处理路由，React-有哪些流行的路由库？" class="headerlink" title="React 如何处理路由，React 有哪些流行的路由库？"></a>React 如何处理路由，React 有哪些流行的路由库？</h3><ul>
<li>React 通过使用 React 路由器库来处理路由，该库为 React 应用程序提供路由功能。一些流行的 React 路由库包括 React Router 和 Next.js。</li>
</ul>
<h3 id="在-React-中优化性能的最佳实践有哪些？"><a href="#在-React-中优化性能的最佳实践有哪些？" class="headerlink" title="在 React 中优化性能的最佳实践有哪些？"></a>在 React 中优化性能的最佳实践有哪些？</h3><ul>
<li>在 React 中优化性能的最佳实践包括使用记忆、避免不必要的重新渲染、对组件和图像使用延迟加载以及使用正确的数据结构。</li>
</ul>
<h3 id="React-如何处理测试，有哪些流行的-React-测试框架？"><a href="#React-如何处理测试，有哪些流行的-React-测试框架？" class="headerlink" title="React 如何处理测试，有哪些流行的 React 测试框架？"></a>React 如何处理测试，有哪些流行的 React 测试框架？</h3><ul>
<li>React 使用 Jest、Mocha 和 Enzyme 等测试框架来处理测试。</li>
<li>Jest 是 React 应用程序的流行测试框架，而 Mocha 和 Enzyme 也被广泛使用。</li>
</ul>
<h3 id="如何在-React-中处理异步数据加载？"><a href="#如何在-React-中处理异步数据加载？" class="headerlink" title="如何在 React 中处理异步数据加载？"></a>如何在 React 中处理异步数据加载？</h3><ul>
<li>React 中的异步数据加载可以使用各种方法进行处理，例如 fetch API、Axios 或其他网络库。</li>
<li>还可以使用 useState 和 useEffect 挂钩来处理它，以便在从 API 调用返回数据时触发状态更新。</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>知识</tag>
        <tag>面试题</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-在项目中遇到的问题</title>
    <url>/2024/11/01/react/%E5%9C%A8react%E9%A1%B9%E7%9B%AE%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="问题：-React-is-not-defined"><a href="#问题：-React-is-not-defined" class="headerlink" title="问题： React is not defined"></a>问题： React is not defined</h2><ul>
<li>前提：是没有用到React但项目一定要引入，不引入就报错</li>
<li>解决方法： 以下四种方法<ul>
<li>1.在项目顶部导入<code>import React from &quot;react&quot;</code>   &#x3D;&#x3D;&#x3D;&gt; 多余</li>
<li>2.在React 17 版本中可以在<code>.babelrc</code>中添加      &#x3D;&#x3D;&#x3D;&gt; 亲测有效，但需要重新构建几次<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;@babel/preset-react&quot;</span>, &#123;<span class="string">&quot;runtime&quot;</span>: <span class="string">&quot;automatic&quot;</span>&#125;] <span class="comment">// 关键</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">-- 第一遍构建后，无效，把webpack.<span class="property">config</span>.<span class="property">json</span>中也添加了类似代码，</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">test</span>: <span class="regexp">/\.(ts|tsx)$/</span>,</span><br><span class="line">	<span class="attr">use</span>: &#123;</span><br><span class="line">		<span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">		<span class="attr">options</span>: &#123;</span><br><span class="line">			<span class="attr">presets</span>: [</span><br><span class="line">				[<span class="string">&#x27;@babel/preset-react&#x27;</span>, &#123; <span class="attr">runtime</span>: <span class="string">&#x27;automatic&#x27;</span> &#125;],</span><br><span class="line">				<span class="string">&#x27;@babel/preset-typescript&#x27;</span>,</span><br><span class="line">			],</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line">-- 第二遍构建有效</span><br></pre></td></tr></table></figure></li>
<li>3.在package.json 中添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;babel&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">&quot;react-app&quot;</span>, <span class="comment">// 换成对应的插件</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;runtime&quot;</span>: <span class="string">&quot;automatic&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>4.在webpack.config.json中添加 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;babel-loader&#x27;</span>),</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">customize</span>: <span class="built_in">require</span>.<span class="title function_">resolve</span>(</span><br><span class="line">      <span class="string">&#x27;babel-preset-react-app/webpack-overrides&#x27;</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">// Add this back</span></span><br><span class="line">    <span class="attr">presets</span>: [</span><br><span class="line">      [</span><br><span class="line">        <span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;babel-preset-react-app&#x27;</span>),</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">runtime</span>: hasJsxRuntime ? <span class="string">&#x27;automatic&#x27;</span> : <span class="string">&#x27;classic&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>问题与方案</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-组件通信方式</title>
    <url>/2025/06/24/react/React-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="父组件向子组件-通过props传递"><a href="#父组件向子组件-通过props传递" class="headerlink" title="父组件向子组件(通过props传递)"></a>父组件向子组件(通过props传递)</h2><ul>
<li>父组件在子组件标签上通过子组件定义的事件或属性进行传递，子组件使用解构从props对象中拿到对应变量</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">const</span> parent = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">Child</span> <span class="attr">title</span>=<span class="string">&quot;我是父组件传递给子组件的变量&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">interface <span class="title class_">IChildProps</span> &#123;</span><br><span class="line">	<span class="attr">title</span>: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = memo&lt;<span class="title class_">IChildProps</span>&gt;(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; title &#125; = props</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Child</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="子组件向父组件通信"><a href="#子组件向父组件通信" class="headerlink" title="子组件向父组件通信"></a>子组件向父组件通信</h2><ul>
<li>子组件定义事件，在事件中传递信息，父组件在子组件标签中通过箭头函数拿到参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">const</span> parent = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">receiveMessage</span> = (<span class="params">value: string</span>) =&gt; &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">sendMessage</span>=<span class="string">&#123;(value:string)</span> =&gt;</span> receiveMessage(value)&#125; /&gt;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">interface <span class="title class_">IChildProps</span> &#123;</span><br><span class="line">	<span class="attr">sendMessage</span>: <span class="function">(<span class="params">value: string</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = memo&lt;<span class="title class_">IChildProps</span>&gt;(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; sendMessage &#125; = props</span><br><span class="line">	<span class="keyword">const</span> [title, setTitle] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; <span class="title function_">sendMessage</span>(title)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> handleClick()&#125;&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Child</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="跨级组件通信-useContext"><a href="#跨级组件通信-useContext" class="headerlink" title="跨级组件通信 useContext"></a>跨级组件通信 useContext</h2><ul>
<li>作用：全局传递数据，读取和订阅组件中的 context</li>
<li>参考：<a href="https://zh-hans.react.dev/reference/react/useContext">想了解useContext更多内容，点击查看</a></li>
<li>用法：</li>
</ul>
<ol>
<li><p>创建一个单独的文件来管理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/context.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title function_">createContext</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在顶级组件中使用Context.Provider来进行包裹，值通过value&#x3D;{}传递，包裹的内部组件都可以使用</p>
</li>
</ol>
<ul>
<li>示例：<ul>
<li>需求：这个ThemeContext会随着点击事件而改变，并且应用于全局</li>
<li>可以在App.tsx文件中使用，也可以在全局的布局组件中使用，这里在全局的布局组件中使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; memo, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ThemeContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@store/context&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Layout</span> = <span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> [theme, setTheme] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">const</span> &#123; children &#125; = props</span><br><span class="line">	<span class="keyword">const</span> sunMoon = <span class="title function_">classNames</span>(<span class="string">`<span class="subst">$&#123;theme</span></span></span><br><span class="line"><span class="subst"><span class="string">	? <span class="string">&#x27;bg-primary text-black transition-all&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">	: <span class="string">&#x27;bg-black text-primary transition-all&#x27;</span>&#125;</span>`</span>)</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;theme&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">div</span>  <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">imgBg</span> $&#123;<span class="attr">sunMoon</span>&#125;`&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">				<span class="tag">&lt;<span class="name">SideColumn</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">					<span class="attr">changeWAB</span>=<span class="string">&#123;()</span>=&gt;</span> setTheme(!theme)&#125;</span></span><br><span class="line"><span class="language-xml">				/&gt;</span></span><br><span class="line"><span class="language-xml">				<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;)</span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Layout</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol start="3">
<li>子组件通过useContext()来拿到传递过来值，直接使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; memo, useState, useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ThemeContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@store/context&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SideColumn</span> = memo&lt;sideColumnProps&gt;(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> theme = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="非嵌套关系的组件通信"><a href="#非嵌套关系的组件通信" class="headerlink" title="非嵌套关系的组件通信"></a>非嵌套关系的组件通信</h2><ul>
<li>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。</li>
<li>可以使用自定义事件通信（发布订阅模式），使用pubsub-js</li>
<li>可以通过redux等进行全局状态管理</li>
<li>如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li>
<li>可以new一个 Vue 的 EventBus,进行事件监听，一边执行监听，一边执行新增 VUE的eventBus 就是发布订阅模式，是可以在React中使用的;</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-协调算法|背后的核心算法React Fiber</title>
    <url>/2025/06/18/react/react-fiber/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>React 核心机制是跟踪组件的状态变化，并将更新的状态映射到新的界面，这个过程称为协调。</li>
<li>React Fiber 是React核心算法的一次重新实现</li>
</ul>
<h2 id="从问题来理解为什么react需要Fiber"><a href="#从问题来理解为什么react需要Fiber" class="headerlink" title="从问题来理解为什么react需要Fiber"></a>从问题来理解为什么react需要Fiber</h2><h3 id="Q1：React的设计理念是构建快速响应的大型Web应用程序。制约快速响应的因素？反映算法不足"><a href="#Q1：React的设计理念是构建快速响应的大型Web应用程序。制约快速响应的因素？反映算法不足" class="headerlink" title="Q1：React的设计理念是构建快速响应的大型Web应用程序。制约快速响应的因素？反映算法不足"></a>Q1：React的设计理念是构建快速响应的大型Web应用程序。制约快速响应的因素？<span class="desc">反映算法不足</span></h3><ul>
<li>CPU瓶颈：大量的同步计算任务阻塞了浏览器的UI渲染，造成页面卡顿。而 React 的 Reconcilation 是 CPU 密集型的操作，React 15使用的Virtual DOM协调算法<span class="desc">(因为它在内部使用堆栈也被称为堆栈协调器)</span>，共享一个协调器,可能会导致混淆。</li>
<li>IO的瓶颈：网络请求响应不及时，造成白屏</li>
</ul>
<h3 id="Q2：Vue3-动静结合的DOM-Diff-与-React的对比？反映编译时优化不足"><a href="#Q2：Vue3-动静结合的DOM-Diff-与-React的对比？反映编译时优化不足" class="headerlink" title="Q2：Vue3 动静结合的DOM Diff 与 React的对比？反映编译时优化不足"></a>Q2：Vue3 动静结合的DOM Diff 与 React的对比？<span class="desc">反映编译时优化不足</span></h3><ul>
<li>Vue3的DOM Diff在预编译进行优化，在预编译阶段静态分析模版，分析出视图依赖了哪些数据，进行响应式处理。Template 模板是一种非常有约束的语言，你只能以某种方式去编写模板。</li>
<li>而React 是局部渲染，无法从模板层面进行静态分析。JSX 具有 JavaScript 的完整表现力，可以构建非常复杂的组件。但是灵活的语法，也意味着引擎难以理解，无法预判开发者的用户意图，从而难以优化性能。</li>
</ul>
<h2 id="React-架构"><a href="#React-架构" class="headerlink" title="React 架构"></a>React 架构</h2><ul>
<li>调度器(Scheduler)：调度任务优先级，高级任务优先进入协调器，不使用requestIdleCallback(兼容性不好)。</li>
<li>协调器(Reconciler)：负责找出更改的组件，更新工作从递归变成可以中断的循环过程。内部采用Fiber架构</li>
<li>渲染器(Renderer)：将变化的组件渲染到页面上</li>
</ul>
<p><a href="https://github.com/facebook/react/blob/v19.1.0/packages/scheduler/src/forks/Scheduler.js">源码地址</a></p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><ul>
<li>以浏览器是否有剩余时间作为任务中断的标准，当浏览器有剩余时间时通知我们。</li>
</ul>
<h3 id="协调器"><a href="#协调器" class="headerlink" title="协调器"></a>协调器</h3><ul>
<li>更新工作从15递归变成了16+可以中断的循环过程。每次循环都会调用shouldYield判断当前是否有剩余时间。</li>
<li>当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟 DOM 打上代表增&#x2F;删&#x2F;更新的标记</li>
<li>整个Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。</li>
</ul>
<h3 id="渲染器"><a href="#渲染器" class="headerlink" title="渲染器"></a>渲染器</h3><ul>
<li>根据Reconciler为虚拟 DOM 打的标记，同步执行对应的 DOM 操作</li>
</ul>
<h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><ul>
<li>本质是『虚拟DOM』。Fiber节点可以保存对应的DOM节点，Fiber节点构成的Fiber树就对应DOM树</li>
<li>从数据结构看，每个Fiber节点对应一个React Element，保存了该组件的类型(函数组件、类组件、原生组件)、对应的DOM节点等信息</li>
<li>从工作单元看，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（删除、插入、更新）</li>
</ul>
<h3 id="Fiber-树"><a href="#Fiber-树" class="headerlink" title="Fiber 树"></a>Fiber 树</h3><ul>
<li>特点：链表结构，将协调的『递归遍历』改为『循环遍历』</li>
<li>React 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。</li>
<li>多个节点如何连接成树？<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>  <span class="comment">// 指向父Fiber节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>   <span class="comment">// 指向子Fiber节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span> <span class="comment">// 指向右边第一个兄弟Fiber节点</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Fiber-架构的工作原理"><a href="#Fiber-架构的工作原理" class="headerlink" title="Fiber 架构的工作原理"></a>Fiber 架构的工作原理</h2><ul>
<li>双缓存：在内存中构建并直接替换</li>
<li>双缓存树：在React中最多会同时存在两棵Fiber树。<ul>
<li>当前屏幕显示内容对应的Fiber树称为current Fiber树（即上次渲染构建的Fiber树）。</li>
<li>正在内存中构建的Fiber树称为workInProgress Fiber树。（<span class="en">无论是创建还是更新、挂起、恢复、终止操作都是发生在W树创建过程中。W树构建过程其实就是循环的执行任务和创建下一个任务。</span>）</li>
</ul>
</li>
</ul>
<h3 id="初次渲染的构建流程"><a href="#初次渲染的构建流程" class="headerlink" title="初次渲染的构建流程"></a>初次渲染的构建流程</h3><ol>
<li>创建阶段：首次执行ReactDOM.render 会创建 fiberRootNode（整个应用的根节点）和 rootFiber（<code>&lt;App /&gt;</code>所在组件树的根节点）。由于首屏渲染，页面没有挂载任何DOM，所以fiberRootNode.current指向的rootFiber没有任何子Fiber节点（即current Fiber树为空）。</li>
<li>render阶段：进入render阶段，根据组件返回的JSX载内存中一次创建Fiber节点并连接在一起构建Fiber树，被称为『workInProgress Fiber树』。在构建W树时会尝试复用C树中已有的Fiber节点内的属性。在首屏渲染时，只有rootFiber存在对应的current Fiber(即rootFiber.alternate)</li>
<li>commit阶段：进入commit阶段，已构建完的workInProgress Fiber树渲染到页面上</li>
</ol>
<h3 id="更新阶段的构建流程"><a href="#更新阶段的构建流程" class="headerlink" title="更新阶段的构建流程"></a>更新阶段的构建流程</h3><ol>
<li>开启新一轮的render阶段并构建新一颗W树。创建时复用C树的对应节点数据</li>
<li>已构建完的W树渲染到页面上。渲染完成W树变成C树。</li>
</ol>
<h3 id="JSX-Fiber节点"><a href="#JSX-Fiber节点" class="headerlink" title="JSX &amp; Fiber节点"></a>JSX &amp; Fiber节点</h3><ul>
<li>在组件mount时，Reconciler『根据JSX描述』的组件内容生成组件对应的『Fiber节点』。</li>
<li>在update时，Reconciler将JSX与Fiber节点保存的『数据对比』，生成组件对应的Fiber节点，并根据对比结果为Fiber节点打上标记。</li>
</ul>
<h2 id="React-Fiber-执行过程"><a href="#React-Fiber-执行过程" class="headerlink" title="React Fiber 执行过程"></a>React Fiber 执行过程</h2><h3 id="任务拆分"><a href="#任务拆分" class="headerlink" title="任务拆分"></a>任务拆分</h3><ul>
<li>在调和阶段递归遍历 VDOM 这个大任务分成若干小任务，每个任务只负责一个节点的处理。</li>
</ul>
<h3 id="任务挂起、恢复、终止"><a href="#任务挂起、恢复、终止" class="headerlink" title="任务挂起、恢复、终止"></a>任务挂起、恢复、终止</h3><ul>
<li>当当前分配的任务完成后，先判断这一帧是否还有空闲时间，没有就挂起下一个任务的执行，记住当前挂起的节点，让出控制权给浏览器执行更高优先级任务</li>
</ul>
<h3 id="任务恢复"><a href="#任务恢复" class="headerlink" title="任务恢复"></a>任务恢复</h3><ul>
<li>在浏览器渲染完一帧后，判断当前帧是否有剩余时间，如果有就恢复执行之前挂起的任务。如果没有任务需要处理，代表调和阶段完成，可以开始进入渲染阶段。</li>
<li>判断一帧是否用空闲时间，使用 RequestIdleCallback</li>
<li>恢复执行时通过链表获取下一个任务</li>
</ul>
<h3 id="任务终止"><a href="#任务终止" class="headerlink" title="任务终止"></a>任务终止</h3><ul>
<li>不是每次更新都会走到提交阶段。当在调和过程中触发了新的更新，在执行下一个任务的时候，判断是否有优先级更高的执行任务，如果有就终止原来将要执行的任务，开始新的 workInProgressFiber 树构建过程，开始新的更新流程。这样可以避免重复更新操作。这也是在 React 16 以后生命周期函数 componentWillMount 有可能会执行多次的原因。</li>
</ul>
<h3 id="任务具备优先级"><a href="#任务具备优先级" class="headerlink" title="任务具备优先级"></a>任务具备优先级</h3><ul>
<li>在任务执行过程中收集到的每个FiberNode的副作用，形成的副作用链表。到commit阶段时，直接遍历副作用链完成DOM更新。更新DOM的过程不可中断。</li>
<li>任务优先级有六种<ul>
<li>synchronous：与之前的堆栈协调器操作一样，同步执行</li>
<li>task：在next tick之前执行</li>
<li>animation：下一帧之前执行</li>
<li>high：在不久的将来立即执行</li>
<li>low：稍微延迟执行也没关系</li>
<li>offscreen：下一次render 或scroll 时执行</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>React</tag>
        <tag>React Fiber</tag>
      </tags>
  </entry>
  <entry>
    <title>React-状态管理useState 与 reducer</title>
    <url>/2024/11/01/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86useState%E4%B8%8Ereducer/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>useState分散逻辑 vs reducer 聚合逻辑</p>
</blockquote>
<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><ul>
<li>React 的一个Hook，在函数组件中管理组件的状态，并在状态更新时，重新渲染组件</li>
<li>缺点： 当有多个状态时，需要写多个，维护困难</li>
</ul>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><ul>
<li>先定义好reducer，就是把要操作的行为定义好，之后使用useReducer</li>
<li>示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state,action</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">switch</span>(state, type) &#123; <span class="comment">// 这里拿到state</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;Add&#x27;</span>: <span class="comment">// 对state进行添加操作</span></span><br><span class="line">			<span class="keyword">const</span> id = state.<span class="property">length</span> +<span class="number">1</span></span><br><span class="line">			<span class="keyword">return</span> [...state, &#123;<span class="attr">id</span>:id, <span class="attr">title</span>: action.<span class="property">payload</span>, <span class="attr">show</span>: <span class="literal">false</span>&#125;]</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;Delete&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> state.<span class="title function_">filter</span>(<span class="function"><span class="params">task</span> =&gt;</span> task.<span class="property">id</span> !== action.<span class="property">payload</span>)</span><br><span class="line">		<span class="attr">default</span>: </span><br><span class="line">			<span class="keyword">return</span> state</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用useReducer来调用reducer的操作和初始化state</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, [</span><br><span class="line">	&#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">title</span>:<span class="string">&quot;第一条&quot;</span>,<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">title</span>:<span class="string">&quot;第二条&quot;</span>,<span class="attr">show</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li>
<li>使用和调取方法<ul>
<li>state 就是数据，也是usestate里的值，dispatch就相当于setState</li>
<li>调用方法：dispatch({type:’Delete’, payload: id}) &#x2F;&#x2F; type传要执行的操作，payload传在该事件中要改变什么，在reducer中要定义</li>
</ul>
</li>
<li>如果有生成初始值的函数，为避免性能浪费，可以把函数也一起传进useReducer<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果createState不能计算除初始值，需要定义一个默认，如果可以直接传null</span></span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, <span class="literal">null</span> ,createInitState)  </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>状态管理库</tag>
      </tags>
  </entry>
  <entry>
    <title>uniCloud</title>
    <url>/2024/10/31/uniApp/uniCloud/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="uniCloud优势："><a href="#uniCloud优势：" class="headerlink" title="uniCloud优势："></a>uniCloud优势：</h3><ul>
<li><p>会js即可</p>
</li>
<li><p>有openDB</p>
</li>
<li><p>有jql</p>
</li>
<li><p>有uniclound</p>
</li>
<li><p>有插件市场</p>
</li>
<li><p>作用：前端 –&gt; 全栈</p>
</li>
</ul>
<h3 id="云函数-就是nodejs代码"><a href="#云函数-就是nodejs代码" class="headerlink" title="云函数 就是nodejs代码"></a>云函数 就是nodejs代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">main</span> = <span class="title function_">async</span> (event, context) =&gt; &#123;</span><br><span class="line">	<span class="comment">// event为客户端上传的参数</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;event:&#x27;</span>,event)</span><br><span class="line">	<span class="comment">// 返回数据给客户端</span></span><br><span class="line">	<span class="keyword">return</span> event</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="云数据库-就是json数据"><a href="#云数据库-就是json数据" class="headerlink" title="云数据库 就是json数据"></a>云数据库 就是json数据</h3><ul>
<li>uniCloud云数据库与mysql和MongoDB的区别<ul>
<li>是基于MongoDB改进了易用性的强化版本，比mysql功能更丰富</li>
</ul>
</li>
<li>发行 –&gt; 上传到网站服务器，选择对应的服务空间</li>
<li>所有uniCloud的代码都在uniCloud的文件夹下</li>
</ul>
<ol>
<li>关联服务器</li>
<li>cloudfunctions目录右键选择新建云函数或云对象<ul>
<li>创建一个云对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 云对象名co1</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">	<span class="title function_">say</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">errCode</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">data</span>: <span class="string">&#x27;hello, I am uniCloud&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>到页面触发云对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;callco&quot;</span>&gt;test&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>云对象模式下不再用ajax请求json云端的代码对象化，可以直接在前端导入这个云对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">callco</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> co1 = uniCloud.<span class="title function_">importObject</span>(<span class="string">&#x27;/*按Tab可以看见云对象列表，直观*/co1&#x27;</span>)</span><br><span class="line">	<span class="comment">// 云对象的方法是异步的</span></span><br><span class="line">	<span class="keyword">let</span> res = <span class="keyword">await</span> co1.<span class="title function_">say</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>连接本地云函数：本地工程目录下的云函数</li>
<li>连接云端云函数：本地的云函数&#x2F;云对象右键上传部署 </li>
<li>权限问题，在database的contacts.schema.json中设置对应的权限为true</li>
<li>生成schema.json的配置，每次修改都要右键schema2code<ul>
<li>新建数据表 –&gt; OpenDB模板 –&gt; 表分类其它选择好后添加数据</li>
<li>数据少使用enum:[{},{},{}]</li>
<li>数据多使用表,field写怎么用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">enum</span>:&#123;<span class="string">&quot;collection&quot;</span>:<span class="string">&quot;另一个schema的表名&quot;</span>, <span class="string">&quot;field&quot;</span>: <span class="string">&quot;name as text, _id as value&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li>定义一下渲染这个表的组件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;componentForEdit&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;组件名&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>省市区那种表要添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;enumType&quot;</span>: <span class="string">&quot;tree&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>联表字段，”foreignKey”: “表名.field中录入的xxx as value 的xxx”<ul>
<li>页面要使用该表的字段，需要在页面的collection属性中多添加这个表，以逗号分隔 ，field中写上”显示的字段”</li>
</ul>
</li>
<li>uniStarter模板包含以下功能<ul>
<li>注册、登陆、用户资料、分享、路由、token等功能 </li>
<li>登陆方式：数组第0向为第一优先级，其它的要看有没有该设备和在什么环境展示</li>
</ul>
</li>
<li>引入自定义的json文件：<ul>
<li>在uni-comfirm-enter中配置json模块 –&gt; 更新uni-id-cf依赖 –&gt; 在index.js中引入模块，然后引入对应json的模块<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aConfig = <span class="title function_">uniConfigCent</span>(&#123;<span class="attr">pluginId</span>: <span class="string">&quot;模块名&quot;</span>&#125;) .<span class="title function_">config</span>()</span><br><span class="line"><span class="keyword">return</span> aConfig</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>验证码：<ul>
<li>在uni-comfirm-enter中配置uni-id模块，能直接使用uni-id的相关模块，测试的话去uni-id-cf模块的index.js中的251行到255取消注释</li>
</ul>
</li>
<li>链接：<ul>
<li>存为.md格式，右键一键分享，安装好后，点击HBuilderX –&gt; 偏好设置 –&gt; 插件配置，配置好后再次右键一键分享，控制台得到链接，复制链接，回到配置协议的地方赋值给url即可，pc端有二维码，手机没有</li>
</ul>
</li>
<li>uniCloud admin框架–后台管理页面<ul>
<li>只能初始化一次账号密码</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>uniApp + vue3组合式开发</title>
    <url>/2024/10/31/uniApp/vue3%E7%BB%84%E5%90%88%E5%BC%8F%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><ul>
<li>页面文件向导Vue单文件组件(SFC)规范</li>
<li>页面标签靠近小程序规范</li>
<li>API靠近微信小程序规范，但是wx需替换为uni</li>
<li>数据绑定及时间处理同Vue.js规范</li>
<li>为了兼容，建议使用flex布局</li>
</ul>
<h2 id="uniApp-在VScode中开发（因为uniapp的ts校验差）"><a href="#uniApp-在VScode中开发（因为uniapp的ts校验差）" class="headerlink" title="uniApp 在VScode中开发（因为uniapp的ts校验差）"></a>uniApp 在VScode中开发（因为uniapp的ts校验差）</h2><ul>
<li>安装ts类型校验<ul>
<li>安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D @types/wechat-miniprogram @uni-helper/uni-app-types</span><br></pre></td></tr></table></figure></li>
<li>配置tsconfig.json<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">	<span class="string">&quot;types&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;@dcloudio/types&quot;</span>,</span><br><span class="line">		<span class="string">&quot;@types/wechat-miniprogram&quot;</span>,</span><br><span class="line">		<span class="string">&quot;@uni-helper/uni-app-types&quot;</span></span><br><span class="line">	]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;vueCompilerOptions&quot;</span>: &#123;</span><br><span class="line">	<span class="string">&quot;experimentalRuntimeMode&quot;</span>: <span class="string">&quot;runtime-uni-app&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>json文件问题<ul>
<li>在项目中看是否有manifest.json,没有就创建然后在设置中搜文件关联或者Association</li>
<li>然后设置 项为manifest.json 值为jsonc，</li>
<li>项为pages.json 值为jsonc</li>
</ul>
</li>
</ul>
<h2 id="uniApp生命周期"><a href="#uniApp生命周期" class="headerlink" title="uniApp生命周期"></a>uniApp生命周期</h2><ul>
<li>onLaunch:当uni-app初始化完成时触发(全局只触发一次)</li>
<li>onShow：当uni-app启动时，或从后台进入前台显示</li>
<li>onHide：当uni-app从前台进入后台</li>
<li>onError： 当uni-app报错时触发</li>
<li>onUniNViewMessage：当 nvue 页面发送数据进行监听，可参考 nvue 向 vue 通讯</li>
<li>onUnhandledRejection：对未处理的 Promise 拒绝事件监听函数</li>
<li>onPageNotFound：页面不存在监听函数</li>
<li>onThemeChange：监听系统主题变化</li>
</ul>
<h2 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h2><ul>
<li>onLoad：监听页面加载,其参数为上个页面传递的数据，参数类型为Object</li>
<li>onShow：监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</li>
<li>onReady：监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发</li>
<li>onHide：监听页面隐藏</li>
<li>onUnload： 监听页面卸载</li>
<li>onResize：监听窗口尺寸变化</li>
<li>onPullDownRefresh：监听用户下拉动作，一般用于下拉刷新</li>
<li>onREachBottom：页面滚动到底部的事件，常用于下拉下一页数据</li>
<li>onTabItemTap：点击tab时触发，参数为Object</li>
<li>onShareAppMessage：用户点击右上角分享</li>
<li>onPageScroll：监听页面滚动，参数为Object</li>
<li>onNavigationBarButtonTap：监听原生标题栏按钮点击事件，参数为Object</li>
<li>onBackPress：监听页面返回</li>
<li>onNavigationBarSearchInputChanged：监听原生标题栏搜索输入框输入内容变化事件</li>
<li>onNavigationBarSearchInputConfirmed：监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发</li>
<li>onNavigationBarSearchInputClicked：监听原生标题栏搜索输入框点击事件</li>
<li>onShareTimeline：监听用户点击右上角转发到朋友圈</li>
<li>onAddToFavorites：监听用户点击右上角收藏</li>
</ul>
<h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><ul>
<li><p>方式一标签式导航：navigator 组件跳转</p>
<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;navigator url=<span class="string">&quot;/pages/404/404&quot;</span>&gt;<span class="number">404</span>页面&lt;/navigator&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方式二编程式导航：调用API跳转</p>
<table>
<thead>
<tr>
<th>路由方式</th>
<th>页面栈表现</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>新页面入栈</td>
<td>uni-app打开的第一个页面</td>
</tr>
<tr>
<td>打开新页面</td>
<td>新页面入栈</td>
<td>调用API uni.navigateTo、<br /> 使用组件<navigator open-type="navigate" /></td>
</tr>
<tr>
<td>页面重定向</td>
<td>当前页面出栈，新页面入栈</td>
<td>调用API uni.redirectTo、<br /> 使用组件</td>
</tr>
<tr>
<td>页面返回</td>
<td>页面不断出栈，直到目标返回页</td>
<td>调用API uni.navigateBack、<br /> 使用组件、<br /> 用户按左上角返回按钮、安卓用户点击物理back按键</td>
</tr>
<tr>
<td>Tab切换</td>
<td>页面全部出栈，只留下新的Tab页面</td>
<td>调用API uni.switchTab、<br /> 使用组件、 <br /> 用户切换Tab</td>
</tr>
<tr>
<td>重加载</td>
<td>页面全部出栈，只留下新的页面</td>
<td>调用API uni.reLaunch、<br /> 使用组件</td>
</tr>
</tbody></table>
</li>
<li><p>注意：<span class="desc">没有配置tabbar(就是类似于微信下面的那个图标状态栏点击可切换的)时，可以使用navigator来跳转任意页面，但是配置tabbar后，只能使用switchTab来跳转到tabbar配置的页面</span></p>
</li>
</ul>
<h2 id="获取当前页面栈"><a href="#获取当前页面栈" class="headerlink" title="获取当前页面栈"></a>获取当前页面栈</h2><ul>
<li>getCurrentPages()函数，以数组形式按照栈的顺序。第一个元素为首页，最后一个元素为当前页面</li>
</ul>
<h2 id="路由传参与接收"><a href="#路由传参与接收" class="headerlink" title="路由传参与接收"></a>路由传参与接收</h2><ul>
<li>页面生命周期的onLoad()监听页面加载，其参数为上个页面传递的数据</li>
<li>如在上个页面通过url在路径中携带参数,?后为所携带参数，用&amp;连接多个参数，以键&#x3D;值的形式传递，pagePath为所要跳转的页面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">uni.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">	<span class="attr">url</span>:<span class="string">&quot;pagePath?name=lily&amp;age=18&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>可以在pagePath页面中使用onLoad获取参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onLoad：<span class="keyword">function</span>(<span class="params">option</span>) &#123;</span><br><span class="line">	conosle.<span class="title function_">log</span>(option.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意：<span class="desc">url有长度限制，所以对于复杂的参数建议使用encodeURI、decodeURI进行处理后传递</span></li>
</ul>
<h2 id="小程序路由分包配置"><a href="#小程序路由分包配置" class="headerlink" title="小程序路由分包配置"></a>小程序路由分包配置</h2><ul>
<li>在pages.json中在subPackges中配置分包的路径和分包下的页面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;subPackages&quot;</span>: [&#123;</span><br><span class="line">	<span class="string">&quot;root&quot;</span>: <span class="string">&quot;subpages&quot;</span>, <span class="comment">// 配置分包名</span></span><br><span class="line">	<span class="string">&quot;pages&quot;</span>: [&#123;</span><br><span class="line">		<span class="string">&quot;path&quot;</span>: <span class="string">&quot;news/news&quot;</span>, <span class="comment">// 分包中的页面路径</span></span><br><span class="line">		<span class="string">&quot;style&quot;</span>: </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;navigationBarTitleText&quot;</span>: <span class="string">&quot;新闻中心&quot;</span>,</span><br><span class="line">			<span class="string">&quot;enablePullDownRefresh&quot;</span>: <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;],</span><br><span class="line">&#125;],</span><br><span class="line"><span class="comment">// 预下载分包设置</span></span><br><span class="line"><span class="string">&quot;preloadRule&quot;</span>: &#123;</span><br><span class="line">	<span class="string">&quot;pages/index&quot;</span>: &#123; <span class="comment">// 进入那个页面才会预下载</span></span><br><span class="line">		<span class="string">&quot;network&quot;</span>: <span class="string">&quot;all&quot;</span>, <span class="comment">// all | wifi 在上面环境下下载</span></span><br><span class="line">		<span class="string">&quot;packages&quot;</span>: [<span class="string">&quot;subpages&quot;</span>]  <span class="comment">// 进入该页面后预下载的分包的root或name，以字符串数组的方式传递。__APP__ 表示主包。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><ul>
<li>使用的两种方式：全局注册 和 页面引入</li>
<li>使用步骤：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 </span></span><br><span class="line"><span class="keyword">import</span> xxx <span class="keyword">from</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 </span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="string">&#x27;xx&#x27;</span>,xx) 或者在script中添加 <span class="attr">components</span>:&#123;xxx&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 </span></span><br><span class="line">&lt;xx /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="全局事件定义与通信"><a href="#全局事件定义与通信" class="headerlink" title="全局事件定义与通信"></a>全局事件定义与通信</h3><ul>
<li>1.在整个应用的任何地方均可以使用uni.$on创建一个全局事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">在任意页面使用</span><br><span class="line">uni.$on(<span class="string">&#x27;getInfo&#x27;</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">anyvar</span> = value <span class="comment">// 可以定义一个变量然后改变时可以看见效果</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我的全局事件被触发了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>要先点击我的页面然后在回去按按钮就会有效果，因为放在onLoad事件中要先加载这个页面</li>
</ul>
</li>
<li>2.在整个应用的任何地方也均可以使用uni.$emit来触发全局事件，实现多组件间的数据通信<ul>
<li>在任意要触发的地方使用uni.$emit(‘getInfo’,’全局事件的传参’)</li>
<li>这个getInfo为全局事件</li>
</ul>
</li>
</ul>
<h2 id="Pinia-状态管理（官方推荐使用，钩子与vuex三件套一样-不需要mutation）"><a href="#Pinia-状态管理（官方推荐使用，钩子与vuex三件套一样-不需要mutation）" class="headerlink" title="Pinia 状态管理（官方推荐使用，钩子与vuex三件套一样,不需要mutation）"></a>Pinia 状态管理（官方推荐使用，钩子与vuex三件套一样,不需要mutation）</h2><ul>
<li>多个组件间共享数据或状态</li>
<li>State：存储状态数据</li>
<li>Getter：从状态数据派生数据，相当于State的计算属性</li>
<li>Mutation：存储用于同步更改状态数据的方法，默认传入的参数为State</li>
<li>Action：存储用于异步更改状态数据，但不是直接更改，而是通过触发Mutation方法实现，默认参数为context</li>
<li>Module：Vuex模块化</li>
</ul>
<h3 id="在项目中使用Pinia"><a href="#在项目中使用Pinia" class="headerlink" title="在项目中使用Pinia"></a>在项目中使用Pinia</h3><ul>
<li><p>首先在main.js文件中引入store文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSSRApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Pinia</span> <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="title function_">createSSRApp</span>(<span class="title class_">App</span>)</span><br><span class="line">	app.<span class="title function_">use</span>(<span class="title class_">Pinia</span>.<span class="title function_">createPinia</span>())</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    app,</span><br><span class="line">		<span class="title class_">Pinia</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建一个store的目录并且在该目录下新建一个js文件，形式大概按照一下形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUserStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;userStore&#x27;</span>,&#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">	<span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">userName</span>: <span class="string">&#x27;未登录用户&#x27;</span> &#125;),</span><br><span class="line">	<span class="attr">actions</span>: &#123;</span><br><span class="line">		<span class="title function_">login</span>(<span class="params">userName</span>) &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">userName</span> = userName</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="title function_">logout</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">userName</span> = <span class="string">&quot;退出登录&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在文件中调用全局事件"><a href="#在文件中调用全局事件" class="headerlink" title="在文件中调用全局事件"></a>在文件中调用全局事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">text</span>&gt;</span>通讯录<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;userStore.userName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;userStore.login(&#x27;lemon&#x27;)&quot;</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;userStore.logout()&quot;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&lt;/view&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">import</span> &#123; useUserStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/index.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">const</span> userStore = <span class="title function_">useUserStore</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="运行环境判断与跨端兼容"><a href="#运行环境判断与跨端兼容" class="headerlink" title="运行环境判断与跨端兼容"></a>运行环境判断与跨端兼容</h2><h3 id="开发环境和生产环境"><a href="#开发环境和生产环境" class="headerlink" title="开发环境和生产环境"></a>开发环境和生产环境</h3><ul>
<li>测试时可以通过uniApp上方导航栏的发行来测试二者的效果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开发环境&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;生产环境&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="判断平台"><a href="#判断平台" class="headerlink" title="判断平台"></a>判断平台</h3><ul>
<li>存在两种场景，一种实在编译器判断，一种是运行期判断</li>
</ul>
<h4 id="编译器判断：即条件编译-不同平台在编译出包后已经是不同的代码"><a href="#编译器判断：即条件编译-不同平台在编译出包后已经是不同的代码" class="headerlink" title="编译器判断：即条件编译,不同平台在编译出包后已经是不同的代码"></a>编译器判断：即条件编译,不同平台在编译出包后已经是不同的代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #ifdef H5</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;只有在H平台上才会有这个方法&quot;</span>)</span><br><span class="line"><span class="comment">// #endif</span></span><br></pre></td></tr></table></figure>
<h4 id="运行期判断：是指代码已经打入包中，仍然需要在运行期判断平台"><a href="#运行期判断：是指代码已经打入包中，仍然需要在运行期判断平台" class="headerlink" title="运行期判断：是指代码已经打入包中，仍然需要在运行期判断平台"></a>运行期判断：是指代码已经打入包中，仍然需要在运行期判断平台</h4><ul>
<li>使用 uni.getSystemInfoSync().platform 判断客户端环境是Android、iOS还是小程序开发工具<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(uni.<span class="title function_">getSystemInfoSync</span>().<span class="property">platform</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;android&#x27;</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;iOS&#x27;</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="attr">default</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="跨端兼容"><a href="#跨端兼容" class="headerlink" title="跨端兼容"></a>跨端兼容</h4><ul>
<li>条件编译写法： 以#ifdef 或 #ifndef 加 %PLATFORM% 开头，以 #endif 结尾</li>
<li>#ifdef: if defined 仅在某平台存在</li>
<li>#ifndef：if not defined 除了某平台均存在</li>
<li>%PLATFORM%：平台名称</li>
</ul>
<table>
<thead>
<tr>
<th>%PLATFORM%的值</th>
<th>平台</th>
</tr>
</thead>
<tbody><tr>
<td>APP-PLUS</td>
<td>App</td>
</tr>
<tr>
<td>APP-PLUS-NVUE</td>
<td>App nvue</td>
</tr>
<tr>
<td>H5</td>
<td>H5</td>
</tr>
<tr>
<td>MP-WEIXIN</td>
<td>微信小程序</td>
</tr>
<tr>
<td>MP-ALIPAY</td>
<td>支付宝小程序</td>
</tr>
<tr>
<td>MP-BAIDU</td>
<td>百度小程序</td>
</tr>
<tr>
<td>MP-TOUTIAO</td>
<td>字节跳动小程序</td>
</tr>
<tr>
<td>MP-QQ</td>
<td>QQ小程序</td>
</tr>
<tr>
<td>MP-360</td>
<td>360小程序</td>
</tr>
<tr>
<td>MP</td>
<td>含以上所有小程序</td>
</tr>
<tr>
<td>QUICKAPP-WEBVIEW-UNION</td>
<td>快应用联盟</td>
</tr>
<tr>
<td>QUICKAPP-WEBVIEW-HUAWEI</td>
<td>快应用华为</td>
</tr>
<tr>
<td>QUICKAPP-WEBVIEW</td>
<td>含以上所有快应用通用</td>
</tr>
</tbody></table>
<h2 id="vue3中的使用方式"><a href="#vue3中的使用方式" class="headerlink" title="vue3中的使用方式"></a>vue3中的使用方式</h2><h3 id="template部分"><a href="#template部分" class="headerlink" title="template部分"></a>template部分</h3><ul>
<li>循环：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-<span class="keyword">for</span>=<span class="string">&quot;(item,index) in list&quot;</span> :key=<span class="string">&quot;index&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>判断：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-<span class="keyword">if</span>=<span class="string">&quot;!item.isMe&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>事件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@click=<span class="string">&quot;sendMsg&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>组件上的属性需要动态的 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:src=<span class="string">&quot;item.img&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>插入页面的文本：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;item.<span class="property">content</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在-script-setup标签中"><a href="#在-script-setup标签中" class="headerlink" title="在 script setup标签中"></a>在 script setup标签中</h3><h4 id="生命周期按这种方式书写"><a href="#生命周期按这种方式书写" class="headerlink" title="生命周期按这种方式书写"></a>生命周期按这种方式书写</h4><ul>
<li>首先引入对应的生命周期：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onLoad &#125; <span class="keyword">from</span> <span class="string">&quot;@dcloudio/uni-app&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onLoad</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="定义一个变量和赋值："><a href="#定义一个变量和赋值：" class="headerlink" title="定义一个变量和赋值："></a>定义一个变量和赋值：</h4><ul>
<li>reactive一般使用场景是数组和对象，ref一般是基本数据类型</li>
<li>使用reactive响应的数据，最好是调用数据中的某一项，如果是添加push一整个数组使用ref比较好。不然不实时更新</li>
<li>定义ref 和使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">name.<span class="property">value</span> =<span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>定义reactive 和使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="title function_">reactive</span>([])</span><br><span class="line">list.<span class="title function_">push</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="定义一个方法："><a href="#定义一个方法：" class="headerlink" title="定义一个方法："></a>定义一个方法：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">clickfn</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="props："><a href="#props：" class="headerlink" title="props："></a>props：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineEmits,defineProps &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line">	<span class="attr">msg</span>: <span class="title class_">String</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="emit："><a href="#emit：" class="headerlink" title="emit："></a>emit：</h4><ul>
<li>将事件定义好<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&#x27;childEvent&#x27;</span>,<span class="string">&#x27;getInfo&#x27;</span>])		</span><br></pre></td></tr></table></figure></li>
<li>调用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">emits</span>(<span class="string">&#x27;childEvent&#x27;</span>,<span class="string">&#x27;传递的参数&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="全局emit"><a href="#全局emit" class="headerlink" title="全局emit"></a>全局emit</h4><ul>
<li>将事件定义好<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&#x27;childEvent&#x27;</span>,<span class="string">&#x27;getInfo&#x27;</span>])	</span><br></pre></td></tr></table></figure></li>
<li>使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">uni.$emit(<span class="string">&#x27;getInfo&#x27;</span>,<span class="string">&#x27;全局事件的传参&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>调用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">uni.$on(<span class="string">&#x27;getInfo&#x27;</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;	name.<span class="property">value</span> = value &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="实时滚动到页面底部"><a href="#实时滚动到页面底部" class="headerlink" title="实时滚动到页面底部"></a>实时滚动到页面底部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	uni.<span class="title function_">pageScrollTo</span>(&#123;</span><br><span class="line">		<span class="attr">scrollTop</span>: <span class="number">999999</span>,</span><br><span class="line">		<span class="attr">duration</span>:<span class="number">0</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="设置登录缓存后，退出清除缓存"><a href="#设置登录缓存后，退出清除缓存" class="headerlink" title="设置登录缓存后，退出清除缓存"></a>设置登录缓存后，退出清除缓存</h4><ul>
<li>使用uni.removeStorageSync(key),只清除这个key的缓存</li>
<li>使用uni.clearStorageSync()，清除本地缓存，全部清除</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>HBuilder X快捷键</title>
    <url>/2024/10/31/uniApp/%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="多光标"><a href="#多光标" class="headerlink" title="多光标"></a>多光标</h3><ul>
<li><em>ctrl + 鼠标左键</em>  <!-- 可增加一个光标 --></li>
<li><em>ctrl + 鼠标右键</em>  <!-- 可取消一个光标或选区 --></li>
<li><em>ctrl + e</em> <!-- 可选中相同的词做批处理 --></li>
<li><em>Ctrl+Shift+e</em> <!-- 可选中相同的词做批处理，并智能识别语法，剔除不相干的词 --></li>
</ul>
<h3 id="列选择"><a href="#列选择" class="headerlink" title="列选择"></a>列选择</h3><ul>
<li><em>alt+鼠标拖选</em></li>
<li>或者用_ctrl+alt+↑或↓_</li>
</ul>
<h3 id="转到定义"><a href="#转到定义" class="headerlink" title="转到定义"></a>转到定义</h3><ul>
<li><em>alt + d</em> </li>
<li><em>alt + 鼠标左键单击</em></li>
<li><em>ctrl + alt + 左键</em> <!-- 把定义处的代码打开在另一侧 --></li>
<li><em>alt+ left</em> 或工具栏上的&lt; <!-- 回到上一个光标位置 --></li>
<li>输入_0_跳转到_首行_、输入_$<em>跳转到_最后一行</em></li>
</ul>
<h3 id="文件、搜索"><a href="#文件、搜索" class="headerlink" title="文件、搜索"></a>文件、搜索</h3><ul>
<li><em>ctrl+p</em>  <!-- 快速打开文件 --></li>
<li><em>ctrl + tab</em> <!-- 可以查看在编辑器中，打开的所有文件的列表 --></li>
<li><em>ctrl + shift + o</em> <!-- 可以查找索引符号 --></li>
<li>选中一段文本，按下_ctrl + shift + f_ <!-- 对局部的文本进行搜索、替换、全选 --></li>
</ul>
<h3 id="在选中区域外围添加标签"><a href="#在选中区域外围添加标签" class="headerlink" title="在选中区域外围添加标签"></a>在选中区域外围添加标签</h3><ul>
<li>选中首尾tag,按 _ctrl + ] _</li>
<li>在js中，按下 <em>ctrl + ]</em> <!-- 包围if、for等函数库++ --></li>
</ul>
<h3 id="反包围"><a href="#反包围" class="headerlink" title="反包围"></a>反包围</h3><ul>
<li>双击tag开头，选中tag</li>
<li>按下 <em>ctrl + shift + ]</em> <!-- 去掉当前tag并自动处理缩进 --></li>
</ul>
<h3 id="扩大选区"><a href="#扩大选区" class="headerlink" title="扩大选区"></a>扩大选区</h3><ul>
<li>&#x3D; 是 + 的默认键，所以_ctrl + &#x3D; _就是ctrl和 + 键一起按下 .</li>
</ul>
<h3 id="交换选区内容"><a href="#交换选区内容" class="headerlink" title="交换选区内容"></a>交换选区内容</h3><ul>
<li>选中第一个要交换的内容</li>
<li>按下_crtl_ ，选中第二个要交换的位置</li>
<li>按下_ctrl + shift + x_ ，交换</li>
</ul>
<h3 id="撤销最后一个多选区或多光标"><a href="#撤销最后一个多选区或多光标" class="headerlink" title="撤销最后一个多选区或多光标"></a>撤销最后一个多选区或多光标</h3><ul>
<li>双击选中内容</li>
<li>按_Ctrl + e_ <!-- 选中相同词 --></li>
<li>按_Ctrl + Shift + z_ <!-- 不再选中最后一个词 --></li>
<li>多选了一个词，<em>ctrl + 鼠标右键</em> <!-- 取消一个选区 --></li>
<li><em>alt + shift + e</em> <!-- 跳过当前词选下一个词 --></li>
</ul>
<h3 id="批量合并行"><a href="#批量合并行" class="headerlink" title="批量合并行"></a>批量合并行</h3><ul>
<li>双击{内侧选中class</li>
<li>按Ctrl+双击选中另一个class</li>
<li>按反格式化_Ctrl+Shift+k_ <!-- 把每个css的区块代码都合并为一行 --></li>
<li>_ Ctrl+k_是格式化代码，那么_Ctrl+Shift+k_就是合并为一行。</li>
</ul>
<h3 id="同时注释if段首尾"><a href="#同时注释if段首尾" class="headerlink" title="同时注释if段首尾"></a>同时注释if段首尾</h3><ul>
<li>双击if选中if代码块</li>
<li>按_Ctrl+_在选区首尾加光标，变成多光标模式</li>
<li>按_Ctrl+&#x2F;_注释掉选区首尾行</li>
</ul>
<h3 id="HBuilderX-语言服务-代码提示，在函数、类前面放置"><a href="#HBuilderX-语言服务-代码提示，在函数、类前面放置" class="headerlink" title="HBuilderX 语言服务&#x2F;代码提示，在函数、类前面放置"></a>HBuilderX 语言服务&#x2F;代码提示，在函数、类前面放置</h3><ul>
<li>支持扩展jsdoc+, <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@alias</span> aliasName   // 别名</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@constructor</span>  // 标识一个函数是构造函数</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@description</span> 描述内容</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@example</span> 示例内容</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@extends</span> &#123;<span class="type">Type</span>&#125; // 标识继承于某个类型</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@param</span> &#123;<span class="type">Type[,Type,...]</span>&#125; 参数名=[可选择值1|可选择值2|...]] 参数描述</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@property</span> &#123;<span class="type">Type[,Type,...]</span>&#125; 属性名 属性描述</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@return</span> &#123;<span class="type">Type[,Type,...]</span>&#125; // 描述一个对象的属性</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@type</span> &#123;<span class="type">Type[,Type,...]</span>&#125;  // 定义某个变量的类型</span></span><br><span class="line"><span class="comment">	*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="vue-doc-–-vue组件说明，类jsdoc"><a href="#vue-doc-–-vue组件说明，类jsdoc" class="headerlink" title="vue doc – vue组件说明，类jsdoc"></a>vue doc – vue组件说明，类jsdoc</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 这里是一个组件描述，会在提示标签的时候显示</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@description</span> 这里也是一个组件描述</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@tutorial</span> 参考地址</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@property</span> &#123;<span class="type">String</span>&#125; type = [button|input|...值域] 这里是属性描述，&#123;&#125;中间的是类型</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@event</span> &#123;<span class="type">Function</span>&#125; tap 这是是事件描述，类型必须是Function</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@example</span> 这里是示例代码</span></span><br><span class="line"><span class="comment">	*/</span></span><br></pre></td></tr></table></figure>

<h3 id="常用代码块"><a href="#常用代码块" class="headerlink" title="常用代码块"></a>常用代码块</h3><h4 id="js-代码块"><a href="#js-代码块" class="headerlink" title="js 代码块"></a>js 代码块</h4><table>
<thead>
<tr>
<th>敲的值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>kv</td>
<td>Key: Value 代码块 ，js中使用json时生效</td>
</tr>
<tr>
<td>ife</td>
<td>if…else结构</td>
</tr>
<tr>
<td>iff</td>
<td>简单if</td>
</tr>
<tr>
<td>forr</td>
<td>for循环结构体</td>
</tr>
<tr>
<td>fori</td>
<td>for循环结构体并包含i</td>
</tr>
<tr>
<td>funn</td>
<td>函数</td>
</tr>
<tr>
<td>funa</td>
<td>匿名函数</td>
</tr>
<tr>
<td>clog</td>
<td>打印日志</td>
</tr>
<tr>
<td>clogvar</td>
<td>打印变量命名和值</td>
</tr>
</tbody></table>
<h4 id="dom-代码块"><a href="#dom-代码块" class="headerlink" title="dom 代码块"></a>dom 代码块</h4><table>
<thead>
<tr>
<th>敲的值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>dg</td>
<td>document.getElementById</td>
</tr>
<tr>
<td>dl</td>
<td>$(“”)</td>
</tr>
</tbody></table>
<h4 id="vue-代码块"><a href="#vue-代码块" class="headerlink" title="vue 代码块"></a>vue 代码块</h4><ul>
<li>v：各种vue代码块</li>
</ul>
<h4 id="uni-app-代码块"><a href="#uni-app-代码块" class="headerlink" title="uni-app 代码块"></a>uni-app 代码块</h4><ul>
<li>u：各种uni-app代码块，还有ifios、ifandroid，这2个平台判断代码块</li>
</ul>
<h4 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h4><ul>
<li><!-- 使用类似于CSS选择器的语法来描述元素在生成的树和元素属性中的位置 --> 缩写时不能空格</li>
<li>嵌套运算符</li>
<li><code>&gt;</code>：元素随着&gt;一层一层向里嵌套</li>
<li>+：元素放置在同一水平上</li>
<li>^：^后携带的元素，可以向&gt;嵌套的元素向上一层移动，一个^向上移动一层</li>
<li>*：输出几次</li>
<li>()：分组</li>
<li>属性运算符<ul>
<li>标签后带#: 生成id选择器</li>
<li>标签后带.: 生成class选择器，可混合写和连写</li>
<li>标签后带[]: 生成的语法，带有[]所写属性值</li>
<li>项目编号$<ul>
<li>li.item$*5: 单个从1开始编号</li>
<li>li.item$$$*5: 多个用0来替代数字</li>
<li>li.item$@-*5: 从大到1开始编号</li>
<li>li.item$@3*5: 从3开始编号，生成五个</li>
<li>li.item$@-3*5: 从大到3开始编号</li>
</ul>
</li>
<li>标签后带{}：像元素添加文本</li>
</ul>
</li>
</ul>
<h4 id="json优化"><a href="#json优化" class="headerlink" title="json优化"></a>json优化</h4><ul>
<li>中文符号免干扰输入</li>
<li>回车时自动补全行尾逗号</li>
<li>保存时自动删除数组或键值对结尾的多余逗号</li>
<li>keyValue代码块</li>
<li>智能双击，快速选中数组或键值对</li>
<li>快速重复插入</li>
<li>Ctrl+Insert或Ctrl+Shift+r</li>
<li>语法提示</li>
<li>保存时自动校验语法</li>
</ul>
<h4 id="markdown优化"><a href="#markdown优化" class="headerlink" title="markdown优化"></a>markdown优化</h4><ul>
<li>标题: 敲h2+Tab即可生成二级标题</li>
<li>图片: img后敲Tab</li>
<li>链接: a后敲Tab</li>
<li>表格: table3*3后敲Tab，表示生成3行3列的表格，行首生效</li>
<li>分割线: hr后敲Tab</li>
<li>代码块: code后敲Tab，行首生效</li>
<li>day后敲Tab，当前日期。注意day需在行首或前面有空格</li>
<li>time后敲Tab，当前时间。注意time需在行首或前面有空格</li>
<li>文字加粗: b后敲Tab</li>
<li>文字倾斜: i后敲Tab</li>
<li>注释：快捷键Ctrl+&#x2F;快速插入注释</li>
<li>标记：使用html语法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">备注：</span><br><span class="line">&lt;sup&gt;是上标</span><br><span class="line">&lt;a&gt;是超链接，herf是指向的位置</span><br><span class="line">用法：</span><br><span class="line">这是标记&lt;sup&gt;&lt;a href=&quot;#ref3&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;</span><br><span class="line">&lt;p name=&quot;ref3&quot;&gt;标记内容的阐述区域，标签看情况给，只要name与href指向的一样就行&lt;/p&gt;</span><br></pre></td></tr></table></figure></li>
<li>强大的智能粘贴</li>
<li>强大的智能双击</li>
<li>强大的整理功能<ul>
<li>Ctrl+K可以自动整理表格格式</li>
</ul>
</li>
<li>直观的文档结构图<ul>
<li>Alt+w</li>
<li>Ctrl+Shift+o</li>
</ul>
</li>
<li>实用的任务列表<ul>
<li>任务列表-未完成任务 快捷键：Ctrl+Alt+[</li>
<li>任务列表-已完成任务 快捷键：Ctrl+Alt+]</li>
</ul>
</li>
<li>路径提示</li>
<li>markdown一键分享</li>
<li>跨文件跳转标题</li>
<li><a href="https://mermaid.js.org/syntax/flowchart.html">Mermaid流程图</a><ul>
<li>流程图布局方向</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>标志</th>
<th>方向</th>
</tr>
</thead>
<tbody><tr>
<td>TB</td>
<td>top bottom - 从上到下</td>
</tr>
<tr>
<td>BT</td>
<td>top bottom - 从上到下</td>
</tr>
<tr>
<td>BT</td>
<td>top bottom - 从上到下</td>
</tr>
<tr>
<td>LR</td>
<td>left right - 从左到右</td>
</tr>
<tr>
<td>TD</td>
<td>等同于 TB</td>
</tr>
</tbody></table>
<ul>
<li>流程图对应图形标识</li>
</ul>
<table>
<thead>
<tr>
<th>图形</th>
<th>代表</th>
</tr>
</thead>
<tbody><tr>
<td>圆角矩形</td>
<td>(desc)</td>
</tr>
<tr>
<td>矩形</td>
<td>[desc]</td>
</tr>
<tr>
<td>圆形</td>
<td>((desc))</td>
</tr>
<tr>
<td>椭圆形</td>
<td>([desc])</td>
</tr>
<tr>
<td>子例程形</td>
<td>[[desc]]</td>
</tr>
<tr>
<td>圆柱体</td>
<td>[(desc)]</td>
</tr>
<tr>
<td>双圆</td>
<td>(((desc)))</td>
</tr>
<tr>
<td>菱形</td>
<td>{desc}</td>
</tr>
<tr>
<td>非对称</td>
<td>&gt;desc]</td>
</tr>
<tr>
<td>六角形</td>
<td></td>
</tr>
<tr>
<td>平行四边形–右倾</td>
<td>[&#x2F;desc&#x2F;]</td>
</tr>
<tr>
<td>平行四边形–左倾</td>
<td>[\desc]</td>
</tr>
<tr>
<td>梯形–正向</td>
<td>[&#x2F;desc]</td>
</tr>
<tr>
<td>梯形–反向</td>
<td>[\desc&#x2F;]</td>
</tr>
<tr>
<td>带箭头的链接</td>
<td>–&gt;</td>
</tr>
<tr>
<td>不带箭头的链接</td>
<td>—</td>
</tr>
<tr>
<td>链接上的文字</td>
<td>– desc —</td>
</tr>
<tr>
<td>带有箭头和文本的链接</td>
<td>A– desc –&gt;B</td>
</tr>
<tr>
<td>虚线链接</td>
<td>A-.-&gt;B</td>
</tr>
<tr>
<td>带文本的虚线链接</td>
<td>A-. text .-&gt; B</td>
</tr>
<tr>
<td>粗链接</td>
<td>A &#x3D;&#x3D;&gt; B</td>
</tr>
<tr>
<td>包含文本的粗链接</td>
<td>A &#x3D;&#x3D; text &#x3D;&#x3D;&gt; B</td>
</tr>
<tr>
<td>看不见的链接</td>
<td>A ~~~ B</td>
</tr>
<tr>
<td>a可以指向b和c</td>
<td>a –&gt; b &amp;	c</td>
</tr>
<tr>
<td>新的箭头类型</td>
<td>A –o B	或 B –x C</td>
</tr>
<tr>
<td>多方向箭头</td>
<td>B &lt;–&gt; C</td>
</tr>
</tbody></table>
<ul>
<li>基本语法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写在```mermaid ```里面</span><br><span class="line">graph LR  // 选择图形方向</span><br><span class="line">c1--&gt;a2</span><br><span class="line">subgraph 第一组  // 从 subgraph 到 end 表示一组</span><br><span class="line">a1--&gt;a2</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp-vue3</title>
    <url>/2024/10/31/uniApp/uniapp-vue3/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>uniapp项目弊端：如果换文件夹或者重新导入uniapp项目不会自动识别为uniapp项目，需要右键文件夹重新识别项目类型</li>
<li>使用组合式+单文件组件+vue3来实现</li>
</ul>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li>ref参数一般是基本数据类型，亦可以是对象类型</span></li>
<li>参数是<span class="key_words">『对象类型，本质还是reactive，系统会自动将ref转换为reactive』</span>，如 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">ref</span>(<span class="number">1</span>) ==&gt; <span class="title function_">reactive</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>在<span class="key_words">『模板中访问ref中的数据，系统会自动添加.value,在JS中访问ref中的数据，需要手动添加.value』</span></li>
<li>ref的底层原理同reactive一样，都是Proxy</li>
<li>ref中可以使用数组的reduce等方法</li>
</ul>
<h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h2><ul>
<li>reactive的参数一般是<span class="key_words">『对象或数组』</span>，能够使复杂数据变为响应式数据</li>
<li>reactive 的响应式是深层次的，底层本质是将传入的数据转换为Proxy对象</li>
<li><span class="key_words">『在JS中访问ref的值需要手动添加.value，访问reactive不需要』</span></li>
</ul>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(name, <span class="function">(<span class="params">curVal, preVal</span>)=&gt;</span>&#123; <span class="comment">/* 业务处理 */</span> &#125;, options)</span><br></pre></td></tr></table></figure>
<ul>
<li>name：需要帧听的属性</li>
<li>(curVal,preVal)&#x3D;&gt;{} 箭头函数: 是监听到的最新值和本次修改之前的值，此处进行逻辑处理。</li>
<li>options：配置项，对监听器的配置，如：是否深度监听。</li>
<li>监听<span class="key_words">『多个』</span>响应式数据：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>([count,obj],<span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>监听对象中的某个属性的变化：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>obj.<span class="property">name</span>,<span class="function">()=&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>深度监听deep、默认执行immediate：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(name,<span class="function">()=&gt;</span>&#123;&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>,<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h2><ul>
<li>侦听器、副作用函数</li>
<li>监听引用数据类型的所有属性，一旦运行就会立即监听，组件卸载的时候会停止监听</li>
<li>在一些情况下，可以显式调用返回值以停止侦听</li>
<li>侦听副作用传入的函数可以接收一个 onInvalidate 函数作入参，用来注册清理失效时的回调。</li>
<li>副作用即将重新执行时，失效回调会被触发</li>
<li>侦听器被停止 (如果在 setup() 或生命周期钩子函数中使用了 watchEffect，则在组件卸载时)，失效回调会被触发</li>
<li>如果要操作“更新之后的DOM”，就要配置 flush: ‘post’。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;	</span><br><span class="line">	<span class="keyword">import</span> &#123; ref，watchEffect, computed, reactive, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">	<span class="comment">// 定义一个变量，使用ref来存取变量的值</span></span><br><span class="line">	<span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">	<span class="comment">//在js中通过.value来获取meaasge在ref中的值，并进行操作来更改message的值</span></span><br><span class="line">	<span class="keyword">const</span> isRed = <span class="title function_">ref</span>(<span class="literal">false</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// reactive</span></span><br><span class="line">	<span class="keyword">const</span> stats = <span class="title function_">reactive</span>(&#123;&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义props</span></span><br><span class="line">	<span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span><br><span class="line">		<span class="attr">data</span>: <span class="title class_">Array</span>,</span><br><span class="line">		<span class="attr">title</span>: <span class="title class_">String</span></span><br><span class="line">		...</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// emit</span></span><br><span class="line">	<span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;click&#x27;</span>])</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// methods</span></span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">		<span class="title function_">emit</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用计算属性</span></span><br><span class="line">	<span class="keyword">const</span> output = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="title function_">marked</span>(input.<span class="property">value</span>))</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 该effect会立即运行，并且在变量更改时重新运行,可以加async变成异步的</span></span><br><span class="line">	<span class="title function_">watchEffect</span>(<span class="title function_">async</span> () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// watch,要明确指明依赖的是那个变量，如count</span></span><br><span class="line">	<span class="title function_">watch</span>(count, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">		anotherCount.<span class="property">value</span> = newValue - <span class="number">1</span></span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 生命周期， setup里面用on开头的生命周期函数</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	// 在模板中直接使用变量名即可，不需要写.value,因为在模板中ref自动解包</span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	</span></span><br><span class="line"><span class="language-xml">	// Attribute绑定 :名称</span></span><br><span class="line"><span class="language-xml">	对象中，变量名(值)与属性名(键)相同的话可以简写，只写其中一个</span></span><br><span class="line"><span class="language-xml">	对象中，类名可以通过布尔值来判断是否显示</span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">view</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; red: isRed &#125;&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; color &#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;可以放置函数名或简单表达式&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	</span></span><br><span class="line"><span class="language-xml">	// 循环判断</span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in 列表&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span>		</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-Pinia</title>
    <url>/2024/11/01/vue3/Pinia/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="dev-tools-支持"><a href="#dev-tools-支持" class="headerlink" title="dev-tools 支持"></a>dev-tools 支持</h3><ul>
<li>跟踪动作、突变的时间线</li>
<li>Store 出现在使用它们的组件中</li>
<li>time travel 和 更容易的调试</li>
</ul>
<h3 id="热模块更换"><a href="#热模块更换" class="headerlink" title="热模块更换"></a>热模块更换</h3><ul>
<li>在不重新加载页面的情况下修改您的 Store</li>
<li>在开发时保持任何现有状态</li>
</ul>
<h3 id="插件：使用插件扩展-Pinia-功能"><a href="#插件：使用插件扩展-Pinia-功能" class="headerlink" title="插件：使用插件扩展 Pinia 功能"></a>插件：使用插件扩展 Pinia 功能</h3><h3 id="为-JS-用户提供适当的-TypeScript-支持或-autocompletion"><a href="#为-JS-用户提供适当的-TypeScript-支持或-autocompletion" class="headerlink" title="为 JS 用户提供适当的 TypeScript 支持或 autocompletion"></a>为 JS 用户提供适当的 TypeScript 支持或 autocompletion</h3><h3 id="服务器端渲染支持"><a href="#服务器端渲染支持" class="headerlink" title="服务器端渲染支持"></a>服务器端渲染支持</h3><h2 id="与-vuex-3-x-4-x-对比"><a href="#与-vuex-3-x-4-x-对比" class="headerlink" title="与 vuex 3.x&#x2F;4.x 对比"></a>与 vuex 3.x&#x2F;4.x 对比</h2><ul>
<li>mutations 不再存在</li>
<li>自动注入、导入函数、调用函数</li>
<li>支持ts，且内容都是类型化</li>
<li>无需动态添加 Store，默认情况下它们都是动态的</li>
<li>没有命名空间模块。</li>
<li>没有module的嵌套结构</li>
</ul>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><ul>
<li>Store是使用 defineStore() 定义的，并且它需要一个唯一名称，作为第一个参数传递</li>
</ul>
<h3 id="定义一个Store"><a href="#定义一个Store" class="headerlink" title="定义一个Store"></a>定义一个Store</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>,&#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> &#123; <span class="comment">//使用完整类型推断的箭头函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 定义的属性会自动推断类型</span></span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    <span class="title function_">doublePlusOne</span>(): number &#123; <span class="comment">// 通过 this 访问,返回类型必须明确设置</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">counter</span> * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">registerUser</span>(<span class="params">login, password</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">userData</span> = <span class="keyword">await</span> api.<span class="title function_">post</span>(&#123; login, password &#125;)</span><br><span class="line">        <span class="title function_">showTooltip</span>(<span class="string">`Welcome back <span class="subst">$&#123;<span class="variable language_">this</span>.userData.name&#125;</span>!`</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">showTooltip</span>(error)</span><br><span class="line">        <span class="comment">// 让表单组件显示错误</span></span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> &#123; name, doubleCount &#125; = store   <span class="comment">// ❌ 不能解构，会破坏响应式</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name, doubleCount &#125; = <span class="title function_">storeToRefs</span>(store) <span class="comment">// 可以解构，但跳过任何 action 或 非响应式（不是 ref/reactive）的属性</span></span><br><span class="line">    store.<span class="property">count</span>++ <span class="comment">// 直接读取和写入 state</span></span><br><span class="line">    store.$reset() <span class="comment">// 重置state到初始值</span></span><br><span class="line">    store.<span class="title function_">increment</span>()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 这将是响应式的</span></span><br><span class="line">      <span class="attr">doubleValue</span>: <span class="title function_">computed</span>(<span class="function">() =&gt;</span> store.<span class="property">doubleCount</span>),</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="在-Options-API-中使用-setup"><a href="#在-Options-API-中使用-setup" class="headerlink" title="在 Options API 中使用 setup()"></a>在 Options API 中使用 setup()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counterStore&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面</span></span><br><span class="line"><span class="keyword">import</span> &#123; useCounterStore &#125; <span class="keyword">from</span> <span class="string">&#x27;../stores/counterStore&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> counterStore = <span class="title function_">useCounterStore</span>()</span><br><span class="line">    <span class="keyword">return</span> &#123; counterStore &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;   <span class="comment">// getter</span></span><br><span class="line">    <span class="title function_">tripleCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> counterStore.<span class="property">counter</span> * <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;  <span class="comment">// action</span></span><br><span class="line">    <span class="title function_">incrementAndPrint</span>(<span class="params"></span>) &#123;</span><br><span class="line">      counterStore.<span class="title function_">increment</span>()</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;New Count:&#x27;</span>, counterStore.<span class="property">count</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在-Options-API-中不使用-setup"><a href="#在-Options-API-中不使用-setup" class="headerlink" title="在 Options API 中不使用 setup()"></a>在 Options API 中不使用 setup()</h3><ul>
<li>使用 mapState() 映射为只读计算属性</li>
<li>使用 mapWritableState() 可以写入</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useCounterStore &#125; <span class="keyword">from</span> <span class="string">&#x27;../stores/counterStore&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  💠 使用 <span class="title function_">mapState</span>() 映射为只读计算属性</span><br><span class="line">    <span class="comment">// 允许访问组件内部的 this.counter</span></span><br><span class="line">    <span class="comment">// 与从 store.counter 读取相同</span></span><br><span class="line">    ...<span class="title function_">mapState</span>(useCounterStore, &#123;</span><br><span class="line">      <span class="attr">myOwnName</span>: <span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">      <span class="attr">double</span>: <span class="function"><span class="params">store</span> =&gt;</span> store.<span class="property">counter</span> * <span class="number">2</span>,<span class="comment">// 还可以编写一个访问 store 的函数</span></span><br><span class="line">      <span class="title function_">magicValue</span>(<span class="params">store</span>) &#123; <span class="comment">// 可以读取“this”，但无法写入...</span></span><br><span class="line">        <span class="keyword">return</span> store.<span class="property">someGetter</span> + <span class="variable language_">this</span>.<span class="property">counter</span> + <span class="variable language_">this</span>.<span class="property">double</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  💠 使用 <span class="title function_">mapWritableState</span>() 可以写入</span><br><span class="line">    ...<span class="title function_">mapWritableState</span>(useCounterStore, [<span class="string">&#x27;counter&#x27;</span>]),<span class="comment">// 与从 store.counter 读取相同</span></span><br><span class="line">    ...<span class="title function_">mapWritableState</span>(useCounterStore, &#123;<span class="comment">// 与上面相同，但将其注册为 this.myOwnName</span></span><br><span class="line">      <span class="attr">myOwnName</span>: <span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于像数组这样的集合，不需要mapWritableState()，除非用cartItems = []替换整个数组</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    ...<span class="title function_">mapActions</span>(useCounterStore, &#123; <span class="attr">myOwnName</span>: <span class="string">&#x27;doubleCounter&#x27;</span> &#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="修改-store-–-更改都出现在-devtool"><a href="#修改-store-–-更改都出现在-devtool" class="headerlink" title="修改 store – 更改都出现在 devtool"></a>修改 store – <span class="desc">更改都出现在 devtool</span></h3><ul>
<li>1、直接用 store.counter++</li>
<li>2、调用 $patch 使用部分“state”对象同时应用多个更改<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cartStore.$patch(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  state.<span class="property">items</span>.<span class="title function_">push</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;shoes&#x27;</span>, <span class="attr">quantity</span>: <span class="number">1</span>&#125;)</span><br><span class="line">  state.<span class="property">hasChanged</span> = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="替换state-—-state-替换整个state"><a href="#替换state-—-state-替换整个state" class="headerlink" title="替换state — $state 替换整个state"></a>替换state — <span class="desc">$state 替换整个state</span></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="property">$state</span> = &#123; <span class="attr">counter</span>: <span class="number">666</span>, <span class="attr">name</span>: <span class="string">&#x27;Paimon&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="订阅状态-—-subscribe-只会在-patches-之后触发一次"><a href="#订阅状态-—-subscribe-只会在-patches-之后触发一次" class="headerlink" title="订阅状态 — $subscribe(): 只会在 patches 之后触发一次"></a>订阅状态 — <span class="desc">$subscribe(): 只会在 patches 之后触发一次</span></h3><h3 id="将参数传递给getter-—-此操作-getter-不再缓存"><a href="#将参数传递给getter-—-此操作-getter-不再缓存" class="headerlink" title="将参数传递给getter — 此操作 getter 不再缓存"></a>将参数传递给getter — <span class="desc">此操作 getter 不再缓存</span></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useState = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">getUserById</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">userId</span>) =&gt;</span> state.<span class="property">users</span>.<span class="title function_">find</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> user.<span class="property">id</span> === userId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)scene=fcodeId%3D17542963626994222</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">getUserById</span>: store.<span class="property">getUserById</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>user 2: &#123;&#123;getUserById(2)&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h3 id="访问其他store的getter-action"><a href="#访问其他store的getter-action" class="headerlink" title="访问其他store的getter&#x2F;action"></a>访问其他store的getter&#x2F;action</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useOtherStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./other-store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;&#125;),</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">otherGetter</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> otherStore = <span class="title function_">useOtherStore</span>()</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">localData</span> + otherStore.<span class="property">data</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">fetchUserPreferences</span>(<span class="params">preferences</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> auth = <span class="title function_">useAuthStore</span>()</span><br><span class="line">      <span class="keyword">if</span> (auth.<span class="property">isAuthenticated</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">preferences</span> = <span class="keyword">await</span> <span class="title function_">fetchPreferences</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;User must be authenticated&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="订阅Actions-—-store-onAction"><a href="#订阅Actions-—-store-onAction" class="headerlink" title="订阅Actions — store.$onAction()"></a>订阅Actions — <span class="desc">store.$onAction()</span></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unsubscribe = someStore.$onAction(</span><br><span class="line">  <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    name, // action 的名字</span></span></span><br><span class="line"><span class="params"><span class="function">    store, // store 实例</span></span></span><br><span class="line"><span class="params"><span class="function">    args, // 调用这个 action 的参数</span></span></span><br><span class="line"><span class="params"><span class="function">    after, // 在这个 action 执行完毕之后，执行这个函数</span></span></span><br><span class="line"><span class="params"><span class="function">    onError, // 在这个 action 抛出异常的时候，执行这个函数</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始的时间变量</span></span><br><span class="line">    <span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="comment">// 如果 action 成功并且完全运行后，after 将触发。</span></span><br><span class="line">    <span class="comment">// 它将等待任何返回的 promise</span></span><br><span class="line">    <span class="title function_">after</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 action 抛出或返回 Promise.reject ，onError 将触发</span></span><br><span class="line">    <span class="title function_">onError</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动移除订阅</span></span><br><span class="line"><span class="title function_">unsubscribe</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> someStore = <span class="title function_">useSomeStore</span>()</span><br><span class="line">    <span class="comment">//第二个参数true ，此订阅将在组件卸载后保留</span></span><br><span class="line">    someStore.$onAction(callback,<span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><blockquote>
<p>Pinia 插件是一个函数，可以选择返回要添加到 store的属性。</p>
</blockquote>
<h3 id="创建Pinia"><a href="#创建Pinia" class="headerlink" title="创建Pinia"></a>创建Pinia</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SecretPiniaPlugin</span>(<span class="params"></span>) &#123;    <span class="comment">// 插件</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">secret</span>: <span class="string">&#x27;the cake is a lie&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line">pinia.<span class="title function_">use</span>(<span class="title class_">SecretPiniaPlugin</span>)  <span class="comment">//将插件添加到pinia实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">store.<span class="property">secret</span></span><br></pre></td></tr></table></figure>
<h3 id="页面使用"><a href="#页面使用" class="headerlink" title="页面使用"></a>页面使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">myPiniaPlugin</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  context.<span class="property">pinia</span> <span class="comment">// 使用 `createPinia()` 创建的 pinia</span></span><br><span class="line">  context.<span class="property">app</span> <span class="comment">// 使用 `createApp()` 创建的当前应用程序（仅限 Vue 3）</span></span><br><span class="line">  context.<span class="property">store</span> <span class="comment">// 插件正在扩充的 store</span></span><br><span class="line">  context.<span class="property">options</span> <span class="comment">// 定义存储的选项对象传递给`defineStore()`</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩充store"><a href="#扩充store" class="headerlink" title="扩充store"></a>扩充store</h3><ul>
<li>1、简单的在插件中返回它们的对象来为每个store添加属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pinia.<span class="title function_">use</span>(<span class="function">() =&gt;</span> (&#123;<span class="attr">hello</span>:<span class="string">&#x27;world&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure></li>
<li>2、直接在store上设置属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pinia.<span class="title function_">use</span>(<span class="function">(<span class="params">&#123; store &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  store.<span class="property">hello</span> = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>3、每个store都是用reactive包装，自动展开任何Ref(ref(),computed(,…))<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shareRef = <span class="title function_">ref</span>(<span class="string">&#x27;shared&#x27;</span>)</span><br><span class="line">pinia.<span class="title function_">use</span>(<span class="function">(<span class="params">&#123;store&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  store.<span class="property">hello</span> = <span class="title function_">ref</span>(<span class="string">&#x27;secret&#x27;</span>)</span><br><span class="line">  store.<span class="property">hello</span> <span class="comment">// secret</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有store都共享 shared属性</span></span><br><span class="line">  store.<span class="property">shared</span> = sharedRef</span><br><span class="line">  store.<span class="property">shared</span> <span class="comment">// shared</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="添加新状态"><a href="#添加新状态" class="headerlink" title="添加新状态"></a>添加新状态</h3><ul>
<li>添加位置：<ul>
<li>在store上，可以使用store.myState访问</li>
<li>在store.$state上，在SSR期间被序列化</li>
</ul>
</li>
<li>共享ref或computed属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> globalSecret = <span class="title function_">ref</span>(<span class="string">&#x27;secret&#x27;</span>)</span><br><span class="line">pinia.<span class="title function_">use</span>(<span class="function">(<span class="params">&#123;store&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// secret在所有state之间共享</span></span><br><span class="line">  store.<span class="property">$state</span>.<span class="property">secret</span> = globalSecret</span><br><span class="line">  store.<span class="property">secret</span> = globalSecret</span><br><span class="line">  store.<span class="property">router</span> = <span class="title function_">markRaw</span>(router) <span class="comment">// 添加外部插件</span></span><br><span class="line">  store.$subscribe(<span class="function">()=&gt;</span>&#123;&#125;)  <span class="comment">// 在存储变化的时候执行</span></span><br><span class="line">  store.$onAction(<span class="function">()=&gt;</span>&#123;&#125;) <span class="comment">// 在 action 的时候执行</span></span><br><span class="line"></span><br><span class="line">  store.<span class="property">secret</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>注意：<span class="desc">插件中发生的状态更改或添加（包括调用store.$patch()）发生在存储处于活动状态之前，因此不会触发任何订阅。</span></li>
</ul>
<h2 id="在组件外使用存储"><a href="#在组件外使用存储" class="headerlink" title="在组件外使用存储"></a>在组件外使用存储</h2><h3 id="单页应用程序"><a href="#单页应用程序" class="headerlink" title="单页应用程序"></a>单页应用程序</h3><ul>
<li>没有进行任何 SSR（服务器端渲染），则在使用 app.use(pinia) 安装 pinia 插件后，任何useStore() 调用都将起作用：</li>
</ul>
<h3 id="服务端渲染应用"><a href="#服务端渲染应用" class="headerlink" title="服务端渲染应用"></a>服务端渲染应用</h3><ul>
<li>必须将 pinia 实例传递给 useStore()</li>
</ul>
<h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><h3 id="vue-and-vite"><a href="#vue-and-vite" class="headerlink" title="vue and vite"></a>vue and vite</h3><ul>
<li>1.只要在 setup 函数、getters 和 actions 的顶部调用 useStore() 函数，使用 Pinia 创建store可以立即用于 SSR<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> main = <span class="title function_">useMainStore</span>()</span><br><span class="line">    <span class="keyword">return</span> &#123; main &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>2.在setup()之外使用存储：则需要将 pinia 实例传递给 useStore() 函数调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">use</span>(pinia)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> main = <span class="title function_">useMainStore</span>(pinia)</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">requiresAuth</span> &amp;&amp; !main.<span class="property">isLoggedIn</span>) <span class="keyword">return</span> <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>3.Pinia 可以将自身作为 $pinia 添加到应用程序中，以便可以在serverPrefetch() 之类的函数中使用它： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">serverPrefetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>(<span class="variable language_">this</span>.<span class="property">$pinia</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>4.State hydration<ul>
<li>为了 hydration 初始状态，需要确保 rootState 包含在 HTML 中的某个位置，以便 Pinia 稍后获取它。出于安全原因，应该转义状态。可以使用 JSON.stringify()&#x2F;JSON.parse() 序列化和解析你的状态</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>状态管理库</tag>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-路由</title>
    <url>/2024/11/01/vue3/vue-router/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="路由标签"><a href="#路由标签" class="headerlink" title="路由标签"></a>路由标签</h2><ul>
<li>router-link：to属性指定组件的链接</li>
<li>router-view：路由出口，to指定的路由组件渲染在该标签内</li>
</ul>
<h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><ul>
<li>由mode改为history，并且属性值也调整<ul>
<li>history模式：history: createWebHistory()</li>
<li>hash模式：history: createWebHashHistory()</li>
<li>abstract模式：history: createMemoryHistory()</li>
</ul>
</li>
</ul>
<h2 id="创建一个路由文件"><a href="#创建一个路由文件" class="headerlink" title="创建一个路由文件"></a>创建一个路由文件</h2><ol>
<li>引入路由api 并定义<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;Home&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">About</span> = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;About&lt;/div&gt;&#x27;</span> &#125;</span><br></pre></td></tr></table></figure></li>
<li>配置路由表跟vue2一样<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123;</span><br><span class="line">	<span class="attr">path</span>: <span class="string">&#x27;/about/:id&#x27;</span>, <span class="comment">//:params,代表动态路径，使用this.$route.params来调用</span></span><br><span class="line">	<span class="attr">component</span>: <span class="title class_">About</span></span><br><span class="line">	<span class="attr">children</span>: [ <span class="comment">// 嵌套路由</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>: <span class="string">&#x27;profile&#x27;</span>, <span class="comment">// 当/about/:id/profile匹配成功就渲染</span></span><br><span class="line">			<span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>, <span class="comment">// 只有子路由具有名称（命名路由）</span></span><br><span class="line">			<span class="attr">component</span>: <span class="title class_">Profile</span></span><br><span class="line">		&#125;</span><br><span class="line">	]	</span><br><span class="line">&#125;,]</span><br></pre></td></tr></table></figure></li>
<li>创建路由实例并传递routes配置<ul>
<li>vue2使用new VueRouter</li>
<li>vue3使用VueRouter.createRouter<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title class_">VueRouter</span>.<span class="title function_">createRouter</span>(&#123;</span><br><span class="line">	<span class="attr">history</span>: <span class="title class_">VueRouter</span>.<span class="title function_">createWebHashHistory</span>()</span><br><span class="line">	routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在main.js文件创建并挂载根实例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>在组件页面中使用：在任意组件中以 this.$router 的形式访问全局的router，以this.$route 的形式访问当前组件的路由，<span class="key_words">『在setup() 函数中访问路由，可以调用useRouter 或 useRoute 函数』</span></li>
</ul>
<h2 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h2><ul>
<li>带参的路由导航到另一个带参路由,相同的组件实例将被重复使用，也意味着组件的生命周期钩子不会被调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">	<span class="attr">template</span>: <span class="string">&#x27;&lt;template&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;template&gt;&#x27;</span>	</span><br><span class="line">	<span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">this</span>.$watch(</span><br><span class="line">			<span class="function">()=&gt;</span> <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>,</span><br><span class="line">			<span class="function">(<span class="params">toParams, previousParams</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="comment">// 对路由变化做出响应</span></span><br><span class="line">			&#125;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>beforeRouteUpdate(to,from){}：取消导航(搭配async&#x2F;await)</li>
</ul>
<h2 id="路由的匹配语法"><a href="#路由的匹配语法" class="headerlink" title="路由的匹配语法"></a>路由的匹配语法</h2><h3 id="匹配所有内容放在-route-params-xxx下"><a href="#匹配所有内容放在-route-params-xxx下" class="headerlink" title="匹配所有内容放在$route.params.xxx下"></a>匹配所有内容放在$route.params.xxx下</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/:xxx(.*)*&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;NotFound&#x27;</span>, <span class="attr">component</span>: <span class="title class_">NotFound</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配以-xxx开头的所有内容，并将其放在-route-params-afterUser下"><a href="#匹配以-xxx开头的所有内容，并将其放在-route-params-afterUser下" class="headerlink" title="匹配以&#x2F;xxx开头的所有内容，并将其放在$route.params.afterUser下"></a>匹配以&#x2F;xxx开头的所有内容，并将其放在$route.params.afterUser下</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/xxx:afterUser(.*)&#x27;</span>,<span class="attr">component</span>: <span class="title class_">UserGeneric</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="在参数中自定义正则-—-适用范围区分同一路径不同参数的路由"><a href="#在参数中自定义正则-—-适用范围区分同一路径不同参数的路由" class="headerlink" title="在参数中自定义正则 — 适用范围区分同一路径不同参数的路由"></a>在参数中自定义正则 — 适用范围区分同一路径不同参数的路由</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 匹配 /o/3549</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/o/:orderId&#x27;</span> &#125;,</span><br><span class="line">  <span class="comment">// 匹配 /p/books</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/p/:productName&#x27;</span> &#125;,</span><br><span class="line">	<span class="comment">// /:orderId -&gt; 仅匹配数字</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/:orderId(\\d+)&#x27;</span> &#125;, </span><br><span class="line">  <span class="comment">// /:productName -&gt; 匹配其他任何内容</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/:productName&#x27;</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="可重复的参数"><a href="#可重复的参数" class="headerlink" title="可重复的参数"></a>可重复的参数</h3><ul>
<li>在参数后面添加 * 表示匹配(0~n)个参数：{ path: ‘&#x2F;:chapters*’ }</li>
<li>在参数后面添加 + 表示匹配(1~n)个参数：{ path: ‘&#x2F;:chapters+’ }</li>
<li>使用命名路由时该参数<span class="key_words">『需要传递一个数组』</span></li>
</ul>
<h2 id="Sensitive-与-strict-路由配置"><a href="#Sensitive-与-strict-路由配置" class="headerlink" title="Sensitive 与 strict 路由配置"></a>Sensitive 与 strict 路由配置</h2><ul>
<li>当 strict: true 时，只能匹配不带有尾部斜线的路由(&#x2F;xx&#x2F;)</li>
<li>当 sensitive: true 时，区分大小写</li>
<li>当前路由上的 strict 或 sensitive 可以覆盖全局<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:id?&#x27;</span>, <span class="attr">sensitive</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">// ?将参数(0个或一个)标记为可选，且参数不能重复</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="attr">strict</span>: <span class="literal">true</span>, <span class="comment">// 应用于全部路由</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="编程式导航-可参考vue2"><a href="#编程式导航-可参考vue2" class="headerlink" title="编程式导航(可参考vue2)"></a>编程式导航(可参考vue2)</h2><h3 id="字符串路径"><a href="#字符串路径" class="headerlink" title="字符串路径"></a>字符串路径</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(<span class="string">&#x27;/users/eduardo&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="带有路径的对象"><a href="#带有路径的对象" class="headerlink" title="带有路径的对象"></a>带有路径的对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/users/eduardo&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="命名的路由，并加上参数"><a href="#命名的路由，并加上参数" class="headerlink" title="命名的路由，并加上参数"></a>命名的路由，并加上参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">username</span>: <span class="string">&#x27;eduardo&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="带查询参数，结果是-register-plan-private"><a href="#带查询参数，结果是-register-plan-private" class="headerlink" title="带查询参数，结果是 &#x2F;register?plan&#x3D;private"></a>带查询参数，结果是 &#x2F;register?plan&#x3D;private</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="带-hash，结果是-about-team"><a href="#带-hash，结果是-about-team" class="headerlink" title="带 hash，结果是 &#x2F;about#team"></a>带 hash，结果是 &#x2F;about#team</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">hash</span>: <span class="string">&#x27;#team&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="router-push-—-向history栈添加一个新记录"><a href="#router-push-—-向history栈添加一个新记录" class="headerlink" title="router.push — 向history栈添加一个新记录"></a>router.push — <span class="desc">向history栈添加一个新记录</span></h3><h3 id="router-replace-—-类似router-push-但不会向history添加新记录"><a href="#router-replace-—-类似router-push-但不会向history添加新记录" class="headerlink" title="router.replace — 类似router.push,但不会向history添加新记录"></a>router.replace — <span class="desc">类似router.push,但不会向history添加新记录</span></h3><h3 id="router-go-整数作参-—-表示在历史堆前进或退后几步"><a href="#router-go-整数作参-—-表示在历史堆前进或退后几步" class="headerlink" title="router.go(整数作参) — 表示在历史堆前进或退后几步"></a>router.go(整数作参) — <span class="desc">表示在历史堆前进或退后几步</span></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">go</span>(<span class="number">1</span>)	<span class="comment">// 前进一条记录</span></span><br><span class="line">router.<span class="title function_">go</span>(-<span class="number">1</span>) <span class="comment">// 返回一条记录</span></span><br></pre></td></tr></table></figure>

<h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><ul>
<li>同时展示多个视图，而不是嵌套展示。用于同一路由多个视图</li>
<li>在路由里面的components配置好多个组件，</li>
<li>然后页面的使用多个router-view标签，带有name属性的会跟默认视图同一级渲染，不带的则是嵌套渲染在同一个router-view标签，注意name的值要和组件的名字一样</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-view <span class="keyword">class</span>=<span class="string">&quot;view main-content&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view right-sidebar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;RightSidebar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: [&#123;</span><br><span class="line">		<span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">		<span class="attr">components</span>: &#123;</span><br><span class="line">			<span class="attr">default</span>: <span class="title class_">Home</span>,</span><br><span class="line">			<span class="title class_">LeftSidebar</span>,</span><br><span class="line">			<span class="title class_">RightSidebar</span>,<span class="comment">// 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h2><ul>
<li>配置在路由路由表上的路由</li>
</ul>
<h3 id="redirect：-重定向"><a href="#redirect：-重定向" class="headerlink" title="redirect： 重定向"></a>redirect： 重定向</h3><ul>
<li>直接写路径：redirect: ‘&#x2F;‘</li>
<li>重定向到命名路由：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;homepage&#x27;</span> &#125;</span><br></pre></td></tr></table></figure></li>
<li>重定向一个方法,动态：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123; </span><br><span class="line">	<span class="attr">path</span>: <span class="string">&#x27;/search/:searchText&#x27;</span>, </span><br><span class="line">	<span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;	<span class="comment">// 可以省略component</span></span><br><span class="line">		<span class="keyword">return</span> &#123; <span class="attr">path</span>: <span class="string">&#x27;search&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">q</span>: to.<span class="property">params</span>.<span class="property">searchText</span> &#125; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="alias：给路径起别名"><a href="#alias：给路径起别名" class="headerlink" title="alias：给路径起别名"></a>alias：给路径起别名</h3><h3 id="相对重定向"><a href="#相对重定向" class="headerlink" title="相对重定向"></a>相对重定向</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 将/users/123/posts重定向到/users/123/profile。</span></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/users/:id/posts&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 相对位置不以`/`开头</span></span><br><span class="line">			<span class="comment">// 或 &#123; path: &#x27;profile&#x27;&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;profile&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="将-props-传递给路由组件"><a href="#将-props-传递给路由组件" class="headerlink" title="将 props 传递给路由组件"></a>将 props 传递给路由组件</h2><ul>
<li>在路由表上的路由配置，路由参数和prop的参数名要相同</li>
<li>以数组形式传递：props: [‘id’]</li>
<li>以布尔值传递：把路由收到的所有 params 参数通过props传给该路由组件<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/user/:params&#x27;</span>,<span class="attr">props</span>:<span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>为每个有命名视图的路由定义props<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123; <span class="attr">default</span>: <span class="literal">true</span>, 命名视图路由名: <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure></li>
<li>函数模式：传递 query 参数通过props传递给组件<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: <span class="function"><span class="params">route</span> =&gt;</span> (&#123; <span class="attr">query</span>: route.<span class="property">query</span>.<span class="property">q</span> &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><ul>
<li>全局前置守卫 – <span class="desc">router.beforeEach</span></li>
<li>全局解析守卫	– <span class="desc">router.beforeResolve</span></li>
<li>全局后置钩子 – <span class="desc">router.afterEach</span></li>
<li>路由独享的守卫 – <span class="desc">routes 里面 beforeEnter 属性</span></li>
<li>组件内的守卫	– <span class="desc">在组件页面中使用的钩子：{beforeRouteEnter(){},beforeRouteUpdate(){},beforeRouteLeave(){}}</span></li>
</ul>
<h3 id="钩子的参数解析"><a href="#钩子的参数解析" class="headerlink" title="钩子的参数解析"></a>钩子的参数解析</h3><ul>
<li>to: 即将要进入的目标</li>
<li>from: 当前导航正要离开的路由</li>
<li>next：多调用一次</li>
<li>isAuthenticated：用户是否登录过</li>
<li>to.name !&#x3D;&#x3D; ‘路由名’ : 避免无限重定向</li>
<li>return false： 取消导航</li>
</ul>
<h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h3><ul>
<li>当一个导航触发时，全局前置守卫<span class="key_words">『按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve完之前一直处于等待中』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">name</span> !== <span class="string">&#x27;Login&#x27;</span> &amp;&amp; !isAuthenticated) <span class="title function_">next</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span> &#125;)</span><br><span class="line">  <span class="keyword">else</span> <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a>全局解析守卫</h3><ul>
<li><span class="key_words">『每次导航时都会触发』</span>，但是确保在导航被确认之前，同时在<span class="key_words">『所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用。是获取数据或执行任何其他操作』</span>（如果用户无法进入页面时你希望避免执行的操作）的理想位置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeResolve</span>(<span class="keyword">async</span> to =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">requiresCamera</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">askForCameraPermission</span>()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">NotAllowedError</span>) &#123;</span><br><span class="line">        <span class="comment">// ... 处理错误，然后取消导航</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 意料之外的错误，取消导航并把错误传给全局处理器</span></span><br><span class="line">        <span class="keyword">throw</span> error</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h3><ul>
<li><span class="key_words">『不接受next 函数也不改变导航本身』</span>,对于分析、更改页面标题、声明页面等辅助功能有用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, failure</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!failure) <span class="title function_">sendToAnalytics</span>(to.<span class="property">fullPath</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h3><ul>
<li>只在<span class="key_words">『进入路由时』</span>触发，不会在params、query或hash改变时触发，只有在<span class="key_words">『从一个不同的路由导航』</span>时，才会被触发。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">UserDetails</span>,</span><br><span class="line">    <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// reject the navigation</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h3><ul>
<li>beforeRouteEnter(to, from, next) {}<ul>
<li>在渲染该组件的对应路由被验证前调用</li>
<li>不能获取组件实例 this</li>
<li>因为当守卫执行时，组件实例还没被创建！<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">	<span class="title function_">next</span>(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">/* 通过vm访问组件实例*/</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>beforeRouteUpdate(to, from) {}<ul>
<li>在当前路由改变，但是该组件被复用时调用</li>
<li>举例: 对于一个带有动态参数的路径 &#x2F;users&#x2F;:id，在 &#x2F;users&#x2F;1 和 &#x2F;users&#x2F;2 之间跳转的时候，</li>
<li>由于会渲染同样的 UserDetails 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</li>
<li>因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 this</li>
</ul>
</li>
<li>beforeRouteLeave(to, from) {}<ul>
<li>在导航离开渲染该组件的对应路由时调用</li>
<li>与 beforeRouteUpdate 一样，它可以访问组件实例 this</li>
<li>通常用来预防用户在还未保存修改前突然离开<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span></span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> answer = <span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> (!answer) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="导航解析流程"><a href="#导航解析流程" class="headerlink" title="导航解析流程"></a>导航解析流程</h3><ol>
<li>导航被触发</li>
<li>在失活的组件里调用 beforeRouteLeave 守卫</li>
<li>调用全局的 beforeEach 守卫</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)</li>
<li>在路由配置里调用 beforeEnter</li>
<li>解析异步路由组件</li>
<li>在被激活的组件里调用 beforeRouteEnter</li>
<li>调用全局的 beforeResolve 守卫(2.5+)</li>
<li>导航被确认</li>
<li>调用全局的 afterEach 钩子</li>
<li>触发 DOM 更新</li>
<li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入</li>
</ol>
<h3 id="路由元信息-—-meta-属性添加附加信息，调用-route-meta"><a href="#路由元信息-—-meta-属性添加附加信息，调用-route-meta" class="headerlink" title="路由元信息 — meta 属性添加附加信息，调用$route.meta"></a>路由元信息 — <span class="desc">meta 属性添加附加信息，调用$route.meta</span></h3><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><ul>
<li>导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。</li>
<li>导航完成之前获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</li>
<li>导航完成后获取数据 — <span class="desc">会马上导航和渲染组件，然后在组件的 created 钩子中获取数据。</span><ul>
<li>在created()中watch路由参数，调用methods中的状态，展示一些状态，当然这些状态要在data中初始化</li>
</ul>
</li>
<li>在导航完成前获取数据 — <span class="desc">导航转入新的路由前获取数据</span><ul>
<li>在 beforeRouteEnter 守卫中获取数据，当数据获取成功后只调用 next方法。建议在数据获取期间，显示一些进度条或者别的指示</li>
</ul>
</li>
</ul>
<h2 id="Vue-Router-和-组合式API-在setup中使用"><a href="#Vue-Router-和-组合式API-在setup中使用" class="headerlink" title="Vue Router 和 组合式API(在setup中使用)"></a>Vue Router 和 组合式API(在setup中使用)</h2><ul>
<li>访问路由和当前路由：使用 useRouter和useRoute 替代this.$router和this.$route</li>
</ul>
<h3 id="组件内的API导航守卫"><a href="#组件内的API导航守卫" class="headerlink" title="组件内的API导航守卫"></a>组件内的API导航守卫</h3><ul>
<li>组合式API守卫可以用在任何 router-view标签 渲染的组件，不必像组件内守卫那样直接用在路由组件上</li>
<li>引入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onBeforeRouteLeave, onBeforeRouteUpdate &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>除了不能访问this其它一样</li>
</ul>
<h3 id="useLink-扩展RouterLink"><a href="#useLink-扩展RouterLink" class="headerlink" title="useLink &#x2F; 扩展RouterLink"></a>useLink &#x2F; 扩展RouterLink</h3><ul>
<li>页面存在router-link标签：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link v-solt=<span class="string">&quot;&#123;props1, props2, props3&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li>编码时引入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouterLink</span>, useLink &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>在props配置项中使用： …RouterLink.props 传入router-link标签上的props</li>
<li>在setup中传入props： setup(props){} </li>
<li>拿到props: 在setup中使用 useLink(props) 并通过解构的方式拿到</li>
</ul>
<h2 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a>过渡动效</h2><h3 id="在路径组件上使用转场，并对导航进行动画处理"><a href="#在路径组件上使用转场，并对导航进行动画处理" class="headerlink" title="在路径组件上使用转场，并对导航进行动画处理"></a>在路径组件上使用转场，并对导航进行动画处理</h3><ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-view v-slot=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;fade&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span></span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="单个路由的过渡-—-元信息meta和上的动态的name"><a href="#单个路由的过渡-—-元信息meta和上的动态的name" class="headerlink" title="单个路由的过渡 — 元信息meta和上的动态的name"></a>单个路由的过渡 — <span class="desc">元信息meta和<transition>上的动态的name</span></h3><ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123;</span><br><span class="line">	<span class="attr">path</span>: <span class="string">&#x27;/custom-transition&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>: <span class="title class_">PanelLeft</span>,</span><br><span class="line">	<span class="attr">meta</span>: &#123; <span class="attr">transition</span>: <span class="string">&#x27;slide-left&#x27;</span> &#125;,</span><br><span class="line">&#125;,]</span><br><span class="line">&lt;router-view v-slot=<span class="string">&quot;&#123; Component, route &#125;&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">&quot;route.meta.transition || &#x27;fade&#x27; &quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span></span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基于路由的动态过渡-—-根据路径的深度动态添加信息到-meta-字段"><a href="#基于路由的动态过渡-—-根据路径的深度动态添加信息到-meta-字段" class="headerlink" title="基于路由的动态过渡 — 根据路径的深度动态添加信息到 meta 字段"></a>基于路由的动态过渡 — <span class="desc">根据路径的深度动态添加信息到 meta 字段</span></h3><ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-view v-slot=<span class="string">&quot;&#123; Component, route &#125;&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">&quot;route.meta.transition&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span></span><br><span class="line">&lt;/router-view&gt;</span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> toDepth = to.<span class="property">path</span>.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> fromDepth = <span class="keyword">from</span>.<span class="property">path</span>.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="property">length</span></span><br><span class="line">  to.<span class="property">meta</span>.<span class="property">transition</span> = toDepth &lt; fromDepth ? <span class="string">&#x27;slide-right&#x27;</span> : <span class="string">&#x27;slide-left&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="强制在复用的视图之间进行过渡"><a href="#强制在复用的视图之间进行过渡" class="headerlink" title="强制在复用的视图之间进行过渡"></a>强制在复用的视图之间进行过渡</h3><ul>
<li>在component标签上再添加一个 key 属性来强制过渡</li>
</ul>
<h2 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h2><ul>
<li><span class="desc">只在支持 history.pushState 的浏览器中可用</span></li>
</ul>
<h3 id="创建router时提供scrollBehavior-to-from-savedPosition-方法"><a href="#创建router时提供scrollBehavior-to-from-savedPosition-方法" class="headerlink" title="创建router时提供scrollBehavior(to, from, savedPosition){}方法"></a>创建router时提供scrollBehavior(to, from, savedPosition){}方法</h3><ul>
<li>savedPosition由浏览器的后退&#x2F;前进按钮触发</li>
<li>return返回期望滚到那个位置</li>
<li>始终滚动到顶部：return { top: 0 }</li>
<li>不滚动：return false | return null</li>
<li>按下后退&#x2F;前进按钮时就会像浏览器原生表现： return savedPosition</li>
</ul>
<h3 id="可以返回一个ScrollToOptions位置对象"><a href="#可以返回一个ScrollToOptions位置对象" class="headerlink" title="可以返回一个ScrollToOptions位置对象"></a>可以返回一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll">ScrollToOptions</a>位置对象</h3><h3 id="通过el传递一个CSS选择器或者一个DOM元素，此时top和left将被视为该元素的相对偏移量"><a href="#通过el传递一个CSS选择器或者一个DOM元素，此时top和left将被视为该元素的相对偏移量" class="headerlink" title="通过el传递一个CSS选择器或者一个DOM元素，此时top和left将被视为该元素的相对偏移量"></a>通过el传递一个CSS选择器或者一个DOM元素，此时top和left将被视为该元素的相对偏移量</h3><ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="title function_">scrollBehavior</span>(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">el</span>: <span class="string">&#x27;#main&#x27;</span>,</span><br><span class="line">      <span class="attr">top</span>: -<span class="number">10</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="滚动到锚点行为"><a href="#滚动到锚点行为" class="headerlink" title="滚动到锚点行为"></a>滚动到锚点行为</h3><ul>
<li>return 时添加behavior: ‘smooth’这个配置</li>
</ul>
<h3 id="延迟滚动"><a href="#延迟滚动" class="headerlink" title="延迟滚动"></a>延迟滚动</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;延时器&#125;), <span class="comment">// 可以返回所需的位置描述符</span></span><br></pre></td></tr></table></figure>

<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><h3 id="动态导入代替静态导入"><a href="#动态导入代替静态导入" class="headerlink" title="动态导入代替静态导入"></a>动态导入代替静态导入</h3><ul>
<li>不使用import…from…使用 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 组件名 = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;路径&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>路由配置的<span class="key_words">『component接受一个返回Promise组件的函数，vue router只会在第一次进入页面时才会获取』</span>这个函数，然后使用缓存数据，不要在路由中使用异步组件<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">UserDetail</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(&#123;<span class="comment">/*组件定义*/</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="把组件按组分块"><a href="#把组件按组分块" class="headerlink" title="把组件按组分块"></a>把组件按组分块</h3><ul>
<li>使用webpack — <span class="desc">把某个路由下的所有组件都打包在同个异步块chunk中</span><ul>
<li>webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中</li>
<li>即使用动态路径导入<span class="key_words">『多个路径不同组件名相同的文件』</span></li>
</ul>
</li>
<li>使用Vite<ul>
<li>在vite.config.js文件下的build –&gt; rollupOptions –&gt; output –&gt; manualChunks中配置</li>
<li>以’组名’: [‘路径1’,’路径2’,’路径3’]的形式添加到manualChunks中</li>
</ul>
</li>
</ul>
<h2 id="导航故障"><a href="#导航故障" class="headerlink" title="导航故障"></a>导航故障</h2><h3 id="等待导航结果"><a href="#等待导航结果" class="headerlink" title="等待导航结果"></a>等待导航结果</h3><ul>
<li>导航是异步的，返回Promise：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> router.<span class="title function_">push</span>(<span class="string">&#x27;/my-profile&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>导航到新页面后隐藏菜单：this.isMenuOpen &#x3D; false</li>
</ul>
<h3 id="检测导航故障-—-失败返回false"><a href="#检测导航故障-—-失败返回false" class="headerlink" title="检测导航故障 — 失败返回false"></a>检测导航故障 — <span class="desc">失败返回false</span></h3><ul>
<li>引入<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavigationFailureType</span>, isNavigationFailure &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>将异步导航赋值给一个变量</li>
<li>检测<span class="key_words">『试图离开未保存的编辑文本界面』</span>并在其中对用户进行提示操作：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_">isNavigationFailure</span>(failure, <span class="title class_">NavigationFailureType</span>.<span class="property">aborted</span>))&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="鉴别导航故障"><a href="#鉴别导航故障" class="headerlink" title="鉴别导航故障"></a>鉴别导航故障</h3><ul>
<li>aborted：在导航守卫中返回false中断了本次导航</li>
<li>cancelled：在当前导航还没有完成之前又有了一个新的导航</li>
<li>duplicated：导航被阻止，因为我们已经在目标位置了</li>
</ul>
<h3 id="导航故障属性"><a href="#导航故障属性" class="headerlink" title="导航故障属性"></a>导航故障属性</h3><ul>
<li>所有的导航失败都会暴露 to 和 from 属性</li>
<li>failure.to.path：反映失败导航的当前位置</li>
<li>failure.from.path：反映失败导航的目标位置</li>
</ul>
<h3 id="检测重定向-—-不会阻止导航，而是创建一个新导航"><a href="#检测重定向-—-不会阻止导航，而是创建一个新导航" class="headerlink" title="检测重定向 — 不会阻止导航，而是创建一个新导航"></a>检测重定向 — <span class="desc">不会阻止导航，而是创建一个新导航</span></h3><ul>
<li>redirectedFrom 是解析出的路由地址，就像导航守卫中的 to和 from</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (router.<span class="property">currentRoute</span>.<span class="property">value</span>.<span class="property">redirectedFrom</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><h3 id="查看现有路由"><a href="#查看现有路由" class="headerlink" title="查看现有路由"></a>查看现有路由</h3><ul>
<li>检查路由是否存在：router.hasRoute()</li>
<li>获取一个包含所有路由记录的数组：router.getRoutes()</li>
</ul>
<h3 id="添加嵌套路由"><a href="#添加嵌套路由" class="headerlink" title="添加嵌套路由"></a>添加嵌套路由</h3><ul>
<li>使用 router.addRoute 来添加路由</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">addRoute</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;admin&#x27;</span>, <span class="attr">path</span>: <span class="string">&#x27;/admin&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Admin</span> &#125;)</span><br><span class="line">router.<span class="title function_">addRoute</span>(<span class="string">&#x27;admin&#x27;</span>, &#123; <span class="attr">path</span>: <span class="string">&#x27;settings&#x27;</span>, <span class="attr">component</span>: <span class="title class_">AdminSettings</span> &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除路由-—-所有别名和子路由也会被删除"><a href="#删除路由-—-所有别名和子路由也会被删除" class="headerlink" title="删除路由 — 所有别名和子路由也会被删除"></a>删除路由 — <span class="desc">所有别名和子路由也会被删除</span></h3><ul>
<li>方法一：使用 router.addRoute 添加一个name相同的路由</li>
<li>方法二：调用 router.addRoute 返回的回调，存在就删除</li>
<li>方法三：使用 router.removeRoute(‘name’)</li>
<li>注：<span class="desc">当路由被删除时，所有的别名和子路由也会被同时删除</span></li>
</ul>
<h3 id="在导航守卫中添加路由"><a href="#在导航守卫中添加路由" class="headerlink" title="在导航守卫中添加路由"></a>在导航守卫中添加路由</h3><ul>
<li>hasNecessaryRoute()：在添加新的路由后返回 false，以避免无限重定向</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-常用的修饰符</title>
    <url>/2024/11/01/vue3/vue%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h1 id="五大类"><a href="#五大类" class="headerlink" title="五大类"></a>五大类</h1><ul>
<li>表单修饰符</li>
<li>事件修饰符</li>
<li>鼠标按键修饰符</li>
<li>键值修饰符</li>
<li>v-bind修饰符</li>
</ul>
<h2 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h2><ul>
<li>填写表单用的最多的是input标签，指令用的最多的是v-model</li>
</ul>
<h3 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;fname&quot;</span>&gt;</span>value: &#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;value&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fname&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>填完信息后，光标离开标签后，才将值赋给value，也就是change事件之后在进行信息同步</li>
</ul>
<h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><ul>
<li>自动过滤输入的首空格字符，而中间的空格不会过滤</li>
</ul>
<h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><ul>
<li>自动将用户的输入值转为数值类型，但如果这个值无法被parseFloat解析，则会返回原来的值</li>
</ul>
<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><ul>
<li><span class="key_words">『阻止事件冒泡』</span>,相当于调用event.stopPropagation方法</li>
</ul>
<h3 id="prevent"><a href="#prevent" class="headerlink" title="prevent"></a>prevent</h3><ul>
<li><span class="key_words">『阻止事件的默认行为』</span>，相当于调用了event.preventDefault方法</li>
</ul>
<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><ul>
<li>只当在 event.target 是当前元素自身时触发处理函数,<span class="key_words">『将事件绑定在自身身上，相当于阻止事件冒泡』</span></li>
</ul>
<h3 id="once"><a href="#once" class="headerlink" title="once"></a>once</h3><ul>
<li>绑定了事件以后<span class="key_words">『只能触发一次』</span>，第二次就不会触发</li>
</ul>
<h3 id="capture"><a href="#capture" class="headerlink" title="capture"></a>capture</h3><ul>
<li>使事件触发从<span class="key_words">『包含这个元素的顶层开始往下触发』</span></li>
</ul>
<h3 id="passive"><a href="#passive" class="headerlink" title="passive"></a>passive</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不要把.passive 和 .prevent 一起使用，因为.prevent将会被忽略</li>
<li><span class="key_words">『移动端』</span>，当我们在<span class="key_words">『监听元素滚动事件的时候，会一直触发onscroll』</span>事件会让我们的网页变卡，因此<code>使用</code>这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符</li>
</ul>
<h3 id="native"><a href="#native" class="headerlink" title="native"></a>native</h3><ul>
<li>让<span class="key_words">『组件』</span>变成像html内置标签那样<span class="key_words">『监听根元素的原生事件』</span>，否则组件上使用 v-on 只会监听自定义事件 </li>
<li>使用.native修饰符来操作普通HTML标签是会令事件失效</li>
</ul>
<h2 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h2><ul>
<li>left: 左键点击</li>
<li>right: 右键点击</li>
<li>middle: 中键点击</li>
</ul>
<h2 id="键盘修饰符"><a href="#键盘修饰符" class="headerlink" title="键盘修饰符"></a>键盘修饰符</h2><ul>
<li>用来修饰键盘事件(onkeyup, onkeydown)</li>
<li>.keyCode：监听特定键盘按下</li>
<li>普通键：enter、tab、delete、space、esc、up…</li>
<li>系统修饰符：ctrl、alt、meta、shift…</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">keyup.keyCode</span>=<span class="string">&quot;shout()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>自定义一些全局键盘码别名：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">keyCodes</span>.<span class="property">f2</span> = <span class="number">113</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="v-bind修饰符"><a href="#v-bind修饰符" class="headerlink" title="v-bind修饰符"></a>v-bind修饰符</h2><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><ul>
<li>能对props进行一个双向绑定</li>
<li>注意：</li>
<li>子组件传递的事件名格式必须为 update:value，其中value必须与子组件中props中声明的名称完全一致</li>
<li>带有.sync修饰符的v-bind不能和表达式一起使用</li>
<li>将v-bind。sync用在一个字面量的对象上，<span class="desc">例如v-bind.sync&#x3D;”{title: doc.title}”,是无法正常工作的</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;comp :myMessage.<span class="property">sync</span>=<span class="string">&quot;bar&quot;</span>&gt;&lt;/comp&gt;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:myMessage&#x27;</span>,params)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h3><ul>
<li>设置自定义标签属性，避免暴露数据，防止污染HTML结构</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;uid&quot;</span> title=<span class="string">&quot;title1&quot;</span> value=<span class="string">&quot;1&quot;</span> :index.<span class="property">prop</span>=<span class="string">&quot;index&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="camel"><a href="#camel" class="headerlink" title="camel"></a>camel</h3><ul>
<li>将命名变为驼峰命名法(viewBox)</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-快速上手</title>
    <url>/2024/11/01/vue3/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="vue概念"><a href="#vue概念" class="headerlink" title="vue概念"></a>vue概念</h2><ul>
<li>用于构建用户界面的 JavaScript 框架–渐进式框架。</li>
<li>基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型。</li>
</ul>
<h2 id="vue核心功能"><a href="#vue核心功能" class="headerlink" title="vue核心功能"></a>vue核心功能</h2><ul>
<li>声明式渲染：拓展了模板语法，描述HTML跟js状态间的关系</li>
<li>响应性：自动跟踪js状态并在发生变化时响应式的更新DOM</li>
</ul>
<h2 id="渐进式框架"><a href="#渐进式框架" class="headerlink" title="渐进式框架"></a>渐进式框架</h2><ul>
<li>无需构建步骤，渐进式增强静态的 HTML</li>
<li>在任何页面中作为 Web Components 嵌入</li>
<li>单页应用 (SPA)</li>
<li>全栈 &#x2F; 服务端渲染 (SSR)</li>
<li>Jamstack &#x2F; 静态站点生成 (SSG)</li>
<li>开发桌面端、移动端、WebGL，甚至是命令行终端中的界面</li>
</ul>
<h2 id="API风格"><a href="#API风格" class="headerlink" title="API风格"></a>API风格</h2><ul>
<li><h3 id="选项式-—-不适用构建工具-低复杂度"><a href="#选项式-—-不适用构建工具-低复杂度" class="headerlink" title="选项式 — 不适用构建工具&#x2F;低复杂度"></a>选项式 — <span class="desc">不适用构建工具&#x2F;低复杂度</span></h3><ul>
<li>包含多个选项的对象来描述组件的逻辑如，data、methods、mounted，选项中定义的属性都会暴露在函数内部的this，this指向当前组件实例</li>
</ul>
</li>
<li><h3 id="组合式API-—-完整单页面应用"><a href="#组合式API-—-完整单页面应用" class="headerlink" title="组合式API — 完整单页面应用"></a>组合式API — <span class="desc">完整单页面应用</span></h3><ul>
<li>使用导入的API函数来描述组件逻辑。通常搭配<code>&lt;script setup&gt;</code>使用</li>
</ul>
</li>
</ul>
<h2 id="vue3优点"><a href="#vue3优点" class="headerlink" title="vue3优点"></a>vue3优点</h2><ul>
<li>性能的提升<ul>
<li>打包大小减少41%</li>
<li>初次渲染快55%, 更新渲染快133%</li>
<li>内存减少54%</li>
</ul>
</li>
<li>源码的升级<ul>
<li>使用Proxy代替defineProperty实现响应式</li>
<li>重写虚拟DOM的实现和Tree-Shaking</li>
</ul>
</li>
<li>拥抱TypeScript</li>
<li>新的特性<ul>
<li>Composition API（组合API）<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
</ul>
</li>
<li>新的内置组件<ul>
<li>Fragment </li>
<li>Teleport<ul>
<li>Suspense</li>
</ul>
</li>
</ul>
</li>
<li>其他改变<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="创建项目-vite"><a href="#创建项目-vite" class="headerlink" title="创建项目 + vite"></a>创建项目 + vite</h2><ul>
<li><a href="E:/practice/study-notes/前端工程化笔记/vite.md">vite</a></li>
<li>node版本要16以上</li>
<li>使用<a href="https://github.com/vuejs/create-vue">create-vue</a></li>
<li>安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm create vue@latest</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><ul>
<li>文本插值：<code>&#123;&#123;&#125;&#125;</code></li>
<li>原始html：v-html&#x3D;””</li>
<li>Attribute绑定：(v-bind:xxx&#x3D;”” 简写 :xxx&#x3D;””)<ul>
<li>正常情况：值为null或undefined，attribute将会从渲染的元素上移除 </li>
<li>布尔型：值为真值或一个空字符串，元素会包含这个attribute；为其他假值时忽略</li>
<li>动态绑定多个值：对象包含多个属性。使用不带参的v-bind，绑定到单个元素上。<ul>
<li>v-bind&#x3D;”obj”</li>
</ul>
</li>
</ul>
</li>
<li>支持javascript表达式或者调用函数</li>
</ul>
<h2 id="指令-Directives"><a href="#指令-Directives" class="headerlink" title="指令(Directives)"></a>指令(Directives)</h2><ul>
<li>期望值为一个javascript表达式，表达式的值变化时响应式更新DOM</li>
<li>javascript表达式使用v-bind(:)，函数使用v-on(@)</li>
<li>参数：:xxx&#x3D;””</li>
<li>动态参数：:[字符串或null]&#x3D;””<ul>
<li>三限制：禁空格、禁引号、禁大写</li>
</ul>
</li>
<li>修饰符.：触发事件</li>
</ul>
<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><ul>
<li><a href="/2024/11/01/vue3/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/" title="VUE3-响应式原理">VUE3-响应式原理</a></li>
</ul>
<h2 id="常用-Composition-API"><a href="#常用-Composition-API" class="headerlink" title="常用 Composition API"></a>常用 Composition API</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><ul>
<li>代表使用组合式API，<code>&lt;script setup&gt;</code>是setup函数的语法糖</li>
<li><code>&lt;script setup&gt;</code>获取props，emit，context<ul>
<li>子组件引入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useContext, defineProps, defineEmit &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>emit：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> emit = <span class="title function_">defineEmit</span>([<span class="string">&#x27;父组件在子组件标签上传的事件名&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子组件的某个事件触发：</span></span><br><span class="line"><span class="title function_">emit</span>(<span class="string">&#x27;事件名&#x27;</span>, 子组件传递的数据) <span class="comment">// 父组件通过事件参数拿到</span></span><br></pre></td></tr></table></figure></li>
<li>ctx：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = <span class="title function_">useContext</span>()</span><br></pre></td></tr></table></figure></li>
<li>props：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123; 父组件在子组件标签上传的属性名: 该属性的类型 &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注意点：<ul>
<li><span class="desc">setup执行的时机</span><ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li><span class="desc">setup的参数</span><ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性</li>
<li>context：上下文对象<ul>
<li>attrs：值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs</li>
<li>slots：收到的插槽内容, 相当于 this.$slots</li>
<li>emit：分发自定义事件的函数, 相当于 this.$emit</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ref函数"><a href="#ref函数" class="headerlink" title="ref函数"></a>ref函数</h3><ul>
<li>作用: 声明一个响应式的状态</li>
<li>使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>语法: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xxx = <span class="title function_">ref</span>(initValue)</span><br></pre></td></tr></table></figure>
<ul>
<li>JS中操作数据：xxx.value</li>
<li>模板中读取数据: 不需要.value，直接：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>优点：<ul>
<li>深层响应性<ul>
<li>应用于任意值，即改变就会检测</li>
<li>shallow ref 可放弃深层响应性</li>
<li>非原始值将通过 reactive() 转换为响应式代理</li>
</ul>
</li>
<li>DOM更新时机<ul>
<li>更改响应式状态后，DOM会自动更新，但并不是同步</li>
<li>等待一个状态改变后的DOM更新完成，使用nextTick()</li>
</ul>
</li>
</ul>
</li>
<li>备注：<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li><span class="key_words">『基本类型』</span>的数据：响应式依然是靠 Object.defineProperty()的get与set 完成的。</li>
<li><span class="key_words">『对象类型』</span>的数据：使用 reactive 处理</li>
</ul>
</li>
</ul>
<h3 id="reactive函数"><a href="#reactive函数" class="headerlink" title="reactive函数"></a>reactive函数</h3><ul>
<li>作用: 定义一个<span class="key_words">『对象类型』</span>的响应式数据，返回一个<span class="key_words">『代理对象』</span>（Proxy的实例对象，简称proxy对象）</li>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 代理对象= <span class="title function_">reactive</span>(源对象) <span class="comment">// 接收一个对象（或数组）</span></span><br></pre></td></tr></table></figure></li>
<li>使用：<span class="key_words">『代理对象』</span></li>
<li>局限性：只能用于对象类型(对象、数组和Map、Set这样的集合类型)，并且不能替换整个对象，解构不友好</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h3 id="reactive-和-ref-区别"><a href="#reactive-和-ref-区别" class="headerlink" title="reactive 和 ref 区别"></a>reactive 和 ref 区别</h3><ul>
<li>从定义数据角度对比：<ul>
<li>ref用来定义：<span class="key_words">『基本类型数据』</span></li>
<li>reactive用来定义：<span class="key_words">『对象(或数组)类型数据』</span></li>
<li>注：ref也可以定义<span class="key_words">『对象(或数组)类型』</span>数据, 它内部会自动通过 reactive 转为代理对象</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li>ref通过 Object.defineProperty()的get与set 来实现响应式(数据劫持)</li>
<li>reactive通过使用 Proxy 来实现响应式(数据劫持), 并通过<span class="key_words">『Reflect操作源对象』</span>内部的数据</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li>ref定义的数据：操作数据<span class="key_words">『需要.value』</span>，读取数据时模板中直接读取<span class="key_words">『不需要.value』</span></li>
<li>reactive定义的数据：操作数据与读取数据：<span class="key_words">『均不需要.value』</span></li>
</ul>
</li>
</ul>
<h3 id="⭐-计算属性computed-—-依赖响应式状态的复杂逻辑"><a href="#⭐-计算属性computed-—-依赖响应式状态的复杂逻辑" class="headerlink" title="⭐ 计算属性computed — 依赖响应式状态的复杂逻辑"></a>⭐ 计算属性computed — <span class="desc">依赖响应式状态的复杂逻辑</span></h3><ul>
<li>与Vue2中computed配置功能一致☞<a href="/2024/11/01/vue2/%E5%9F%BA%E7%A1%80/" title="VUE2-基础（主了解）">VUE2-基础（主了解）</a></li>
<li>计算属性值会基于其响应式依赖被缓存，只有依赖改变才会去重新计算</li>
<li>写法：<ul>
<li>引入钩子：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">computed</span>(<span class="function">()=&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="侦听器-watch-—-在状态变化时执行一些“副作用”"><a href="#侦听器-watch-—-在状态变化时执行一些“副作用”" class="headerlink" title="侦听器 watch — 在状态变化时执行一些“副作用”"></a>侦听器 watch — <span class="desc">在状态变化时执行一些“副作用”</span></h3><ul>
<li>与Vue2中watch配置功能一致☞<a href="/2024/11/01/vue2/%E5%9F%BA%E7%A1%80/" title="VUE2-基础（主了解）">VUE2-基础（主了解）</a></li>
<li>两个小“坑”：<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视(deep配置失效)</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效</li>
</ul>
</li>
<li>写法：<ul>
<li>引入钩子：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>基本使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(变量,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>监视多个ref定义的响应式数据：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>([变量<span class="number">1</span>,变量<span class="number">2</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>监视reactive定义的响应式数据中的某个属性(监视的是对象中的某个属性，所以deep配置有效)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>对象.属性,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>监视reactive定义的响应式数据中的多个属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>对象.属性,<span class="function">()=&gt;</span>对象.属性<span class="number">2</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="深层侦听器"><a href="#深层侦听器" class="headerlink" title="深层侦听器"></a>深层侦听器</h4><ul>
<li>使用 deep: true 开启，开销很大，无必要不使用</li>
</ul>
<h4 id="即时回调的侦听器"><a href="#即时回调的侦听器" class="headerlink" title="即时回调的侦听器"></a>即时回调的侦听器</h4><ul>
<li>使用 immediate: true 开启</li>
</ul>
<h4 id="watchEffect函数"><a href="#watchEffect函数" class="headerlink" title="watchEffect函数"></a>watchEffect函数</h4><ul>
<li>watch的套路是：既要指明监视的属性，也要指明监视的回调。</li>
<li>watchEffect的套路是：<span class="key_words">『不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性』</span></li>
<li>使用：watchEffect(()&#x3D;&gt;{})</li>
<li>注：<span class="desc">仅会在其同步执行期间，才追踪依赖。在使用异步回调时，只有在第一个 await 正常工作前访问到的属性才会被追踪。</span></li>
</ul>
<h4 id="回调的触发时机"><a href="#回调的触发时机" class="headerlink" title="回调的触发时机"></a>回调的触发时机</h4><ul>
<li>默认，用户创建的侦听器回调，都会在<span class="key_words">『Vue 组件更新前被调用』</span></li>
<li>在侦听器回调中能访问被 <span class="key_words">『Vue 更新之后的 DOM，指明 flush: ‘post’ 选项』</span></li>
</ul>
<h4 id="停止侦听器"><a href="#停止侦听器" class="headerlink" title="停止侦听器"></a>停止侦听器</h4><ul>
<li>场景：用异步回调创建一个侦听器，它不会绑定到当前组件上，必须手动停止它，以防内存泄漏</li>
<li>停止一个侦听器：调用 watch 或 watchEffect 返回的函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="title function_">unwatch</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="⭐-生命周期钩子"><a href="#⭐-生命周期钩子" class="headerlink" title="⭐ 生命周期钩子"></a>⭐ 生命周期钩子</h2><p><img src="/../../img/vue3/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90.png" alt="vue生命周期钩子"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Vue3可继续使用Vue2的生命周期钩子，但有两个更名：<ul>
<li>beforeDestroy 改名为 beforeUnmount</li>
<li>destroyed 改名为 unmounted</li>
</ul>
</li>
</ul>
<h3 id="Vue3的Composition-API-形式的生命周期钩子，与Vue2中钩子对应关系如下：-vue3-vue2"><a href="#Vue3的Composition-API-形式的生命周期钩子，与Vue2中钩子对应关系如下：-vue3-vue2" class="headerlink" title="Vue3的Composition API 形式的生命周期钩子，与Vue2中钩子对应关系如下：(vue3:vue2)"></a>Vue3的Composition API 形式的生命周期钩子，与Vue2中钩子对应关系如下：(vue3:vue2)</h3><ul>
<li>beforeCreate &#x3D;&#x3D;&gt; setup()</li>
<li>created &#x3D;&#x3D;&gt; setup()</li>
<li>beforeMount &#x3D;&#x3D;&gt; onBeforeMount</li>
<li>mounted &#x3D;&#x3D;&gt; onMounted</li>
<li>beforeUpdate &#x3D;&#x3D;&gt; onBeforeUpdate</li>
<li>updated &#x3D;&#x3D;&gt; onUpdated</li>
<li>beforeUnmount &#x3D;&#x3D;&gt; onBeforeUnmount</li>
<li>unmounted &#x3D;&#x3D;&gt; onUnmounted</li>
</ul>
<h3 id="vue3生命周期钩子的作用"><a href="#vue3生命周期钩子的作用" class="headerlink" title="vue3生命周期钩子的作用"></a>vue3生命周期钩子的作用</h3><ul>
<li>beforeCreate<ul>
<li>在组件实例初始化完成后立即调用，data() 和 computed 等选项处理之前立即调用</li>
</ul>
</li>
<li>created<ul>
<li>已完成响应式数据、计算属性、方法和侦听器。</li>
<li>然而，此时挂载阶段还未开始，因此 $el 属性仍不可用</li>
</ul>
</li>
<li>beforeMount<ul>
<li>在组件被挂载之前调用，还没创建DOM节点</li>
</ul>
</li>
<li>mounted<ul>
<li>在组件挂载之后调用，所有同步子组件都已经被挂载。</li>
<li>其自身的 DOM 树已经创建完成并插入了父容器中。</li>
<li>处理副作用</li>
</ul>
</li>
<li>beforeUpdate<ul>
<li>在组件即将因为一个响应式状态变更而更新其DOM树之前调用。</li>
<li>在 Vue 更新 DOM 之前访问 DOM 状态</li>
</ul>
</li>
<li>update<ul>
<li>在组件因为一个响应式状态变更而更新其 DOM 树之后调用。</li>
<li>父组件的更新钩子将在其子组件的更新钩子之后调用。</li>
<li>在组件的任意 DOM 更新后被调用</li>
</ul>
</li>
<li>beforeUnmount<ul>
<li>在一个组件实例被卸载之前调用</li>
<li>当这个钩子被调用时，组件实例依然还保有全部的功能</li>
</ul>
</li>
<li>unmounted<ul>
<li>在一个组件实例被卸载之后调用，</li>
<li>可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。</li>
</ul>
</li>
<li>activated<ul>
<li>组件实例是 KeepAlive标签 缓存树的一部分，当组件被插入到 DOM 中时调用</li>
</ul>
</li>
<li>deactivated<ul>
<li>组件实例是 KeepAlive标签 缓存树的一部分，当组件从 DOM 中被移除时调用</li>
</ul>
</li>
</ul>
<h3 id="组件生命周期执行路线"><a href="#组件生命周期执行路线" class="headerlink" title="组件生命周期执行路线"></a>组件生命周期执行路线</h3><h4 id="生命周期（父子组件）："><a href="#生命周期（父子组件）：" class="headerlink" title="生命周期（父子组件）："></a>生命周期（父子组件）：</h4><ul>
<li>父组件beforeCreate –&gt; 父组件created –&gt; 父组件beforeMount –&gt; 子组件beforeCreate –&gt; 子组件created –&gt; 子组件beforeMount –&gt; 子组件 mounted –&gt; 父组件mounted –&gt;父组件beforeUpdate –&gt;子组件beforeDestroy–&gt; 子组件destroyed –&gt; 父组件updated</li>
</ul>
<h4 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h4><ul>
<li>父beforeCreate –&gt; 父created –&gt; 父beforeMount –&gt; 子beforeCreate –&gt; 子created –&gt; 子beforeMount –&gt; 子mounted –&gt; 父mounted</li>
</ul>
<h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><ul>
<li>父created –&gt; 子created –&gt; 子mounted –&gt; 父mounted</li>
</ul>
<h4 id="父组件更新阶段"><a href="#父组件更新阶段" class="headerlink" title="父组件更新阶段"></a>父组件更新阶段</h4><ul>
<li>父beforeUpdate –&gt; 父updated</li>
</ul>
<h4 id="子组件更新阶段"><a href="#子组件更新阶段" class="headerlink" title="子组件更新阶段"></a>子组件更新阶段</h4><ul>
<li>父beforeUpdate –&gt; 子beforeUpdate –&gt; 子updated –&gt; 父updated</li>
</ul>
<h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><ul>
<li>父beforeDestroy –&gt; 子beforeDestroy –&gt; 子destroyed –&gt; 父destroyed</li>
</ul>
<h2 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h2><ul>
<li>ref：直接访问底层DOM元素，DOM 元素或子组件实例被挂载后，可以直接引用</li>
<li>使用：<ul>
<li>引入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view ref=<span class="string">&quot;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="v-for中的模板引用："><a href="#v-for中的模板引用：" class="headerlink" title="v-for中的模板引用："></a>v-for中的模板引用：</h3><ul>
<li>ref的值是数组 </li>
<li><span class="key_words">『ref 数组并不保证与源数组相同的顺序』</span></li>
</ul>
</li>
<li><h3 id="函数模板引用："><a href="#函数模板引用：" class="headerlink" title="函数模板引用："></a>函数模板引用：</h3><ul>
<li><span class="key_words">『:ref绑定为一个函数』</span>，函数会收到元素引用作为其第一个参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input :ref=<span class="string">&quot;(el) =&gt; &#123;&#125;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="组件上的ref："><a href="#组件上的ref：" class="headerlink" title="组件上的ref："></a>组件上的ref：</h3><ul>
<li>用在组件上获取的是组件实例</li>
</ul>
</li>
</ul>
<h2 id="其它-Composition-API"><a href="#其它-Composition-API" class="headerlink" title="其它 Composition API"></a>其它 Composition API</h2><h3 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a>shallowReactive 与 shallowRef</h3><ul>
<li>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</li>
<li>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</li>
<li>使用场景：<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; <span class="desc">shallowReactive</span></li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; <span class="desc">shallowRef</span></li>
</ul>
</li>
</ul>
<h3 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h3><ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h3 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h3><ul>
<li>toRaw：<ul>
<li>作用：将一个由 reactive 生成的<span class="key_words">『响应式对象转为普通对象』</span></li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象</li>
<li>应用场景:<ul>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><ul>
<li>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制</li>
<li>实现防抖效果：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;keyword&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;keyword&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123;ref,customRef&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="attr">name</span>:<span class="string">&#x27;Demo&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="title function_">setup</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="comment">//自定义一个myRef</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="keyword">function</span> <span class="title function_">myRef</span>(<span class="params">value,delay</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			<span class="keyword">let</span> timer</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			<span class="comment">//通过customRef去实现自定义</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			<span class="keyword">return</span> <span class="title function_">customRef</span>(<span class="function">(<span class="params">track,trigger</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">				<span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">					<span class="title function_">get</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">						<span class="title function_">track</span>() <span class="comment">//告诉Vue这个value值是需要被“追踪”的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">						<span class="keyword">return</span> value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">					&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">					<span class="title function_">set</span>(<span class="params">newValue</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">						<span class="built_in">clearTimeout</span>(timer)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">						timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">							value = newValue</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">							<span class="title function_">trigger</span>() <span class="comment">//告诉Vue去更新界面</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">						&#125;,delay)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">					&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">				&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="keyword">let</span> keyword = <span class="title function_">myRef</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="number">500</span>) <span class="comment">//使用程序员自定义的ref</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="keyword">return</span> &#123; keyword &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h3><ul>
<li>作用：<span class="key_words">『实现祖先与后代组件间通信』</span></li>
<li>套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据</li>
<li>具体写法：<ol>
<li>祖组件中：使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="string">&#x27;通信的别名&#x27;</span>,要传递的变量)</span><br></pre></td></tr></table></figure></li>
<li>后代组件中：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 得到的变量 = <span class="title function_">inject</span>(<span class="string">&#x27;通信的别名&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="响应式API：工具函数"><a href="#响应式API：工具函数" class="headerlink" title="响应式API：工具函数"></a>响应式API：工具函数</h3><ul>
<li>isRef(): 检查一个值是否为一个 ref 对象</li>
<li>unref(): 如果参数是 ref，则返回内部值，否则返回参数本身</li>
<li>isReactive(): 检查一个对象是否是由 reactive 创建的响应式代理</li>
<li>isReadonly(): 检查一个对象是否是由 readonly 创建的只读代理</li>
<li>isProxy(): 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理</li>
<li>toRef()：创建一个 ref 对象，其value值指向另一个对象中的某个属性。<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">toRef</span>(person,<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>toRefs(): 与 toRef 功能一致，值指向一个对象<ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">toRefs</span>(person)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h2><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><ul>
<li>定义: 将<span class="key_words">『组件html结构』</span>移动到指定位置的技术</li>
<li>使用：teleport标签包裹的内容是移动的内容，标签上指定to&#x3D;”移动位置”</li>
</ul>
<h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><ul>
<li>等待异步组件时渲染一些额外内容</li>
<li>使用步骤：<ul>
<li>引入钩子：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>异步引入组件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 组件名 = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;组件路径&#x27;</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 Suspense 包裹组件，并配置好对应插槽的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="全局API的转移"><a href="#全局API的转移" class="headerlink" title="全局API的转移"></a>全局API的转移</h3><ul>
<li>Vue 2 有许多全局 API 和配置在vue3中调整。<ul>
<li>将全局的API，即：Vue.xxx 调整到应用实例（app）上<table>
<thead>
<tr>
<th>全局 API</th>
<th>实例 API (app)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td>移除</td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="其他改变"><a href="#其他改变" class="headerlink" title="其他改变"></a>其他改变</h3><ul>
<li>data选项应始终被声明为一个函数。</li>
<li>过度类名的更改：.v-enter-from,.v-leave-to(vue3写法)</li>
<li>移除keyCode作为 v-on 的修饰符，同时也不再支持 config.keyCodes</li>
<li>移除 v-on.native修饰符</li>
<li>移除过滤器（filter）</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-源码系列</title>
    <url>/2024/11/01/vue3/vue%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><ul>
<li>最大的特点就是<span class="key_words">『数据驱动视图』</span></li>
<li>公式：UI &#x3D; render(state)     </li>
<li>解析：输入状态一旦改变，页面输出也随着改变，vue扮演render()</li>
</ul>
<h2 id="变化侦测-—-使用属性拦截的方式实现的"><a href="#变化侦测-—-使用属性拦截的方式实现的" class="headerlink" title="变化侦测 — 使用属性拦截的方式实现的"></a>变化侦测 — 使用属性拦截的方式实现的</h2><ul>
<li>释义：追踪状态，即数据一旦发生变化，就要去更新视图</li>
<li>vue：通过对比虚拟DOM–VNode类来实现侦测</li>
<li>react：通过对比虚拟DOM来实现侦测</li>
</ul>
<h2 id="数据变的“可观测”"><a href="#数据变的“可观测”" class="headerlink" title="数据变的“可观测”"></a>数据变的“可观测”</h2><ul>
<li>释义：知道数据什么时候被读取或改写</li>
<li>方法：通过 Object.defineProperty 方法，<span class="key_words">『只能观测Object的取值或写入，观测不到向object数据里添加或删除』</span>key&#x2F;value，但是可以用两个全局API：Vue.set和 Vue.delete解决</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = &#123;</span><br><span class="line">	<span class="string">&#x27;brand&#x27;</span>: <span class="string">&#x27;BMW&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;price&#x27;</span>: <span class="number">3000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car= &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> val=<span class="number">3000</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(car,<span class="string">&#x27;price&#x27;</span>,&#123;</span><br><span class="line">	<span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;price属性被读取&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> val</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="title function_">set</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;price属性被修改了&#x27;</span>)</span><br><span class="line">		val = newVal</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><ul>
<li>释义：把“谁用到了这个数据”称为“谁依赖了这个数据”</li>
<li>用法：在 getter 中收集依赖，在 setter 中通知依赖更新</li>
</ul>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><ul>
<li>释义：用一个JS对象来描述一个DOM节点</li>
<li>存在的原因：数据驱动视图会操作DOM，但操作真实DOM耗性能。</li>
<li>方法：对比变化前后的虚拟DOM节点，通过DOM-Diff算法计算出需要更新的地方，然后去更新需要更新的视图。</li>
</ul>
<h2 id="Vue中的虚拟DOM-—-VNode类"><a href="#Vue中的虚拟DOM-—-VNode类" class="headerlink" title="Vue中的虚拟DOM — VNode类"></a>Vue中的虚拟DOM — VNode类</h2><ul>
<li>释义：包含了描述一个真实DOM节点所需要的一系列属性</li>
<li>作用：<ul>
<li>在视图渲染之前，把写好的template模板先编译成VNode并缓存下来，等到数据发生变化页面需要重新渲染的时候，把变化后生成的VNode与前一次缓存下来的VNode进行对比，找出差异，然后有差异的VNode对应的真实DOM节点就是需要重新渲染的节点，最后根据有差异的VNode创建出真实的DOM节点再插入到视图中，最终完成一次视图更新。</li>
</ul>
</li>
</ul>
<h3 id="注释节点-源码"><a href="#注释节点-源码" class="headerlink" title="注释节点(源码)"></a>注释节点(源码)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createEmptyVNode = (<span class="attr">text</span>: string = <span class="string">&#x27;&#x27;</span> =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">VNode</span>()</span><br><span class="line">	node.<span class="property">text</span> = text <span class="comment">// 表示具体的注释信息</span></span><br><span class="line">	node.<span class="property">isComment</span> = <span class="literal">true</span> <span class="comment">// 标识一个节点是否是注释节点</span></span><br><span class="line">	<span class="keyword">return</span> node</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="文本节点-源码"><a href="#文本节点-源码" class="headerlink" title="文本节点(源码)"></a>文本节点(源码)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createTextVNode</span> (<span class="params">val: string | number</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>,unfined,<span class="title class_">String</span>(val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h3><ul>
<li>接近真实的DOM节点，反应到VNode节点上:tag表示标签名，data表示标签的属性id等，children表示子节点数组</li>
</ul>
<h3 id="组件节点"><a href="#组件节点" class="headerlink" title="组件节点"></a>组件节点</h3><ul>
<li>除了有元素节点具有的属性之外，它还有两个特有的属性：componentOptions、componentInstance</li>
</ul>
<h3 id="函数式组件节点"><a href="#函数式组件节点" class="headerlink" title="函数式组件节点"></a>函数式组件节点</h3><ul>
<li>相较于组件节点，它又有两个特有的属性：fnContext、fnOptions</li>
</ul>
<h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><ul>
<li>把现有节点的属性全部复制到新节点中，而现有节点和新克隆得到的节点之间唯一的不同就是克隆得到的节点isCloned为true</li>
</ul>
<h2 id="DOM-Diff-算法"><a href="#DOM-Diff-算法" class="headerlink" title="DOM-Diff 算法"></a>DOM-Diff 算法</h2><ul>
<li>释义：在vue中，把 DOM-Diff过程 叫做patch过程，意为”补丁”，<span class="key_words">『本质就是对比新旧两份VNode的过程』</span>,以新的VNode为基准，改造旧的oldNVNode使之成为跟新的VNode一样，这就是patch过程要干的事</li>
</ul>
<h3 id="创建节点-源码"><a href="#创建节点-源码" class="headerlink" title="创建节点(源码)"></a>创建节点(源码)</h3><ul>
<li>前提：<span class="key_words">『新的VNode中有而oldVNode中没有，就在oldVNode中创建』</span></li>
<li>方法：判断新的VNode中有而旧的VNode中没有的这个节点是属于元素节点、文本节点、注释节点中的哪一种，从而调用不同的方法创建并插入到DOM中 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>  <span class="title function_">createElm</span> (<span class="params">vnode, parentElm, refElm</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> tag = vode.<span class="property">tag</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="title function_">isDef</span>(tag))&#123;</span><br><span class="line">		vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createElement</span>(tag, vnode) <span class="comment">// 创建元素节点</span></span><br><span class="line">		<span class="title function_">createChildren</span>(vnode, vnode.<span class="property">children</span>, insertedVnodeQueue)	<span class="comment">// 创建元素节点的子节点</span></span><br><span class="line">		<span class="title function_">insert</span>(parentElm, vonode.<span class="property">elm</span>, refElm)	<span class="comment">// 插入到DOM中</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isTrue</span>(vnode,isComment)) &#123;</span><br><span class="line">		vnode.<span class="property">elm</span> = nodeDps.<span class="title function_">createComment</span>(vnode.<span class="property">text</span>) <span class="comment">// 创建注释节点</span></span><br><span class="line">		<span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>,refElm)	<span class="comment">// 插入到DOM中</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createTextNode</span>(vnode.<span class="property">text</span>)	<span class="comment">// 创建文本节点</span></span><br><span class="line">		<span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm)	<span class="comment">// 插入到DOM中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除节点-源码"><a href="#删除节点-源码" class="headerlink" title="删除节点(源码)"></a>删除节点(源码)</h3><ul>
<li>前提：<span class="key_words">『新的VNode中没有而oldVNode中有，就从oldVNode中删除』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeNode</span> (<span class="params">el</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> parent = nodeOps.<span class="title function_">parentNode</span>(el)  <span class="comment">// 获取父节点</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="title function_">isDef</span>(parent)) &#123;</span><br><span class="line">		nodeOps.<span class="title function_">removeChild</span>(parent, el)  <span class="comment">// 调用父节点的removeChild方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><ul>
<li>前提：新的VNode和旧的oldVNode中<span class="key_words">『都有，就以新的VNode为准』</span>，更新旧的oldVNode</li>
<li>如果VNode和oldVNode<span class="key_words">『均为静态节点,不处理』</span>，跳过</li>
<li>如果<span class="key_words">『VNode是文本节点』</span>,看oldVNode是否也是文本节点，<ul>
<li>是，就更新 oldVNode节点，</li>
<li>不是，直接调用 setTextNode 方法改成文本节点，并且内容与VNode相同</li>
</ul>
</li>
<li>如果<span class="key_words">『VNode是元素节点』</span><ul>
<li>该节点包含子节点,看oldVNode是否包含子节点<ul>
<li>是，就需要递归对比更新字节点。</li>
<li>不是，则oldVNode可能是空节点或者是文本节点。</li>
<li>空节点就把VNode的子节点创建一份然后插入到oldVNode节点里面。</li>
<li>文本节点则把文本清空，然后把VNode的子节点创建一份然后插入到oldVNode节点里面。</li>
</ul>
</li>
<li><span class="key_words">『不包含子节点,直接清空oldVNode里面的内容』</span></li>
</ul>
</li>
</ul>
<h2 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h2><ul>
<li>当新旧节点<span class="key_words">『都是元素节点但并且都包含子节点』</span>时，这两个节点的VNode实例上的<span class="key_words">『children属性就是所包含的子节点数组』</span>。</li>
<li>把newChildren里面的元素与oldChildren里的元素<span class="key_words">『一一进行对比，外层循环newChildren数组,内层循环oldChildren』</span>数组，每循环外层newChildren数组里的一个子节点，就去内层oldChildren数组里去找看有没有与之相同的子节点。</li>
</ul>
<h3 id="创建子节点"><a href="#创建子节点" class="headerlink" title="创建子节点"></a>创建子节点</h3><ul>
<li>newChildren的某个节点在oldChildren中找不到相同的子节点，就<span class="key_words">『创建节点，并插入到所有未处理节点之前』</span></li>
</ul>
<h3 id="删除子节点"><a href="#删除子节点" class="headerlink" title="删除子节点"></a>删除子节点</h3><ul>
<li>newChildren里面的每一个子节点都<span class="key_words">『循环完毕』</span>，发现oldChildren还有未处理子节点，则<span class="key_words">『删除未处理子节点』</span></li>
</ul>
<h3 id="移动子节点"><a href="#移动子节点" class="headerlink" title="移动子节点"></a>移动子节点</h3><ul>
<li>newChildren的某个节点在oldChildren中找到相同的子节点，但位置不同，就以newChildren为基准，调整oldChildren里节点的位置.<span class="key_words">『所有未处理节点之前就是我们要移动的目的位置』</span></li>
</ul>
<h3 id="更新节点-1"><a href="#更新节点-1" class="headerlink" title="更新节点"></a>更新节点</h3><ul>
<li>newChildren的某个节点在oldChildren中找到<span class="key_words">『相同的子节点，位置相同』</span>，就更新oldChildren节点</li>
</ul>
<h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><ul>
<li>新前与旧前<ul>
<li>把newChildren数组里的<span class="key_words">『所有未处理子节点的第一个子节点』</span>和oldChildren数组里所有未处理子节点的第一个子节点比对<ul>
<li>相同,更新节点,并且不需要移动节点</li>
<li>不同, 往下</li>
</ul>
</li>
</ul>
</li>
<li>新后与旧后<ul>
<li>把newChildren数组里的<span class="key_words">『所有未处理子节点的最后一个子节点』</span>和oldChildren数组里所有未处理子节点的最后一个子节点比对 </li>
<li>相同,更新节点,并且不需要移动节点<ul>
<li>不同, 往下</li>
</ul>
</li>
</ul>
</li>
<li>新后与旧前<ul>
<li>把newChildren数组里的<span class="key_words">『所有未处理子节点的最后一个子节点』</span>和oldChildren数组里<span class="key_words">『所有未处理子节点的第一个子节点』</span>比对 </li>
<li>相同,更新节点,再将oldChildren数组里的该节点移动到与newChildren数组里节点相同的位置<ul>
<li>不同, 往下</li>
</ul>
</li>
</ul>
</li>
<li>新前与旧后<ul>
<li>把newChildren数组里的<span class="key_words">『所有未处理子节点的第一个子节点』</span>和oldChildren数组里<span class="key_words">『所有未处理子节点的最后一个子节点』</span>比对 </li>
<li>相同,更新节点,再将oldChildren数组里的该节点移动到与newChildren数组里节点相同的位置<ul>
<li>不同, 使用之前的循环方式查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="模板编译-用户写的模板进行编译，就会产生VNode"><a href="#模板编译-用户写的模板进行编译，就会产生VNode" class="headerlink" title="模板编译 (用户写的模板进行编译，就会产生VNode)"></a>模板编译 (用户写的模板进行编译，就会产生VNode)</h2><blockquote>
<p>把用户在 template标签 中写的类似于原生HTML的内容进行编译，把原生HTML的内容找出来，再把非原生HTML找出来，经过一系列的逻辑处理生成渲染函数 — 即<span class="key_words">『render函数的过程』</span></p>
</blockquote>
<h3 id="抽象语法树AST"><a href="#抽象语法树AST" class="headerlink" title="抽象语法树AST"></a>抽象语法树AST</h3><ul>
<li>释义：以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</li>
</ul>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul>
<li>将用户在 template标签中写的模板解析并提取除元素、属性、变量插值</li>
</ul>
<h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><ul>
<li>模板解析阶段<ul>
<li>将一堆模板字符串用正则等方式解析成AST</li>
<li>模板解析阶段——解析器——源码路径：src&#x2F;compiler&#x2F;parser&#x2F;index.js</li>
</ul>
</li>
<li>优化阶段<ul>
<li>遍历AST，找出其中的静态节点，并打上标记</li>
<li>优化阶段——优化器——源码路径：src&#x2F;compiler&#x2F;optimizer.js</li>
<li>静态节点 — <span class="desc">全是文本没有动态的变量</span></li>
<li>静态根节点 — <span class="desc">包含静态节点的容器</span></li>
</ul>
</li>
<li>代码生成阶段<ul>
<li>将AST转换成渲染函数</li>
<li>代码生成阶段——代码生成器——源码路径：src&#x2F;compiler&#x2F;codegen&#x2F;index.js</li>
<li>方法：根据已有的AST生成对应的render函数供组件挂载时调用，组件只要调用的这个render函数就可以得到AST对应的虚拟DOM的VNode</li>
<li>元素节点<ul>
<li>_c(tagName,data,children)</li>
<li>tagName:节点标签名；</li>
<li>data：节点属性；判断plain属性是否为true，true则表示节点没有属性，将data赋值为undefined；不为true则调用genData函数获取节点属性data数据</li>
<li>chiledren：节点的子节点列表；遍历AST的children属性中的元素，然后根据元素属性的不同生成不同的VNode创建函数调用字符串</li>
</ul>
</li>
<li>文本节点<ul>
<li>_v(text)</li>
<li>如果文本是动态文本，则使用动态文本AST节点的expression属性，如果是纯静态文本，则使用text属性</li>
</ul>
</li>
<li>注释节点<ul>
<li>_e(text)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><blockquote>
<p>就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成AST</p>
</blockquote>
<ul>
<li>HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。</li>
<li>HTML解析器: 源码中，HTML解析器就是parseHTML函数</li>
<li>内部运行流程<ul>
<li>当解析开始，调用start (tag, attrs, unary) {}</li>
<li>当解析结束，调用end () {}</li>
<li>当解析到文本时，调用chars (text) {}</li>
<li>当解析到注释时，调用comment (text) {}</li>
</ul>
</li>
<li>html解析器内容解析<ul>
<li>解析HTML注释：找以<span class="key_words">『<code>&lt;!--</code>』</span>开头，并且后面有<span class="key_words">『<code>--&gt;</code>』</span>结尾</li>
<li>解析条件注释：找以<span class="key_words">『&lt;![』</span>开头，并且后面存在<span class="key_words">『]&gt;』</span>结尾</li>
<li>解析DOCTYPE：匹配是否存在<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^&lt;!<span class="variable constant_">DOCTYPE</span> [^&gt;]+&gt;/i</span><br></pre></td></tr></table></figure></li>
<li>解析开始标签：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">html.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(^&lt;((?:([a-zA-<span class="variable constant_">Z_</span>][\\w\\-\\.]*)\\:)?([a-zA-<span class="variable constant_">Z_</span>][\\w\\-\\.]*))))</span><br></pre></td></tr></table></figure></li>
<li>解析结束标签：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">html.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(^<span class="language-xml">&lt;\\/((?:([a-zA-Z_][\\w\\-\\.]*)\\:)?([a-zA-Z_][\\w\\-\\.]*))[^&gt;]*&gt;))</span></span><br></pre></td></tr></table></figure></li>
<li>解析文本：判断字符串是不是以<span class="key_words">『&lt;』</span>开头，不是就是文本<br><img src="/../../img/vue3/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="生命周期流程图"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h2 id="生命周期-—-vue实例的生命周期大致分为4个阶段"><a href="#生命周期-—-vue实例的生命周期大致分为4个阶段" class="headerlink" title="生命周期 — vue实例的生命周期大致分为4个阶段"></a>生命周期 — vue实例的生命周期大致分为4个阶段</h2><h3 id="初始化阶段：为Vue实例上初始化一些属性，事件以及响应式数据"><a href="#初始化阶段：为Vue实例上初始化一些属性，事件以及响应式数据" class="headerlink" title="初始化阶段：为Vue实例上初始化一些属性，事件以及响应式数据"></a>初始化阶段：<span class="desc">为Vue实例上初始化一些属性，事件以及响应式数据</span></h3><ul>
<li>new Vue() — <span class="desc">创建一个vue实例</span><ul>
<li>作用：<ul>
<li><span class="key_words">『执行了vue类的构造函数，构造函数会执行_init方法』</span>。</li>
<li>_init方法把Vue实例赋值给变量vm，并且把用户传递的 options选项 与当前构造函数的 options属性 及其父级构造函数的 options<span class="key_words">『属性合并』</span>，得到新的options选项<span class="key_words">『赋值给$options属性，并将$options属性挂载到vue』</span>实例。</li>
<li>接着，调用一些<span class="key_words">『初始化函数』</span>来为Vue实例初始化一些属性，事件，响应式数据。</li>
<li>在所有的<span class="key_words">『初始化工作都完成以后，会判断用户是否传入了el选项，传入了则调用 $mount』</span>函数进入模板编译与挂载阶段，<span class="key_words">『没有传入el选项，需要用户手动执行 vm.$mount』</span>方法才进入下一个生命周期阶段。</li>
</ul>
</li>
</ul>
</li>
<li>initLifecycle函数— <span class="desc">初始化了一些属性，包括以$开头的供用户使用的外部属性，也包括以_开头的供内部使用的内部属性。</span><ul>
<li>作用：给Vue实例上挂载了一些属性并设置了默认值，值得一提的是挂载$parent属性和$root属性。</li>
</ul>
</li>
<li>initEvents函数 — <span class="desc">初始化实例的事件系统</span><ul>
<li>作用：初始化的是父组件在模板中使用v-on或@注册的监听子组件内触发的事件</li>
</ul>
</li>
<li>initInjections函数 — <span class="desc">初始化实例中的inject选项的</span></li>
<li>initState函数 — <span class="desc">初始化实例的状态选项(props、data、methods、computed、watch)</span></li>
</ul>
<h3 id="模板编译阶段：将模板编译成渲染函数；只存在与完整版-有编译器"><a href="#模板编译阶段：将模板编译成渲染函数；只存在与完整版-有编译器" class="headerlink" title="模板编译阶段：将模板编译成渲染函数；只存在与完整版(有编译器)"></a>模板编译阶段：将模板编译成渲染函数；只存在与完整版(有编译器)</h3><ul>
<li>调用vm.$mount标志着初始化阶段的结束和进入模板编译阶段。</li>
<li>完整版的$mount会先将$mount方法缓存起来，记作mount。然后等模板编译完成，再执行mount方法</li>
<li>作用：从用户传入的el选项和template选项中获取到用户传入的内部或外部模板，然后将获取到的模板编译成渲染函数</li>
</ul>
<h3 id="挂载阶段：将实例挂载到指定的DOM上，即将模板渲染到真实DOM中；"><a href="#挂载阶段：将实例挂载到指定的DOM上，即将模板渲染到真实DOM中；" class="headerlink" title="挂载阶段：将实例挂载到指定的DOM上，即将模板渲染到真实DOM中；"></a>挂载阶段：将实例挂载到指定的DOM上，即将模板渲染到真实DOM中；</h3><ul>
<li>作用：创建Vue实例并用其替换el选项对应的DOM元素，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。</li>
<li>将模板渲染到视图上，第二部分是开启对模板中数据的监控，直到实例被销毁，挂在阶段完成，调用mounted</li>
</ul>
<h3 id="销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；"><a href="#销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；" class="headerlink" title="销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；"></a>销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；</h3><ul>
<li>作用：当调用了vm.$destroy方法，Vue实例就进入了销毁阶段，该阶段所做的主要工作是将当前的Vue实例从其父级实例中删除，取消当前实例上的所有依赖追踪并且移除实例上的所有事件监听器。</li>
</ul>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="与数据相关：vm-set、vm-delete和vm-watch"><a href="#与数据相关：vm-set、vm-delete和vm-watch" class="headerlink" title="与数据相关：vm.$set、vm.$delete和vm.$watch"></a>与数据相关：<span class="desc">vm.$set、vm.$delete和vm.$watch</span></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="attr">expOrFn</span>:string | <span class="title class_">Function</span>,<span class="attr">callback</span>: <span class="title class_">Function</span> | <span class="title class_">Object</span>,[<span class="attr">options</span>:<span class="title class_">Object</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>options</li>
<li>deep: boolean: 深度监听</li>
<li>immediate: boolean: 是否立即触发回调，如果存在immediate，第一次回调不能取消侦听给定的property</li>
<li>返回值：unwatch: Function: 返回一个取消观察函数，用来停止回调 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unwatch = vm.$watch(expOrFn,callback,[options])  </span><br><span class="line"><span class="title function_">unwatch</span>()</span><br></pre></td></tr></table></figure></li>
<li>用法：观察 Vue 实例变化的一个<span class="key_words">『表达式或计算属性函数』</span>。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</li>
</ul>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$set(<span class="attr">target</span>: <span class="title class_">Object</span> | <span class="title class_">Array</span>, propertyName/<span class="attr">index</span>: string | number, <span class="attr">value</span>: any)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：设置的值。</li>
<li>用法：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。必须用于向响应式对象上添加新属性.<span class="key_words">『对象不能是 Vue 实例，或者 Vue 实例的根数据对象。』</span></li>
</ul>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$delete(<span class="attr">target</span>: <span class="title class_">Object</span> | <span class="title class_">Array</span>, propertyName/<span class="attr">index</span>: string | number)</span><br></pre></td></tr></table></figure>
<ul>
<li>用法：删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。<span class="key_words">『目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。』</span></li>
</ul>
<h3 id="与事件相关：vm-on、vm-emit、vm-off和vm-once"><a href="#与事件相关：vm-on、vm-emit、vm-off和vm-once" class="headerlink" title="与事件相关：vm.$on、vm.$emit、vm.$off和vm.$once"></a>与事件相关：<span class="desc">vm.$on、vm.$emit、vm.$off和vm.$once</span></h3><ul>
<li>$on和$emit 的内部原理是设计模式中最典型的发布订阅模式，首先定义一个事件中心，通过$on订阅事件，将事件存储在事件中心里面，然后通过 $emit触发事件中心里面存储的订阅事件。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$on(<span class="attr">event</span>: string | <span class="title class_">Array</span>&lt;string&gt;, <span class="attr">callback</span>: <span class="title class_">Function</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。	</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$on(<span class="string">&#x27;test&#x27;</span>,<span class="keyword">function</span>(<span class="params">msg</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(msg)&#125;)</span><br><span class="line">vm.$emit(<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;hi&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$emit(<span class="attr">eventName</span>: string, […args])</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：触发当前实例上的事件。附加参数都会传给监听器回调</li>
</ul>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$off([<span class="attr">event</span>: string | <span class="title class_">Array</span>&lt;string&gt;, <span class="attr">callback</span>: <span class="title class_">Function</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：移除自定义事件监听器。<ul>
<li>如果没有提供参数，则移除所有事件的监听器</li>
<li>如果只提供了事件，则移除该事件所有的监听器</li>
<li>如果同时提供了事件与回调，则移除这个回调的监听器</li>
</ul>
</li>
</ul>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$once(<span class="attr">event</span>: string, <span class="attr">callback</span>: <span class="title class_">Function</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：监听一个自定义事件，但是只触发一次。一旦触发，监听器就会被移除。</li>
</ul>
<h3 id="与生命周期相关：vm-mount、vm-forceUpdate、vm-nextTick和vm-destory"><a href="#与生命周期相关：vm-mount、vm-forceUpdate、vm-nextTick和vm-destory" class="headerlink" title="与生命周期相关：vm.$mount、vm.$forceUpdate、vm.$nextTick和vm.$destory"></a>与生命周期相关：<span class="desc">vm.$mount、vm.$forceUpdate、vm.$nextTick和vm.$destory</span></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$mount([<span class="attr">elementOrSelector</span>: <span class="title class_">Element</span> | string],[<span class="attr">hydrating</span>: boolean])</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：vm</li>
<li>作用：实例化时没有收到el选项，处于未挂载状态。使用vm.$mount手动挂载</li>
</ul>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$forceUpdate()</span><br></pre></td></tr></table></figure>
<ul>
<li>作用: 迫使 Vue 实例重新渲染.仅仅影响实例本身和插入插槽内容的子组件</li>
</ul>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$nextTick([<span class="attr">callback</span>: <span class="title class_">Function</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>用法：将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。回调的 this 自动绑定到调用它的实例上。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="attr">el</span>: <span class="string">&#x27;##example&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			<span class="attr">message</span>: <span class="string">&#x27;123&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	vm.<span class="property">message</span> = <span class="string">&#x27;new message&#x27;</span> <span class="comment">// 更改数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">$el</span>.<span class="property">innerHTML</span>) <span class="comment">// &#x27;123&#x27;，这里调用时拿到的数据还是之前的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">$el</span>.<span class="property">innerHTML</span>) <span class="comment">// &#x27;new message&#x27;，使用nextTick后可以获取到更新后的数据，异步执行</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="JS的运行机制"><a href="#JS的运行机制" class="headerlink" title="JS的运行机制:"></a>JS的运行机制:</h3><ul>
<li>JS执行的时单线程的，基于事件循环</li>
</ul>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><ul>
<li>所有同步任务都在主线程上执行，形成一个执行栈</li>
<li>主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li>
<li>一旦”执行栈”中所有同步任务执行完毕，系统就会读取任务列表，将任务列表中的异步任务放进执行栈中执行，主线程不断重复该步骤<br>主线程的执行过程就是一个tick，而所有的异步结果都是通过 “任务队列” 来调度。任务队列中存放宏任务和微任务，并且每执行完一个宏任务，都要去清空对应的微任务</li>
</ul>
<h3 id="vm-destroy"><a href="#vm-destroy" class="headerlink" title="vm.$destroy()"></a>vm.$destroy()</h3><ul>
<li>用法：完全销毁一个实例。清理它与其他实例的连接，解绑它的全部指令即事件监听器。触发 beforeDestroy 和 destroyed 的钩子。</li>
</ul>
<h2 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h2><ul>
<li>Vue.extend(options: Object)<ul>
<li>作用：用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</li>
</ul>
</li>
<li>Vue.nextTick([callback:Function, context: Object])<ul>
<li>参照$nextTick</li>
</ul>
</li>
<li>Vue.set(target: Object | Array, propertyName&#x2F;index: string | number, value: any)<ul>
<li>参照$set</li>
</ul>
</li>
<li>Vue.delete(target: Object | Array, propertyName&#x2F;index: string | number)<ul>
<li>参照$delete</li>
</ul>
</li>
<li>Vue.directive(id: string, [definition: Function | Object])<ul>
<li>作用：注册或获取全局指令。</li>
</ul>
</li>
<li>Vue.filter(id: string, [definition: Function])<ul>
<li>作用：注册或获取全局过滤器。</li>
</ul>
</li>
<li>Vue.component(id: string, [definition: Function | Object])<ul>
<li>作用：注册或获取全局组件。注册还会自动使用给定的id设置组件的名称</li>
</ul>
</li>
<li>Vue.use(plugin: Object | Function)<ul>
<li>作用：安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。需要在调用 new Vue() 之前被调用。当 install 方法被同一个插件多次调用，插件只会安装一次。</li>
</ul>
</li>
<li>Vue.mixin(mixin: Object)<ul>
<li>作用：全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用。</li>
</ul>
</li>
<li>Vue.compile(template: string)<ul>
<li>作用：在 render 函数中编译模板字符串。只在独立构建时有效</li>
</ul>
</li>
<li>Vue.observable(object：Object)<ul>
<li>作用：让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器</li>
</ul>
</li>
<li>Vue.version<ul>
<li>作用：提供字符串形式的 Vue 安装版本号</li>
<li>用法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (version === <span class="number">2</span>) &#123;&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (version === <span class="number">1</span>) &#123;&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul>
<li>双大括号插值中被添加在js表达式尾部，由‘|’指示：存在标签文本中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;message | capitablize&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>和v-bind表达式中被添加在js表达式尾部，由‘|’指示: 存在标签属性中<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>在组件中使用filters选项来定义本地过滤器，也可以使用Vue.filter来定义全局过滤器</li>
</ul>
<h3 id="串联过滤器"><a href="#串联过滤器" class="headerlink" title="串联过滤器"></a>串联过滤器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | <span class="title function_">filterA</span>(<span class="string">&#x27;arg1&#x27;</span>, arg2) &#125;&#125; <span class="comment">// 还可以传参</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><table>
<thead>
<tr>
<th>钩子函数名称</th>
<th>触发时机</th>
<th>回调参数</th>
</tr>
</thead>
<tbody><tr>
<td>init</td>
<td>已创建VNode，在patch期间发现新的虚拟节点时被触发</td>
<td>VNode</td>
</tr>
<tr>
<td>create</td>
<td>已基于VNode创建了DOM元素</td>
<td>emptyNode和VNode</td>
</tr>
<tr>
<td>activate</td>
<td>keep-alive组件被创建</td>
<td>emptyNode和VNode</td>
</tr>
<tr>
<td>insert</td>
<td>VNode对应的DOM元素被插入到父节点中时被触发</td>
<td>VNode</td>
</tr>
<tr>
<td>prepatch</td>
<td>一个VNode即将被patch之前触发</td>
<td>oldVNode和VNode</td>
</tr>
<tr>
<td>update</td>
<td>一个VNode更新时触发</td>
<td>oldVNode和VNode</td>
</tr>
<tr>
<td>postpatch</td>
<td>一个VNode被patch完毕时触发</td>
<td>oldVNode和VNode</td>
</tr>
<tr>
<td>destory</td>
<td>一个VNode对应的DOM元素从DOM中移除时或者它的父元素从DOM中移除时触发</td>
<td>VNode</td>
</tr>
<tr>
<td>remove</td>
<td>一个VNode对应的DOM元素从DOM中移除时触发。与destory不同的是，如果是直接将该VNode的父元素从DOM中移除导致该元素被移除不会触发</td>
<td>VNode和removeCallback</td>
</tr>
</tbody></table>
<h3 id="指令钩子函数-—-对应指令的状态"><a href="#指令钩子函数-—-对应指令的状态" class="headerlink" title="指令钩子函数 — 对应指令的状态"></a>指令钩子函数 — 对应指令的状态</h3><ul>
<li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</li>
<li>inserted：被绑定元素插入父节点时调用(仅保证父节点存在，但不一定已被插入文档中)</li>
<li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前</li>
<li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用</li>
<li>unbind：只调用一次，指令与元素解绑时调用</li>
</ul>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><ul>
<li><a href="https://cn.vuejs.org/guide/built-ins/keep-alive">官网介绍</a></li>
<li>作用：实现组件缓存，保存组件状态，避免反复渲染影响性能。适合频繁切换，但不需要改变切换前的状态的组件。</li>
<li>场景：tabs标签页，后台导航，vue性能优化</li>
<li>语法：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;字符串|正则表达式&quot;</span> <span class="attr">exclude</span>=<span class="string">&quot;字符串|正则表达式&quot;</span> <span class="attr">max</span>=<span class="string">&quot;Number&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>属性：<ul>
<li>include：只有名称匹配的组件会被缓存</li>
<li>exclude：任何名称匹配的组件都不会被缓存</li>
<li>max：最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，<span class="key_words">『已缓存组件中最久没有被访问的实例会被销毁掉』</span></li>
</ul>
</li>
<li>注意：<ul>
<li>include 和 exclude的值: 逗号分割字符串、一个正则表达式、字符串数组的形式</li>
<li>数组和正则需要使用:include(v-bind形式),字符串直接include</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则表达式 (使用 `v-bind`)</span></span><br><span class="line">&lt;keep-alive :include=<span class="string">&quot;/a|b/&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"><span class="comment">// 数组 (使用 `v-bind`) </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 匹配时首先检查组件自身的name选项，如果name不可用，则匹配它的局部注册名称(父组件components选项的键值)。匿名组件不能被匹配</span></span><br></pre></td></tr></table></figure></li>
<li>组件一旦被 keep-alive 缓存，那么再次渲染的时候就不会执行created、mounted等钩子</li>
<li>如果希望能再次渲染时使用 activated 和 deactivated，它的执行时机是 keep-alive 包裹的组件激活时调用和停用时调用</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>知识</tag>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-VUEX(状态管理库) 不推荐</title>
    <url>/2024/11/01/vue3/vuex/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），是一种适用于任意组件间通信的方式。</p>
</blockquote>
<ul>
<li><a href="https://vuex.vuejs.org/zh/installation.html">点击查看安装步骤</a></li>
<li>每一个 Vuex<span class="key_words">『应用的核心』</span>就是 store（仓库）</li>
<li>修改store值的<span class="key_words">『唯一方法』</span>就是通过 mutation 来修改 </li>
<li>actions不能直接修改state需要通过mutations提交修改state,actions可以进行异步操作</li>
</ul>
<h2 id="状态管理模式"><a href="#状态管理模式" class="headerlink" title="状态管理模式"></a>状态管理模式</h2><ul>
<li>状态：驱动应用的数据源 — data</li>
<li>视图：以声明方式将状态映射到视图 — template</li>
<li>操作: 响应在视图上的用户输入导致的状态变化 — methods<br><img src="/../../img/vue3/vuex.png" alt="vuex"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="不使用单向数据流的原因："><a href="#不使用单向数据流的原因：" class="headerlink" title="不使用单向数据流的原因："></a>不使用单向数据流的原因：</h2><ul>
<li>使用场景：多个组件共享状态 – <span class="desc">会依赖同一状态和变更同一状态（单向数据流的简洁性会被破坏）</span></li>
</ul>
<h2 id="Vuex-和单纯的全局对象的不同："><a href="#Vuex-和单纯的全局对象的不同：" class="headerlink" title="Vuex 和单纯的全局对象的不同："></a>Vuex 和单纯的全局对象的不同：</h2><ol>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。</li>
</ol>
<h2 id="创建一个简单的store-vue2版"><a href="#创建一个简单的store-vue2版" class="headerlink" title="创建一个简单的store(vue2版)"></a>创建一个简单的store(vue2版)</h2><ul>
<li>创建文件：src&#x2F;store&#x2F;index.js<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"><span class="comment">// 准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">	<span class="title function_">jiaWait</span>(<span class="params">context,value</span>)&#123; </span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			context.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>,value)</span><br><span class="line">		&#125;,<span class="number">500</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">	<span class="title function_">increment</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line">		state.<span class="property">count</span> += value</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">//准备getters——用于将state中的数据进行加工</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">	<span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> state.<span class="property">count</span>*<span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state,</span><br><span class="line">	getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>在 main.js 中引入store，并将 store 添加到new Vue中</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul>
<li>初始化数据、配置 actions、配置 mutations，操作文件store.js</li>
<li>读取vuex中的数据：页面通过store.state来获取状态对象，组件通过this.$store老访问store实例</li>
<li>修改vuex中的数据：通过<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;action中的方法名&#x27;</span>,数据) </span><br><span class="line">或 </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;mutations中的方法名&#x27;</span>,数据)</span><br></pre></td></tr></table></figure></li>
<li>注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即<span class="key_words">『不写dispatch，直接编写commit』</span></li>
</ul>
<h3 id="state-单一状态树"><a href="#state-单一状态树" class="headerlink" title="state (单一状态树)"></a>state (<span class="desc">单一状态树</span>)</h3><ul>
<li>组件中获得 Vuex 状态 – <span class="desc">在computed中返回某个state</span></li>
</ul>
<h3 id="Getter-store-的计算属性"><a href="#Getter-store-的计算属性" class="headerlink" title="Getter (store 的计算属性)"></a>Getter (<span class="desc">store 的计算属性</span>)</h3><ol>
<li>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</li>
<li>组件中读取数据：$store.getters.count</li>
</ol>
<h3 id="Mutation-更改state的唯一方法-且必须是同步函数"><a href="#Mutation-更改state的唯一方法-且必须是同步函数" class="headerlink" title="Mutation (更改state的唯一方法 且必须是同步函数)"></a>Mutation (<span class="desc">更改state的唯一方法 且必须是同步函数</span>)</h3><ul>
<li>提交的两种方式(传入额外的参数)<ul>
<li>载荷(Payload)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;mutation的方法名&#x27;</span>, &#123;额外参数: n&#125;)</span><br></pre></td></tr></table></figure></li>
<li>对象风格<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;mutation的方法名&#x27;</span>,额外参数: n&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Action-—-包含异步操作且提交的是Mutation"><a href="#Action-—-包含异步操作且提交的是Mutation" class="headerlink" title="Action — (包含异步操作且提交的是Mutation)"></a>Action — (<span class="desc">包含异步操作且提交的是Mutation</span>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123; <span class="title function_">increment</span>(<span class="params">&#123;commit&#125;</span>) &#123;</span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&#x27;mutations的方法名&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>载荷形式分发<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&#x27;actions的方法名&#x27;</span>, &#123;额外参数: n&#125;)</span><br></pre></td></tr></table></figure></li>
<li>以对象形式分发<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;actions的方法名&#x27;</span>, 额外参数: n&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="组合Action"><a href="#组合Action" class="headerlink" title="组合Action"></a>组合Action</h3><ul>
<li>store.dispatch可以处理触发的action的处理函数返回Promise<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="title function_">actionA</span>(<span class="params">&#123; commit &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;someMutation&#x27;</span>)</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&#x27;actionA&#x27;</span>).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 设 gotData(),getOtherData() 返回的是Promise</span></span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">actionA</span>(<span class="params">&#123;commit&#125;</span>) &#123;</span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&#x27;gotData&#x27;</span>, <span class="keyword">await</span> <span class="title function_">getData</span>())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">actionB</span> (&#123; dispatch, commit&#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">dispatch</span>(<span class="string">&#x27;actionA&#x27;</span>)</span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&#x27;getOtherData&#x27;</span>,<span class="keyword">await</span> getOtherData)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="map方法的使用"><a href="#map方法的使用" class="headerlink" title="map方法的使用"></a>map方法的使用</h2><h3 id="mapState方法：映射-state-中的数据为计算属性"><a href="#mapState方法：映射-state-中的数据为计算属性" class="headerlink" title="mapState方法：映射 state 中的数据为计算属性"></a>mapState方法：映射 state 中的数据为计算属性</h3><ul>
<li>使用：在computed中将state的数据拿出来<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象写法：...<span class="title function_">mapState</span>(&#123;再定义的变量名:<span class="string">&#x27;变量名&#x27;</span>&#125;)</span><br><span class="line">数组写法：...<span class="title function_">mapState</span>([<span class="string">&#x27;变量名&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="mapGetters方法：映射-getters-中的数据为计算属性"><a href="#mapGetters方法：映射-getters-中的数据为计算属性" class="headerlink" title="mapGetters方法：映射 getters 中的数据为计算属性"></a>mapGetters方法：映射 getters 中的数据为计算属性</h3><ul>
<li>使用：在computed中将getters的方法拿出来<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象写法：...<span class="title function_">mapGetters</span>(&#123;再定义的方法名:<span class="string">&#x27;方法名&#x27;</span>&#125;)</span><br><span class="line">数组写法：...<span class="title function_">mapGetters</span>([<span class="string">&#x27;方法名&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="mapActions方法："><a href="#mapActions方法：" class="headerlink" title="mapActions方法："></a>mapActions方法：</h3><ul>
<li>生成与 actions 对话的方法，即：包含 $store.dispatch(xxx) 的函数</li>
<li>使用：在computed中将actions的方法拿出来<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象写法：...<span class="title function_">mapActions</span>(&#123;再定义的方法名:<span class="string">&#x27;方法名&#x27;</span>&#125;)</span><br><span class="line">数组写法：...<span class="title function_">mapActions</span>([<span class="string">&#x27;方法名&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="mapMutations方法："><a href="#mapMutations方法：" class="headerlink" title="mapMutations方法："></a>mapMutations方法：</h3><ul>
<li>生成与 mutations 对话的方法，即：包含 $store.commit(xxx) 的函数</li>
<li>使用：在computed中将mutations的方法拿出来<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象写法：...<span class="title function_">mapMutations</span>(&#123;再定义的方法名:<span class="string">&#x27;方法名&#x27;</span>&#125;)</span><br><span class="line">数组写法：...<span class="title function_">mapMutations</span>([<span class="string">&#x27;方法名&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
<li>注：<span class="desc">mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</span></li>
</ul>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;...&#125;), </span><br><span class="line">  <span class="attr">mutations</span>: &#123;...&#125;, <span class="comment">// 局部模块的state</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;...&#125;, <span class="comment">// 局部模块的context.state和根节点状态context.rootState</span></span><br><span class="line">  <span class="attr">getters</span>: &#123;...&#125;，<span class="comment">// 局部模块的state，根节点状态rootState会作为第三个参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;...&#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123;...&#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;...&#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.<span class="property">state</span>.<span class="property">a</span> <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.<span class="property">state</span>.<span class="property">b</span> <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>

<h2 id="模块化-命名空间"><a href="#模块化-命名空间" class="headerlink" title="模块化+命名空间"></a>模块化+命名空间</h2><h3 id="目的：让代码更好维护，让多种数据分类更加明确。"><a href="#目的：让代码更好维护，让多种数据分类更加明确。" class="headerlink" title="目的：让代码更好维护，让多种数据分类更加明确。"></a>目的：让代码更好维护，让多种数据分类更加明确。</h3><h3 id="修改store-js"><a href="#修改store-js" class="headerlink" title="修改store.js"></a>修改store.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">modules</span>: &#123;</span><br><span class="line">  模块<span class="number">1</span>: &#123;</span><br><span class="line">    <span class="attr">namespaced</span>: <span class="literal">true</span>, <span class="comment">// 开启命名空间,getters、action、mutation有影响</span></span><br><span class="line">    <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;...&#125;), </span><br><span class="line">    <span class="attr">getters</span>:&#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开启命名空间后，组件中读取state数据："><a href="#开启命名空间后，组件中读取state数据：" class="headerlink" title="开启命名空间后，组件中读取state数据："></a>开启命名空间后，组件中读取state数据：</h3><ul>
<li>方式一：自己直接读取<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">xxx</span></span><br></pre></td></tr></table></figure></li>
<li>方式二：借助mapState读取：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;模块名&#x27;</span>,[<span class="string">&#x27;state的属性&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="开启命名空间后，组件中读取getters数据："><a href="#开启命名空间后，组件中读取getters数据：" class="headerlink" title="开启命名空间后，组件中读取getters数据："></a>开启命名空间后，组件中读取getters数据：</h3><ul>
<li>方式一：自己直接读取<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;模块名/getters的方法&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li>方式二：借助mapGetters读取：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;模块名&#x27;</span>,[<span class="string">&#x27;getters的方法&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="开启命名空间后，组件中调用dispatch"><a href="#开启命名空间后，组件中调用dispatch" class="headerlink" title="开启命名空间后，组件中调用dispatch"></a>开启命名空间后，组件中调用dispatch</h3><ul>
<li>方式一：自己直接dispatch<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;模块名/actions的方法&#x27;</span>,传参)</span><br></pre></td></tr></table></figure></li>
<li>方式二：借助mapActions：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;模块名&#x27;</span>,&#123;定义的别名:<span class="string">&#x27;actions的方法&#x27;</span>,定义的别名:<span class="string">&#x27;actions的方法&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="开启命名空间后，组件中调用commit"><a href="#开启命名空间后，组件中调用commit" class="headerlink" title="开启命名空间后，组件中调用commit"></a>开启命名空间后，组件中调用commit</h3><ul>
<li>方式一：自己直接commit<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;模块名/mutations的方法&#x27;</span>,传参)</span><br></pre></td></tr></table></figure></li>
<li>方式二：借助mapMutations：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;模块名&#x27;</span>,&#123;别名:<span class="string">&#x27;mutations的方法&#x27;</span>,别名:<span class="string">&#x27;mutations的方法&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在带命名空间的模块内访问全局内容"><a href="#在带命名空间的模块内访问全局内容" class="headerlink" title="在带命名空间的模块内访问全局内容"></a>在带命名空间的模块内访问全局内容</h3><ul>
<li>使用全局 state 和 getter，rootState 和 rootGetters 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。</li>
<li>在<span class="key_words">『全局命名空间』</span>内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。</li>
</ul>
<h3 id="在带命名空间的模块注册全局-action"><a href="#在带命名空间的模块注册全局-action" class="headerlink" title="在带命名空间的模块注册全局 action"></a>在带命名空间的模块注册全局 action</h3><ul>
<li>在命名空间的actions方法中给要注册为全局的方法添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">root</span>: <span class="literal">true</span></span><br><span class="line"><span class="title function_">handler</span> (namespacedContext, payload) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模块动态注册-store-registerModule"><a href="#模块动态注册-store-registerModule" class="headerlink" title="模块动态注册 store.registerModule"></a>模块动态注册 store.registerModule</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;&#125;)</span><br><span class="line">store.<span class="title function_">registerModule</span>(<span class="string">&#x27;myModule&#x27;</span>,&#123;&#125;) <span class="comment">// 注册模块</span></span><br><span class="line">store.<span class="title function_">registerModule</span>([<span class="string">&#x27;nested&#x27;</span>,<span class="string">&#x27;myModule&#x27;</span>],&#123;&#125;)  <span class="comment">// 注册嵌套模块 /nested/myModule</span></span><br><span class="line">store.<span class="title function_">unregisterModule</span>(modulename)  <span class="comment">// 卸载动态模块，静态不行</span></span><br><span class="line">store.<span class="title function_">hasModule</span>(moduleName) <span class="comment">// 检查是否被注册到store，注意嵌套模块要以数组形式传递</span></span><br></pre></td></tr></table></figure>
<ul>
<li>保留 state<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">registerModule</span>(<span class="string">&#x27;a&#x27;</span>,<span class="variable language_">module</span>, &#123;<span class="attr">preserveState</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="vue3的vuex"><a href="#vue3的vuex" class="headerlink" title="vue3的vuex"></a>vue3的vuex</h2><ul>
<li>与vue2比，引入时需要从vuex导入createStore<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>使用，在setup中：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>();</span><br><span class="line">store.<span class="property">xxx</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h2><ul>
<li>调用useStore，在setup中访问store &#x3D;&#x3D; this.$store<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 在 computed 函数中访问 state</span></span><br><span class="line">      <span class="attr">count</span>: <span class="title function_">computed</span>(<span class="function">() =&gt;</span> store.<span class="property">state</span>.<span class="property">count</span>),</span><br><span class="line">      <span class="comment">// 在 computed 函数中访问 getter</span></span><br><span class="line">      <span class="attr">double</span>: <span class="title function_">computed</span>(<span class="function">() =&gt;</span> store.<span class="property">getters</span>.<span class="property">double</span>)</span><br><span class="line">      <span class="comment">// 使用 mutation</span></span><br><span class="line">      <span class="attr">increment</span>: <span class="function">() =&gt;</span> store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>),</span><br><span class="line">      <span class="comment">// 使用 action</span></span><br><span class="line">      <span class="attr">asyncIncrement</span>: <span class="function">() =&gt;</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;asyncIncrement&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myPlugin</span> = (<span class="params">store</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 当store 初始化调用</span></span><br><span class="line">  store.<span class="title function_">subscribe</span>(<span class="function">(<span class="params">mutation,state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每次mutation 之后调用</span></span><br><span class="line">    <span class="comment">// mutation的格式为&#123;type， payload&#125;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">plugin</span>: [myPlugin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ul>
<li>在store中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">strict：process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> <span class="comment">// 发布环境不能为true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h2><h3 id="方法一：v-model-用v-bind绑定value和v-on去监听实现"><a href="#方法一：v-model-用v-bind绑定value和v-on去监听实现" class="headerlink" title="方法一：v-model 用v-bind绑定value和v-on去监听实现"></a>方法一：v-model 用v-bind绑定value和v-on去监听实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input :value=<span class="string">&quot;message&quot;</span> @input=<span class="string">&quot;updateMessage&quot;</span> /&gt;</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">	...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">		<span class="attr">message</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">message</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">	<span class="title function_">updateMessage</span> (e) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;updateMessage&#x27;</span>,e.<span class="property">detail</span>.<span class="property">value</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span> (&#123;</span><br><span class="line">	<span class="attr">mutations</span>: &#123;</span><br><span class="line">		<span class="title function_">updateMessage</span> (state,message) &#123;</span><br><span class="line">			store.<span class="property">message</span> = message</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="方法二：-用getter和setter的双向绑定计算属性"><a href="#方法二：-用getter和setter的双向绑定计算属性" class="headerlink" title="方法二： 用getter和setter的双向绑定计算属性"></a>方法二： 用getter和setter的双向绑定计算属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;message&quot;</span> /&gt;</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">message</span>: &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">message</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span> (value) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;updateMessage&#x27;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span> (&#123;</span><br><span class="line">	<span class="attr">mutations</span>: &#123;</span><br><span class="line">		<span class="title function_">updateMessage</span> (state,message) &#123;</span><br><span class="line">			store.<span class="property">message</span> = message</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="支持ts"><a href="#支持ts" class="headerlink" title="支持ts"></a>支持ts</h2><h3 id="在vuex-d-ts中添加"><a href="#在vuex-d-ts中添加" class="headerlink" title="在vuex.d.ts中添加"></a>在vuex.d.ts中添加</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vuex.d.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Store</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;@vue/runtime-core&#x27;</span> &#123;</span><br><span class="line">  <span class="comment">// 声明自己的 store state</span></span><br><span class="line">  interface <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: number</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为 `this.$store` 提供类型声明</span></span><br><span class="line">  interface <span class="title class_">ComponentCustomProperties</span> &#123;</span><br><span class="line">    <span class="attr">$store</span>: <span class="title class_">Store</span>&lt;<span class="title class_">State</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="useState-组合式函数类型声明"><a href="#useState-组合式函数类型声明" class="headerlink" title="useState 组合式函数类型声明"></a>useState 组合式函数类型声明</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">InjectionKey</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, useStore <span class="keyword">as</span> baseUseStore, <span class="title class_">Store</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">State</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;<span class="title class_">Store</span>&lt;<span class="title class_">State</span>&gt;&gt; = <span class="title class_">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore&lt;<span class="title class_">State</span>&gt;(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义自己的 `useStore` 组合式函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useStore</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">baseUseStore</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>状态管理库</tag>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-内置组件</title>
    <url>/2024/11/01/vue3/%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="Transition标签"><a href="#Transition标签" class="headerlink" title="Transition标签"></a>Transition标签</h2><ul>
<li>一个元素或组件进入和离开 DOM 时应用动画</li>
</ul>
<h3 id="触发条件："><a href="#触发条件：" class="headerlink" title="触发条件："></a>触发条件：</h3><ul>
<li>由 v-if 所触发的切换</li>
<li>由 v-show 所触发的切换</li>
<li>由特殊元素 component标签 切换的动态组件</li>
</ul>
<h3 id="基于侦听器的动画"><a href="#基于侦听器的动画" class="headerlink" title="基于侦听器的动画"></a>基于侦听器的动画</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gsap <span class="keyword">from</span> <span class="string">&#x27;gsap&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">number</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">tweened</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title function_">number</span>(<span class="params">n</span>) &#123;</span><br><span class="line">      gsap.<span class="title function_">to</span>(<span class="variable language_">this</span>, &#123; <span class="attr">duration</span>: <span class="number">0.5</span>, <span class="attr">tweened</span>: <span class="title class_">Number</span>(n) || <span class="number">0</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Type</span> a <span class="attr">number</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">&quot;number&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; tweened.toFixed(0) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="基于-CSS-的过渡效果"><a href="#基于-CSS-的过渡效果" class="headerlink" title="基于 CSS 的过渡效果"></a>基于 CSS 的过渡效果</h3><ul>
<li>v-enter-from: 进入动画的起始状态</li>
<li>v-enter-active：进入动画的生效状态</li>
<li>v-enter-to：进入动画的结束状态</li>
<li>v-leave-from：离开动画的起始状态</li>
<li>v-leave-active：离开动画的生效状态</li>
<li>v-leave-to：离开动画的结束状态<br><img src="/../../img/vue3/transition-classes.png" alt="transition-classes"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="为过渡效果命名-—-给-Transition-上添加name属性"><a href="#为过渡效果命名-—-给-Transition-上添加name属性" class="headerlink" title="为过渡效果命名 — 给 Transition 上添加name属性"></a>为过渡效果命名 — 给 Transition 上添加name属性</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Transition</span> <span class="attr">name</span>=<span class="string">&quot;fade&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">Transition</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>样式 .fade-enter-from</li>
</ul>
<h3 id="CSS-的-transition"><a href="#CSS-的-transition" class="headerlink" title="CSS 的 transition"></a>CSS 的 transition</h3><ul>
<li>transition：执行动画的属性 持续时间 速度曲线</li>
</ul>
<h3 id="CSS-的-animation"><a href="#CSS-的-animation" class="headerlink" title="CSS 的 animation"></a>CSS 的 animation</h3><ul>
<li>*-enter-from 不是在元素插入后立即移除，而是在一个 animationend 事件触发时被移除<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bounce-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bounce-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in <span class="number">0.5s</span> reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> bounce-in &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.25</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自定义过渡-class-—-使用覆盖默认class"><a href="#自定义过渡-class-—-使用覆盖默认class" class="headerlink" title="自定义过渡 class — 使用覆盖默认class"></a>自定义过渡 class — 使用覆盖默认class</h3><ul>
<li>enter-from-class</li>
<li>enter-active-class</li>
<li>enter-to-class</li>
<li>leave-from-class</li>
<li>leave-active-class</li>
<li>leave-to-class<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设你已经在页面中引入了 Animate.css</span></span><br><span class="line">&lt;<span class="title class_">Transition</span></span><br><span class="line">  name=<span class="string">&quot;custom-classes&quot;</span></span><br><span class="line">  enter-active-<span class="keyword">class</span>=<span class="string">&quot;animate__animated animate__tada&quot;</span></span><br><span class="line">  leave-active-<span class="keyword">class</span>=<span class="string">&quot;animate__animated animate__bounceOutRight&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Transition</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="同时使用-transition-和-animation-传type"><a href="#同时使用-transition-和-animation-传type" class="headerlink" title="同时使用 transition 和 animation 传type"></a>同时使用 transition 和 animation 传type</h3><h3 id="深层级过渡与显式过渡时长"><a href="#深层级过渡与显式过渡时长" class="headerlink" title="深层级过渡与显式过渡时长"></a>深层级过渡与显式过渡时长</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="attribute">Transition</span> name=&quot;nested&quot; :duration=<span class="string">&quot;550&quot;</span>&gt;</span><br><span class="line">// duration = 内部过渡时间+匹配延迟时间</span><br><span class="line">  &lt;div v-if=<span class="string">&quot;show&quot;</span> class=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;inner&quot;</span>&gt;</span><br><span class="line">      Hello</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/Transition&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 应用于嵌套元素的规则 */</span></span><br><span class="line">.nested-enter-active .inner,</span><br><span class="line">.nested-leave-active .inner &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.3s</span> ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nested-enter-from</span> <span class="selector-class">.inner</span>,</span><br><span class="line"><span class="selector-class">.nested-leave-to</span> <span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">30px</span>);</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="可以被监听、可复用（插槽）、可动态"><a href="#可以被监听、可复用（插槽）、可动态" class="headerlink" title="可以被监听、可复用（插槽）、可动态"></a>可以被监听、可复用（插槽）、可动态</h3><h3 id="初次渲染时应用一个过渡效果-添加appear属性"><a href="#初次渲染时应用一个过渡效果-添加appear属性" class="headerlink" title="初次渲染时应用一个过渡效果 添加appear属性"></a>初次渲染时应用一个过渡效果 添加appear属性</h3><h3 id="元素间的过渡-用v-if家族，"><a href="#元素间的过渡-用v-if家族，" class="headerlink" title="元素间的过渡: 用v-if家族，"></a>元素间的过渡: 用v-if家族，</h3><h3 id="过渡模式：mode-”out-in”-—-等上一个元素离开后执行"><a href="#过渡模式：mode-”out-in”-—-等上一个元素离开后执行" class="headerlink" title="过渡模式：mode&#x3D;”out-in” — 等上一个元素离开后执行"></a>过渡模式：mode&#x3D;”out-in” — 等上一个元素离开后执行</h3><h2 id="TransitionGroup标签"><a href="#TransitionGroup标签" class="headerlink" title="TransitionGroup标签"></a>TransitionGroup标签</h2><ul>
<li>一个 v-for 列表中的元素或组件被插入，移动，或移除时应用动画。</li>
<li>tag?：指明渲染的片段</li>
</ul>
<h2 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h2><ul>
<li><span class="key_words">『在多个组件间动态切换时缓存被移除的组件实例』</span><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;activeComponent&quot;</span> /&gt;</span> // 动态组件，切换会重置状态</span><br><span class="line"><span class="tag">&lt;<span class="name">KeepAlive</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;activeComponent&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">KeepAlive</span>&gt;</span> // 切换时缓存切换前的状态，不会重置</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="包含include-排除exclude，最大缓存实例数max"><a href="#包含include-排除exclude，最大缓存实例数max" class="headerlink" title="包含include&#x2F;排除exclude，最大缓存实例数max"></a>包含include&#x2F;排除exclude，最大缓存实例数max</h3><ul>
<li>指明（不）缓存那个组件，以组件的参数name匹配</li>
</ul>
<h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><ul>
<li>当一个组件在 KeepAlive标签 中被切换时，它的 activated 和 deactivated 生命周期钩子将被调用，用来替代 mounted 和 unmounted。</li>
</ul>
<h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><ul>
<li>一个组件模板的一部分在逻辑上从属于该组件，但从整个应用视图的角度来看，它在 DOM 中应该被渲染在整个 Vue 应用外部的其他地方。</li>
<li>如全屏的模态框</li>
</ul>
<h3 id="多个-组件可以将其内容挂载在同一个目标元素"><a href="#多个-组件可以将其内容挂载在同一个目标元素" class="headerlink" title="多个  组件可以将其内容挂载在同一个目标元素"></a>多个 <Teleport> 组件可以将其内容挂载在同一个目标元素</h3><ul>
<li>顺序：从上往下，后挂载的将排在目标元素下更后面的位置上</li>
</ul>
<h3 id="属性-to-—-指定渲染到那个元素-容器"><a href="#属性-to-—-指定渲染到那个元素-容器" class="headerlink" title="属性 to — 指定渲染到那个元素&#x2F;容器"></a>属性 to — 指定渲染到那个元素&#x2F;容器</h3><h3 id="属性-disabled-—-禁用，不渲染到外层容器-元素"><a href="#属性-disabled-—-禁用，不渲染到外层容器-元素" class="headerlink" title="属性 disabled — 禁用，不渲染到外层容器&#x2F;元素"></a>属性 disabled — 禁用，不渲染到外层容器&#x2F;元素</h3>]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-响应式原理</title>
    <url>/2024/11/01/vue3/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="vue2的响应式"><a href="#vue2的响应式" class="headerlink" title="vue2的响应式"></a>vue2的响应式</h3><ul>
<li>实现原理：<ul>
<li>对象类型：通过 Object.defineProperty() 对属性的读取、修改进行拦截(数据劫持)</li>
<li>数组类型：通过重写更新数组的一系列方法来实现拦截。(对数组的变更方法进行了包裹)</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">	<span class="title function_">get</span>(<span class="params"></span>) &#123;&#125;, </span><br><span class="line">	<span class="title function_">set</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>存在问题：<ul>
<li>新增属性、删除属性, 界面不会更新</li>
<li>直接通过下标修改数组, 界面不会自动更新</li>
</ul>
</li>
</ul>
<h3 id="Vue3的响应式"><a href="#Vue3的响应式" class="headerlink" title="Vue3的响应式"></a>Vue3的响应式</h3><ul>
<li>实现原理: <ul>
<li>通过Proxy：拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li>
<li>通过Reflect：对源对象的属性进行操作。</li>
<li>MDN文档中描述的Proxy与Reflect：<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">	<span class="comment">// 拦截读取属性值</span></span><br><span class="line">	<span class="title function_">get</span> (target, prop) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">	<span class="title function_">set</span> (target, prop, value) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 拦截删除属性</span></span><br><span class="line">	<span class="title function_">deleteProperty</span> (target, prop) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure>
<ul>
<li>通过Object.defineProperty去操作<ul>
<li>使用try…catch… 来捕获错误<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,<span class="string">&#x27;c&#x27;</span>,&#123;</span><br><span class="line">		<span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>通过 Reflect.defineProperty 去操作<ul>
<li>与 Object.defineProperty 操作 差不多，但不需要 try…catch…</li>
<li>并且 Reflect.defineProperty 是存储到变量里，并通过条件判断来提示</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-应用规模化</title>
    <url>/2024/11/01/vue3/%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="SFC–单文件组件（-vue）"><a href="#SFC–单文件组件（-vue）" class="headerlink" title="SFC–单文件组件（*.vue）"></a>SFC–单文件组件（*.vue）</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>Count is &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>预编译模板</li>
<li>组件作用域的css</li>
<li>组合式的API语法</li>
<li>模块热更新</li>
<li>自动补全，对表达式的类型检查</li>
</ul>
<h3 id="SFC如何工作？"><a href="#SFC如何工作？" class="headerlink" title="SFC如何工作？"></a>SFC如何工作？</h3><ol>
<li>Vue SFC 是一个框架指定的文件格式，</li>
<li>由 @vue&#x2F;compiler-sfc 编译为标准的 JavaScript 和 CSS</li>
<li>编译后的 SFC 可以像导入其他 ES 模块一样导入</li>
<li>SFC 中的 style标签一般会在开发时注入成原生的 style 标签以支持热更新，而生产环境下它们会被抽取、合并成单独的 CSS 文件。</li>
</ol>
<h2 id="项目脚手架"><a href="#项目脚手架" class="headerlink" title="项目脚手架"></a>项目脚手架</h2><ul>
<li>vite创建vue：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm init vue@latest</span><br></pre></td></tr></table></figure></li>
<li>Vue Cli 建议用vite</li>
<li>script块提供类型检查<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://cn.vuejs.org/guide/typescript/overview.html">ts 搭配 vue 的一些事</a></li>
</ul>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h3><ul>
<li>在单页面应用中，客户端的js可以拦截页面的跳转请求</li>
</ul>
<h3 id="服务端路由"><a href="#服务端路由" class="headerlink" title="服务端路由"></a>服务端路由</h3><ul>
<li>服务器根据用户访问的 URL 路径返回不同的响应结果</li>
</ul>
<h2 id="不推荐"><a href="#不推荐" class="headerlink" title=" 不推荐"></a><a href="/2024/11/01/vue3/vuex/" title="VUE3-VUEX(状态管理库) 不推荐">状态管理vuex</a> 不推荐</h2><blockquote>
<p>适用于多个组件共享一个共同的状态</p>
</blockquote>
<h3 id="用响应式-API-做简单状态管理"><a href="#用响应式-API-做简单状态管理" class="headerlink" title="用响应式 API 做简单状态管理"></a>用响应式 API 做简单状态管理</h3><ul>
<li>data() 的返回值对象会通过 reactive() 函数转为响应式。</li>
<li>使用reactive() 来实现在多个组件实例间共享状态<ol>
<li>新建一个store文件夹，在下面新建一个index文件</li>
<li>从 vue 中引入 reactive，</li>
<li>暴露一个通过reactive()返回的数据和修改的方法</li>
<li>其他页面直接引入store&#x2F;index，在data中返回这个数据</li>
</ol>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title function_">modifies</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用其他响应式 API 如 ref() 或是 computed()，或是通过一个组合式函数来返回一个全局状态<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局状态，创建在模块作用域下</span></span><br><span class="line"><span class="keyword">const</span> globalCount = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 局部状态，每个组件都会创建</span></span><br><span class="line">  <span class="keyword">const</span> localCount = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    globalCount,</span><br><span class="line">    localCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Pinia-推荐"><a href="#Pinia-推荐" class="headerlink" title="Pinia 推荐"></a>Pinia 推荐</h3><ul>
<li><a href="https://pinia.vuejs.org/zh/core-concepts/">Pinia官方文档</a></li>
<li><a href="/2024/11/01/vue3/Pinia/" title="VUE3-Pinia">VUE3-Pinia</a></li>
</ul>
<h2 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>将组件在服务端直接渲染成 HTML 字符串，作为服务端响应返回给浏览器，最后在浏览器端将静态的 HTML“激活”(hydrate) 为能够交互的客户端应用</li>
</ul>
<h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul>
<li>更快的首屏加载：<ul>
<li>服务端渲染的 HTML 无需等到所有的 JavaScript 都下载并执行完成之后才显示</li>
<li>数据获取过程在首次访问时在服务端完成</li>
</ul>
</li>
<li>统一的心智模型：<ul>
<li>使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换。</li>
</ul>
</li>
<li>更好的 SEO：<ul>
<li>搜索引擎爬虫可以直接看到完全渲染的页面。</li>
</ul>
</li>
</ul>
<h3 id="静态站点生成-SSG-预渲染"><a href="#静态站点生成-SSG-预渲染" class="headerlink" title="静态站点生成(SSG&#x2F;预渲染):"></a>静态站点生成(SSG&#x2F;预渲染):</h3><ul>
<li>首屏加载性能</li>
<li>花销更小，部署更容易</li>
<li>仅用于消费静态数据的页面</li>
<li>优化为数不多的营销页面的 SEO</li>
</ul>
<p><a href="https://cn.vuejs.org/guide/scaling-up/ssr.html">SSR创建及注意事项</a></p>
<h2 id="性能的优化"><a href="#性能的优化" class="headerlink" title="性能的优化"></a>性能的优化</h2><h3 id="页面加载优化"><a href="#页面加载优化" class="headerlink" title="页面加载优化"></a>页面加载优化</h3><ul>
<li>选用正确的架构  <ul>
<li>避免将其部署为纯客户端的 SPA，而是让服务器直接发送包含用户想要查看的内容的 HTML 代码</li>
<li>必须是 SPA，但还有其他的营销相关页面，请单独部署这些页面</li>
</ul>
</li>
<li>包体积与 Tree-shaking 优化<ul>
<li>尽可能地采用构建步骤 </li>
<li>在引入新的依赖项时要小心包体积膨胀 – <span class="desc">选择提供 ES 模块格式的依赖</span></li>
</ul>
</li>
<li>代码分割</li>
</ul>
<h3 id="更新优化"><a href="#更新优化" class="headerlink" title="更新优化"></a>更新优化</h3><ul>
<li>Props 稳定性<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">ListItem</span></span><br><span class="line">v-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span></span><br><span class="line">:id=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">:active-id=<span class="string">&quot;activeId&quot;</span> /&gt;</span><br><span class="line">改</span><br><span class="line">&lt;<span class="title class_">ListItem</span></span><br><span class="line">v-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span></span><br><span class="line">:id=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">:active=<span class="string">&quot;item.id === activeId&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li>
<li>v-once : 渲染依赖运行时数据但无需再更新的内容</li>
<li>v-memo : 有条件地跳过某些大型子树或者 v-for 列表的更新</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-插件</title>
    <url>/2024/11/01/vue3/%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="概念：-为-Vue-添加全局功能的工具代码"><a href="#概念：-为-Vue-添加全局功能的工具代码" class="headerlink" title="概念： 为 Vue 添加全局功能的工具代码"></a>概念： 为 Vue 添加全局功能的工具代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(myPlugin, &#123;</span><br><span class="line">  <span class="comment">/* 可选的选项 */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myPlugin = &#123;</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">app, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 配置此应用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>通过 app.component() 和 app.directive() 注册一到多个全局组件或自定义指令。</li>
<li>通过 app.provide() 使一个资源可被注入进整个应用。</li>
<li>向app.config.globalProperties 中添加一些全局实例属性或方法</li>
<li>一个可能上述三种都包含了的功能库 (例如 vue-router)。</li>
</ol>
<h3 id="编写一个场景-—-就是在install写方法暴露出来调用"><a href="#编写一个场景-—-就是在install写方法暴露出来调用" class="headerlink" title="编写一个场景 — 就是在install写方法暴露出来调用"></a>编写一个场景 — 就是在install写方法暴露出来调用</h3>]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-组件知识</title>
    <url>/2024/11/01/vue3/%E7%BB%84%E4%BB%B6%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<ul>
<li>组件名格式：PascalCase</li>
</ul>
<h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><ul>
<li>全局注册</li>
<li>局部注册</li>
</ul>
<h3 id="全局注册-—-只有多个页面都要用到才使用全局"><a href="#全局注册-—-只有多个页面都要用到才使用全局" class="headerlink" title="全局注册 — 只有多个页面都要用到才使用全局"></a>全局注册 — <span class="desc">只有多个页面都要用到才使用全局</span></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">create</span>(&#123;&#125;)</span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;注册的名字&#x27;</span>, 写好的组件) --可以被链式调用</span><br></pre></td></tr></table></figure>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><ul>
<li>使用该组件的父组件引入且在components：{}中注册</li>
</ul>
<h2 id="Props声明-—-组件间通信父传子"><a href="#Props声明-—-组件间通信父传子" class="headerlink" title="Props声明 — 组件间通信父传子"></a>Props声明 — <span class="desc">组件间通信父传子</span></h2><ul>
<li>Prop名字的格式：camelCase</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul>
<li>子组件：在props定义好属性，然后使用</li>
<li>父组件：在组件中调用这个属性，传值</li>
</ul>
<h3 id="组件的props标注类型-—-ts"><a href="#组件的props标注类型-—-ts" class="headerlink" title="组件的props标注类型 — ts"></a>组件的props标注类型 — ts</h3><ul>
<li>defineComponent(): 启用类型推导<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> <span class="comment">// 类型： string | undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>PropType: 多层级时启用工具类<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">PropType</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">author</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">year</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">book</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Object</span> <span class="keyword">as</span> <span class="title class_">PropType</span>&lt;<span class="title class_">Book</span>&gt;,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">callback</span>: <span class="title class_">Function</span> <span class="keyword">as</span> <span class="title class_">PropType</span>&lt;<span class="function">(<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span> &gt;</span><br><span class="line">    <span class="comment">// validater 和 default ts版本低于4.7要使用箭头函数</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">book</span>.<span class="property">title</span> <span class="comment">// string</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callback</span>?.(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="静态prop："><a href="#静态prop：" class="headerlink" title="静态prop："></a>静态prop：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">prop=<span class="string">&quot;只能传字符串&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="动态prop："><a href="#动态prop：" class="headerlink" title="动态prop："></a>动态prop：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:prop=<span class="string">&quot;可传多种类型&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用一个对象绑定多个prop："><a href="#使用一个对象绑定多个prop：" class="headerlink" title="使用一个对象绑定多个prop："></a>使用一个对象绑定多个prop：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-bind=<span class="string">&quot;对象数据&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p><img src="/../../img/vue3/%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="单向数据流"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>所有props都遵循着单向绑定原则</li>
<li>props因父组件的更新而变化</li>
<li>❌ 子组件更改prop</li>
</ul>
<h3 id="prop校验"><a href="#prop校验" class="headerlink" title="prop校验"></a>prop校验</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">props：&#123;</span><br><span class="line">  <span class="attr">propA</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: 该属性的类型</span><br><span class="line">    <span class="attr">default</span>: 该属性的默认值</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>  该属性必传</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">propB</span>: [类型A, 类型B] <span class="comment">// 多类型</span></span><br><span class="line">  <span class="attr">propC</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Object</span> | <span class="title class_">Function</span></span><br><span class="line">    <span class="title function_">default</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">propC</span>: &#123;</span><br><span class="line">    <span class="title function_">validator</span>(<span class="params">value</span>)&#123;&#125; <span class="comment">// 自定义类型校验函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h2><h3 id="触发与监听事件"><a href="#触发与监听事件" class="headerlink" title="触发与监听事件"></a>触发与监听事件</h3><ul>
<li><h3 id="子组件事件"><a href="#子组件事件" class="headerlink" title="子组件事件"></a>子组件事件</h3><ul>
<li>子组件上的要监听事件要调用 $emit 方法，通过传入事件名称来抛出一个事件</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;)&quot;</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="父组件事件"><a href="#父组件事件" class="headerlink" title="父组件事件"></a>父组件事件</h3><ul>
<li>通过 v-on 或 @ 来选择性监听子组件上的事件</li>
<li>示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">子组件名</span> @<span class="attr">enlarge-text</span>=<span class="string">&quot;表达式&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h3><ul>
<li>子组件：$emit(事件名，事件参数)</li>
<li>父组件: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@事件名=<span class="string">&quot;(事件参数) =&gt; 表达式&quot;</span> </span><br><span class="line">或者 </span><br><span class="line">@事件名=<span class="string">&quot;事件处理函数&quot;</span>,  然后在methods写事件处理函数</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="显式声明触发事件-标注类型-emits-ts"><a href="#显式声明触发事件-标注类型-emits-ts" class="headerlink" title="显式声明触发事件+标注类型 emits + ts"></a>显式声明触发事件+标注类型 emits + ts</h3><ul>
<li>语法:<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="attr">emits</span>:[] <span class="comment">// 字符串数组语法</span></span><br><span class="line"><span class="attr">emits</span>:&#123;&#125; <span class="comment">//对象语法，支持校验</span></span><br></pre></td></tr></table></figure></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addBook为事件名，</span></span><br><span class="line"><span class="comment">// bookName为事件内的一个属性且类型为字符串</span></span><br><span class="line"><span class="attr">emits</span>:&#123;</span><br><span class="line">  <span class="title function_">addBook</span>(<span class="params">payload:&#123;bookName: string&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> payload.<span class="property">bookNAme</span>.<span class="property">length</span> &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="attr">onSubmit</span>: &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&#x27;addBook&#x27;</span>,&#123;</span><br><span class="line">      <span class="attr">bookName</span>: <span class="string">&#x27;5655&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="组件-v-model"><a href="#组件-v-model" class="headerlink" title="组件 v-model"></a>组件 v-model</h2><ul>
<li>默认情况下，v-model 在组件上都是使用 modelValue 作为 prop，并以 update:modelValue 作为对应的事件</li>
</ul>
<h3 id="组件上使用v-model实现双向绑定"><a href="#组件上使用v-model实现双向绑定" class="headerlink" title="组件上使用v-model实现双向绑定"></a>组件上使用v-model实现双向绑定</h3><ul>
<li>方法一    <ul>
<li>组件内的表单元素要有以下两行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:value=<span class="string">&quot;modelValue&quot;</span></span><br><span class="line">@input=<span class="string">&quot;$emit(&#x27;update:modelValue&#x27;),$event.target.value&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>方法二<ul>
<li>使用具有 getter 和 setter 的 computed 属性<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;modelValue&#x27;</span>],</span><br><span class="line">  <span class="attr">emits</span>: [<span class="string">&#x27;update:modelValue&#x27;</span>],</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">modelValue</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:modelValue&#x27;</span>, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="v-model的参数-—-适用于组件有多个-v-model-绑定"><a href="#v-model的参数-—-适用于组件有多个-v-model-绑定" class="headerlink" title="v-model的参数 — 适用于组件有多个 v-model 绑定"></a>v-model的参数 — <span class="desc">适用于组件有多个 v-model 绑定</span></h3><ul>
<li>通过给 v-model 指定一个参数来更改modelValue这个名<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 名字从modelValue改为title</span></span><br><span class="line">父组件: &lt;子组件名 v-<span class="attr">model</span>:title=<span class="string">&quot;&quot;</span> /&gt;</span><br><span class="line">子组件:</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: [<span class="string">&#x27;title&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">emits</span>: [<span class="string">&#x27;update:title&#x27;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:value</span>=<span class="string">&quot;title&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="处理-v-model-修饰符"><a href="#处理-v-model-修饰符" class="headerlink" title="处理 v-model 修饰符"></a>处理 v-model 修饰符</h3><ul>
<li>自定义的修饰符 capitalize</li>
<li>示例：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">父组件： &lt;<span class="title class_">MyComponent</span> v-model.<span class="property">capitalize</span>=<span class="string">&quot;myText&quot;</span> /&gt;</span><br><span class="line">子组件：</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">modelValue</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">modelModifiers</span>: &#123;</span><br><span class="line">      <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123;&#125;) <span class="comment">// 默认触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">emits</span>: [<span class="string">&#x27;update:modelValue&#x27;</span>],</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 写给修饰符的对应事件</span></span><br><span class="line">    <span class="title function_">emitValue</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">modelModifiers</span>.<span class="property">capitalize</span>) &#123;</span><br><span class="line">        value = value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:modelValue&#x27;</span>,value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">input</span>=<span class="string">&quot;emitValue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="透传-Attributes：传递给一个组件，却没有被组件声明的属性或v-on"><a href="#透传-Attributes：传递给一个组件，却没有被组件声明的属性或v-on" class="headerlink" title="透传 Attributes：传递给一个组件，却没有被组件声明的属性或v-on"></a>透传 Attributes：传递给一个组件，却没有被组件声明的属性或v-on</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;组件名 <span class="keyword">class</span>=<span class="string">&quot;btn&quot;</span>&gt;&lt;<span class="regexp">/组件名&gt; /</span>/ 这个组件的根元素就多了一个btn的类</span><br></pre></td></tr></table></figure>
<h3 id="单根节点：有自动-attribute-透传行为"><a href="#单根节点：有自动-attribute-透传行为" class="headerlink" title="单根节点：有自动 attribute 透传行为"></a>单根节点：有自动 attribute 透传行为</h3><ul>
<li>禁用Attributes继承：inheritAttrs: false</li>
<li>使用 v-bind&#x3D;”$attrs” 可以让透传的attribute指定到目标元素</li>
</ul>
<h3 id="多根节点（一个组件多个子组件）：没有自动-attribute-透传行为"><a href="#多根节点（一个组件多个子组件）：没有自动-attribute-透传行为" class="headerlink" title="多根节点（一个组件多个子组件）：没有自动 attribute 透传行为"></a>多根节点（一个组件多个子组件）：没有自动 attribute 透传行为</h3><ul>
<li>必须使用 v-bind&#x3D;”$attrs” 让透传的attribute指定到目标元素</li>
</ul>
<h2 id="插槽slot-—在组件中添加-slot标签"><a href="#插槽slot-—在组件中添加-slot标签" class="headerlink" title="插槽slot —在组件中添加 slot标签"></a>插槽slot —在组件中添加 slot标签</h2><ul>
<li>插槽的内容无法访问到子组件的状态</li>
<li>v-slot 简写 #</li>
<li>具名插槽: 适用一个组件多个插槽<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;slot name=<span class="string">&quot;&quot;</span> /&gt; <span class="comment">// 无名=默认插槽</span></span><br></pre></td></tr></table></figure></li>
<li>父组件<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">BaseLayout</span>&gt;</span><br><span class="line">  <span class="comment">// 当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 `&lt;template&gt; `节点都被隐式地视为默认插槽的内容</span></span><br><span class="line">  <span class="comment">// 指定插入那个插槽</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:插槽名</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">插槽名</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">BaseLayout</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li>动态插槽名：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template #[插槽名]&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li>作用域插槽<ul>
<li>插槽内容想要同时使用父组件域内和子组件域内的数据</li>
<li>传递prop: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;slot name=<span class="string">&quot;可不写为默认插槽&quot;</span> message=<span class="string">&quot;hello&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li>
<li>接受插槽：<ul>
<li>默认插槽：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;组件名 v-slot=<span class="string">&quot;slotProps&quot;</span>&gt;&#123;&#123;slotProps.<span class="property">xxx</span>&#125;&#125;&lt;/组件名&gt;</span><br></pre></td></tr></table></figure></li>
<li>具名插槽：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;组件名 #插槽名=<span class="string">&quot;插槽名Props&quot;</span>&gt;&#123;&#123;&#125;&#125;&lt;/组件名&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="Provide"><a href="#Provide" class="headerlink" title="Provide"></a>Provide</h3><ul>
<li>为组件后代提供数据<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">exeport <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">provide</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="应用层-Provide"><a href="#应用层-Provide" class="headerlink" title="应用层 Provide"></a>应用层 Provide</h3><ul>
<li>为整个应用层提供依赖app页面<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">provide</span>(<span class="string">&#x27;注入名&#x27;</span>，值)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Inject"><a href="#Inject" class="headerlink" title="Inject"></a>Inject</h3><ul>
<li>注入上层组件提供的数据<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;message&#x27;</span>],</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>) <span class="comment">// test</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">fullMessage</span>: <span class="variable language_">this</span>.<span class="property">meaaage</span> <span class="comment">// data的时候拿得到this.message</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注入别名-默认值（不要求必须有提供者）"><a href="#注入别名-默认值（不要求必须有提供者）" class="headerlink" title="注入别名&#x2F;默认值（不要求必须有提供者）"></a>注入别名&#x2F;默认值（不要求必须有提供者）</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject</span>: &#123;</span><br><span class="line">  别名: &#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&#x27;原注入名&#x27;</span>, <span class="comment">// 别名</span></span><br><span class="line">    <span class="attr">default</span>: <span class="string">&#x27;default value&#x27;</span>  <span class="comment">// 默认值，无提供者时</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和响应式数据配合使用"><a href="#和响应式数据配合使用" class="headerlink" title="和响应式数据配合使用"></a>和响应式数据配合使用</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 显式提供一个计算属性</span></span><br><span class="line">      <span class="attr">message</span>: <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><ul>
<li>仅在需要时再从服务器加载相关组件 defineAsyncComponent<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp1</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...从服务器获取组件</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="comment">/* 获取到的组件 */</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp2</span> = <span class="title function_">defineAsyncComponent</span>(&#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;组件路径&#x27;</span>),  <span class="comment">// 加载组件</span></span><br><span class="line">  <span class="attr">loadingComponent</span>: <span class="title class_">LoadingComponent</span>, <span class="comment">// 加载异步组件时使用的组件</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>, <span class="comment">// 展示加载组件前的延迟时间，默认为 200ms</span></span><br><span class="line">  <span class="attr">errorComponent</span>: <span class="title class_">ErrorComponent</span>, <span class="comment">// 加载失败后展示的组件</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 像使用其他一般组件一样使用 `AsyncComp`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册：</span></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;MyComponent&#x27;</span>, <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./components/MyComponent.vue&#x27;</span>)</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部注册：</span></span><br><span class="line"><span class="attr">components</span>: &#123;</span><br><span class="line">  异步组件名: <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./components/MyComponent.vue&#x27;</span>)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="动态组件-—-适用于Tab界面"><a href="#动态组件-—-适用于Tab界面" class="headerlink" title="动态组件 — 适用于Tab界面"></a>动态组件 — <span class="desc">适用于Tab界面</span></h2><ul>
<li>在多个组件间作切换时，被切换掉的组件会被卸载<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;component :is=<span class="string">&quot;组件名/组件对象&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="DOM-模板-—-在-DOM-中直接书写-Vue-模板"><a href="#DOM-模板-—-在-DOM-中直接书写-Vue-模板" class="headerlink" title="DOM 模板 — 在 DOM 中直接书写 Vue 模板"></a>DOM 模板 — <span class="desc">在 DOM 中直接书写 Vue 模板</span></h2><ul>
<li>区分大小写，以 kebab-case (短横线连字符) 形式</li>
<li>显示关闭标签: <code>&lt;&gt;&lt;/&gt;</code></li>
<li>元素位置限制，ul标签、ol标签、tr标签 等要放在特定元素中才会显示</li>
<li>解决办法：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">&quot;vue:要放的组件名&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-渲染机制、渲染函数、JSX</title>
    <url>/2024/11/01/vue3/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><blockquote>
<p>将目标所需的UI通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的DOM与之保持同步</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode =&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;div&#x27;</span>,  <span class="comment">// 创建一个&lt;div&gt;元素，并且是虚拟DOM树的根节点</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;rootdiv&#x27;</span>    <span class="comment">// div的 id 为rootdiv </span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    <span class="comment">/*更多的元素*/</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="挂载："><a href="#挂载：" class="headerlink" title="挂载："></a>挂载：</h3><ul>
<li>一个运行时渲染器将会遍历整个虚拟DOM树，并据此构建真实的DOM树</li>
</ul>
<h3 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h3><ul>
<li>存在两份及以上的虚拟树，渲染器会有比较地遍历它们，找区别并应用到真实DOM上</li>
</ul>
<h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><h3 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h3><ul>
<li>Vue模板被编译成<span class="key_words">『渲染函数』</span>，即用来返回虚拟DOM树的函数</li>
</ul>
<h3 id="挂载：-1"><a href="#挂载：-1" class="headerlink" title="挂载："></a>挂载：</h3><ul>
<li>运行时渲染器<span class="key_words">『调用渲染函数，遍历返回的虚拟DOM树，并基于它创建实际的DOM节点』</span>。会作为响应式副作用执行，会追踪所用到的所有响应式依赖</li>
</ul>
<h3 id="更新：-1"><a href="#更新：-1" class="headerlink" title="更新："></a>更新：</h3><ul>
<li>依赖变化,副作用重新运行，创建一个更新后的虚拟DOM树。运行时渲染器<span class="key_words">『遍历新树，与旧树对比』</span>，更新到真实DOM上</li>
</ul>
<h2 id="模板-vs-渲染函数"><a href="#模板-vs-渲染函数" class="headerlink" title="模板 vs 渲染函数"></a>模板 vs 渲染函数</h2><ul>
<li>渲染函数一般只会在需要处理高度动态渲染逻辑的可重用组件中使用</li>
<li>模板对大多数应用场景都是够用且高效</li>
</ul>
<h2 id="带编译时信息的虚拟-DOM"><a href="#带编译时信息的虚拟-DOM" class="headerlink" title="带编译时信息的虚拟 DOM"></a>带编译时信息的虚拟 DOM</h2><ul>
<li>Vue 中，框架同时控制着编译器和运行时。</li>
<li>编译器可以静态分析模板并在生成的代码中留下标记，使得运行时尽可能地走捷径。</li>
<li>保留了边界情况时用户想要使用底层渲染函数的能力。</li>
</ul>
<h3 id="静态提升"><a href="#静态提升" class="headerlink" title="静态提升"></a>静态提升</h3><ul>
<li>模板中的元素不带任何绑定，完全静态，vue编译器会自动提升这部分元素到这个模板的渲染函数外，对比时完全跳过去</li>
</ul>
<h3 id="更新类型标记"><a href="#更新类型标记" class="headerlink" title="更新类型标记"></a>更新类型标记</h3><ul>
<li>对于单个有动态绑定的元素，vue在vnode调用中直接编码每个元素所需的更新类型，且一个元素可以有多个更新类型的标记</li>
</ul>
<h3 id="树结构打平"><a href="#树结构打平" class="headerlink" title="树结构打平"></a>树结构打平</h3><ul>
<li>打平成一个数组，且仅包含所有动态的后代节点。重渲染时，只需遍历打平的树，减少虚拟DOM更新时需遍历的节点数量</li>
</ul>
<h3 id="对SSR激活的影响-–-提升"><a href="#对SSR激活的影响-–-提升" class="headerlink" title="对SSR激活的影响 – 提升"></a>对SSR激活的影响 – 提升</h3><h2 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// h() 函数用于创建vnodes，能生成 HTML (超文本标记语言) 的 JavaScript</span></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">h</span>(</span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>, <span class="comment">// type</span></span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">class</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, <span class="comment">// props</span></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">/* children */</span></span><br><span class="line">  ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, [])</span><br><span class="line"></span><br><span class="line">vnode.<span class="property">type</span> <span class="comment">// &#x27;div&#x27;</span></span><br><span class="line">vnode.<span class="property">props</span> <span class="comment">// &#123; id: &#x27;foo&#x27; &#125;</span></span><br><span class="line">vnode.<span class="property">children</span> <span class="comment">// []</span></span><br><span class="line">vnode.<span class="property">key</span> <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h3 id="声明渲染函数-—-使用render"><a href="#声明渲染函数-—-使用render" class="headerlink" title="声明渲染函数 — 使用render"></a>声明渲染函数 — <span class="desc">使用render</span></h3><ul>
<li>示例：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// render() 函数可以访问同一个 this 组件实例</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, <span class="variable language_">this</span>.<span class="property">msg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Vnodes-必须唯一"><a href="#Vnodes-必须唯一" class="headerlink" title="Vnodes 必须唯一"></a>Vnodes 必须唯一</h3><h3 id="渲染多个重复的元素或者组件-—-工厂函数"><a href="#渲染多个重复的元素或者组件-—-工厂函数" class="headerlink" title="渲染多个重复的元素或者组件 — 工厂函数"></a>渲染多个重复的元素或者组件 — <span class="desc">工厂函数</span></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">20</span> &#125;).<span class="title function_">map</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JSX-TSX-—-是-JavaScript-的一个类似-XML-的扩展"><a href="#JSX-TSX-—-是-JavaScript-的一个类似-XML-的扩展" class="headerlink" title="JSX &#x2F; TSX — 是 JavaScript 的一个类似 XML 的扩展"></a>JSX &#x2F; TSX — <span class="desc">是 JavaScript 的一个类似 XML 的扩展</span></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#123;dynamicId&#125;</span>&gt;</span>hello, &#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>当使用 TSX 语法时，确保在 tsconfig.json 中配置了 “jsx”: “preserve”</li>
</ul>
<h3 id="Vue-的-JSX-编译方式与-React-中-JSX-的编译方式区别"><a href="#Vue-的-JSX-编译方式与-React-中-JSX-的编译方式区别" class="headerlink" title="Vue 的 JSX 编译方式与 React 中 JSX 的编译方式区别"></a>Vue 的 JSX 编译方式与 React 中 JSX 的编译方式区别</h3><ul>
<li>可以使用 HTML attributes 比如 class 和 for 作为 props </li>
<li>不需要使用 className 或 htmlFor。</li>
<li>传递子元素给组件 (比如 slots) 的方式不同。</li>
</ul>
<h2 id="渲染案例"><a href="#渲染案例" class="headerlink" title="渲染案例"></a>渲染案例</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><ul>
<li>渲染函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [<span class="variable language_">this</span>.<span class="property">ok</span> ? <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;yes&#x27;</span>) : <span class="title function_">h</span>(<span class="string">&#x27;span&#x27;</span>, <span class="string">&#x27;no&#x27;</span>)])</span><br></pre></td></tr></table></figure></li>
<li>JSX： <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.ok ? <span class="tag">&lt;<span class="name">div</span>&gt;</span>yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span> : <span class="tag">&lt;<span class="name">span</span>&gt;</span>no<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ul>
<li>渲染函数：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">h</span>(</span><br><span class="line">  <span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; id, text &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">key</span>: id &#125;, text)</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>JSX：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &#123;<span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; id, text &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;id&#125;</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  &#125;)&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul>
<li>渲染函数：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">h</span>(</span><br><span class="line">  <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="title function_">onClick</span>(<span class="params">event</span>) &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;click me&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>JSX：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  onClick=&#123;<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  click me</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="事件修饰符-–-使用驼峰写法将他们拼接在事件名后面"><a href="#事件修饰符-–-使用驼峰写法将他们拼接在事件名后面" class="headerlink" title="事件修饰符 – 使用驼峰写法将他们拼接在事件名后面"></a>事件修饰符 – <span class="desc">使用驼峰写法将他们拼接在事件名后面</span></h3><ul>
<li>.passive —&gt; onClickPassive</li>
<li>对于事件和按键修饰符，可以使用 withModifiers 函数：</li>
<li>渲染函数：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withModifiers &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">onClick</span>: <span class="title function_">withModifiers</span>(<span class="function">() =&gt;</span> &#123;&#125;, [<span class="string">&#x27;self&#x27;</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>JSX：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div onClick=&#123;<span class="title function_">withModifiers</span>(<span class="function">() =&gt;</span> &#123;&#125;, [<span class="string">&#x27;self&#x27;</span>])&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="组件-–-不再需要注册组件-直接导入"><a href="#组件-–-不再需要注册组件-直接导入" class="headerlink" title="组件 – 不再需要注册组件,直接导入"></a>组件 – <span class="desc">不再需要注册组件,直接导入</span></h3><ul>
<li>渲染函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [<span class="title function_">h</span>(<span class="title class_">Foo</span>), <span class="title function_">h</span>(<span class="title class_">Bar</span>)])</span><br></pre></td></tr></table></figure></li>
<li>JSX： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Foo</span> /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="渲染插槽-–-通过-this-slots-来访问插槽"><a href="#渲染插槽-–-通过-this-slots-来访问插槽" class="headerlink" title="渲染插槽 – 通过 this.$slots 来访问插槽"></a>渲染插槽 – <span class="desc">通过 this.$slots 来访问插槽</span></h3><ul>
<li>渲染函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="title function_">default</span>())</span><br></pre></td></tr></table></figure></li>
<li>JSX: <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.$slots.default()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="传递插槽"><a href="#传递插槽" class="headerlink" title="传递插槽"></a>传递插槽</h3><ul>
<li>传递一个插槽函数或者是一个包含插槽函数的对象而非是数组</li>
<li>插槽函数的返回值同一个正常的渲染函数的返回值一样——并且在子组件中被访问时总是会被转化为一个 vnodes 数组。</li>
<li>渲染函数：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个默认插槽</span></span><br><span class="line"><span class="title function_">h</span>(<span class="title class_">MyComponent</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名插槽</span></span><br><span class="line"><span class="comment">// 注意 `null` 是必需的</span></span><br><span class="line"><span class="comment">// 以避免 slot 对象被当成 prop 处理</span></span><br><span class="line"><span class="title function_">h</span>(<span class="title class_">MyComponent</span>, <span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">default</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;default slot&#x27;</span>,</span><br><span class="line">    <span class="attr">foo</span>: <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    <span class="attr">bar</span>: <span class="function">() =&gt;</span> [<span class="title function_">h</span>(<span class="string">&#x27;span&#x27;</span>, <span class="string">&#x27;one&#x27;</span>), <span class="title function_">h</span>(<span class="string">&#x27;span&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>JSX：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认插槽</span></span><br><span class="line">&lt;<span class="title class_">MyComponent</span>&gt;&#123;<span class="function">() =&gt;</span> <span class="string">&#x27;hello&#x27;</span>&#125;&lt;/<span class="title class_">MyComponent</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名插槽</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span>&#123;&#123;</span></span><br><span class="line"><span class="language-xml">  default: () =&gt; &#x27;default slot&#x27;,</span></span><br><span class="line"><span class="language-xml">  foo: () =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">  bar: () =&gt; [<span class="tag">&lt;<span class="name">span</span>&gt;</span>one<span class="tag">&lt;/<span class="name">span</span>&gt;</span>, <span class="tag">&lt;<span class="name">span</span>&gt;</span>two<span class="tag">&lt;/<span class="name">span</span>&gt;</span>]</span></span><br><span class="line"><span class="language-xml">&#125;&#125;<span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>插槽以函数的形式传递使得它们可以被子组件懒调用。</li>
</ul>
<h3 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h3><ul>
<li>在渲染函数中必须导入才能使用</li>
</ul>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul>
<li>扩展为 modelValue 和 onUpdate:modelValue, 模板编译过程中必须自己提供props<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;modelValue&#x27;</span>],</span><br><span class="line">  <span class="attr">emits</span>: [<span class="string">&#x27;update:modelValue&#x27;</span>],</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">SomeComponent</span>, &#123;</span><br><span class="line">      <span class="attr">modelValue</span>: <span class="variable language_">this</span>.<span class="property">modelValue</span>,</span><br><span class="line">      <span class="string">&#x27;onUpdate:modelValue&#x27;</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:modelValue&#x27;</span>, value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><ul>
<li>当一个指令是以名称注册并且不能被直接导入时，可以使用 resolveDirective 函数<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, withDirectives &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义指令</span></span><br><span class="line"><span class="keyword">const</span> pin = &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="title function_">updated</span>(<span class="params"></span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;div v-pin:top.animate=&quot;200&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">withDirectives</span>(<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>), [</span><br><span class="line">  [pin, <span class="number">200</span>, <span class="string">&#x27;top&#x27;</span>, &#123; <span class="attr">animate</span>: <span class="literal">true</span> &#125;]</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><ul>
<li>使用 withDirectives 将自定义指令应用于 vnode<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为函数式组件里没有 this 引用,Vue 会把 props 当作第一个参数传入</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">  <span class="attr">context</span>:&#123;attrs,emit,slots&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyComponent</span>.<span class="property">inheritAttrs</span> = <span class="literal">false</span> <span class="comment">// 没有明确指定 props 的函数式组件，需禁透传</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-组合式函数(参见react hook)</title>
    <url>/2024/11/01/vue3/%E7%BB%84%E5%90%88%E5%BC%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数 — 把js&#x2F;ts代码封装成一个方法。</p>
</blockquote>
<h2 id="约定和最佳实践"><a href="#约定和最佳实践" class="headerlink" title="约定和最佳实践"></a>约定和最佳实践</h2><h3 id="命名-方法名以use开头-驼峰形式"><a href="#命名-方法名以use开头-驼峰形式" class="headerlink" title="命名: 方法名以use开头,驼峰形式"></a>命名: 方法名以use开头,驼峰形式</h3><h3 id="输入参数-unref"><a href="#输入参数-unref" class="headerlink" title="输入参数 unref()"></a>输入参数 unref()</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useFeature</span>(<span class="params">maybeRef</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">unref</span>(maybeRef)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>约定：组合式函数始终返回一个包含多个 ref 的普通的非响应式对象（<span class="desc">因为ref可以维持在解构过程中与组合式函数内状态的响应式连接</span>）</li>
<li>reactive(组合式函数) – <span class="desc">以对象属性的形式来使用组合式函数中返回的状态</span></li>
</ul>
<h3 id="副作用：组件挂载后在调用生命周期钩子并及时清理"><a href="#副作用：组件挂载后在调用生命周期钩子并及时清理" class="headerlink" title="副作用：组件挂载后在调用生命周期钩子并及时清理"></a>副作用：组件挂载后在调用生命周期钩子并及时清理</h3><h3 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h3><ul>
<li>组合式函数在 script setup标签 或 setup() 钩子中，应始终被<span class="key_words">『同步』</span>地调用。在某些场景下，也可以在 onMounted() 中使用。</li>
</ul>
<h2 id="在选项式-API-中使用组合式函数"><a href="#在选项式-API-中使用组合式函数" class="headerlink" title="在选项式 API 中使用组合式函数"></a>在选项式 API 中使用组合式函数</h2><ul>
<li>组合式函数必须在setup()中调用，且其返回的绑定必须在setup()中返回</li>
<li>示例： <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMouse &#125; <span class="keyword">from</span> <span class="string">&#x27;./mouse.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useFetch &#125; <span class="keyword">from</span> <span class="string">&#x27;./fetch.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMouse</span>()</span><br><span class="line">    <span class="keyword">const</span> &#123; data, error &#125; = <span class="title function_">useFetch</span>(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; x, y, data, error &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// setup() 暴露的属性可以在通过 `this` 访问到</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...其他选项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="与其他模式比较"><a href="#与其他模式比较" class="headerlink" title="与其他模式比较"></a>与其他模式比较</h2><h3 id="与-Mixin-的对比"><a href="#与-Mixin-的对比" class="headerlink" title="与 Mixin 的对比"></a>与 Mixin 的对比</h3><ul>
<li>Minxin存在短板，vue3不推荐使用，存在只为项目迁移的需求</li>
</ul>
<h3 id="与-无渲染组件-的对比"><a href="#与-无渲染组件-的对比" class="headerlink" title="与 无渲染组件 的对比"></a>与 无渲染组件 的对比</h3><ul>
<li>组合式函数不会产生额外的组件实例开销</li>
</ul>
<h3 id="与-React-Hooks-的对比"><a href="#与-React-Hooks-的对比" class="headerlink" title="与 React Hooks 的对比"></a>与 React Hooks 的对比</h3><ul>
<li>仅调用 setup() 或 script setup标签 的代码一次。不需要担心闭包变量的问题。组合式 API 也并不限制调用顺序，还可以有条件地进行调用。</li>
<li>Vue 的响应性系统运行时会自动收集计算属性和侦听器的依赖，因此无需手动声明依赖。</li>
<li>无需手动缓存回调函数来避免不必要的组件更新。Vue 细粒度的响应性系统能够确保在绝大部分情况下组件仅执行必要的更新。</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE3-自定义指令</title>
    <url>/2024/11/01/vue3/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="自定义指令的使用"><a href="#自定义指令的使用" class="headerlink" title="自定义指令的使用"></a>自定义指令的使用</h2><h3 id="何时使用自定义指令："><a href="#何时使用自定义指令：" class="headerlink" title="何时使用自定义指令："></a>何时使用自定义指令：</h3><ul>
<li>只有当所需功能<span class="key_words">『只能通过直接的 DOM 操作』</span>来实现时</li>
</ul>
<h3 id="不推荐在组件上使用自定义指令-—-多根组件"><a href="#不推荐在组件上使用自定义指令-—-多根组件" class="headerlink" title="不推荐在组件上使用自定义指令 — 多根组件"></a>不推荐在组件上使用自定义指令 — <span class="desc">多根组件</span></h3><ul>
<li>始终应用于组件的根节点，和透传 attributes 类似</li>
<li>指令不能通过 v-bind&#x3D;”$attrs” 来传递给一个不同的元素</li>
</ul>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><ul>
<li>全局注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>局部注册<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;foucs <span class="comment">/* 启用 v-focus*/</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h2><h3 id="el"><a href="#el" class="headerlink" title="el"></a>el</h3><ul>
<li>指令绑定到的元素。用于直接操作 DOM。</li>
<li>除了 el 外，其他参数都是只读的</li>
</ul>
<h3 id="binding"><a href="#binding" class="headerlink" title="binding"></a>binding</h3><ul>
<li>一个对象，包含以下属性</li>
<li>value: 传递给指令的值</li>
<li>oldValue: 之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。</li>
<li>arg: 传递给指令的参数</li>
<li>modifiers: 一个包含修饰符的对象。<span class="desc">例如在 v-my-directive.foo.bar 中，修饰符对象是 { foo: true, bar: true }。</span></li>
<li>instance: 使用该指令的组件实例</li>
<li>dir: 指令的定义对象</li>
</ul>
<h3 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h3><ul>
<li>代表绑定元素的底层 VNode</li>
</ul>
<h3 id="prevNode"><a href="#prevNode" class="headerlink" title="prevNode"></a>prevNode</h3><ul>
<li>之前的渲染中代表指令所绑定元素的 VNode<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myDirective = &#123;</span><br><span class="line">  <span class="comment">// 在绑定元素的属性或事件监听器应用前调用</span></span><br><span class="line">  <span class="title function_">created</span>(<span class="params">el, binding, vnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在元素被插入到 DOM 前调用</span></span><br><span class="line">  <span class="title function_">beforeMount</span>(<span class="params">el, binding, vnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在绑定元素的父组件及他自己的所有子节点都挂载完成后调用</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding, vnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定元素的父组件更新前调用</span></span><br><span class="line">  <span class="title function_">beforeUpdate</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在绑定元素的父组件及他自己的所有子节点都更新后调用</span></span><br><span class="line">  <span class="title function_">updated</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载前调用</span></span><br><span class="line">  <span class="title function_">beforeUnmount</span>(<span class="params">el, binding, vnode</span>) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载后调用</span></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params">el, binding, vnode</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="简化形式-—-仅用-mounted-和-updated-的指令"><a href="#简化形式-—-仅用-mounted-和-updated-的指令" class="headerlink" title="简化形式 — 仅用 mounted 和 updated 的指令"></a>简化形式 — <span class="desc">仅用 mounted 和 updated 的指令</span></h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;div v-color=<span class="string">&quot;color&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;color&#x27;</span>, <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这会在 `mounted` 和 `updated` 时都调用</span></span><br><span class="line">  el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="对象字面量-—-指令需要多个值"><a href="#对象字面量-—-指令需要多个值" class="headerlink" title="对象字面量 — 指令需要多个值"></a>对象字面量 — <span class="desc">指令需要多个值</span></h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;div v-demo=<span class="string">&quot;&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;&quot;</span> &gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;demo&#x27;</span>, <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(binding.<span class="property">value</span>.<span class="property">color</span>) <span class="comment">// =&gt; &quot;white&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(binding.<span class="property">value</span>.<span class="property">text</span>) <span class="comment">// =&gt; &quot;hello!&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE2-基础（主了解）</title>
    <url>/2024/11/01/vue2/%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>阻止 vue 在启动时生成生产提示<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="创建一个vue实例"><a href="#创建一个vue实例" class="headerlink" title="创建一个vue实例"></a>创建一个vue实例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>:<span class="string">&#x27;#demo&#x27;</span>, <span class="comment">// el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。</span></span><br><span class="line">	<span class="attr">data</span>:&#123; <span class="comment">// data中用于存储数据，数据供el所指定的容器去使用</span></span><br><span class="line">		<span class="attr">name</span>:<span class="string">&#x27;atguigu&#x27;</span>,</span><br><span class="line">		<span class="attr">address</span>:<span class="string">&#x27;北京&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><ul>
<li>插值语法<ul>
<li>功能：用于解析标签体内容</li>
<li>写法：<code>&#123;&#123;xxx&#125;&#125;</code>，xxx是js表达式，且可以直接读取到data中的所有属性</li>
</ul>
</li>
<li>指令语法<ul>
<li>功能：用于解析标签（<span class="desc">包括：标签属性、标签体内容、绑定事件…</span>）</li>
<li>示例：v-bind:href&#x3D;”xxx” 或  简写为 :href&#x3D;”xxx”</li>
</ul>
</li>
</ul>
<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><ul>
<li>单向绑定(v-bind)：数据只能从data流向页面</li>
<li>双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data</li>
<li>注：<ul>
<li><span class="key_words">『双向绑定一般都应用在表单类元素上』</span></li>
<li>v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</li>
</ul>
</li>
</ul>
<h2 id="el与data的两种写法"><a href="#el与data的两种写法" class="headerlink" title="el与data的两种写法"></a>el与data的两种写法</h2><ul>
<li>el有2种写法<ul>
<li>1.new Vue时候配置el属性</li>
<li>2.先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值<ul>
<li>把new Vue创建的实例赋值给变量vm，然后使用vm.$mount(‘#root’)来添加</li>
</ul>
</li>
</ul>
</li>
<li>data有2种写法<ul>
<li>对象式: data: {}</li>
<li>函数式(组件只能用函数式): data() { return{}}</li>
</ul>
</li>
<li>重点：<span class="key_words">『由Vue管理的函数，一定不要写箭头函数&#x3D;&gt;』</span>,一旦写了，this就不再是Vue实例了</li>
</ul>
<h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><ul>
<li>视图模型双向绑定。</li>
<li>M(Model)：data中的数据</li>
<li>V(View)：UI组件，模板代码</li>
<li>VM(ViewModel)：Vue实例，M和V的桥梁，数据会绑定到VM并自动将数据渲染到页面中，视图变化的时候会通知VM更新数据。以前时操作DOM结构更新视图，现在是数据驱动视图.</li>
<li>观察可发现：<ul>
<li>data中所有的属性，最后都出现在了vm身上。</li>
<li>vm身上所有的属性及Vue原型上所有属性，在Vue模板中都可以直接使用</li>
</ul>
</li>
<li>优点：<ul>
<li>低耦合</li>
<li>可复用</li>
<li>独立开发</li>
<li>可测试</li>
</ul>
</li>
</ul>
<h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><ul>
<li>定义：通过一个对象代理对另一个对象中属性的操作（读&#x2F;写）<br><img src="/../../img/vue2/%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86.jpg" alt="数据代理"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="Object-defineproperty方法"><a href="#Object-defineproperty方法" class="headerlink" title="Object.defineproperty方法"></a>Object.defineproperty方法</h3><ul>
<li>定义：会直接在一个对象上定义一个新属性，或修改其现有属性，并返回此对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">18</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">	<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person,<span class="string">&#x27;age&#x27;</span>,&#123;</span><br><span class="line">	<span class="comment">// value:18,</span></span><br><span class="line">	<span class="comment">// enumerable:true, //控制属性是否可以枚举，默认值是false</span></span><br><span class="line">	<span class="comment">// writable:true, //控制属性是否可以被修改，默认值是false</span></span><br><span class="line">	<span class="comment">// configurable:true //控制属性是否可以被删除，默认值是false</span></span><br><span class="line">	<span class="comment">// 以上属性都可以在控制台被修改，删除delete person.age</span></span><br><span class="line">	<span class="comment">// 当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值</span></span><br><span class="line">	<span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> number</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值</span></span><br><span class="line">	<span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">		number = value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Vue中的数据代理"><a href="#Vue中的数据代理" class="headerlink" title="Vue中的数据代理"></a>Vue中的数据代理</h3><ul>
<li>通过vm对象来代理data对象中属性的操作（读&#x2F;写）</li>
<li>优点：更加方便的操作data中的数据</li>
<li>基本原理：<ol>
<li>通过Object.defineProperty()把data对象中所有属性添加到vm上</li>
<li>为每一个添加到vm上的属性，都指定一个getter&#x2F;setter</li>
<li>在getter&#x2F;setter内部去操作（读&#x2F;写）data中对应的属性</li>
</ol>
<ul>
<li>比如data对象中定义的属性，在vm中要使用_data.属性名来读取</li>
</ul>
</li>
</ul>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li>使用 v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名</li>
<li>事件的回调需要配置在methods对象中，最终会在vm上</li>
<li><span class="key_words">『methods中配置的函数，不要用箭头函数』</span>！否则this就不是vm了</li>
<li>methods中配置的函数，都是被Vue所管理的函数，<span class="key_words">『this的指向是vm 或 组件实例对象』</span></li>
<li>@click&#x3D;”demo” 和 @click&#x3D;”demo($event)” 效果一致，但后者可以传参</li>
</ul>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul>
<li>prevent：阻止默认事件</li>
<li>stop：阻止事件冒泡</li>
<li>once：事件只触发一次</li>
<li>capture：使用事件的捕获模式，先捕获在冒泡</li>
<li>self：只有event.target是当前操作的元素时才触发事件，self也能阻止冒泡</li>
<li>passive：事件的默认行为立即执行，无需等待事件回调执行完毕<ul>
<li>@scroll滚动条滚动触发,到滚动条末端不会再触发，<ul>
<li>流程：优先滚动滚动条,然后在执行事件，不需要passive</li>
</ul>
</li>
<li>@wheel鼠标的滚轮滚动触发,到滚动条末端,只要滚轮在动就会触发<ul>
<li>流程：滚动滚轮,先执行事件,后滚动条在往下走，passive后：先滚动,在执行demo</li>
</ul>
</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div @click.<span class="property">prevent</span>.<span class="property">stop</span>=<span class="string">&quot;showInfo&quot;</span>&gt;修饰符可以连续使用&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ul>
<li>@keydown：键盘按下时触发</li>
<li>@keyup：键盘弹起</li>
<li>@keypress：键盘按住时触发</li>
<li><h3 id="常用的按键别名"><a href="#常用的按键别名" class="headerlink" title="常用的按键别名"></a>常用的按键别名</h3><ul>
<li>回车 &#x3D;&gt; @keyup.enter</li>
<li>删除 &#x3D;&gt; @keyup.delete (捕获“删除”和“退格”键)</li>
<li>退出 &#x3D;&gt; @keyup.esc</li>
<li>空格 &#x3D;&gt; @keyup.space</li>
<li>换行 &#x3D;&gt; @keyup.tab (特殊，必须配合keydown去使用)  把当前元素当前位置切走</li>
<li>上 &#x3D;&gt; @keyup.up</li>
<li>下 &#x3D;&gt; @keyup.down</li>
<li>左 &#x3D;&gt; @keyup.left</li>
<li>右 &#x3D;&gt; @keyup.right</li>
</ul>
</li>
<li>Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case形式</li>
<li><h3 id="系统修饰键（用法特殊）：ctrl、alt、shift、meta-windows键"><a href="#系统修饰键（用法特殊）：ctrl、alt、shift、meta-windows键" class="headerlink" title="系统修饰键（用法特殊）：ctrl、alt、shift、meta(windows键)"></a>系统修饰键（用法特殊）：ctrl、alt、shift、meta(windows键)</h3><ul>
<li>配合keyup使用：按下修饰键的同时，再按下任意键，随后释放任意键，事件才被触发<ul>
<li>比如按ctrl+y,还可以用ctrl.y来指定只有使用ctrl+y才可以触发事件</li>
</ul>
</li>
<li>配合keydown使用：正常触发事件。</li>
</ul>
</li>
<li><h3 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h3><ul>
<li>.left</li>
<li>.right</li>
<li>.middle</li>
</ul>
</li>
<li>Vue.config.keyCodes.自定义键名 &#x3D; 键码，可以去定制按键别名</li>
<li><a href="https://cn.vuejs.org/guide/essentials/event-handling.html#key-modifiers">更多别名</a></li>
</ul>
<h2 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性(computed)"></a>计算属性(computed)</h2><ul>
<li>定义：要用的属性不存在，要通过已有属性计算得来。</li>
<li>原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</li>
<li>get函数什么时候执行？<ol>
<li>初次读取时会执行一次。</li>
<li>当依赖的数据发生改变时会被再次调用。</li>
</ol>
</li>
<li>优势：与methods实现相比，内部有缓存机制(复用)，效率更高，调试方便。</li>
<li>备注：<ol>
<li>计算属性最终会出现在vm上，直接读取使用即可。</li>
<li>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">	<span class="comment">// 简写(只读不写)</span></span><br><span class="line">	<span class="title function_">fullName</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//完整写法</span></span><br><span class="line">	<span class="attr">fullName</span>: &#123;</span><br><span class="line">		<span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">			<span class="keyword">const</span> arr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">firstName</span>= arr[<span class="number">0</span>]</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">lastName</span> = arr[<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="监视属性-watch"><a href="#监视属性-watch" class="headerlink" title="监视属性(watch)"></a>监视属性(watch)</h2><ul>
<li>当被监视的属性变化时, 回调函数自动调用, 进行相关操作</li>
<li><span class="key_words">『监视的属性必须存在，才能进行监视』</span></li>
<li>写法<ol>
<li>new Vue时传入watch配置</li>
<li>通过vm.$watch监视</li>
</ol>
</li>
<li>深度监视<ul>
<li>deep:true可以监视多级结构中所有属性的变化</li>
</ul>
</li>
<li>写法一示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">	<span class="comment">// 完整写法</span></span><br><span class="line">	<span class="attr">isHot</span>:&#123;</span><br><span class="line">		<span class="attr">immediate</span>:<span class="literal">true</span>, <span class="comment">//初始化时让handler调用一下</span></span><br><span class="line">		<span class="attr">deep</span>:<span class="literal">true</span>, <span class="comment">// 深度监视</span></span><br><span class="line">		<span class="comment">//当isHot发生改变时，handler被调用</span></span><br><span class="line">		<span class="title function_">handler</span>(<span class="params">newValue,oldValue</span>)&#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isHot被修改了&#x27;</span>,newValue,oldValue)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 简写</span></span><br><span class="line">	<span class="title function_">isHot</span>(<span class="params">newValue,oldValue</span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isHot被修改了&#x27;</span>,newValue,oldValue,<span class="variable language_">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//监视多级结构中某个属性的变化</span></span><br><span class="line">	<span class="string">&#x27;numbers.a&#x27;</span>:&#123;</span><br><span class="line">		<span class="title function_">handler</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a被改变了&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>写法二示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完整写法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;isHot&#x27;</span>,&#123;</span><br><span class="line">	<span class="comment">// 其它的一样</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;isHot&#x27;</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 其它的一样</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="computed和watch之间的区别"><a href="#computed和watch之间的区别" class="headerlink" title="computed和watch之间的区别"></a>computed和watch之间的区别</h3><ul>
<li>computed能完成的功能，watch都可以完成。优先使用computed</li>
<li>watch属性监听是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听特定数据的变化，从而进行某些具体的业务逻辑操作，监听属性的变化，需要在数据变化时执行异步或开销大的操作时使用。</li>
<li>computed计算属性，属性的结果会被缓存，当computed中的函数所依赖的属性没有改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当作属性来使用。computed中的函数必须用return返回最终的结果。data不变，computed不更新</li>
<li>使用场景：<ul>
<li>computed：当一个属性搜多个属性影响时使用，如商品结算</li>
<li>watch：当一条数据影响多条数据时使用，如搜索</li>
</ul>
</li>
<li>两个重要的原则<ol>
<li>所有被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</li>
<li>所有不被Vue所管理的函数（<span class="desc">定时器的回调函数、ajax的回调函数等、Promise的回调函数</span>），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。</li>
</ol>
</li>
</ul>
<h2 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式"></a>绑定样式</h2><h3 id="class样式"><a href="#class样式" class="headerlink" title="class样式"></a>class样式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">class</span>=<span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>xxx可以是字符串、对象、数组。</li>
<li>字符串写法适用于：类名不确定，要动态获取。</li>
<li>对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</li>
<li>数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</li>
</ul>
<h3 id="style样式"><a href="#style样式" class="headerlink" title="style样式"></a>style样式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:style=<span class="string">&quot;&#123;fontSize: xxx&#125;&quot;</span> <span class="comment">// 其中xxx是动态值</span></span><br><span class="line">:style=<span class="string">&quot;[a,b]&quot;</span> <span class="comment">// 其中a、b是样式对象</span></span><br></pre></td></tr></table></figure>

<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-<span class="keyword">if</span>=<span class="string">&quot;表达式&quot;</span> </span><br><span class="line">v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;表达式&quot;</span></span><br><span class="line">v-<span class="keyword">else</span>=<span class="string">&quot;表达式&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>适用于：切换频率较低的场景。</li>
<li>特点：不展示的DOM元素直接被移除。</li>
<li>注意：v-if可以和v-else-if、v-else一起使用，但要求结构不能被”打断”</li>
</ul>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-show=<span class="string">&quot;表达式&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>适用于：切换频率较高的场景。</li>
<li>特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</li>
<li>备注：<ul>
<li>template只能与v-if一起用</li>
<li>使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</li>
</ul>
</li>
</ul>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="基本列表-v-for指令"><a href="#基本列表-v-for指令" class="headerlink" title="基本列表(v-for指令):"></a>基本列表(v-for指令):</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in/of xxx&quot;</span> :key=<span class="string">&quot;index&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用于展示列表数据</li>
<li>可遍历：数组、对象、字符串（不常用）、指定次数（不常用，of 次数）</li>
</ul>
<h3 id="v-for-与-对象"><a href="#v-for-与-对象" class="headerlink" title="v-for 与 对象"></a>v-for 与 对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">&quot;(value, key) in myObject&quot;</span>&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>value：表值</li>
<li>key：表属性名</li>
<li>index：表索引</li>
</ul>
<h3 id="在-v-for-里使用范围值"><a href="#在-v-for-里使用范围值" class="headerlink" title="在 v-for 里使用范围值"></a>在 v-for 里使用范围值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span v-<span class="keyword">for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<h3 id="template标签-上的-v-for"><a href="#template标签-上的-v-for" class="headerlink" title="template标签 上的 v-for"></a>template标签 上的 v-for</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">for</span>=<span class="string">&quot;item in items&quot;</span>&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在组件标签上使用"><a href="#在组件标签上使用" class="headerlink" title="在组件标签上使用"></a>在组件标签上使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">MyComponent</span></span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in items&quot;</span></span><br><span class="line">  :item=<span class="string">&quot;item&quot;</span></span><br><span class="line">  :index=<span class="string">&quot;index&quot;</span></span><br><span class="line">  :key=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">&lt;/<span class="title class_">MyComponent</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="列表过滤"><a href="#列表过滤" class="headerlink" title="列表过滤"></a>列表过滤</h3><ul>
<li>表单使用v-model实现双向数据绑定</li>
<li>在计算属性或者监听属性上处理数据，并使用filter</li>
<li>字符串的模糊搜索，使用indexof</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">	<span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> list.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> item.<span class="property">str</span>.<span class="title function_">indexof</span>(keyWord) !== -<span class="number">1</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">p1,p2</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回p2-p1是降序(高到低)，返回p1-p2是升序(从低到高)</li>
</ul>
<h3 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h3><ul>
<li>push()：将一个或多个元素添加到数组的末尾，并返回该数组的新长度</li>
<li>pop()：从数组中删除最后一个元素，并返回该元素的值</li>
<li>shift()：从数组中删除第一个元素，并返回该元素的值</li>
<li>unshift()：将一个或多个元素添加到数组的开头，并返回该数组的新长度</li>
<li>splice()：删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。<span class="desc">此方法会改变原数组</span></li>
<li>sort()：排序(升序)。<span class="desc">此方法会改变原数组</span></li>
<li>reverse()：排序(降序)。<span class="desc">此方法会改变原数组</span></li>
<li>filter()：过滤</li>
<li>替换原数组：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">items.<span class="property">value</span> = items.<span class="property">value</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> 条件)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="react、vue中的key有什么作用？（key的内部原理）"><a href="#react、vue中的key有什么作用？（key的内部原理）" class="headerlink" title="react、vue中的key有什么作用？（key的内部原理）"></a>react、vue中的key有什么作用？（key的内部原理）</h2><ol>
<li>虚拟DOM中key的作用：<ul>
<li>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据<span class="key_words">『新数据生成新的虚拟DOM』</span>, 随后Vue进行<span class="key_words">『新虚拟DOM与旧虚拟DOM的差异比较』</span></li>
</ul>
</li>
<li>对比规则：<ul>
<li>旧虚拟DOM中存在与新虚拟DOM<span class="key_words">『相同的key』</span><ul>
<li>内容<span class="key_words">『没变, 使用旧的』</span>真实DOM</li>
<li>内容<span class="key_words">『变了, 则生成新的真实DOM，并替换掉旧的』</span>真实DOM</li>
</ul>
</li>
<li>旧虚拟DOM中<span class="key_words">『未找到』</span>与新虚拟DOM相同的key<ul>
<li><span class="key_words">『创建新的真实DOM』</span>，随后渲染到到页面</li>
</ul>
</li>
</ul>
</li>
<li>用index作为key可能会引发的问题：<ul>
<li>若对数据进行：<span class="key_words">『逆序添加、逆序删除』</span>等破坏顺序操作:<ul>
<li>会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低</li>
</ul>
</li>
<li>如果结构中还<span class="key_words">『包含输入类的DOM』</span>：<ul>
<li>会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题</li>
</ul>
</li>
</ul>
</li>
<li>开发中如何选择key?<ul>
<li>最好<span class="key_words">『使用每条数据的唯一标识作为key』</span></li>
<li>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，<span class="key_words">『仅用于渲染列表用于展示，使用index作为key』</span>是没有问题的。</li>
</ul>
</li>
</ol>
<h2 id="Vue检测数据改变的原理"><a href="#Vue检测数据改变的原理" class="headerlink" title="Vue检测数据改变的原理"></a>Vue检测数据改变的原理</h2><h3 id="vue-set"><a href="#vue-set" class="headerlink" title="vue.set()"></a>vue.set()</h3><ul>
<li>使用场景：对数组或对象进行操作时，有些操作是非响应式的，所以使用Vue.set()来进行响应式的数据更新</li>
<li>Vue不能检测以下变动<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.<span class="property">list</span>[<span class="number">0</span>] = newValue</span><br><span class="line">vm.<span class="property">list</span>.<span class="property">length</span> = newLength</span><br><span class="line">property 的添加或移除</span><br></pre></td></tr></table></figure></li>
<li>使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(target,index,newValue) </span><br><span class="line">vm.$set(vm.<span class="property">items</span>, indexOfItem, newValue)</span><br></pre></td></tr></table></figure></li>
<li>注：vue不允许添加根级响应式属性，只可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性</li>
</ul>
<h3 id="数据监测的原理"><a href="#数据监测的原理" class="headerlink" title="数据监测的原理"></a>数据监测的原理</h3><ul>
<li>vue会监视data中所有层次的数据</li>
<li>如何监测对象中的数据？<ul>
<li>通过setter实现监视，且要在new Vue时就传入要监测的数据</li>
</ul>
<ol>
<li>对象中后追加的属性，Vue默认不做响应式处理</li>
<li>如需给后添加的属性做响应式，请使用如下API：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(target，propertyName/index，value) </span><br><span class="line">或 </span><br><span class="line">vm.$set(target，propertyName/index，value)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>如何监测数组中的数据？<ul>
<li>通过包裹数组更新元素的方法实现，本质就是做了两件事：<ul>
<li>调用原生对应的方法对数组进行更新。</li>
<li>重新解析模板，进而更新页面。</li>
</ul>
</li>
</ul>
</li>
<li>在Vue修改数组中的某个元素一定要用如下方法：<ul>
<li>使用这些API: push()、pop()、shift()、unshift()、splice()、sort()、reverse()</li>
<li>Vue.set() 或 vm.$set()</li>
</ul>
</li>
<li>特别注意：Vue.set() 和 vm.$set() 不能给vm或vm的根数据对象添加属性</li>
</ul>
<h3 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h3><ul>
<li>type&#x3D;”text”，则v-model收集的是value值，用户输入的就是value值</li>
<li>type&#x3D;”radio”，则v-model收集的是value值，且要给标签配置value值</li>
<li>type&#x3D;”checkbox”<ul>
<li>没有配置input的value属性，那么收集的就是checked</li>
<li>配置input的value属性:<ol>
<li>v-model的初始值是非数组，那么收集的就是checked</li>
<li>v-model的初始值是数组，那么收集的的就是value组成的数组</li>
</ol>
</li>
</ul>
</li>
<li>备注：v-model的三个修饰符：<ul>
<li>lazy：失去焦点再收集数据</li>
<li>number：输入字符串转为有效的数字</li>
<li>trim：输入首尾空格过滤</li>
</ul>
</li>
</ul>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ul>
<li>定义：对要显示的数据进行特定格式化后再显示</li>
<li>语法：<ul>
<li>注册过滤器：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(name,callback) 或 <span class="keyword">new</span> <span class="title class_">Vue</span>&#123;<span class="attr">filters</span>:&#123;&#125;&#125; </span><br><span class="line"><span class="comment">// name: 过滤器的名字，filters里面定义过滤的函数</span></span><br></pre></td></tr></table></figure></li>
<li>使用过滤器：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123; xxx | 过滤器名&#125;&#125;</span><br><span class="line">或</span><br><span class="line">v-<span class="attr">bind</span>:属性 = <span class="string">&quot;xxx | 过滤器名&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注： <ul>
<li>过滤器也可以接收额外参数、多个过滤器也可以串联</li>
<li>并没有改变原本的数据, 是产生新的对应的数据</li>
</ul>
</li>
</ul>
<h3 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h3><ul>
<li>v-bind: 单向绑定解析表达式, 可简写为 :xxx</li>
<li>v-model: 双向数据绑定</li>
<li>v-for: 遍历数组&#x2F;对象&#x2F;字符串</li>
<li>v-on: 绑定事件监听, 可简写为 @</li>
<li>v-if: 条件渲染（动态控制节点是否存在）</li>
<li>v-else: 条件渲染（动态控制节点是否存在）</li>
<li>v-show: 条件渲染 (动态控制节点是否展示)</li>
</ul>
<h3 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h3><ul>
<li>v-text指令<ul>
<li>作用：向其所在的节点中渲染文本内容<ul>
<li>用法：在标签上使用v-text&#x3D;”str”</li>
<li>与插值语法的区别：v-text会替换掉节点中的内容，<code>&#123;&#123;xx&#125;&#125;</code>则不会</li>
</ul>
</li>
</ul>
</li>
<li>v-html指令<ul>
<li>作用：向指定节点中渲染包含html结构的内容</li>
<li>用法：在标签上使用v-html&#x3D;”str”</li>
<li>与插值语法的区别：<ul>
<li>v-html会替换掉节点中所有的内容，<code>&#123;&#123;xx&#125;&#125;</code>则不会</li>
<li>v-html可以识别html结构。</li>
</ul>
</li>
<li>严重注意：v-html有安全性问题！！！<ul>
<li>在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击</li>
<li>一定要在可信的内容上使用v-html，不要用在用户提交的内容上</li>
</ul>
</li>
<li>cookie本质是字符串</li>
</ul>
</li>
<li>v-cloak指令<ul>
<li>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</li>
<li>使用css配合v-cloak可以解决网速慢时页面展示出的问题</li>
<li>用法：在标签上使用v-cloak</li>
</ul>
</li>
<li>v-once指令<ul>
<li>v-once所在节点在初次动态渲染后，就视为静态内容</li>
<li>数据的改变不会引起v-once所在结构的更新，可以用于优化性能</li>
<li>用法：在标签上使用v-once</li>
</ul>
</li>
<li>v-pre指令<ul>
<li>跳过其所在节点的编译过程</li>
<li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译</li>
<li>用法：在标签上使用v-pre</li>
</ul>
</li>
</ul>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><ol>
<li>定义语法<ul>
<li>局部指令：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123; <span class="attr">directives</span>: &#123;指令名:配置对象/回调函数&#125; &#125;)</span><br></pre></td></tr></table></figure></li>
<li>全局指令：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(指令名,配置对象/回调函数)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>配置对象中常用的3个回调：<ul>
<li>bind：指令与元素成功绑定时调用</li>
<li>inserted：指令所在元素被插入页面时调用</li>
<li>update：指令所在模板结构被重新解析时调用</li>
</ul>
</li>
<li>注：<ul>
<li>指令定义时不加v-，但使用时要加v-</li>
<li>指令名如果是多个单词，要使用kebab-case命名方式</li>
</ul>
</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>定义：Vue在关键时刻帮我们调用的一些特殊名称的函数。生命周期函数中的this指向是vm 或 组件实例对象。<br><img src="/../../img/vue2/lifecycle2.png" alt="vue2的生命周期"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>常用的生命周期钩子<ul>
<li>mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】</li>
<li>beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】</li>
</ul>
</li>
<li>关于销毁Vue实例<ol>
<li>销毁后借助Vue开发者工具看不到任何信息</li>
<li>销毁后自定义事件会失效，但原生DOM事件依然有效</li>
<li>一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程</li>
</ol>
</li>
</ul>
<h3 id="非单文件组件"><a href="#非单文件组件" class="headerlink" title="非单文件组件"></a>非单文件组件</h3><ul>
<li>Vue中使用组件的三大步骤：<ul>
<li>定义组件(创建组件)<ul>
<li>使用Vue.extend(options)，其中options和new Vue()时的options相似，但也有区别<ul>
<li><span class="key_words">『el不要写』</span>，最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器</li>
<li><span class="key_words">『data必须写成函数』</span>，避免组件被复用时，数据存在引用关系</li>
</ul>
</li>
</ul>
</li>
<li>注册组件<ol>
<li>局部注册：new Vue的时候传入components选项</li>
<li>全局注册：</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;组件名&#x27;</span>,组件) </span><br></pre></td></tr></table></figure>
<ul>
<li>使用组件(写组件标签): - <code>&lt;school/&gt;</code></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="keyword">const</span> school = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">	<span class="attr">template</span>:<span class="string">`&lt;div&gt;......&lt;/div&gt;`</span>,</span><br><span class="line">	<span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;&#125; <span class="comment">//这里定义的变量是template中使用的</span></span><br><span class="line">	&#125;，</span><br><span class="line">	methods：&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;school&#x27;</span>,school)</span><br></pre></td></tr></table></figure></li>
<li>注：<ul>
<li>组件名写法：kebab-case命名 或 CamelCase命名(需要Vue脚手架支持)</li>
<li>组件标签：不使用脚手架时，<code>&lt;school/&gt;</code>会导致后续组件不能渲染</li>
<li>简写方式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> school = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(options) </span><br><span class="line">简写：<span class="keyword">const</span> school = options</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="VueComponent"><a href="#VueComponent" class="headerlink" title="VueComponent"></a>VueComponent</h3><ul>
<li>组件本质是一个VueComponent的构造函数，且不是自定义的，是Vue.extend生成的</li>
<li>组件标签是Vue解析时会创建的实例对象，即Vue执行new VueComponent(options)</li>
<li>每次调用Vue.extend，返回的都是一个全新的VueComponent</li>
<li>this指向：<ol>
<li>组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数,this均是<span class="key_words">『VueComponent实例对象』</span></li>
<li>new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数,this均是<span class="key_words">『Vue实例对象』</span></li>
</ol>
</li>
<li>VueComponent的实例对象，简称vc;Vue的实例对象，简称vm</li>
<li>内置关系：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">VueComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>让组件实例对象(vc)可以访问到 Vue原型上的属性、方法</li>
</ul>
</li>
</ul>
<h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><ul>
<li>直接引用</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE2-拓展（主了解）</title>
    <url>/2024/11/01/vue2/%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="经典面试题-—-路由篇"><a href="#经典面试题-—-路由篇" class="headerlink" title="经典面试题 — 路由篇"></a>经典面试题 — 路由篇</h3><ol>
<li><p>编程式导航push与replace区别?</p>
<ul>
<li>能记录历史记录：push</li>
<li>不能记住历史记录：replace</li>
</ul>
</li>
<li><p>路由组件与非路由组件的区别</p>
<ul>
<li>文件放置位置不同</li>
<li>路由组件一般需要在router文件夹中进行注册，非路由组件在使用的时候，一般但是以标签的形式使用</li>
<li>注册完路由，不管是路由组件还是非路由组件身上都有$route、$router属性<ul>
<li>$route: 一般获取路由信息(<span class="desc">路径、query、params等</span>)</li>
<li>$router: 一般进行编程式导航进行路由跳转(<span class="desc">push|replace</span>)</li>
</ul>
</li>
</ul>
</li>
<li><p>路由传递参数（对象写法）path是否可以结合params参数一起使用？</p>
<ul>
<li>不可以,路由传参的时候，对象的写法可以是name、path形式，但是path这中写法不能与params参数一起使用</li>
</ul>
</li>
<li><p>如何指定params参数可传可不传？</p>
<ul>
<li>在配置路由的文件下，给对应路由传参占位的地方后面加一个 ?</li>
</ul>
</li>
<li><p>params参数可以传递也可以不传递，但是如果传递的是空串，如何解决？</p>
<ul>
<li>使用undefined解决：params参数: ‘’ || undefined 即可</li>
</ul>
</li>
<li><p>路由组件能不能传递props数据</p>
<ul>
<li>可以，有三种写法：(<span class="desc">路由组件只能传递props属性，并且是params参数</span>)<ul>
<li>布尔值写法</li>
<li>对象写法: 额外的给路由组件传递一些props</li>
<li>函数写法（常见）：可以params参数、query参数，通过props传递给路由组件</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="经典面试题-—-其它"><a href="#经典面试题-—-其它" class="headerlink" title="经典面试题 — 其它"></a>经典面试题 — 其它</h3><ol>
<li><p>函数防抖与节流</p>
<ul>
<li>正常：<ul>
<li>事件触发非常频繁，而且每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部有计算，那么很可能出现浏览器卡顿）</li>
</ul>
</li>
<li>防抖：<ul>
<li>前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次</li>
</ul>
</li>
<li>节流：<ul>
<li>在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发</li>
</ul>
</li>
<li>需要把防抖与节流的原理，通过JS实现(<span class="desc">闭包 + 延迟器</span>)</li>
<li>按需加载引用loadsh插件</li>
</ul>
</li>
<li><p>GET与POST</p>
<ul>
<li>相同点：都是HTTP协议。</li>
<li>不同点:<ul>
<li>GET请求携带参数是有上限的且相对而言不安全，post请求携带的参数是没有’上限的’但安全</li>
</ul>
</li>
</ul>
</li>
<li><p>token面试题:项目当中token过期、失效如何处理？</p>
<ul>
<li>清除本地token（本地存储），让用户回到登录页，获取最新的token</li>
</ul>
</li>
<li><p>本地存储与会话存储区别？</p>
<ul>
<li>本地存储：持久化的5m；</li>
<li>会话存储：并非持久, 会话结束就消失</li>
</ul>
<p>	</p>
</li>
<li><p>v-for 与 v-if 的优先级？ </p>
<ul>
<li>vue 2 中，在同一个元素上使用，v-for 的优先级高于 v-if。<span class="desc">比较浪费资源</span></li>
<li>vue 3 中，v-if 的优先级总是高于 v-for。<span class="desc">所以如果v-if变量不存在会导致异常</span></li>
</ul>
</li>
<li><p>项目的性能优化手段</p>
<ul>
<li>v-if|v-show：尽可能采用v-show</li>
<li>按需引入：如lodash、elementUI</li>
<li>防抖与节流</li>
<li>路由懒加载</li>
</ul>
</li>
</ol>
<h3 id="其它知识"><a href="#其它知识" class="headerlink" title="其它知识"></a>其它知识</h3><h3 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h3><ul>
<li><a href="http://mockjs.com/">mock官方地址</a></li>
<li>模拟的数据一般：对象、数组</li>
<li>安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install mockjs</span><br></pre></td></tr></table></figure></li>
<li>在src文件夹下创建mock文件夹</li>
<li>准备模拟的数据</li>
<li>注：mock数据需要的图片要放置于public文件夹中！</li>
<li>在mock文件夹中创建一个server.js文件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Mock</span> = <span class="built_in">require</span>(<span class="string">&#x27;mockjs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title class_">Mock</span>.<span class="title function_">mock</span>(&#123;<span class="string">&#x27;list&#x27;</span>:[&#123;&#125;]&#125;)</span><br></pre></td></tr></table></figure></li>
<li>回到入口文件，引入serve.js</li>
<li>之后写一个请求用来模拟API</li>
</ul>
<h4 id="分页器业务"><a href="#分页器业务" class="headerlink" title="分页器业务"></a>分页器业务</h4><ul>
<li>前端三大件:轮播图、分页、日历。这属于前端开发常见三种业务</li>
<li>分页器封装业务分析:</li>
<li>需知：总数据条数，一页最多展示多少条数据，当前页数，连续页码数(一般5、7、9,案例用5)<ul>
<li>当前页数为1， 则展示连续页码数1，2，3，4，5</li>
<li>当前页数为2， 则展示连续页码数1，2，3，4，5</li>
<li>当前页数为最后一页n，则展示n-4，n-3，n-2，n-1，n</li>
<li>当前页数为最后一页n-1，则展示n-4，n-3，n-2，n-1，n</li>
<li>当前页数为除以上数字m，则展示m-2，m-1，m，m+1,m+2</li>
</ul>
</li>
</ul>
<h4 id="身份凭证"><a href="#身份凭证" class="headerlink" title="身份凭证"></a>身份凭证</h4><ul>
<li>UUID生成的临时身份</li>
<li>用户（注册与登录）token(<span class="desc">正式身份</span>)</li>
</ul>
<h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><ul>
<li>路由懒加载: 当用户访问的时候，加载对应组件进行展示</li>
<li>图片懒加载: vue-lazyload</li>
</ul>
<h4 id="框架-组件库的选择"><a href="#框架-组件库的选择" class="headerlink" title="框架 + 组件库的选择"></a>框架 + 组件库的选择</h4><ul>
<li>react框架:<ul>
<li>UI组件库antd(<span class="desc">蚂蚁金服旗下PC端UI组件库</span>)</li>
<li>antd-mobile(<span class="desc">蚂蚁金服旗下的移动端UI组件库</span>)</li>
</ul>
</li>
<li>Vue框架:<ul>
<li>element-UI(<span class="desc">饿了么旗下的UI组件库，官方承认的PC组件库插件</span>)</li>
<li>vant(<span class="desc">Vue官方提供移动端UI组件库</span>)</li>
</ul>
</li>
</ul>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ul>
<li>qrcode插件：展示二维码<ul>
<li>通过qrCode.toDataUrl方法，将字符串转换为加密的在线二维码链接，通过图片进行展示</li>
</ul>
</li>
<li>swiper.js：处理滚动屏<ul>
<li>安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">swiper：cnpm install --save swiper@<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li>引入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Swiper</span> <span class="keyword">from</span> <span class="string">&#x27;swiper&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-<span class="keyword">for</span>=<span class="string">&quot;(carousel,index) in 轮播图请求返回的数据&quot;</span> :key=<span class="string">&quot;carousel.id&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>注：引入swiper的实例，！！！在引入前，页面中的结构必须要有不然看不见</li>
<li>解决方案：watch(数据监听) –&gt; 监听已有数据的变化 + nextTick(<span class="desc">在图片列表从初始值变为接收的数据时，循环结束之后，执行延迟回调</span>)</li>
<li>分析：<ul>
<li>mounted：代表组件挂载完毕，正常说组件结构DOM已经全有了。但是不包括AJAX，获取动态数据</li>
<li>v-for,在遍历来自于Vuex（<span class="desc">数据:通过ajax向服务器发请求，存在异步</span>）</li>
<li>mounted挂载后–&gt;store.dispatch派发axios，通知vuex发送数据–&gt;发送请求提交mutations修改state–&gt;state有了数据组件才能获得相应的数据(<span class="desc">要延时，所以不能直接写swiper的实例</span>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="moment-js：处理时间"><a href="#moment-js：处理时间" class="headerlink" title="moment.js：处理时间"></a>moment.js：处理时间</h4><h4 id="nprogress-js：-处理进度条"><a href="#nprogress-js：-处理进度条" class="headerlink" title="nprogress.js： 处理进度条"></a>nprogress.js： 处理进度条</h4><h4 id="vee-validate插件：Vue官方提供的一个表单验证的插件"><a href="#vee-validate插件：Vue官方提供的一个表单验证的插件" class="headerlink" title="vee-validate插件：Vue官方提供的一个表单验证的插件"></a>vee-validate插件：Vue官方提供的一个表单验证的插件</h4><ul>
<li>安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cnpm i vee-validate@<span class="number">2</span> --save</span><br></pre></td></tr></table></figure></li>
<li>引入：在main.js文件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VeeValidate</span> <span class="keyword">from</span> <span class="string">&#x27;vee-validate&#x27;</span></span><br><span class="line"><span class="keyword">import</span> zh_CN <span class="keyword">from</span> <span class="string">&#x27;vee-validate/dist/locale/zh_CN&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VeeValidate</span>)</span><br></pre></td></tr></table></figure></li>
<li>提示信息<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">VeeValidate</span>.<span class="property">Validator</span>.<span class="title function_">localize</span>(<span class="string">&#x27;zh_CN&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">messages</span>: &#123;</span><br><span class="line">		...zh_CN.<span class="property">messages</span>,</span><br><span class="line">		<span class="attr">is</span>: <span class="function">(<span class="params">field</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;field&#125;</span>必须与密码相同`</span> <span class="comment">// 修改内置规则的 message，让确认密码和密码相同</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">attributes</span>: &#123; <span class="comment">// 给校验的 field 属性名映射中文名称</span></span><br><span class="line">		<span class="attr">phone</span>: <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">		<span class="attr">code</span>: <span class="string">&#x27;验证码&#x27;</span>,</span><br><span class="line">		<span class="attr">password</span>:<span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">		<span class="attr">password1</span>:<span class="string">&#x27;确认密码&#x27;</span>,</span><br><span class="line">		<span class="attr">isCheck</span>:<span class="string">&#x27;协议&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>在表单标签上添加<ul>
<li>绑定v-model&#x3D;”attributes的字段”</li>
<li>v-validate&#x3D;”{ required: true, regex: 验证规则 }”</li>
</ul>
</li>
<li>页面使用：errors.has(“字段”)来使用…</li>
<li>代码等待全部验证：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> success = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$validator</span>.<span class="title function_">validateAll</span>()</span><br></pre></td></tr></table></figure></li>
<li>自定义校验规则：定义协议必须打勾同意<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">VeeValidate</span>.<span class="property">Validator</span>.<span class="title function_">extend</span>(<span class="string">&#x27;agree&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">validate</span>: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> value</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">getMessage</span>: <span class="function"><span class="params">field</span> =&gt;</span> field + <span class="string">&#x27;必须同意&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>知识</tag>
        <tag>面试题</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE-组件通信</title>
    <url>/2024/11/01/vue2/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="父子数据同步"><a href="#父子数据同步" class="headerlink" title="父子数据同步"></a>父子数据同步</h2><ul>
<li>v-model指令，可以收集表单数据（<span class="desc">注：v-model收集checkbox需要用数组收集</span>）</li>
<li>属性修饰符.sync，可以实现父子数据同步。</li>
</ul>
<h2 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h2><ul>
<li>props</li>
<li>插槽</li>
</ul>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><ul>
<li>传递数据类型：<ul>
<li>函数 — <span class="desc">实质子组件想给父亲传递数据</span></li>
<li>非函数 — <span class="desc">实质就是父亲给子组件传递数据</span></li>
</ul>
</li>
<li>示例：<ul>
<li>传递动态：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;child :msg=<span class="string">&quot;动态数据&quot;</span> updateChecked=<span class="string">&quot;hander&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li>传递静态数据：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;child msg=<span class="string">&quot;父组件定义一个属性向子组件传递信息&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
<li>子组件在data前面添加props: [‘msg’],然后可以直接使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view&gt;&#123;&#123;msg&#125;&#125;&lt;/view&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>特殊情况：路由传递props<ul>
<li>布尔值类型，把路由中params参数映射为组件props数据</li>
<li>对象，静态数据</li>
<li>函数，可以把路由中params|query参数映射为组件props数据</li>
</ul>
</li>
</ul>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><ul>
<li>作用：<ol>
<li>父组件通过调用子组件内部嵌套html内容作为slot分发给子组件</li>
<li>子组件通过在slot标签上添加属性，向父组件通信数据，作用域插槽</li>
</ol>
</li>
<li>分类：默认插槽、具名插槽、作用域插槽</li>
</ul>
<h4 id="默认插槽name-”default”："><a href="#默认插槽name-”default”：" class="headerlink" title="默认插槽name&#x3D;”default”："></a>默认插槽name&#x3D;”default”：</h4><ul>
<li>父组件使用子组件标签，并在开始和结束标签中间添加内容，单标签不添加内容</li>
<li>子组件在页面中使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;slot&gt;父组件传递的内容会插入slot中&lt;/slot&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="具名插槽："><a href="#具名插槽：" class="headerlink" title="具名插槽："></a>具名插槽：</h4><ul>
<li>适用于多个插槽</li>
<li>父组件在页面中使用子组件标签时，添加内容的模板标签上指定插槽名<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template v-<span class="attr">slot</span>:slotname&gt;&lt;<span class="regexp">/template&gt; /</span>/ v-slot只能用在template上</span><br></pre></td></tr></table></figure></li>
<li>子组件在页面中使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;slot name=<span class="string">&quot;slotname&quot;</span>&gt;父组件传递的内容会插入slot中&lt;/slot&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="作用域插槽："><a href="#作用域插槽：" class="headerlink" title="作用域插槽："></a>作用域插槽：</h4><ul>
<li>理解：<span class="key_words">『在父组件中访问子组件的数据，但是展示的样式由父组件决定』</span></li>
<li>在子组件的插槽标签上中绑定数据：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;slot :<span class="keyword">var</span>=<span class="string">&quot;data&quot;</span> name=<span class="string">&quot;slotname&quot;</span>&gt;&#123;&#123;data&#125;&#125;&lt;<span class="regexp">/slot&gt; /</span>/ data是在子组件中定义的</span><br></pre></td></tr></table></figure></li>
<li>父组件使用子组件标签，在内容区域使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template v-<span class="attr">slot</span>:slotname=<span class="string">&quot;接收数据的变量名，且等于子组件的data&quot;</span>&gt;...&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h2><ul>
<li>自定义事件</li>
<li>ref：在父组件内部获取子组件</li>
<li>$children：在父组件内部获取全部的子组件<span class="key_words">『返回数组』</span></li>
<li>$parent：在子组件内部获取唯一的父组件<span class="key_words">『返回组件实例』</span></li>
</ul>
<h3 id="自定义事件-emit-on-简写"><a href="#自定义事件-emit-on-简写" class="headerlink" title="自定义事件($emit, $on[简写@])"></a>自定义事件($emit, $on[简写@])</h3><ul>
<li>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件，<span class="key_words">『事件的回调在A中』</span></li>
<li>绑定自定义事件, 方式一在父组件中：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Child</span> @childEvent=<span class="string">&quot;要触发的事件&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>要触发的事件要在父组件的methods中定义</li>
<li>父组件可以通过该事件的参数获取子组件传递的信息</li>
<li>子组件也要定义任意一个事件，在该事件要触发<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;childEvent&#x27;</span>，<span class="string">&#x27;要传递的参数&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>绑定自定义事件, 方式二，在父组件中给组件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;实例名&quot;</span>/&gt;</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">$refs</span>.实例名.$on(<span class="string">&#x27;事件名&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>若想让自定义事件只能触发一次，可以使用 once修饰符，或 $once方法</li>
<li>自定义事件名：父组件通过该事件的参数获取子组件传递过来的数据，名字随意</li>
<li>子组件触发自定义事件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;事件名&#x27;</span>,数据)</span><br></pre></td></tr></table></figure></li>
<li>子组件解绑自定义事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$off(<span class="string">&#x27;事件名&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>组件上也可以绑定原生DOM事件，需要使用 native修饰符</li>
<li>注意：<span class="desc">通过 this.$refs.实例名.$on(‘事件名’,获取事件的回调)，回调要事先在methods中定义或用箭头函数</span></li>
</ul>
<h2 id="跨级组件通信"><a href="#跨级组件通信" class="headerlink" title="跨级组件通信"></a>跨级组件通信</h2><ul>
<li>$attrs：组件实例的属性，可以获取到父亲传递的props数据（前提子组件没有通过props接受）</li>
<li>$listeners：组件实例的属性，可以获取到父亲传递自定义事件（对象形式呈现）</li>
</ul>
<h2 id="万能"><a href="#万能" class="headerlink" title="万能"></a>万能</h2><ul>
<li>全局事件总线</li>
<li>pubsub</li>
</ul>
<h3 id="bus全局事件总线（GlobalEventBus）"><a href="#bus全局事件总线（GlobalEventBus）" class="headerlink" title="$bus全局事件总线（GlobalEventBus）"></a>$bus全局事件总线（GlobalEventBus）</h3><ul>
<li>安装全局事件总线：在main.js的new Vue中添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，<span class="key_words">『事件的回调留在A组件自身』</span><ul>
<li>在mounted中使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;自定义事件名&#x27;</span>,事件的回调函数)</span><br></pre></td></tr></table></figure></li>
<li>在beforeDestroy中解绑<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$off(<span class="string">&#x27;自定义事件名&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>提供数据：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$emit(<span class="string">&#x27;自定义事件名&#x27;</span>,数据)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="pubsub-js-消息订阅与发布"><a href="#pubsub-js-消息订阅与发布" class="headerlink" title="pubsub-js[消息订阅与发布]"></a>pubsub-js[消息订阅与发布]</h3><ol>
<li>安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i pubsub-js</span><br></pre></td></tr></table></figure></li>
<li>引入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pubsub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>接收数据：A组件接收数据，则在A组件中订阅消息，订阅的<span class="key_words">『回调留在A组件自身』</span><ul>
<li>在mounted中添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;自定义事件名&#x27;</span>,回调事件)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>提供数据：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;自定义事件名&#x27;</span>,数据)</span><br></pre></td></tr></table></figure></li>
<li>在beforeDestroy中，用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">unsubscribe</span>(pid) <span class="comment">// 取消订阅</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE2-路由（主了解）</title>
    <url>/2024/11/01/vue2/%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="路由-vue2版"><a href="#路由-vue2版" class="headerlink" title="路由(vue2版)"></a>路由(vue2版)</h2><ol>
<li>理解： 一个路由(route)就是一组映射关系(key - value)，多个路由需要路由器(router)进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3 id="路由标签"><a href="#路由标签" class="headerlink" title="路由标签"></a>路由标签</h3><ul>
<li>router-link：to属性指定组件的链接</li>
<li>router-view：路由出口，to指定的路由组件渲染在该标签内</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>安装vue-router，命令：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i vue-router</span><br></pre></td></tr></table></figure></li>
<li>应用插件：在main.js中添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br></pre></td></tr></table></figure></li>
<li>编写router配置项:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li>
<li>导入全局：在mian.js中引入router文件，并添加到new Vue中</li>
<li>实现切换：借助router-link标签(active-class可配置高亮样式)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link active-<span class="keyword">class</span>=<span class="string">&quot;active&quot;</span> to=<span class="string">&quot;/about&quot;</span>&gt;<span class="title class_">About</span>&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
<li>指定展示位置：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>路由组件通常存放在 pages 文件夹，一般组件通常存放在 components 文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的 $route 属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的 $router 属性获取到。</li>
</ol>
<h3 id="多级路由"><a href="#多级路由" class="headerlink" title="多级路由"></a>多级路由</h3><ol>
<li>配置路由规则，使用children配置项：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">About</span>,</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">	<span class="attr">children</span>:[&#123; <span class="comment">//通过children配置子级路由</span></span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">	&#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li>
<li>跳转(要写完整路径)：<ul>
<li>在父级组件页面中：指定展示位置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">&quot;/home/news&quot;</span>&gt;<span class="title class_">News</span>&lt;<span class="regexp">/router-link&gt;`，并添加`&lt;router-view&gt;&lt;/</span>router-view&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><ul>
<li>作用：可以简化路由的跳转。</li>
<li>使用<ul>
<li>给路由命名： 给路由表的每个路由添加name属性<ul>
<li>简化跳转：在router-link标签上使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:to=<span class="string">&quot;&#123;name:&quot;</span>xxx<span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>带参跳转：在router-link标签上使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:to=<span class="string">&quot;&#123; name:&quot;</span>xxx<span class="string">&quot;,query:&#123;params:value&#125; &#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="路由的query参数"><a href="#路由的query参数" class="headerlink" title="路由的query参数"></a>路由的query参数</h3><ol>
<li>跳转并携带query参数<ul>
<li>to的字符串写法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">&quot;/home/news?参数名1=值&amp;参数名1=值&quot;</span>&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
<li>to的对象写法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;path:&#x27;/home/news&#x27;, query:&#123; 参数名1=值 &#125;&#125;&quot;</span>&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>接收参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">query</span>.参数名</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="路由的params参数"><a href="#路由的params参数" class="headerlink" title="路由的params参数"></a>路由的params参数</h3><ol>
<li>在路由表上的path属性中使用占位符声明接收params参数<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:参数1/:参数2&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>跳转并携带params参数<ul>
<li>to的字符串写法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">&quot;/home/news/参数1的值/参数2的值&quot;</span>&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
<li>to的对象写法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name:&#x27;路由的name&#x27;, params:&#123;参数1:值,参数2:值&#125; &#125;&quot;</span>&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
<li>注意：路由携带params参数时，使用to的对象写法，只能使用name配置</li>
</ul>
</li>
<li>接收参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">params</span>.参数名</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h3><ul>
<li>作用：让路由组件更方便的收到参数</li>
<li>使用：在路由表上的路由添加props配置<ul>
<li>写法一：props值为对象，该对象中所有的 key-value 的组合最终都会通过props传给该路由组件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123; <span class="attr">key</span>: value &#125;</span><br></pre></td></tr></table></figure></li>
<li>写法二：props值为布尔值，布尔值为true，则把路由收到的所有 params 参数通过props传给该路由组件<ul>
<li>示例：props:true</li>
</ul>
</li>
<li>写法三：props值为函数，该函数返回的对象中每一组key-value都会通过props传给该路由组件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">props</span>(<span class="params">route</span>)&#123; <span class="keyword">return</span> &#123;<span class="attr">id</span>: route.<span class="property">query</span>.<span class="property">id</span>,&#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="router-link标签-的replace属性"><a href="#router-link标签-的replace属性" class="headerlink" title="router-link标签 的replace属性"></a>router-link标签 的replace属性</h3><ul>
<li>作用：控制路由跳转时<span class="key_words">『操作浏览器历史记录的模式』</span></li>
<li>浏览器的历史记录有两种写入方式：分别为 push 和 replace，push 是追加历史记录，replace 是替换当前记录。路由跳转时候默认为push</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link replace&gt;<span class="title class_">News</span>&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><ul>
<li>定义：不借助router-link标签实现路由跳转，调用 API 方法实现导航的方式</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">push：<span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>:<span class="string">&#x27;路由的name&#x27;</span>, <span class="attr">params</span>:&#123; <span class="attr">id</span>:xxx,&#125; &#125;)</span><br><span class="line">replace：<span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123; <span class="attr">name</span>:<span class="string">&#x27;路由的name&#x27;</span>, <span class="attr">params</span>:&#123; <span class="attr">id</span>:xxx,&#125; &#125;)</span><br><span class="line">前进：<span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>()</span><br><span class="line">后退：<span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>()</span><br><span class="line">可前进也可后退：<span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="缓存路由组件keep-alive"><a href="#缓存路由组件keep-alive" class="headerlink" title="缓存路由组件keep-alive"></a>缓存路由组件keep-alive</h3><ul>
<li>作用：让不展示的路由组件保持挂载，不被销毁，避免了反复渲染影响性能</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">&quot;路由名&quot;</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span>&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><ul>
<li>作用：对路由进行权限控制，每个路由添加meta属性</li>
<li>分类：全局守卫、独享守卫、组件内守卫</li>
</ul>
<h4 id="全局守卫："><a href="#全局守卫：" class="headerlink" title="全局守卫："></a>全局守卫：</h4><ul>
<li>用法：在路由表中配置，路由配置完在写</li>
<li>全局前置守卫 router.beforeEach：初始化时执行、每次路由切换前执行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;本地存储的字段&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line">			<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>全局后置守卫 router.afterEach：初始化时执行、每次路由切换后执行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">title</span>)&#123; </span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="独享守卫-beforeEnter："><a href="#独享守卫-beforeEnter：" class="headerlink" title="独享守卫 beforeEnter："></a>独享守卫 beforeEnter：</h4><ul>
<li>用法：与全局前置路由相似，但它是在路由表里的单独的路由里面配置的</li>
</ul>
<h4 id="组件内守卫："><a href="#组件内守卫：" class="headerlink" title="组件内守卫："></a>组件内守卫：</h4><ul>
<li>用法：与全局前置路由相似，但它是在组件页面配置的</li>
<li>进入守卫 beforeRouteEnter：通过路由规则，进入该组件时被调用</li>
<li>离开守卫 beforeRouteLeave：通过路由规则，离开该组件时被调用</li>
</ul>
<h3 id="路由器的两种工作模式"><a href="#路由器的两种工作模式" class="headerlink" title="路由器的两种工作模式"></a>路由器的两种工作模式</h3><ul>
<li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li>
<li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li>
<li>hash模式：<ol>
<li>地址中永远带着#号，不美观</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法</li>
<li>兼容性较好</li>
</ol>
</li>
<li>history模式：<ol>
<li>地址干净，美观 </li>
<li>兼容性和hash模式相比略差</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>路由</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE2-进阶（主了解）</title>
    <url>/2024/11/01/vue2/%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><pre><code>├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre>
<h2 id="关于不同版本的Vue："><a href="#关于不同版本的Vue：" class="headerlink" title="关于不同版本的Vue："></a>关于不同版本的Vue：</h2><ul>
<li>vue.js与vue.runtime.xxx.js的区别：<ul>
<li>vue.js是完整版的Vue，包含：核心功能+模板解析器</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器</li>
</ul>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容</li>
</ul>
<h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ul>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">Vue CLI</a></li>
</ul>
<h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ul>
<li>作用：给元素或子组件注册引用信息</li>
<li>标签上使用 ref&#x3D;”str”</li>
<li>在函数中通过this.$refs.str 来获取真实DOM元素</li>
<li><span class="key_words">『应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象(vc)』</span></li>
</ul>
<h2 id="props配置"><a href="#props配置" class="headerlink" title="props配置"></a>props配置</h2><ul>
<li>父组件使用子组件的标签，并通过子组件的标签传递属性<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">School</span> name=<span class="string">&quot;moli&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>子组件通过props声明接收,三种方式：<ul>
<li>简单接收：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:[<span class="string">&#x27;name&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li>接收并对数据进行类型限制：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;<span class="attr">sex</span>:<span class="title class_">String</span>,<span class="attr">name</span>:<span class="title class_">String</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>接收并对数据进行类型限制+默认值的指定+必要性的限制<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line">	<span class="attr">name</span>:&#123;</span><br><span class="line">		<span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">// 类型是字符串</span></span><br><span class="line">		<span class="attr">requigreen</span>:<span class="literal">true</span>, <span class="comment">// 必填的</span></span><br><span class="line">		<span class="attr">default</span>:<span class="string">&#x27;a&#x27;</span> <span class="comment">// 默认值</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注：<span class="desc">props是只读的，Vue底层会监测props的修改，如果改动，就会发出警告，若需要修改，则将props的内容添加到data，并给标签上的变量前面添加v-bind</span></li>
</ul>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ul>
<li>功能：可以把多个组件共用的配置提取成一个混入对象</li>
<li>单独创建一个js文件，然后把共用的变量和方法写好，并暴露出来<ul>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> huhe = &#123;<span class="title function_">data</span>(<span class="params"></span>)&#123;&#125;,<span class="attr">methods</span>:&#123;&#125;,...&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在需要使用的组件中引入import<ul>
<li>全局混入：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(xxx)</span><br></pre></td></tr></table></figure></li>
<li>局部混入：在组件中添加 mixins:[xxx] 配置</li>
</ul>
</li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul>
<li>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据</li>
<li>定义插件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">	<span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">	<span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line">	<span class="comment">// 2. 添加全局指令</span></span><br><span class="line">	<span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;指令名&#x27;</span>&#123;</span><br><span class="line">		<span class="comment">//指令与元素成功绑定时（一上来）</span></span><br><span class="line">		<span class="title function_">bind</span>(<span class="params">element,binding</span>)&#123;</span><br><span class="line">			element.<span class="property">value</span> = binding.<span class="property">value</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//指令所在元素被插入页面时</span></span><br><span class="line">		<span class="title function_">inserted</span>(<span class="params">element,binding</span>)&#123;</span><br><span class="line">			element.<span class="title function_">focus</span>()</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">//指令所在的模板被重新解析时</span></span><br><span class="line">		<span class="title function_">update</span>(<span class="params">element,binding</span>)&#123;</span><br><span class="line">			element.<span class="property">value</span> = binding.<span class="property">value</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">	<span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line">	<span class="comment">// 4. 添加实例方法</span></span><br><span class="line">	<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line">	<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用插件：在main.js中引入<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(插件名,参数可选)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="style标签的scoped属性"><a href="#style标签的scoped属性" class="headerlink" title="style标签的scoped属性"></a>style标签的scoped属性</h2><ul>
<li>作用：样式只作用于当前页面</li>
</ul>
<h2 id="组件化编码流程"><a href="#组件化编码流程" class="headerlink" title="组件化编码流程"></a>组件化编码流程</h2><ol>
<li>拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突</li>
<li>实现动态组件：考虑好数据的存放位置<ul>
<li>数据是一个组件在用：放在组件自身</li>
<li>数据是一些组件在用：放在他们共同的父组件上（<span class="key_words">『状态提升』</span>）</li>
</ul>
</li>
<li>实现交互：从绑定事件开始</li>
</ol>
<ul>
<li>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</li>
<li>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐</li>
</ul>
<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ul>
<li><a href="/2024/10/31/JS/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" title="浏览器缓存">阅读浏览器缓存</a></li>
</ul>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$nextTick(回调函数)</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调</li>
<li>使用场景：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行</li>
<li>不用定时器的原因：setInterval会无限循环</li>
<li>原理：<ul>
<li>nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，都不行则用setTimeout定义一个异步方法，多次调用，nextTick会将方法存入队列中，通过这个异步方法清空当前队列</li>
</ul>
</li>
<li>实现：<ul>
<li><span class="key_words">『Vue在更新DOM时是异步执行的。』</span>只要侦听到数据变化，Vue将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果一个watcher被<span class="key_words">『多次』</span>触发，只会被推入到队列中<span class="key_words">『一次』</span>。避免不必要的计算和DOM操作。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。</li>
</ul>
</li>
</ul>
<h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ul>
<li>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</li>
<li>写法一：<ul>
<li>使用 transition标签 包裹要过度的元素，并配置name属性</li>
<li>如果给 transition标签 添加appear属性代表一出场就要有动画</li>
<li>在style标签中写好动画样式，按一下规则命名：<ul>
<li>元素进入的样式：<ol>
<li>name-enter：进入的起点</li>
<li>name-enter-active：进入过程中</li>
<li>name-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>name-leave：离开的起点</li>
<li>name-leave-active：离开过程中</li>
<li>name-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li>若有多个元素需要过度，则需要使用：transition-group标签 替换 transition标签，且每个元素都要指定key值</li>
</ul>
</li>
<li>写法二：也可以使用外部样式表+标签来展示<ul>
<li>页面标签同上</li>
<li>引入外部样式表</li>
<li>将样式赋给标签上对应的样式(<span class="desc">与上面的命名规则类似，不要前面的name-，在后面加-class</span>)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;transition-group </span><br><span class="line">	appear</span><br><span class="line">	name=<span class="string">&quot;animate__animated animate__bounce&quot;</span> </span><br><span class="line">	enter-active-<span class="keyword">class</span>=<span class="string">&quot;animate__swing&quot;</span></span><br><span class="line">	leave-active-<span class="keyword">class</span>=<span class="string">&quot;animate__backOutUp&quot;</span></span><br><span class="line">&gt;...&lt;/transition-group&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>常见的动画样式：animation+@keyframes，transition，transform<ul>
<li><a href="/2024/10/30/HTMLCSS/css-%E5%8A%A8%E7%94%BB/" title="CSS-动画篇">CSS-动画篇</a></li>
</ul>
</li>
</ul>
<h2 id="解决跨域的方式"><a href="#解决跨域的方式" class="headerlink" title="解决跨域的方式"></a>解决跨域的方式</h2><ul>
<li>页面使用axios来请求接口时，会存在浏览器跨域的问题。这是因为同源策略。</li>
<li>同源策略&#x2F;SOP（Same origin policy）：一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了，浏览器很容易受到XSS、CSFR等攻击。</li>
<li>所谓同源 –&gt; 指的是 “协议+域名+端口” 三者的相同 只要有一个不同就会导致跨域问题</li>
<li>解决方案<ol>
<li>cors 主后端 </li>
<li>jsonp 前后端配合 </li>
<li>代理服务器 <ul>
<li>nginx</li>
<li>vue</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><ul>
<li>前情提要<ul>
<li>本地的端口一般默认时8080，所以配置proxy写的是另一个服务器的端口号</li>
<li>都是在vue.config.js文件中添加配置</li>
</ul>
</li>
</ul>
<h3 id="开启代理服务器方法一：直接配置proxy"><a href="#开启代理服务器方法一：直接配置proxy" class="headerlink" title="开启代理服务器方法一：直接配置proxy"></a>开启代理服务器方法一：直接配置proxy</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优劣：<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配前端资源）</li>
</ol>
</li>
</ul>
<h3 id="开启代理服务器方法二：配置具体代理规则"><a href="#开启代理服务器方法二：配置具体代理规则" class="headerlink" title="开启代理服务器方法二：配置具体代理规则"></a>开启代理服务器方法二：配置具体代理规则</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">	<span class="attr">proxy</span>: &#123;</span><br><span class="line">		<span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">			<span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,</span><br><span class="line">			<span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">			<span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>接口配置属性的解析</p>
<ul>
<li>target：代理目标的基础路径</li>
<li>changeOrigin：<ul>
<li>默认值为true，服务器收到的请求头中的host为：localhost:5000。</li>
<li>为false时，服务器收到的请求头中的host为：localhost:8080</li>
</ul>
</li>
<li>pathRewrite：配带冒号前面的字符，将它替换为空字符</li>
<li>ws：为true，支持websocket</li>
</ul>
</li>
<li><p>优劣：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
</li>
<li><p>案例</p>
<ul>
<li>使用axios请求github的搜索接口：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//api.github.com/search/users?q=$&#123;this.keyWord&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>也可以使用封装好的插件来请求或响应接口服务：vue-resource插件</li>
</ul>
</li>
</ul>
<h2 id="Vuex-了解即可，现在推荐使用Pinia"><a href="#Vuex-了解即可，现在推荐使用Pinia" class="headerlink" title="Vuex(了解即可，现在推荐使用Pinia)"></a>Vuex(了解即可，现在推荐使用Pinia)</h2><ul>
<li><a href="/2024/11/01/vue3/vuex/" title="VUE3-VUEX(状态管理库) 不推荐">VUE3-VUEX(状态管理库) 不推荐</a></li>
</ul>
<h2 id="额外补充的知识"><a href="#额外补充的知识" class="headerlink" title="额外补充的知识"></a>额外补充的知识</h2><ul>
<li>obj.hasOwnProperty(‘属性名’)：判断对象身上是否存在某一元素</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>Lodash</title>
    <url>/2024/11/01/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Lodash/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>只有存在node_modules，并且引入了lodash的内置插件包，才可以使用</p>
</blockquote>
<h3 id="uniqueId-‘prefix’"><a href="#uniqueId-‘prefix’" class="headerlink" title="uniqueId(‘prefix’)"></a>uniqueId(‘prefix’)</h3><ul>
<li>返回的是一个带前缀的自增id</li>
</ul>
<h3 id="⭐-toPath-‘-6-4-f-45-5-f-2’"><a href="#⭐-toPath-‘-6-4-f-45-5-f-2’" class="headerlink" title="⭐ toPath(‘[6],4, [f[45[5]]],f,2’)"></a>⭐ toPath(‘[6],4, [f[45[5]]],f,2’)</h3><ul>
<li>把字符串里的属性返回成数组 ，适合两个深层数组合并，<span class="key_words">『对象不行』</span></li>
</ul>
<h3 id="times-n-type-fn"><a href="#times-n-type-fn" class="headerlink" title="times(n, type | fn )"></a>times(n, type | fn )</h3><ul>
<li>默认返回一个调用了n次的index类型的数组</li>
</ul>
<h3 id="⭐-times-3-stubString"><a href="#⭐-times-3-stubString" class="headerlink" title="⭐ times(3, stubString)"></a>⭐ times(3, stubString)</h3><ul>
<li>结合times创建一个有长度且初始值为空的数组</li>
</ul>
<h3 id="rangeRight-start默认0-end-间隔"><a href="#rangeRight-start默认0-end-间隔" class="headerlink" title="rangeRight(start默认0, end, 间隔)"></a>rangeRight(start默认0, end, 间隔)</h3><ul>
<li>返回一个不包括end值的start到end值的范围内的新数字数组，且是<span class="key_words">『降序』</span></li>
</ul>
<h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><ul>
<li>返回一个不包括end值的start到end值的范围内的新数字数组<span class="key_words">『升序』</span></li>
</ul>
<h3 id="const-func-overSome-返回结果-func-1-21-5"><a href="#const-func-overSome-返回结果-func-1-21-5" class="headerlink" title="const func &#x3D; overSome([返回结果]);func([1,21,5])"></a>const func &#x3D; overSome([返回结果]);func([1,21,5])</h3><ul>
<li>返回的是带有返回条件的新函数</li>
</ul>
<h3 id="map-‘a-2-’-‘c-0-’-methodOf-object"><a href="#map-‘a-2-’-‘c-0-’-methodOf-object" class="headerlink" title="map([‘a[2]’, ‘c[0]’], methodOf(object))"></a>map([‘a[2]’, ‘c[0]’], methodOf(object))</h3><ul>
<li>通过map来调用methods上对象的方法，返回新的结果</li>
</ul>
<h3 id="constant-value"><a href="#constant-value" class="headerlink" title="constant(value)"></a>constant(value)</h3><ul>
<li>创建一个值，返回新的<span class="key_words">『常量函数』</span></li>
</ul>
<h3 id="defaultTo-value-defaultValue"><a href="#defaultTo-value-defaultValue" class="headerlink" title="defaultTo(value, defaultValue)"></a>defaultTo(value, defaultValue)</h3><ul>
<li>如果value为NaN, null, 或者 undefined，那么返回defaultValue</li>
</ul>
<h3 id="pad-要填充的字符串-填充长度-填充的字符"><a href="#pad-要填充的字符串-填充长度-填充的字符" class="headerlink" title="pad(要填充的字符串, 填充长度, 填充的字符)"></a>pad(要填充的字符串, 填充长度, 填充的字符)</h3><ul>
<li>字符串长度小于填充长度左右平均填充，不平均截断超出的</li>
</ul>
<h3 id="chain-value"><a href="#chain-value" class="headerlink" title="chain(value)"></a>chain(value)</h3><ul>
<li>启用显示链模式，解除用value()</li>
</ul>
<h3 id="assign-object-source"><a href="#assign-object-source" class="headerlink" title="assign(object, [source])"></a>assign(object, [source])</h3><ul>
<li>有四个， 把对象分配到目标对象上</li>
</ul>
<h3 id="findKey-object-fn"><a href="#findKey-object-fn" class="headerlink" title="findKey(object ,fn)"></a>findKey(object ,fn)</h3><ul>
<li>在object上返回一个符合条件的的key（返回找到的第一个）</li>
</ul>
<h3 id="findLastKey-object-fn"><a href="#findLastKey-object-fn" class="headerlink" title="findLastKey(object ,fn)"></a>findLastKey(object ,fn)</h3><ul>
<li>在object上返回一个符合条件的的key（返回反方向找到的第一个）</li>
</ul>
<h3 id="for开头的遍历对象无法保证遍历顺序，-加In的标识遍历到原型上"><a href="#for开头的遍历对象无法保证遍历顺序，-加In的标识遍历到原型上" class="headerlink" title="for开头的遍历对象无法保证遍历顺序， 加In的标识遍历到原型上"></a>for开头的遍历对象无法保证遍历顺序， 加In的标识遍历到原型上</h3><h3 id="invert-object"><a href="#invert-object" class="headerlink" title="invert(object)"></a>invert(object)</h3><ul>
<li>返回一个键值倒置后的对象，如果有重复的值，后面的值会覆盖前面的值</li>
</ul>
<h3 id="castArray-value"><a href="#castArray-value" class="headerlink" title="castArray(value)"></a>castArray(value)</h3><ul>
<li>强制转为数组，返回转换后的数组</li>
</ul>
<h3 id="⭐-isEqual-value-other"><a href="#⭐-isEqual-value-other" class="headerlink" title="⭐ isEqual(value,other)"></a>⭐ isEqual(value,other)</h3><ul>
<li>执行深比较确定两者的值是否相等，不管是对象还是数组都可以比较，适用于判断是否编辑过</li>
</ul>
<h3 id="⭐-throttle-要节流的函数-wait-节流的毫秒，默认为0-options-节流"><a href="#⭐-throttle-要节流的函数-wait-节流的毫秒，默认为0-options-节流" class="headerlink" title="⭐ throttle(要节流的函数, [wait&#x3D;节流的毫秒，默认为0], [options&#x3D;]) 节流"></a>⭐ throttle(要节流的函数, [wait&#x3D;节流的毫秒，默认为0], [options&#x3D;]) 节流</h3><ul>
<li>options.leading &#x3D; true : 指定调用在节流开始前</li>
<li>options.trailing &#x3D; true : 指定调用在节流结束后</li>
</ul>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip([],[],[])"></a>zip([],[],[])</h3><ul>
<li>将各个数组的相同的index提取出来组成一个新数组并返回</li>
</ul>
<h3 id="upzip"><a href="#upzip" class="headerlink" title="upzip()"></a>upzip()</h3><ul>
<li>还原，把zip后的数组还原回zip前的数组</li>
</ul>
<h3 id="zipWith-array-fn-unzipWith-array-fn"><a href="#zipWith-array-fn-unzipWith-array-fn" class="headerlink" title="zipWith(array, fn)&#x2F;unzipWith(array, fn)"></a>zipWith(array, fn)&#x2F;unzipWith(array, fn)</h3><h3 id="without-要检查的数组，要剔除的值"><a href="#without-要检查的数组，要剔除的值" class="headerlink" title="without(要检查的数组，要剔除的值)"></a>without(要检查的数组，要剔除的值)</h3><ul>
<li>返回过滤后的新数组</li>
</ul>
<h3 id="uniq-array"><a href="#uniq-array" class="headerlink" title="uniq(array)"></a>uniq(array)</h3><ul>
<li>返回一个去重后的新数组</li>
</ul>
<h3 id="用at方法读取尾元素-任意位置"><a href="#用at方法读取尾元素-任意位置" class="headerlink" title="用at方法读取尾元素&#x2F;任意位置"></a>用at方法读取尾元素&#x2F;任意位置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="keyword">const</span> lastEle = array.<span class="title function_">at</span>(-<span class="number">1</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">const</span> ele1 = array.<span class="title function_">at</span>(<span class="number">0</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="pick-object-props"><a href="#pick-object-props" class="headerlink" title="pick(object, [props])"></a>pick(object, [props])</h3><ul>
<li>创建一个从object中选中的属性的对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">_.<span class="title function_">pick</span>(object,[<span class="string">&#x27;a&#x27;</span>,c<span class="string">&#x27;&#x27;</span>]) ==&gt; &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="omit-object-props-反向版-pick"><a href="#omit-object-props-反向版-pick" class="headerlink" title="omit(object,[props]):反向版_.pick"></a>omit(object,[props]):反向版_.pick</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">omit</span>(object,[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]) ==&gt; &#123;<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;2&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>Babel</title>
    <url>/2024/11/01/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/babel/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h1 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a><a href="https://babel.docschina.org/docs/en/">Babel</a></h1><ul>
<li>一个Javascript 编译器</li>
<li>一个工具链，运行在当前和旧的浏览器或环境中，功能是将ES2015+转换为Javascript 向后兼容的代码</li>
<li>本质：操作<span class="key_words">『AST(抽象语法树)』</span>来完成代码的转译</li>
</ul>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><ol>
<li><p><span class="key_words">『解析(Parse)』</span>: 通过词法分析和语法分析将源码转为AST。</p>
<ul>
<li>词法分析: 把字符流(Char Stream)源码转为令牌流(Token Stream)</li>
<li>语法分析：把令牌流转为AST<span class="desc">(源代码的抽象语法结构的树状表示)</span></li>
</ul>
</li>
<li><p><span class="key_words">『转换(Transform)』</span>：将高版本的AST转换为支持低版本语法的AST，并优化</p>
</li>
<li><p><span class="key_words">『生成(Generate)』</span>: 将AST转换为字符串形式的低版本代码，并创建Source Map映射</p>
</li>
</ol>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>可压缩 – 提供assumptions选项</li>
</ul>
<h3 id="删除类型注释"><a href="#删除类型注释" class="headerlink" title="删除类型注释"></a>删除类型注释</h3><ul>
<li>可以安装 Flow preset 和 Typescript preset 来做类型检查</li>
<li>flow preset – js的静态类型检查器<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">安装：npm install --save-dev @babel/preset-flow</span><br><span class="line">使用：<span class="keyword">const</span> square = (<span class="attr">n</span>: number) : <span class="function"><span class="params">number</span> =&gt;</span> n * n</span><br></pre></td></tr></table></figure></li>
<li>typescript preset – ts的静态类型检查器<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">安装：npm install --save-dev @babel/preset-typescript</span><br><span class="line">使用：<span class="keyword">const</span> <span class="title class_">Greeter</span>(<span class="attr">greeting</span>: string) &#123; <span class="variable language_">this</span>.<span class="property">greeting</span> = greeting &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache echarts基础</title>
    <url>/2025/02/17/%E5%8F%AF%E8%A7%86%E5%8C%96/Apache%20echarts%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>当前echarts版本5.6.0</li>
<li>全局安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install echarts</span><br></pre></td></tr></table></figure></li>
<li>局部安装：<a href="https://echarts.apache.org/en/builder.html">定制图表</a><ul>
<li>下载后把文件包放置在应用echart文件的根目录</li>
<li>如：应用echart的文件位于statistics文件夹下，那下载下来的echarts文件放置到该目录下<br><img src="/../../img/echart/echarts%E5%AE%9A%E5%88%B6%E6%96%87%E4%BB%B6.png" alt="定制文件放置位置"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>定制的：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&quot;./echarts/echarts.min.js&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>全局安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&quot;echarts&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="初始化echart（react）"><a href="#初始化echart（react）" class="headerlink" title="初始化echart（react）"></a>初始化echart（react）</h2><ol>
<li>定义ref：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mychartRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure></li>
<li>获取元素的dom: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div ref=&#123;mychartRef&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
<li>在useEffect钩子中去初始化获取echart的宽高大小： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chart = echarts.<span class="title function_">init</span>(mychartRef.<span class="property">current</span> <span class="keyword">as</span> unknown <span class="keyword">as</span> <span class="title class_">HTMLDivElement</span>,<span class="literal">undefined</span>, &#123;</span><br><span class="line">  <span class="attr">width</span>: width,<span class="number">1</span></span><br><span class="line">  <span class="attr">height</span>: <span class="number">300</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>定义一个option对象，查看<a href="https://echarts.apache.org/zh/option.html#title">配置项手册</a></li>
<li>将option设置到echart中：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chart.<span class="title function_">setOption</span>(option)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="调整图像的位置和大小"><a href="#调整图像的位置和大小" class="headerlink" title="调整图像的位置和大小"></a>调整图像的位置和大小</h2><ul>
<li>柱状图和折线图: 通过调整grid的值</li>
<li>饼状图: 直接在series里面，通过改变radius和center的值</li>
<li>雷达图: 在radar的radius的位置</li>
</ul>
<h2 id="如何给echarts添加动态背景图"><a href="#如何给echarts添加动态背景图" class="headerlink" title="如何给echarts添加动态背景图"></a>如何给echarts添加动态背景图</h2><ul>
<li>不能直接给echarts添加，echart只能使用静态的</li>
<li>在应用echarts的容器的父容器上添加背景，背景为动态的即可</li>
</ul>
<h2 id="itemStyle的颜色"><a href="#itemStyle的颜色" class="headerlink" title="itemStyle的颜色"></a>itemStyle的颜色</h2><h3 id="不配置"><a href="#不配置" class="headerlink" title="不配置"></a>不配置</h3><ul>
<li>默认按照系统设置的颜色列表循环取颜色作为系列色</li>
</ul>
<h3 id="配置静态样式"><a href="#配置静态样式" class="headerlink" title="配置静态样式"></a>配置静态样式</h3><ul>
<li>如：”ccc”, rgba(128,128,128,0.5),rgb(128,128,128)</li>
</ul>
<h3 id="配置线性渐变"><a href="#配置线性渐变" class="headerlink" title="配置线性渐变"></a>配置线性渐变</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;linear&#x27;</span>,</span><br><span class="line">  <span class="attr">x</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">y</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">x2</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">y2</span>:<span class="number">1</span>, <span class="comment">// 不改变x只改变y，表示y的径向渐变</span></span><br><span class="line">  <span class="attr">colorStops</span>:[&#123;</span><br><span class="line">    <span class="attr">offset</span>:<span class="number">0</span>,<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>, <span class="comment">// 0%处的颜色</span></span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="attr">offset</span>:<span class="number">1</span>,<span class="attr">color</span>:<span class="string">&#x27;blue&#x27;</span> <span class="comment">// 100%处的颜色</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">global</span>: <span class="literal">false</span> <span class="comment">// 缺省为 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置径向渐变"><a href="#配置径向渐变" class="headerlink" title="配置径向渐变"></a>配置径向渐变</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;radial&#x27;</span>,</span><br><span class="line">  <span class="attr">x</span>: <span class="number">0.5</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">0.5</span>,</span><br><span class="line">  <span class="attr">r</span>: <span class="number">0.5</span>,</span><br><span class="line">  <span class="attr">colorStops</span>: [&#123;</span><br><span class="line">      <span class="attr">offset</span>: <span class="number">0</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> <span class="comment">// 0% 处的颜色</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">      <span class="attr">offset</span>: <span class="number">1</span>, <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> <span class="comment">// 100% 处的颜色</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">global</span>: <span class="literal">false</span> <span class="comment">// 缺省为 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置纹理填充"><a href="#配置纹理填充" class="headerlink" title="配置纹理填充"></a>配置纹理填充</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">image</span>: imageDom, <span class="comment">// 支持为 HTMLImageElement, HTMLCanvasElement，不支持路径字符串</span></span><br><span class="line">  <span class="attr">repeat</span>: <span class="string">&#x27;repeat&#x27;</span> <span class="comment">// 是否平铺，可以是 &#x27;repeat-x&#x27;, &#x27;repeat-y&#x27;, &#x27;no-repeat&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态，根据数据的颜色展示-渐变也可以这样处理"><a href="#动态，根据数据的颜色展示-渐变也可以这样处理" class="headerlink" title="动态，根据数据的颜色展示(渐变也可以这样处理)"></a>动态，根据数据的颜色展示(渐变也可以这样处理)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [&#123;<span class="attr">value</span>: <span class="number">56</span>, <span class="attr">color</span>: <span class="string">&#x27;#fffacc&#x27;</span>&#125;]</span><br><span class="line"><span class="attr">color</span>: <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> params.<span class="property">color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="legend"><a href="#legend" class="headerlink" title="legend"></a>legend</h2><h3 id="什么时候展示"><a href="#什么时候展示" class="headerlink" title="什么时候展示"></a>什么时候展示</h3><ul>
<li>当data中的数据有name属性</li>
</ul>
<h3 id="控制legend的位置"><a href="#控制legend的位置" class="headerlink" title="控制legend的位置"></a>控制legend的位置</h3><ul>
<li>top 和 left: 决定图例位于图标的那个位置</li>
<li>orient：’vertical’| ‘horizontal’: 决定图例是垂直或水平排列</li>
</ul>
<h3 id="修改item的间隔和样式"><a href="#修改item的间隔和样式" class="headerlink" title="修改item的间隔和样式"></a>修改item的间隔和样式</h3><ul>
<li>itemGap: 控制图例每项的间隔</li>
<li>itemWidth 和 itemHeight: 控制图例图形大小</li>
<li>itemStyle: 控制图形的样式</li>
</ul>
<h3 id="图例的关闭"><a href="#图例的关闭" class="headerlink" title="图例的关闭"></a>图例的关闭</h3><ul>
<li>selectedMode：控制是否可点击图例，也可以设置为’single’ 或 ‘multiple’的选择模式</li>
<li>inactiveColor：关闭图例的颜色</li>
<li>图例关闭动态影响其他的事件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chart.<span class="title function_">on</span>(<span class="string">&#x27;legendselectchanged&#x27;</span>,<span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="graphic"><a href="#graphic" class="headerlink" title="graphic"></a>graphic</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li>适用于自定义一个轮播条或其他自定义线段图形</li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li>group</li>
<li>image</li>
<li>text</li>
<li>circle</li>
<li>rect</li>
<li>line  （以这个为分界线上面的常用）</li>
<li>sector</li>
<li>ring</li>
<li>polygon</li>
<li>polyline</li>
<li>bezierCurve</li>
<li>arc</li>
<li>主要通过x，y来控制位置</li>
</ul>
<h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: &#x27;bar&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="option必须要有的属性"><a href="#option必须要有的属性" class="headerlink" title="option必须要有的属性"></a>option必须要有的属性</h3><ul>
<li>xAxis，yAxis，grid，series, 前面三个可以空着但一定要有</li>
</ul>
<h3 id="如何设置label的字体和背景与柱体颜色一致"><a href="#如何设置label的字体和背景与柱体颜色一致" class="headerlink" title="如何设置label的字体和背景与柱体颜色一致"></a>如何设置label的字体和背景与柱体颜色一致</h3><ul>
<li>首先在series.itemStyle中去控制颜色</li>
<li>字体：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">series.<span class="property">label</span>.<span class="property">color</span>: <span class="string">&#x27;inherit&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>文本框：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">series.<span class="property">label</span>.<span class="property">borderColor</span>: <span class="string">&#x27;inherit&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>文本的背景：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">series.<span class="property">label</span>.<span class="property">backgroundColor</span>: <span class="string">&#x27;inherit&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="label格式和位置"><a href="#label格式和位置" class="headerlink" title="label格式和位置"></a>label格式和位置</h3><ul>
<li>distance + position: 控制标签的位置和距离柱体的距离</li>
<li>formatter: 设置label展示的文本格式，字符串模板或回调函数<ul>
<li>字符串模板：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">formatter</span>: <span class="string">&#x27;&#123;b&#125;: &#123;c&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>{a}：系列名(seriesName) </li>
<li>{b}：数据名(name) </li>
<li>{c}：数据值(value)</li>
</ul>
</li>
<li>回调函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="attr">params</span>: <span class="title class_">Object</span>|<span class="title class_">Array</span>) =&gt; string</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="让柱体根据数值动态排序"><a href="#让柱体根据数值动态排序" class="headerlink" title="让柱体根据数值动态排序"></a>让柱体根据数值动态排序</h3><ul>
<li>开启该系列的动态排序效果: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">series.<span class="property">realtimeSort</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>实时改变标签: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">series.<span class="property">label</span>.<span class="property">valueAnimation</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>在label中设置动画效果：animationFrom(进场) + animationTo（退场）</li>
</ul>
<h3 id="提示框tooltip"><a href="#提示框tooltip" class="headerlink" title="提示框tooltip"></a>提示框tooltip</h3><ul>
<li>tirgger：触发类型，根据图形选择，坐标轴类的选择’axis’</li>
<li>axisPointer：指示器，可以用来做高亮时（选中时）的背景颜色<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axisPointer.<span class="property">type</span> = <span class="string">&#x27;shadow&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置背景颜色<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axisPointer.<span class="property">shadowStyle</span>.<span class="property">color</span>= <span class="string">&quot;rgba(74, 211, 164, 0.15)&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>如果不想有附带的虚线<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axisPointer.<span class="property">lineStyle</span>.<span class="property">color</span>=<span class="string">&quot;transparent&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>文本格式与label一样</li>
<li>动态时需要设置延迟为0：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tooltip.<span class="property">showDelay</span>:<span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li>自定义完成后，想让tooltip定时移动展示，使用dispatchAction事件交互<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">updateCurrentTip</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> len = option.<span class="property">series</span>[<span class="number">0</span>].<span class="property">data</span>.<span class="property">length</span></span><br><span class="line">  chart.<span class="title function_">dispatchAction</span>(&#123; <span class="comment">// 取消之前的高亮</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;downplay&#x27;</span>,</span><br><span class="line">    <span class="attr">seriesIndex</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: currentIndex.<span class="property">current</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  currentIndex.<span class="property">current</span> = (currentIndex.<span class="property">current</span> +<span class="number">1</span>) % len</span><br><span class="line"></span><br><span class="line">  chart.<span class="title function_">dispatchAction</span>(&#123; <span class="comment">// 高亮当前</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;hightlight&#x27;</span>,</span><br><span class="line">    <span class="attr">seriesIndex</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: currentIndex.<span class="property">current</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 高亮时展示提示框</span></span><br><span class="line">  chart.<span class="title function_">dispatchAction</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;showTip&#x27;</span>,</span><br><span class="line">    <span class="attr">seriesIndex</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: currentIndex.<span class="property">current</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">updateCurrentTip</span>()</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="堆叠series-stack"><a href="#堆叠series-stack" class="headerlink" title="堆叠series.stack"></a>堆叠series.stack</h3><ul>
<li>可以用于做正负双轴，</li>
<li>在想要堆叠的对象上添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">stack</span>: <span class="string">&#x27;名字任意&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>在下一个要堆叠的对象上也添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">stack</span>:<span class="string">&#x27;名字要保持一致&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>堆叠的对象可以用barGap来控制重叠的距离，完全重叠设置’-100%’</li>
<li>堆叠的柱体要隐藏，则把itemStyle的 color 设置成透明<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">series</span>: [&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">stack</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">stack</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="柱状图-环形"><a href="#柱状图-环形" class="headerlink" title="柱状图-&gt;环形"></a>柱状图-&gt;环形</h3><ul>
<li>如果配置angleAxis（角度轴）、radiusAxis（半径轴）和polar（极坐标）</li>
<li>但是data中的数据需要一个个遍历成一个对象存放在series中</li>
<li>注意，如果实现的圆环，要一半有背景色一半没有，可以使用渐变但效果不好，建议还是使用type：’pie’类型实现</li>
</ul>
<h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: &#x27;line&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="一定要有的对象"><a href="#一定要有的对象" class="headerlink" title="一定要有的对象"></a>一定要有的对象</h3><ul>
<li>xAxis</li>
<li>yAxis</li>
<li>grid</li>
<li>series</li>
</ul>
<h3 id="两种类型的折线"><a href="#两种类型的折线" class="headerlink" title="两种类型的折线"></a>两种类型的折线</h3><ul>
<li>平滑折线：smooth: true</li>
<li>曲直折线：默认</li>
</ul>
<h3 id="关于xAxis刻度的间隔"><a href="#关于xAxis刻度的间隔" class="headerlink" title="关于xAxis刻度的间隔"></a>关于xAxis刻度的间隔</h3><ul>
<li>通过interval的回调函数返回的true OR false，让刻度、标签每隔n个展示<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">axisLabel</span>: &#123;  <span class="comment">// 刻度的间隔</span></span><br><span class="line">  <span class="attr">interval</span>:<span class="function">(<span class="params">index:number,value: string</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 数组长度大于6移除一个，最终只展示6个标签，对于这种情况，标签和数据最好分开成两个数组</span></span><br><span class="line">    <span class="keyword">if</span>(monthList.<span class="property">length</span> &gt; <span class="number">6</span>) monthList.<span class="title function_">shift</span>() </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 返回true表示展示</span></span><br><span class="line">  &#125;,  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="折线图上的点"><a href="#折线图上的点" class="headerlink" title="折线图上的点"></a>折线图上的点</h3><ul>
<li>data中的value在x轴和y轴相交的点<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">symbol：<span class="string">&#x27;none&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>内置类型：circle, rect, roundRect, triangle, diamond, pin, arrow, none</li>
<li>自定义<ul>
<li>图片形式：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;image:// 图片链接|dataURI&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>svg路径：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;path://....&#x27;</span></span><br><span class="line">如：<span class="string">&#x27;path://d=&quot;M1022.165868 1.17248h2447.020998c65.425217 ...&quot;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="环形（饼图）"><a href="#环形（饼图）" class="headerlink" title="环形（饼图）"></a>环形（饼图）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: &#x27;pie&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="调整圆环的弧度和大小"><a href="#调整圆环的弧度和大小" class="headerlink" title="调整圆环的弧度和大小"></a>调整圆环的弧度和大小</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">radius：[<span class="string">&#x27;53%&#x27;</span>, <span class="string">&#x27;53%&#x27;</span>]：控制圆的大小和是否变成圆环，参数：[圆环宽度, 圆大小]</span><br><span class="line"><span class="attr">center</span>: [<span class="string">&#x27;50%&#x27;</span>,<span class="string">&#x27;50%&#x27;</span>]：圆的位置</span><br><span class="line"><span class="attr">startAngle</span>: <span class="number">275</span>：弧度的起始位置</span><br><span class="line"><span class="attr">endAngle</span>: <span class="number">30</span>：弧度的结束位置</span><br></pre></td></tr></table></figure>

<h3 id="多个圆环"><a href="#多个圆环" class="headerlink" title="多个圆环"></a>多个圆环</h3><ul>
<li>建立多个对象，并使用stack堆叠</li>
<li>多个堆叠，center要一样</li>
<li>每个data一定要用数组的形式</li>
</ul>
<h3 id="没有数据是否展示圆"><a href="#没有数据是否展示圆" class="headerlink" title="没有数据是否展示圆"></a>没有数据是否展示圆</h3><ul>
<li>showEmptyCircle: true</li>
<li>emptyCircleStyle对象：控制没有数据时圆的样式</li>
</ul>
<h3 id="饼图类型"><a href="#饼图类型" class="headerlink" title="饼图类型"></a>饼图类型</h3><ul>
<li>当数据都在一个对象上，形成饼图，默认按照数据大小，平分饼图的扇形</li>
<li>roseType：南丁格尔玫瑰样式(按照数据，高低呈现)</li>
</ul>
<h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: &#x27;graph&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ul>
<li>展示节点与节点的关系</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li>布局: layout: ‘none’</li>
<li>data: 格式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>&lt;&#123;<span class="attr">name</span>:<span class="string">&#x27;&#x27;</span>, x,<span class="number">100</span>,<span class="attr">y</span>:<span class="number">100</span>，value&#125;&gt;</span><br></pre></td></tr></table></figure></li>
<li>links配置节点<ul>
<li>每一个线段都能设定起始位置和结束位置并且设置线段的弧度<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">source</span>: <span class="number">7</span> <span class="comment">// 源节点（data的索引）</span></span><br><span class="line"><span class="attr">target</span>: <span class="number">0</span> <span class="comment">// 目标节点（data的索引）  7 -&gt; 0</span></span><br><span class="line"><span class="attr">lineStyle</span>:&#123;</span><br><span class="line">  <span class="attr">curveness</span>: <span class="number">0.5</span> <span class="comment">// 线段的曲度（正负控制方向）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>设置线段两端的样式: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">edgeSymbol</span>: [<span class="string">&#x27;circle&#x27;</span>, <span class="string">&#x27;arrow&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li>线段两端的图形的大小: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">edgeSymbolSize：<span class="number">10</span></span><br></pre></td></tr></table></figure></li>
<li>节点(数据)大小: 文本溢出之后再去label设置宽高去限制<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">symbolSize： data</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="雷达图"><a href="#雷达图" class="headerlink" title="雷达图"></a>雷达图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type=&#x27;radar&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="radar"><a href="#radar" class="headerlink" title="radar"></a>radar</h3><ul>
<li>标签数组：indicator中设置，格式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;name： <span class="string">&#x27;&#x27;</span>,<span class="attr">max</span>:<span class="number">0</span>,<span class="attr">color</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>背景颜色：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">splitArea</span>:&#123;areaStyle.<span class="property">color</span>: <span class="string">&#x27;transparent&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>也可以处理线段样式等</li>
</ul>
<h3 id="series"><a href="#series" class="headerlink" title="series"></a>series</h3><ul>
<li>data：与indicator基本一致，数据多一个value，表示具体数值。如果需要对单个颜色不一致，通过<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">areaStyle</span>:&#123;<span class="attr">color</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果数据存在min，和max则alignTicks要为false</li>
<li>areaStyle的颜色也可以设置为渐变的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">areaStyle</span>: &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="keyword">new</span> echarts.<span class="property">graphic</span>.<span class="title class_">RadialGradient</span>(<span class="number">0.1</span>, <span class="number">0.6</span>, <span class="number">1</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;rgba(255, 145, 124, 0.1)&#x27;</span>,</span><br><span class="line">      <span class="attr">offset</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;rgba(255, 145, 124, 0.9)&#x27;</span>,</span><br><span class="line">      <span class="attr">offset</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="联动图"><a href="#联动图" class="headerlink" title="联动图"></a>联动图</h2><ul>
<li>一个echart中有多种类型的图</li>
<li>在series存放多个类型的图形，然后通过grid或者自身的位置来调整位置</li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li>一般联动图会定时动态改变数据，在定时器中实时改变图的数据</li>
<li>一般联动图会有一个滚动条显示，可以使用dataZoom或者使用graphic自定义一个组件，然后动画和事件在图形上调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chart.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">params</span>) &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>ESlint</title>
    <url>/2024/11/01/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/eslint/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<blockquote>
<p>js代码的检查工具</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i eslint -D</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">生成配置文件: npx eslint --init</span><br><span class="line">检查js文件:   npx eslint 目录名</span><br></pre></td></tr></table></figure>

<h3 id="命中的规则"><a href="#命中的规则" class="headerlink" title="命中的规则:"></a>命中的规则:</h3><ul>
<li>字符串必须使用单引号</li>
<li>语句结尾不能有分号</li>
<li>文件的最后必须要有换行</li>
</ul>
<h3 id="eslint结合git"><a href="#eslint结合git" class="headerlink" title="eslint结合git"></a>eslint结合git</h3><ul>
<li>husky: 哈士奇, 为Git仓库设置钩子程序</li>
<li>在仓库初始化完毕之后再去安装哈士奇</li>
<li>在package.json文件写配置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;husky&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;pre-commit&quot;</span>: <span class="string">&quot;npm run lint&quot;</span>   </span><br><span class="line">    <span class="comment">// 在git commit之前一定要通过npm run lint的检查</span></span><br><span class="line">    <span class="comment">// 只有npm run lint不报错时 commit才能真正的运行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ESlint</tag>
      </tags>
  </entry>
  <entry>
    <title>SVG基础</title>
    <url>/2025/03/10/%E5%8F%AF%E8%A7%86%E5%8C%96/SVG%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h1 id="svg标签"><a href="#svg标签" class="headerlink" title="svg标签"></a>svg标签</h1><ul>
<li>绘制图形使，使用svg标签包裹</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="width-height-决定svg-的宽高"><a href="#width-height-决定svg-的宽高" class="headerlink" title="width,height: 决定svg 的宽高"></a>width,height: 决定svg 的宽高</h3><ul>
<li>注意：默认宽高300*150，内部元素大于时，溢出部分被隐藏</li>
</ul>
<h3 id="viewBox-定义svg可以显示的区域"><a href="#viewBox-定义svg可以显示的区域" class="headerlink" title="viewBox: 定义svg可以显示的区域"></a>viewBox: 定义svg可以显示的区域</h3><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">viewBox=<span class="string">&quot;x y w h&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>x,y为起始点，w,h为显示区域的宽高</li>
<li>示例：<ul>
<li>viewBox：以(0,0)为圆点，宽高为100*100的显示区域</li>
<li>svg: 宽高300*300</li>
<li>circle: 以(100,100)为圆点，半径为100</li>
<li>最终显示：viewBox在svg中截取的这一部分并放大到svg布局中，相当于viewBox区域放大3倍</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;svg width=<span class="string">&quot;300&quot;</span> height=<span class="string">&quot;300&quot;</span> viewBox=<span class="string">&quot;0 0 100 100&quot;</span>&gt; </span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;100&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;100&quot;</span> <span class="attr">r</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<h3 id="version-指明SVG的版本和规范"><a href="#version-指明SVG的版本和规范" class="headerlink" title="version: 指明SVG的版本和规范"></a>version: 指明SVG的版本和规范</h3><ul>
<li>目前只有1.0和1.1版本，只做说明，对渲染没有影响</li>
</ul>
<h3 id="xmlns和xmlns-xlink"><a href="#xmlns和xmlns-xlink" class="headerlink" title="xmlns和xmlns:xlink:"></a>xmlns和xmlns:xlink:</h3><ul>
<li>svg是使用xml格式定义的图形，svg文件是纯粹的xml文件</li>
<li>xmlns用于声明命名空间，再次声明下的所有子标签都属于这个空间内</li>
<li>xmlns:xlink 表示前缀为xlink的标签和属性，应该由理解该规范的UA 使用xlink规范 来解释。</li>
<li><span class="desc">注解：UA是User Agent的简称。User Agent是Http协议中的一部分，属于头域的组成部分。通俗地讲UA是一种向访问网站提供你所使用的浏览器类型、操作系统、浏览器内核等信息的标识。通过这个标识，用户所访问的网站可以显示不同的排版，从而为用户提供更好的体验或者进行信息统计</span></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;svg xmlns=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">xmlns</span>:xlink=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<h1 id="基本图形"><a href="#基本图形" class="headerlink" title="基本图形"></a>基本图形</h1><ul>
<li>以下所有代码都包裹在该svg标签中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;svg</span><br><span class="line">  width=<span class="string">&quot;300&quot;</span></span><br><span class="line">  height=<span class="string">&quot;300&quot;</span></span><br><span class="line">  xmlns=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span><br><span class="line">  style=<span class="string">&quot;border: 2px solid orange&quot;</span></span><br><span class="line">  &gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="圆-circle"><a href="#圆-circle" class="headerlink" title="圆 circle"></a>圆 circle</h2><ul>
<li>语法: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;circle cx=<span class="string">&quot;5&quot;</span> cy=<span class="string">&quot;5&quot;</span> r=<span class="string">&quot;4&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>cx: 圆心所在x位置</li>
<li>cy：圆心所在y位置</li>
<li>r：圆的半径，决定圆大小</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;circle cx=<span class="string">&quot;100&quot;</span> cy=<span class="string">&quot;100&quot;</span> r=<span class="string">&quot;20&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/circle.png" alt="圆"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="矩形-rect"><a href="#矩形-rect" class="headerlink" title="矩形 rect"></a>矩形 rect</h2><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;rect x=<span class="string">&quot;0&quot;</span> y=<span class="string">&quot;0&quot;</span> rx=<span class="string">&quot;5&quot;</span> ry=<span class="string">&quot;5&quot;</span> width=<span class="string">&quot;300&quot;</span> height=<span class="string">&quot;200&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>x、y：矩形的起始点坐标</li>
<li>rx、ry：为圆角x、y轴方向的半径</li>
<li>width、height：为矩形的宽高</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;rect</span><br><span class="line">  x=<span class="string">&quot;0&quot;</span></span><br><span class="line">  y=<span class="string">&quot;0&quot;</span></span><br><span class="line">  rx=<span class="string">&quot;10&quot;</span></span><br><span class="line">  ry=<span class="string">&quot;10&quot;</span></span><br><span class="line">  width=<span class="string">&quot;250&quot;</span></span><br><span class="line">  height=<span class="string">&quot;200&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/rect.png" alt="矩形"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="椭圆-ellipse"><a href="#椭圆-ellipse" class="headerlink" title="椭圆 ellipse"></a>椭圆 ellipse</h2><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ellipse cx=<span class="string">&quot;100&quot;</span> cy=<span class="string">&quot;100&quot;</span> rx=<span class="string">&quot;100&quot;</span> ry=<span class="string">&quot;50&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>cx、cy: 椭圆的坐标，</li>
<li>rx: 椭圆的x轴半径</li>
<li>ry: 椭圆的y轴半径</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ellipse</span><br><span class="line">  cx=<span class="string">&quot;100&quot;</span></span><br><span class="line">  cy=<span class="string">&quot;100&quot;</span></span><br><span class="line">  rx=<span class="string">&quot;80&quot;</span></span><br><span class="line">  ry=<span class="string">&quot;50&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/ellipse.png" alt="椭圆"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="线条-line"><a href="#线条-line" class="headerlink" title="线条 line"></a>线条 line</h2><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;line x1=<span class="string">&quot;10&quot;</span> x2=<span class="string">&quot;50&quot;</span> y1=<span class="string">&quot;110&quot;</span> y2=<span class="string">&quot;150&quot;</span> style=<span class="string">&quot;stroke:#dedede&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>x1、y1: 起点的坐标</li>
<li>x2、y2: 终点的坐标</li>
</ul>
</li>
<li>注意：<span class="key_words">『要设置样式才看的出来』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;line</span><br><span class="line">  x1=<span class="string">&quot;10&quot;</span></span><br><span class="line">  x2=<span class="string">&quot;250&quot;</span></span><br><span class="line">  y1=<span class="string">&quot;110&quot;</span></span><br><span class="line">  y2=<span class="string">&quot;150&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/line.png" alt="线条"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="折线-polyline"><a href="#折线-polyline" class="headerlink" title="折线 polyline"></a>折线 polyline</h2><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;polyline points=<span class="string">&quot;0 0, 20 40, 70 80, 100 90, 200 30, 250 50&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>points</span>: 点集数列，以x坐标 y坐标成对出现，多个用逗号隔开</li>
</ul>
</li>
<li>注意：<span class="key_words">『polyline默认为填充需要把fill属性设置为none,再添加样式』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;polyline</span><br><span class="line">  points=<span class="string">&quot;0 0, 20 40, 70 80, 100 90, 200 30, 250 50&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/polyline.png" alt="折线"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="多边形-polygon"><a href="#多边形-polygon" class="headerlink" title="多边形 polygon"></a>多边形 polygon</h2><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;polygon points=<span class="string">&quot;0 0, 20 40, 70 80, 100 90, 200 30, 250 50&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>points：点集数列，以x坐标 y坐标成对出现，多个用逗号隔开</li>
</ul>
</li>
<li>注意：<ul>
<li><span class="key_words">『最后一个点和第一个点默认闭合，polyline不是』</span></li>
<li><span class="key_words">『polyline默认为填充需要把fill属性设置为none,再添加样式』</span></li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;polygon</span><br><span class="line">  points=<span class="string">&quot;0 0, 20 40, 70 80, 100 90, 200 30, 250 50&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/polygon.png" alt="多边形"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="路径-path"><a href="#路径-path" class="headerlink" title="路径 path"></a>路径 path</h2><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;path d=<span class="string">&quot;M50 50 H 200 V 200 H 50 L 50 50&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
<li>解释：<span class="desc">从(50,50)出发水平画一条到(200,50)的线，然后从(200,50)垂直画一条(200,200)的线，然后从(200,200)水平画一条(50,200),最后把(50,200)和(50,50)连接起来</span></li>
<li>参数<ul>
<li>d：为一个点集数列以及其它绘制路径的信息</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;path</span><br><span class="line">  d=<span class="string">&quot;M50 50 H 200 V 200 H 50 L 50 50&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/path.png" alt="多边形"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h1 id="路径-path-1"><a href="#路径-path-1" class="headerlink" title="路径 path"></a>路径 path</h1><ul>
<li>注意：<span class="key_words">『所有命令中大写为绝对定位，小写为相对定位』</span></li>
</ul>
<h2 id="path字母意义（简）"><a href="#path字母意义（简）" class="headerlink" title="path字母意义（简）"></a>path字母意义（简）</h2><ul>
<li>M &#x3D; Move to 移动</li>
<li>L &#x3D; Line to 线</li>
<li>H &#x3D; Horizontal Line to 水平线</li>
<li>V &#x3D; Vertical Line to 垂直线</li>
<li>Q &#x3D; Quadratic Bezier Curve to 二次贝塞尔曲线</li>
<li>T &#x3D; Smooth Quadratic Bezier Curve to 延长二次贝塞尔曲线</li>
<li>C &#x3D; Curve to 三次贝塞尔曲线</li>
<li>S &#x3D; Smooth Curve to 三次贝塞尔曲线延长</li>
<li>A &#x3D; Elliptical Arc 椭圆弧</li>
<li>Z &#x3D; close path 关闭路径</li>
</ul>
<h2 id="直线命令"><a href="#直线命令" class="headerlink" title="直线命令"></a>直线命令</h2><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><ul>
<li>路径的起始点，用来指明画笔从何处开始绘制。（还没画）</li>
<li>每一段路径都必须以M开头，如果有多个M命令则表示新路径开始</li>
<li>语法：<ul>
<li>绝对定位：Mx y</li>
<li>相对定位：mx y</li>
</ul>
</li>
<li>参数：<ul>
<li>x,y: X轴和Y轴坐标</li>
</ul>
</li>
</ul>
<h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><ul>
<li>绘制一点并且和之前的点（也就是L命令前面的点）连成一条直线。</li>
<li>与M命令结合就是从M点到L点形成一条直线</li>
<li>语法:<ul>
<li>绝对定位：Lx y</li>
<li>相对定位：lx y</li>
</ul>
</li>
<li>参数：<ul>
<li>x,y: X轴和Y轴坐标</li>
</ul>
</li>
<li>示例1：从起始点(50, 50)画一条到(250, 50)的直线 和 从起始点(50, 100)画一条到(250, 100)的直线<ul>
<li>注意：<span class="key_words">『M命令为多个时，后面的M命令为新线段的起始点』</span></li>
</ul>
</li>
<li>示例2：从起始点(50, 50)画一条到(250, 50)的直线<ul>
<li>注意：<span class="key_words">『M命令后面连续跟着多个坐标点，除了第一个坐标点，后面的全部默认为隐式的L命令』</span></li>
</ul>
</li>
<li>示例3：从起始点(50, 50)画一条到(250, 200)的直线，然后画一条从(250, 200)到(250,250)的直线<ul>
<li>注意：<span class="key_words">『多个L命令连续可以省略后面的L命令，并且前一个L跟后一个L相连』</span><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1：</span></span><br><span class="line">&lt;path d=<span class="string">&quot;M50 50 L250 50 M50 100 L250 100&quot;</span> stroke=<span class="string">&quot;red&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M50 150 250 150&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M50 200 L250 200 250 250 &quot;</span> <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;green&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/L.png" alt="L"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><ul>
<li>从前一个点绘制一条水平的直线，与前一个点为y相同，x不同</li>
<li>语法：<ul>
<li>绝对定位：H x</li>
<li>相对定位：h x</li>
</ul>
</li>
<li>参数：<ul>
<li>x：X轴坐标</li>
</ul>
</li>
<li>注意：<span class="key_words">『连续的H命令取最大值』</span><ul>
<li>如：d&#x3D;”M50 20 H250 100”，会直接从(50,20)到(250,20)</li>
</ul>
</li>
<li>示例：从起始点(50, 50)画一条X坐标为250的水平直线，即把(50,50)和(250,50)连接起来的直线<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;path d=<span class="string">&quot;M50 50 H250&quot;</span> fill=<span class="string">&quot;none&quot;</span> stroke=<span class="string">&quot;green&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/H.png" alt="H"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><ul>
<li>从前一个点绘制一条垂直的直线，与前一个点为x相同，y不同</li>
<li>语法：<ul>
<li>绝对定位：V y</li>
<li>相对定位：v y</li>
</ul>
</li>
<li>参数：<ul>
<li>y：Y轴坐标</li>
</ul>
</li>
<li>注意：<span class="key_words">『连续的V命令取最大值』</span><ul>
<li>如：d&#x3D;”M50 20 V250 100”，会直接从(50,20)到(50,250)</li>
</ul>
</li>
<li>示例：从起始点(50, 50)画一条Y坐标为250的垂直直线，即把(50,50)和(50,250)连接起来的直线<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;path d=<span class="string">&quot;M50 50 V250&quot;</span> fill=<span class="string">&quot;none&quot;</span> stroke=<span class="string">&quot;green&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/V.png" alt="V"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h3><ul>
<li>从当前点画一条直线到路径的起始点</li>
<li>语法：<ul>
<li>绝对定位：Z</li>
<li>相对定位：z</li>
</ul>
</li>
<li>参数：无</li>
<li>示例：从起始点(50, 50)画一条X坐标为200的水平直线，然后再画一条Y200的垂直线条，然后闭合路径<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;path d=<span class="string">&quot;M50 50 H200 V200 Z&quot;</span> fill=<span class="string">&quot;none&quot;</span> stroke=<span class="string">&quot;green&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/Z.png" alt="Z"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="曲线命令"><a href="#曲线命令" class="headerlink" title="曲线命令"></a>曲线命令</h2><h3 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h3><ul>
<li>绘制一条二次贝塞尔曲线，二次贝塞尔曲线需要一个控制点，用来确定起点和终点的曲线斜率。</li>
<li>语法：<ul>
<li>绝对定位：Q x1 y1 x y</li>
<li>相对定位：q x1 y1 x y</li>
</ul>
</li>
<li>参数：<ul>
<li>x、y: 终点位置</li>
<li>x1、y1: 控制点</li>
<li>起点是M命令</li>
</ul>
</li>
<li>示例：可以看出控制点就是弧度最低点或最高点<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;path</span><br><span class="line">  d=<span class="string">&quot;M50 100 Q 175 200 250 100&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/Q.png" alt="Q"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><ul>
<li>延长Q的简化命令。可以通过前一个控制点推断后一个控制点</li>
<li>语法：<ul>
<li>绝对定位：T x y</li>
<li>相对定位：t x y</li>
</ul>
</li>
<li>参数：<ul>
<li>x,y: 终点位置</li>
</ul>
</li>
<li>注意：<span class="key_words">『T命令前面必须有一个Q或其他T命令。单独使用会被认为控制点和终点是同一个点，变成一条直线』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;path</span><br><span class="line">  d=<span class="string">&quot;M50 100 Q 145 200 200 100 T 300 100&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/T.png" alt="T"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><ul>
<li>绘制一条三次贝塞尔曲线</li>
<li>语法：<ul>
<li>绝对定位：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C x1 y1 x2 y2 x y</span><br></pre></td></tr></table></figure></li>
<li>相对定位：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c x1 y1 x2 y2 x y</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>参数：<ul>
<li>x、y：终点位置</li>
<li>x1、y1：曲线起始点的控制点</li>
<li>x2、y2：曲线终止的控制点</li>
</ul>
</li>
<li>示例：x1，y1都过M来判断方向和x2，y2通过终点来判断方向，然后中间连接起来<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;path</span><br><span class="line">  d=<span class="string">&quot;M50 20 C 100 100 150 200 250 100&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">d</span>=<span class="string">&quot;M50 200 C 100 100 150 200 250 100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/C.png" alt="C"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><ul>
<li>与T相似，<span class="key_words">『跟在C或者其他S后面，那么第一个控制点被假设成前一个控制点的对称点』</span></li>
<li><span class="key_words">『单独使用，它的两个控制点当做为同一个控制点』</span></li>
<li>语法：<ul>
<li>绝对定位：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S x2 y2 x y</span><br></pre></td></tr></table></figure></li>
<li>相对定位：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s x2 y2 x y</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>参数：<ul>
<li>x、y：终点位置，</li>
<li>x2、y2：曲线终止的控制点</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;path</span><br><span class="line">  d=<span class="string">&quot;M50 150 S 100 250 150 150&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">d</span>=<span class="string">&quot;M10 80 S 60 10 120 80 S 180 140 260 80&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/S.png" alt="S"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><ul>
<li>画弧形，可以截取圆或者椭圆的弧形成曲线</li>
<li>语法：<ul>
<li>绝对定位：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A rx ry x-axis-rotation large-arc-flag sweep-flag x y</span><br></pre></td></tr></table></figure></li>
<li>相对定位：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a rx ry x-axis-rotation large-arc-flag sweep-flag x y</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>参数：<ul>
<li>rx、ry：分别为X轴的半径和Y轴的半径</li>
<li>x-axis-rotation：弧度在X轴的旋转角度</li>
<li>large-arc-flag：决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧</li>
<li>sweep-flag: 弧的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧</li>
<li>x、y：弧形的终点</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 半径为30的圆 旋转0 小角弧 顺时针</span></span><br><span class="line">&lt;path</span><br><span class="line">  d=<span class="string">&quot;M10 50 50 50 A 30 30 0 0 1 150 50 L 200 50&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line"><span class="comment">// x半径为30, y半径50的椭圆 旋转45 小角弧 顺时针</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">d</span>=<span class="string">&quot;M10 100 50 100 A 30 50 45 0 1 150 100 L 200 100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="comment">// x半径为30, y半径50的椭圆 旋转-45 大角弧 逆时针</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">d</span>=<span class="string">&quot;M10 200 50 200 A 30 50 -45 1 1 150 200 L 200 200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;pink&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="comment">// x半径为30, y半径50的椭圆 旋转45 大角弧 顺时针</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">d</span>=<span class="string">&quot;M10 220 50 220 A 30 50 45 1 0 150 220 L 200 220&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;red&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/A.png" alt="A"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h1 id="填充和轮廓"><a href="#填充和轮廓" class="headerlink" title="填充和轮廓"></a>填充和轮廓</h1><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><ul>
<li>用于填充图形，文本的颜色</li>
<li>语法：fill&#x3D;”color” 或者 style&#x3D;”fill:color”</li>
<li><span class="key_words">『不设置时，默认填充为黑色』</span></li>
<li>取消默认填充:fill&#x3D;”none”</li>
</ul>
<h3 id="fill-opacity"><a href="#fill-opacity" class="headerlink" title="fill-opacity"></a>fill-opacity</h3><ul>
<li>用于设置颜色的透明度</li>
</ul>
<h3 id="fill-rule"><a href="#fill-rule" class="headerlink" title="fill-rule"></a>fill-rule</h3><ul>
<li>用来设置复杂形状的填充规则</li>
<li>填充方式：大概是判断图形绘制结束后，中间闭合的部分填不填充，图形一定会填充<ul>
<li>fnonzero 默认值，大部分中间填充</li>
<li>fevenodd 大部分中间不填充</li>
</ul>
</li>
<li>nonzero：判断一个点是否在图形内，从该点做任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右（顺时针）穿过射线则计数加1，从右向左（逆时针）穿过射线则计数减1。得出计数结果后，如果结果是0，则认为点在图形外部，否则认为在内部。</li>
<li>evenodd: 要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部。</li>
</ul>
<h2 id="stroke"><a href="#stroke" class="headerlink" title="stroke"></a>stroke</h2><ul>
<li>线条、文本或者元素轮廓的颜色</li>
<li>语法：stroke&#x3D;”color” 或者 style&#x3D;”stroke&#x3D;color”</li>
<li>如果不取消默认填充，在不设置宽度的情况下很难看的</li>
</ul>
<h3 id="stroke-width"><a href="#stroke-width" class="headerlink" title="stroke-width"></a>stroke-width</h3><ul>
<li>轮廓的宽度</li>
</ul>
<h3 id="stroke-opacity"><a href="#stroke-opacity" class="headerlink" title="stroke-opacity"></a>stroke-opacity</h3><ul>
<li>轮廓的透明度</li>
</ul>
<h3 id="stroke-linecap"><a href="#stroke-linecap" class="headerlink" title="stroke-linecap"></a>stroke-linecap</h3><ul>
<li>轮廓终点的形状</li>
<li>语法: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stroke-linecap=&quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li>属性值：<ul>
<li>butt: 默认，两端是直边</li>
<li>round: 两端是圆角，圆角半径由stroke-width控制</li>
<li>square: 两端是直边，但是两边会多出一小截，这一截由stroke-width控制</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;g</span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">  stroke-width=<span class="string">&quot;10&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linecap</span>=<span class="string">&quot;butt&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M20 50 L200 50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M20 100 L200 100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linecap</span>=<span class="string">&quot;square&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M20 150 L200 150&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">&lt;/g&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/linecap.png" alt="linecap"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="stroke-linejoin"><a href="#stroke-linejoin" class="headerlink" title="stroke-linejoin"></a>stroke-linejoin</h3><ul>
<li>轮廓连接处的样式（线段的交点样式）</li>
<li>语法: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stroke-linejoin=&quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li>属性值：<ul>
<li>miter: 默认，两条线相交，交点是一个直角</li>
<li>round: 交点是圆角</li>
<li>bevel：交点是直角但被切了一个三角形</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;g</span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">  stroke-width=<span class="string">&quot;30&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linecap</span>=<span class="string">&quot;butt&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linejoin</span>=<span class="string">&quot;miter&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M40 70 80 30 120 70&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M40 140 80 100 120 140&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linecap</span>=<span class="string">&quot;square&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linejoin</span>=<span class="string">&quot;bevel&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M40 220 80 180 120 220&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">&lt;/g&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/linejoin.png" alt="linejoin"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="stroke-dasharray"><a href="#stroke-dasharray" class="headerlink" title="stroke-dasharray"></a>stroke-dasharray</h3><ul>
<li>轮廓变虚线</li>
<li>语法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stroke-dasharray=&quot;xxx&quot;</span><br></pre></td></tr></table></figure></li>
<li>参数: 数值的形式，以线, 空格, 线段, 空格….不断循环</li>
<li>示例：可能上一轮回是线段长度，下一轮回是空格长度<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;g</span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">  stroke-width=<span class="string">&quot;5&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-dasharray</span>=<span class="string">&quot;5,10&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M40 70 150 70&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-dasharray</span>=<span class="string">&quot;5,10,5&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M40 140 150 140&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-dasharray</span>=<span class="string">&quot;10,5,20&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M40 220 150 220&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">&lt;/g&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/dasharray.png" alt="dasharray"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="stroke-dashoffset"><a href="#stroke-dashoffset" class="headerlink" title="stroke-dashoffset"></a>stroke-dashoffset</h3><ul>
<li>虚线的偏移量，按照固定的范围偏移</li>
<li>参数：正数 | 负数 | 百分比</li>
<li><span class="key_words">『前提：要先设置好stroke-dasharray』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;path</span><br><span class="line">  d=<span class="string">&quot;M40 20 250 20&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">  stroke-width=<span class="string">&quot;5&quot;</span></span><br><span class="line">&gt;&lt;/path&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">g</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;green&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke-width</span>=<span class="string">&quot;5&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke-dasharray</span>=<span class="string">&quot;20&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M40 70 250 70&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-dashoffset</span>=<span class="string">&quot;10&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-dashoffset</span>=<span class="string">&quot;1%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M40 140 250 140&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-dashoffset</span>=<span class="string">&quot;-10&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M40 220 250 220&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">g</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/dashoffset.png" alt="dashoffset"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="stroke-miterlimit"><a href="#stroke-miterlimit" class="headerlink" title="stroke-miterlimit"></a>stroke-miterlimit</h3><ul>
<li>当两条线相交，且stroke-linejoin&#x3D;”miter”，斜接可能远超过路径轮廓线的线宽。</li>
<li><span class="key_words">『而stroke-miterlimit 对斜接长度和stroke-width的比率强加了一个极限。』</span></li>
<li><span class="key_words">『当极限到达时，交汇处由斜接变成倒角。』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;g</span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;green&quot;</span></span><br><span class="line">  stroke-width=<span class="string">&quot;15&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linejoin</span>=<span class="string">&quot;miter&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M20 80 60 40 100 80 100 40 130 90&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linejoin</span>=<span class="string">&quot;miter&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-miterlimit</span>=<span class="string">&quot;1&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M20 180 60 140 100 180 100 140 130 190&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linejoin</span>=<span class="string">&quot;miter&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-miterlimit</span>=<span class="string">&quot;2&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M20 280 60 240 100 280 100 240 130 290&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linejoin</span>=<span class="string">&quot;miter&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-miterlimit</span>=<span class="string">&quot;3&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M180 80 220 40 260 80 260 40 290 90&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linejoin</span>=<span class="string">&quot;miter&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-miterlimit</span>=<span class="string">&quot;4&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M180 180 220 140 260 180 260 140 290 190&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-linejoin</span>=<span class="string">&quot;miter&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke-miterlimit</span>=<span class="string">&quot;5&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">d</span>=<span class="string">&quot;M180 280 220 240 260 280 260 240 290 290&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span></span><br><span class="line">&lt;/g&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/miterlimit.png" alt="miterlimit"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h1 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h1><h2 id="text-标签"><a href="#text-标签" class="headerlink" title="text 标签"></a>text 标签</h2><h3 id="x-和-y"><a href="#x-和-y" class="headerlink" title="x 和 y"></a>x 和 y</h3><ul>
<li>决定文字的起点位置</li>
<li>注意：<span class="key_words">『如果x和y是一个数列，则每个坐标会应用到每一个字符上，数列形式下空字符也算字符』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;text</span><br><span class="line">  x=<span class="string">&quot;0 30 60 90 120 150 180 210 240&quot;</span></span><br><span class="line">  y=<span class="string">&quot;60 90 120 150 180 150 120 90 60&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;green&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;blue&quot;</span></span><br><span class="line">  font-size=<span class="string">&quot;30&quot;</span></span><br><span class="line">  font-weight=<span class="string">&quot;bold&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="variable constant_">HELLO</span> <span class="variable constant_">SVG</span>!!</span><br><span class="line">&lt;/text&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;240&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-size</span>=<span class="string">&quot;30&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-weight</span>=<span class="string">&quot;bold&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  HELLO SVG!!</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/text.png" alt="text"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="dx-和-dy"><a href="#dx-和-dy" class="headerlink" title="dx 和 dy"></a>dx 和 dy</h3><ul>
<li>相对于当前位置的偏移量</li>
<li>注意：<span class="key_words">『如果参数是一个数列，则每个坐标会应用到每一个字符上，数列形式下空字符也算字符』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;text</span><br><span class="line">  dx=<span class="string">&quot;10 10 10 10 10 10 10 10 10&quot;</span></span><br><span class="line">  dy=<span class="string">&quot;50 20 -20 20 -20 20 -20 20 -20&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;green&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;blue&quot;</span></span><br><span class="line">  font-size=<span class="string">&quot;30&quot;</span></span><br><span class="line">  font-weight=<span class="string">&quot;bold&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="variable constant_">HELLO</span> <span class="variable constant_">SVG</span>!!</span><br><span class="line">&lt;/text&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/dxdy.png" alt="dxdy"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h3><ul>
<li>把文字旋转到一个角度</li>
<li>注意：<span class="key_words">『如果参数是一个数列，则每个坐标会应用到每一个字符上，数列形式下空字符也算字符』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;text</span><br><span class="line">  x=<span class="string">&quot;50&quot;</span></span><br><span class="line">  y=<span class="string">&quot;50&quot;</span></span><br><span class="line">  rotate=<span class="string">&quot;10&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;green&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;blue&quot;</span></span><br><span class="line">  font-size=<span class="string">&quot;30&quot;</span></span><br><span class="line">  font-weight=<span class="string">&quot;bold&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="variable constant_">HELLO</span> <span class="variable constant_">SVG</span>!!</span><br><span class="line">&lt;/text&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/rotate.png" alt="rotate"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="textLength"><a href="#textLength" class="headerlink" title="textLength"></a>textLength</h3><ul>
<li>规定字符串的计算长度。在文字长度和textLength属性给定长度不一致的情况下，会自动调整字型的位置。</li>
<li>计算长度：包括了字体的大小，粗细</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;text</span><br><span class="line">  x=<span class="string">&quot;10&quot;</span></span><br><span class="line">  y=<span class="string">&quot;50&quot;</span></span><br><span class="line">  textLength=<span class="string">&quot;140&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;green&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;blue&quot;</span></span><br><span class="line">  font-size=<span class="string">&quot;30&quot;</span></span><br><span class="line">  font-weight=<span class="string">&quot;bold&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="variable constant_">HELLO</span> <span class="variable constant_">SVG</span>!!</span><br><span class="line">&lt;/text&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;10&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">textLength</span>=<span class="string">&quot;140&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-size</span>=<span class="string">&quot;30&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-weight</span>=<span class="string">&quot;normal&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  HELLO SVG!!</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;10&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;150&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">textLength</span>=<span class="string">&quot;300&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-size</span>=<span class="string">&quot;30&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-weight</span>=<span class="string">&quot;bold&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  HELLO SVG!!</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/textLength.png" alt="textLength.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="lengthAdjust"><a href="#lengthAdjust" class="headerlink" title="lengthAdjust"></a>lengthAdjust</h3><ul>
<li>控制文本已说明方式伸展到由textLength属性定义的长度</li>
<li>参数：<ul>
<li>spacing: 只拉伸或压缩间距（文字不变形）</li>
<li>spacingAndGlyphs: 同时拉伸或压缩间距和文字本身（文字变形）</li>
</ul>
</li>
<li>示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;text</span><br><span class="line">  x=<span class="string">&quot;10&quot;</span></span><br><span class="line">  y=<span class="string">&quot;50&quot;</span></span><br><span class="line">  textLength=<span class="string">&quot;140&quot;</span></span><br><span class="line">  lengthadjust=<span class="string">&quot;spacing&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;green&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;blue&quot;</span></span><br><span class="line">  font-size=<span class="string">&quot;30&quot;</span></span><br><span class="line">  font-weight=<span class="string">&quot;bold&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="variable constant_">HELLO</span> <span class="variable constant_">SVG</span>!!</span><br><span class="line">&lt;/text&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;10&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">textLength</span>=<span class="string">&quot;140&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">lengthadjust</span>=<span class="string">&quot;spacingAndGlyphs&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-size</span>=<span class="string">&quot;30&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-weight</span>=<span class="string">&quot;bold&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  HELLO SVG!!</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;10&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;150&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">textLength</span>=<span class="string">&quot;300&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">lengthadjust</span>=<span class="string">&quot;spacing&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-size</span>=<span class="string">&quot;30&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-weight</span>=<span class="string">&quot;bold&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  HELLO SVG!!</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;10&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">textLength</span>=<span class="string">&quot;300&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">lengthadjust</span>=<span class="string">&quot;spacingAndGlyphs&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-size</span>=<span class="string">&quot;30&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-weight</span>=<span class="string">&quot;bold&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  HELLO SVG!!</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/lengthadjust.png" alt="lengthadjust.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="CSS文字属性"><a href="#CSS文字属性" class="headerlink" title="CSS文字属性"></a>CSS文字属性</h3><ul>
<li>一些CSS中的文字样式属性同样也可以应用于SVG的文字中</li>
<li>font-size、font-family、font-style、font-variant、font-stretch、font-size-adjust、kerning、letter-spacing、word-spacing、text-decoration等</li>
</ul>
<h2 id="tspan-标签"><a href="#tspan-标签" class="headerlink" title="tspan 标签"></a>tspan 标签</h2><ul>
<li>标记文本中的部分内容。类似于span</li>
<li>tspan标签的属性和text标签一致</li>
<li>注意：<span class="key_words">『tspan必须是一个text元素的子元素或别的子元素tspan的子元素』</span></li>
<li>注意：<span class="key_words">『tspan的x、y和dx、dy会影响标签后面的内容』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;text</span><br><span class="line">  x=<span class="string">&quot;10&quot;</span></span><br><span class="line">  y=<span class="string">&quot;50&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;green&quot;</span></span><br><span class="line">  stroke=<span class="string">&quot;blue&quot;</span></span><br><span class="line">  font-size=<span class="string">&quot;30&quot;</span></span><br><span class="line">  font-weight=<span class="string">&quot;bold&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="variable constant_">HELLO</span></span><br><span class="line">  &lt;tspan fill=<span class="string">&quot;orange&quot;</span>&gt;<span class="variable constant_">SVG</span>&lt;/tspan&gt;</span><br><span class="line">  !!</span><br><span class="line">&lt;/text&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/tspan.png" alt="tspan"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="tref-标签"><a href="#tref-标签" class="headerlink" title="tref 标签"></a>tref 标签</h2><ul>
<li>配合xlink:href属性能引用已经定义好的文本，实现复制的效果。并且还可以自定义样式</li>
<li>2.0版本已废弃，只能用在SVG 1.1</li>
<li>2.0版本替代方案: <span class="key_words">『use标签』</span><ul>
<li>defs标签可以定义一些之后绘制中需要重复使用的图形元素. <span class="key_words">『defs中的元素定义id，没有使用不会展示』</span></li>
<li>use标签可以在SVG文档内读取目标节点，并在别的地方复制使用。<span class="key_words">『use使用xlink:href复制对应元素的id，才会显示这个元素』</span></li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">x</span>=<span class="string">&quot;10&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">y</span>=<span class="string">&quot;50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">id</span>=<span class="string">&quot;text&quot;</span>   // &lt;<span class="attr">---</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">font-size</span>=<span class="string">&quot;30&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">font-weight</span>=<span class="string">&quot;bold&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    HELLO SVG !!</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span></span><br><span class="line">&lt;use</span><br><span class="line">  x=&quot;10&quot;</span><br><span class="line">  y=&quot;100&quot;</span><br><span class="line">  fill=&quot;red&quot;</span><br><span class="line">  xlink:href=&quot;#text&quot; // &lt;---</span><br><span class="line">/&gt;</span><br><span class="line">&lt;use</span><br><span class="line">  x=&quot;10&quot;</span><br><span class="line">  y=&quot;150&quot;</span><br><span class="line">  fill=&quot;pink&quot;</span><br><span class="line">  rotate=&quot;45&quot;</span><br><span class="line">  xlink:href=&quot;#text&quot; // &lt;---</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/tref.png" alt="tref"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="textPath-标签"><a href="#textPath-标签" class="headerlink" title="textPath 标签"></a>textPath 标签</h2><ul>
<li>利用xlink:href属性取得一个任意路径，并且可以让字符顺着路径渲染</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;path</span><br><span class="line">  id=<span class="string">&quot;pathM&quot;</span></span><br><span class="line">  d=<span class="string">&quot;M 50 50 100 100 200 50 300 100&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;none&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">id</span>=<span class="string">&quot;pathQ&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">d</span>=<span class="string">&quot;M50 100 Q 175 200 300 100 T 600 100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">textPath</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#pathM&quot;</span>&gt;</span>HELLO SVG !!<span class="tag">&lt;/<span class="name">textPath</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">textPath</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#pathQ&quot;</span>&gt;</span>HELLO SVG !!<span class="tag">&lt;/<span class="name">textPath</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/textpath.png" alt="textpath"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h1 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h1><ul>
<li>应用： 图形，文字, 轮廓</li>
<li>使用的标签及意义：<ul>
<li>defs标签：定义渐变</li>
<li>stop标签：定义渐变的颜色坡度<ul>
<li>offset：渐变开始和结束的位置</li>
<li>stop-color：颜色</li>
<li>stop-opacity：透明度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h2><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">x1</span>=<span class="string">&quot;&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;0%&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    ...</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;20%&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    ...</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;100%&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span></span><br><span class="line">&lt;/defs&gt;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>x1，y1：线性渐变的起点</li>
<li>x2，y2：线性渐变的终点</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">linearGradient</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">id</span>=<span class="string">&quot;linearGradient&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">x2</span>=<span class="string">&quot;100%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">y2</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">stop</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">offset</span>=<span class="string">&quot;0%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">stop-color</span>=<span class="string">&quot;rgb(255,255,0)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">stop</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">offset</span>=<span class="string">&quot;100%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">stop-color</span>=<span class="string">&quot;rgb(255,0,0)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span></span><br><span class="line">&lt;/defs&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ellipse</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">cx</span>=<span class="string">&quot;150&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">cy</span>=<span class="string">&quot;70&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">rx</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">ry</span>=<span class="string">&quot;50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;url(#linearGradient)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;url(#linearGradient)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-size</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-family</span>=<span class="string">&quot;Verdana&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  SVG</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke-width</span>=<span class="string">&quot;5&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;url(#linearGradient)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-size</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">font-family</span>=<span class="string">&quot;Verdana&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;280&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  SVG</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/linearGradient.png" alt="linearGradient"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h2><ul>
<li>语法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">radialGradient</span> <span class="attr">cx</span>=<span class="string">&quot;&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;&quot;</span> <span class="attr">r</span>=<span class="string">&quot;&quot;</span> <span class="attr">fx</span>=<span class="string">&quot;&quot;</span> <span class="attr">fy</span>=<span class="string">&quot;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;0%&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    ...</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;20%&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    ...</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;100%&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">radialGradient</span>&gt;</span></span></span><br><span class="line">&lt;/defs&gt;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>cx，cy：圆的坐标</li>
<li>r：渐变半径</li>
<li>fx，fy：渐变的中心点（渐变焦点）</li>
</ul>
</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">radialGradient</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">id</span>=<span class="string">&quot;radialGradient&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">cx</span>=<span class="string">&quot;50%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">cy</span>=<span class="string">&quot;50%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">r</span>=<span class="string">&quot;50%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fx</span>=<span class="string">&quot;50%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fy</span>=<span class="string">&quot;100%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">stop</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">offset</span>=<span class="string">&quot;0%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stop-color</span>=<span class="string">&quot;rgb(255, 255, 0)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">stop</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">offset</span>=<span class="string">&quot;100%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stop-color</span>=<span class="string">&quot;rgb(255, 0, 0)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">radialGradient</span>&gt;</span></span></span><br><span class="line">&lt;/defs&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ellipse</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cx</span>=<span class="string">&quot;150&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cy</span>=<span class="string">&quot;70&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rx</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">ry</span>=<span class="string">&quot;50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">fill</span>=<span class="string">&quot;url(#radialGradient)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">fill</span>=<span class="string">&quot;url(#radialGradient)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">font-size</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">font-family</span>=<span class="string">&quot;Verdana&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">x</span>=<span class="string">&quot;50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">y</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">SVG</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">stroke-width</span>=<span class="string">&quot;5&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">stroke</span>=<span class="string">&quot;url(#radialGradient)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">fill</span>=<span class="string">&quot;none&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">font-size</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">font-family</span>=<span class="string">&quot;Verdana&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">x</span>=<span class="string">&quot;50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">y</span>=<span class="string">&quot;280&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">SVG</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/radialGradient.png" alt="radialGradient"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h1 id="裁剪和蒙层"><a href="#裁剪和蒙层" class="headerlink" title="裁剪和蒙层"></a>裁剪和蒙层</h1><h2 id="裁剪-clipPath标签"><a href="#裁剪-clipPath标签" class="headerlink" title="裁剪 clipPath标签"></a>裁剪 clipPath标签</h2><ul>
<li>定义一条裁剪路径，然后从元素中裁剪出对应的路径形状</li>
<li>无透明效果</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">clipPath</span> <span class="attr">id</span>=<span class="string">&quot;clipPath&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">d</span>=<span class="string">&quot;M10 50 A50 50 0 0 1 100 50 A50 50 0 0 1 190 50 Q210 100 100 200  Q-5 100 10 50 Z&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">clipPath</span>&gt;</span></span></span><br><span class="line">&lt;/defs&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">rect</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">width</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">height</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;#f00&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">clip-path</span>=<span class="string">&quot;url(#clipPath)&quot;</span> //&lt;<span class="attr">--</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/clippath.png" alt="clipPath"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="蒙层-mask标签"><a href="#蒙层-mask标签" class="headerlink" title="蒙层 mask标签"></a>蒙层 mask标签</h2><ul>
<li>裁剪并显示mask标签路径中的元素</li>
<li>与clipPath不同的是，可以有透明度（透明度为0 无蒙层效果）和灰度值遮罩计算得软边缘</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">mask</span> <span class="attr">id</span>=<span class="string">&quot;Mask&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">path</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">d</span>=<span class="string">&quot;M10 50 A50 50 0 0 1 100 50 A50 50 0 0 1 190 50 Q210 100 100 200  Q-5 100 10 50 Z&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">fill</span>=<span class="string">&quot;#fff&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">fill-opacity</span>=<span class="string">&quot;0.5&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">mask</span>&gt;</span></span></span><br><span class="line">&lt;/defs&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">rect</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">width</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">height</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">mask</span>=<span class="string">&quot;url(#Mask)&quot;</span> // &lt;<span class="attr">--</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/mask.png" alt="mask"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="基础动画"><a href="#基础动画" class="headerlink" title="基础动画"></a>基础动画</h2><ul>
<li>跟css动画属性一样</li>
</ul>
<h3 id="translate-平移"><a href="#translate-平移" class="headerlink" title="translate 平移"></a>translate 平移</h3><ul>
<li>语法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform=&quot;translate(x, y)&quot;</span><br></pre></td></tr></table></figure></li>
<li>参数： <ul>
<li>x: x轴上的平移距离</li>
<li>y：y轴上的平移距离</li>
</ul>
</li>
</ul>
<h3 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale 缩放"></a>scale 缩放</h3><ul>
<li>语法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform=&quot;scale(x, y)&quot;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>x：X轴上的缩放大小</li>
<li>y：Y轴上的缩放大小，当两个值一样时，写一个值就可以</li>
</ul>
</li>
</ul>
<h3 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><ul>
<li>语法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform=&quot;rotate(deg)&quot;</span><br></pre></td></tr></table></figure></li>
<li>参数：deg：旋转的角度，不用带单位</li>
<li>注意：<span class="key_words">『元素的旋转中心点默认是svg布局的（0，0）,而不是元素中心』</span></li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;rect</span><br><span class="line">  x=<span class="string">&quot;200&quot;</span></span><br><span class="line">  y=<span class="string">&quot;0&quot;</span></span><br><span class="line">  width=<span class="string">&quot;100&quot;</span></span><br><span class="line">  height=<span class="string">&quot;100&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;orange&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">rect</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">width</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">height</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;pink&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">transform</span>=<span class="string">&quot;rotate(20)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">rect</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">width</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">height</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">transform</span>=<span class="string">&quot;rotate(40)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">rect</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">width</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">height</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">transform</span>=<span class="string">&quot;rotate(60)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/animation-rotate.png" alt="animation-rotate"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><ul>
<li>设置元素的中点</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;rect</span><br><span class="line">  x=<span class="string">&quot;200&quot;</span></span><br><span class="line">  y=<span class="string">&quot;0&quot;</span></span><br><span class="line">  width=<span class="string">&quot;100&quot;</span></span><br><span class="line">  height=<span class="string">&quot;100&quot;</span></span><br><span class="line">  fill=<span class="string">&quot;orange&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">rect</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">width</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">height</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;pink&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">transform-origin</span>=<span class="string">&quot;250 50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">transform</span>=<span class="string">&quot;rotate(20)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">rect</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">width</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">height</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">transform-origin</span>=<span class="string">&quot;250 50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">transform</span>=<span class="string">&quot;rotate(40)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">rect</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">width</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">height</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">transform-origin</span>=<span class="string">&quot;250 50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">transform</span>=<span class="string">&quot;rotate(60)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/transform-origin.png" alt="transform-origin"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="skew-倾斜"><a href="#skew-倾斜" class="headerlink" title="skew 倾斜"></a>skew 倾斜</h3><ul>
<li>语法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform=&quot;skewX(x) skewY(y)&quot;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>x：X轴上的倾斜度</li>
<li>y：Y轴上的倾斜度</li>
</ul>
</li>
<li>注意：<span class="key_words">『在SVG中skew属性需要分开设置，写成 skew(x, y) 是不生效的』</span></li>
</ul>
<h2 id="JS动画"><a href="#JS动画" class="headerlink" title="JS动画"></a>JS动画</h2><ul>
<li>用定时器setInterval来实现</li>
<li>通过更改对应属性来实现动画，不同框架有不同做法</li>
<li>如：<ul>
<li>更改dom位置：3<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform=`translate($&#123;x&#125;, $&#123;y&#125;)`</span><br></pre></td></tr></table></figure></li>
<li>更改路径：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d=`M 250 100 300 0 $&#123;x&#125; 100 $&#123;x1&#125; $&#123;y&#125; z`</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h2><ul>
<li>使用@keyframes定义动画帧然后使用animation去调用</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">#line &#123;</span><br><span class="line">  stroke-<span class="attr">dasharray</span>: <span class="number">500</span>;</span><br><span class="line">  stroke-<span class="attr">dashoffset</span>: <span class="number">500</span>;</span><br><span class="line">  <span class="attr">animation</span>: animation 2s linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes animation &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    stroke-<span class="attr">dashoffset</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">line</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">id</span>=<span class="string">&quot;line&quot;</span> // &lt;<span class="attr">--</span> <span class="attr">或者</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">x2</span>=<span class="string">&quot;500&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">y2</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke</span>=<span class="string">&quot;orange&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">stroke-width</span>=<span class="string">&quot;10&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="案例-动态框"><a href="#案例-动态框" class="headerlink" title="案例-动态框"></a>案例-动态框</h3><ul>
<li>主要改变stroke-dasharray 和stroke-dashoffset</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="comment">/*定义线初始展示位置*/</span></span><br><span class="line">.<span class="property">line</span> &#123;</span><br><span class="line">  stroke-<span class="attr">dasharray</span>: <span class="number">100</span> <span class="number">500</span>; <span class="comment">/*修改dasharray和dashoffset*/</span></span><br><span class="line">  stroke-<span class="attr">dashoffset</span>: -<span class="number">320</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">line</span>:hover &#123;</span><br><span class="line">  <span class="attr">animation</span>: animation 12s linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes animation &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    stroke-<span class="attr">dasharray</span>: <span class="number">100</span> <span class="number">500</span>;</span><br><span class="line">    stroke-<span class="attr">dashoffset</span>: -<span class="number">320</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    stroke-<span class="attr">dasharray</span>: <span class="number">700</span>;</span><br><span class="line">    stroke-<span class="attr">dashoffset</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">svg</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">width</span>=<span class="string">&quot;300&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">height</span>=<span class="string">&quot;300&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">style</span>=<span class="string">&quot;border: 2px solid orange&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">linearGradient</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">id</span>=<span class="string">&quot;linearGradient&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">x2</span>=<span class="string">&quot;100%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">y2</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">stop</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">offset</span>=<span class="string">&quot;0%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">stop-color</span>=<span class="string">&quot;rgb(255,255,0)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">stop</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">offset</span>=<span class="string">&quot;100%&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">stop-color</span>=<span class="string">&quot;rgb(255,0,0)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">text</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">x</span>=<span class="string">&quot;120&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">y</span>=<span class="string">&quot;150&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">fill</span>=<span class="string">&quot;url(#linearGradient)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    Hover</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">rect</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">class</span>=<span class="string">&quot;line&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">x</span>=<span class="string">&quot;50&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">y</span>=<span class="string">&quot;120&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">fill</span>=<span class="string">&quot;transparent&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">height</span>=<span class="string">&quot;60&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">width</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">stroke</span>=<span class="string">&quot;url(#linearGradient)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="/../../img/visualization/animation-stroke.gif" alt="动态按钮"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="GreenSock-GSAP"><a href="#GreenSock-GSAP" class="headerlink" title="GreenSock(GSAP)"></a>GreenSock(GSAP)</h2><ul>
<li>可以借用一些插件来实现比如GSAP</li>
<li><a href="https://gsap.com/docs/v3/GSAP/Tween/">https://gsap.com/docs/v3/GSAP/Tween/</a></li>
</ul>
<h1 id="工具和插件"><a href="#工具和插件" class="headerlink" title="工具和插件"></a>工具和插件</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li>生成SVG路径： 去iconfont网站找图标然后选择svg下载</li>
<li>然后复制代码，保留svg那一段然后用手动给图形添加id</li>
<li>之后使用use获取这个图标</li>
<li>路径生成： 使用Sketch辅助生成路径</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gsap.<span class="title function_">registerPlugin</span>(<span class="title class_">MotionPathPlugin</span>);</span><br><span class="line">  gsap.<span class="title function_">to</span>(<span class="string">&quot;#airplane&quot;</span>, &#123; <span class="comment">// 要运动的元素</span></span><br><span class="line">    <span class="attr">duration</span>: <span class="number">3</span>, <span class="comment">// 时间</span></span><br><span class="line">    <span class="attr">repeat</span>: -<span class="number">1</span>, <span class="comment">// 循环（1、2、3、4 为循环次数，-1为无限循环）</span></span><br><span class="line">    <span class="attr">ease</span>: <span class="title class_">Linear</span>.<span class="property">easeNone</span>, <span class="comment">// 运动曲线</span></span><br><span class="line">    <span class="attr">motionPath</span>:&#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;#airplane-path&quot;</span>, <span class="comment">// 运动的轨迹</span></span><br><span class="line">      <span class="attr">align</span>: <span class="string">&quot;#airplane-path&quot;</span>,</span><br><span class="line">      <span class="attr">autoRotate</span>: <span class="number">45</span>, <span class="comment">// 飞机运动旋转角度 （true为自动调整角度）</span></span><br><span class="line">      <span class="attr">alignOrigin</span>: [<span class="number">1</span>, <span class="number">1</span>] <span class="comment">// 飞机的运动原点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>原出处：<a href="https://juejin.cn/post/7124312346947764260?searchId=202503101451055B89B2C172923C00C2DA#heading-75">https://juejin.cn/post/7124312346947764260?searchId=202503101451055B89B2C172923C00C2DA#heading-75</a></p>
</blockquote>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>echartGL</title>
    <url>/2025/03/05/%E5%8F%AF%E8%A7%86%E5%8C%96/echartGL/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pnpm install echarts-gl</span><br></pre></td></tr></table></figure>

<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><a href="https://echarts.apache.org/zh/option-gl.html#globe">GL配置</a></li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>bar3D，line3D: 三维直角坐标系</li>
<li>globe: 地球仪</li>
<li>map3D: 地图</li>
<li>scatter3D: 散点图、气泡图</li>
<li>lines3D: 飞线图</li>
<li>surface: 曲面图金属零件</li>
<li>polygons3D: 建筑群</li>
<li>graphGL: 关系图</li>
<li>flowGL: 风场气象等量子场</li>
</ul>
<h3 id="三维直角坐标系要素"><a href="#三维直角坐标系要素" class="headerlink" title="三维直角坐标系要素"></a>三维直角坐标系要素</h3><ul>
<li>grid3D：控制图形的位置</li>
<li>xAxisD：控制x轴坐标</li>
<li>yAxis3D：控制y轴坐标</li>
<li>zAxis3D：控制z轴坐标</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>mapbox3D：基于 mapbox-gl-js 的地理组件，地图上绘制三维的散点图、飞线图、柱状图、地图</li>
<li>geo3D：三维的地理坐标系组件，地图上绘制三维的散点图、气泡图、柱状图、飞线图</li>
<li>globe：地球组件。展示三维的散点图、气泡图、柱状图、飞线图</li>
</ul>
<h2 id="灯光"><a href="#灯光" class="headerlink" title="灯光"></a>灯光</h2><ul>
<li>在三维图形中，灯光必不可少</li>
<li>通过设置light决定图形的影子与物体的距离</li>
<li>另外series中的对象也需要设置着色效果shading</li>
</ul>
<h2 id="如何隐藏网格线和视觉坐标辅助线"><a href="#如何隐藏网格线和视觉坐标辅助线" class="headerlink" title="如何隐藏网格线和视觉坐标辅助线"></a>如何隐藏网格线和视觉坐标辅助线</h2><ul>
<li>在grid3D中show: false,解决视觉坐标线条</li>
<li>axisTick，axisLabel，splitLine，splitArea解决网格线，坐标轴线，标签等显隐</li>
</ul>
<h2 id="如何不让物体随鼠标左右滑动而移动，也不受滑轮影响"><a href="#如何不让物体随鼠标左右滑动而移动，也不受滑轮影响" class="headerlink" title="如何不让物体随鼠标左右滑动而移动，也不受滑轮影响"></a>如何不让物体随鼠标左右滑动而移动，也不受滑轮影响</h2><ul>
<li>通过grid中的viewControl<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">projection</span>: <span class="string">&#x27;orthographic&#x27;</span>, <span class="comment">// 投影方式</span></span><br><span class="line"><span class="attr">orthographicSize</span>: <span class="number">110</span>, <span class="comment">//控制地图大小</span></span><br><span class="line"><span class="attr">maxOrthographicSize</span>: <span class="number">110</span>, <span class="comment">// 投影最大值</span></span><br><span class="line"><span class="attr">minOrthographicSize</span>: <span class="number">110</span>, <span class="comment">// 投影最小值</span></span><br><span class="line"><span class="attr">alpha</span>:<span class="number">60</span>, <span class="comment">// 确定视线角度</span></span><br><span class="line"><span class="attr">beta</span>:<span class="number">10</span>,</span><br><span class="line"><span class="attr">autoRotate</span>:<span class="literal">false</span>, <span class="comment">// 是否开启自动旋转</span></span><br><span class="line"><span class="attr">rotateSensitivity</span>: <span class="number">0</span>, <span class="comment">// 设置为0 无法旋转</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="scatter3D"><a href="#scatter3D" class="headerlink" title="scatter3D"></a>scatter3D</h2><ul>
<li>symbol: 决定物体的形状，可以添加svg路径</li>
<li>symbolSize: 设置物体的宽高[宽,高]</li>
<li>data：要以[{value：[x, y, z]}]的形式</li>
<li>像是做一些自定义的图案，比如3D金字塔比较方便</li>
</ul>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>仪表盘</title>
    <url>/2025/03/03/%E5%8F%AF%E8%A7%86%E5%8C%96/%E4%BB%AA%E8%A1%A8%E7%9B%98/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<p><img src="/../../img/echart/driverPlate.png" alt="仪表盘示例"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="外盘的样式、位置、刻度"><a href="#外盘的样式、位置、刻度" class="headerlink" title="外盘的样式、位置、刻度"></a>外盘的样式、位置、刻度</h3><ul>
<li>startAngle 和 endAngle: 控制外盘的形状</li>
<li>center 和 radius: 控制位置</li>
<li>min 和 max: 控制刻度的数值</li>
<li>splitNumber: 控制了刻度间隔，而不是每过splitNumber展示数值，用来调整数值的展示</li>
<li>axisLine: 控制表盘最外面的弧线的样式</li>
<li>axisLabel: 刻度文字的样式</li>
<li>axisTick: 小刻度线的样式</li>
<li>splitLine: 大刻度线的样式</li>
<li>progress: 指针的样式，默认就可以忽略</li>
<li>detail: 指针下方的文本，detail中的formatter回调中可以获取data的value</li>
<li>data: 指针所在位置，可以动态改变</li>
</ul>
<h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">type</span>:<span class="string">&#x27;gauge&#x27;</span>,</span><br><span class="line"><span class="attr">startAngle</span>: <span class="number">230</span>,</span><br><span class="line"><span class="attr">endAngle</span>: -<span class="number">50</span>,</span><br><span class="line"><span class="attr">center</span>: [<span class="string">&#x27;50%&#x27;</span>, <span class="string">&#x27;55%&#x27;</span>],</span><br><span class="line"><span class="attr">radius</span>: <span class="string">&#x27;90%&#x27;</span>,</span><br><span class="line"><span class="attr">min</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">max</span>: <span class="number">220</span>,</span><br><span class="line"><span class="attr">splitNumber</span>: <span class="number">11</span>, <span class="comment">// 刻度间隔</span></span><br><span class="line"><span class="attr">axisLine</span>: &#123;</span><br><span class="line">  <span class="attr">lineStyle</span>: &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">color</span>: [ <span class="comment">// 只能用小数点来控制颜色的百分比</span></span><br><span class="line">      [<span class="number">0.10</span>, <span class="string">&#x27;#7CFFB2&#x27;</span>],</span><br><span class="line">      [<span class="number">0.80</span>, <span class="string">&#x27;#58D9F9&#x27;</span>],</span><br><span class="line">      [<span class="number">1</span>, <span class="string">&#x27;#FF6E76&#x27;</span>]</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">shadowBlur</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">shadowColor</span>: <span class="string">&#x27;rgba(255,255,255,0.5)&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">axisLabel</span>: &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  <span class="attr">distance</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="attr">fontSize</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">fontWeight</span>: <span class="string">&#x27;bold&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">axisTick</span>: &#123; <span class="comment">// 小刻度</span></span><br><span class="line">  <span class="attr">length</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">lineStyle</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">shadowBlur</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">shadowColor</span>: <span class="string">&#x27;rgba(255,255,255,0.5)&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">splitLine</span>: &#123; <span class="comment">// 大刻度</span></span><br><span class="line">  <span class="attr">length</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">lineStyle</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;rgba(255,255,255,1)&#x27;</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">shadowBlur</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">shadowColor</span>: <span class="string">&#x27;rgba(255,255,255,0.5)&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">detail</span>: &#123; <span class="comment">// 展示</span></span><br><span class="line">  <span class="attr">fontSize</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">offsetCenter</span>: [<span class="number">0</span>, <span class="string">&#x27;40%&#x27;</span>],</span><br><span class="line">  <span class="attr">valueAnimation</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">formatter</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`km/h\n<span class="subst">$&#123;value.toFixed(<span class="number">2</span>)&#125;</span>`</span> <span class="comment">// 数值保留两位小数</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;rgba(255,255,255)&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">data</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>水球图</title>
    <url>/2025/03/03/%E5%8F%AF%E8%A7%86%E5%8C%96/%E6%B0%B4%E7%90%83%E5%9B%BE/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<p><img src="/../../img/echart/waterBall.png" alt="水球图示例"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li>属于echart扩展，需要另外下载</li>
<li>安装：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pnpm install echarts-liquidfill</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">type</span>:<span class="string">&#x27;liquidFill&#x27;</span>,</span><br><span class="line"><span class="attr">phase</span>:<span class="number">0.5</span>,                          <span class="comment">// 起始相位</span></span><br><span class="line"><span class="attr">amplitude</span>:<span class="number">10</span>,                       <span class="comment">// 波浪高度</span></span><br><span class="line"><span class="attr">shape</span>:<span class="string">&#x27;diamond&#x27;</span>,                    <span class="comment">// 水球形状 &#x27;circle&#x27;， &#x27;rect&#x27;， &#x27;roundRect&#x27;， &#x27;triangle&#x27;， &#x27;pin&#x27;， &#x27;arrow&#x27;，&#x27;container&#x27;</span></span><br><span class="line"><span class="attr">shape</span>:<span class="string">&#x27;path://&#x27;</span>,                    <span class="comment">// 自定义形状，svg路径</span></span><br><span class="line"><span class="attr">direction</span>:<span class="string">&#x27;left&#x27;</span>,                   <span class="comment">// 水波运动方向</span></span><br><span class="line"><span class="attr">data</span>:[<span class="number">0.5</span>,<span class="number">0.2</span>],                     <span class="comment">// 写法一，这里设置多个值时就会出现多个波浪 取值 0到1</span></span><br><span class="line"><span class="attr">data</span>:[</span><br><span class="line">  <span class="number">0.2</span>,&#123;</span><br><span class="line">    <span class="attr">value</span>:<span class="number">0.5</span>,                      <span class="comment">// 写法二</span></span><br><span class="line">    <span class="attr">direction</span>:<span class="string">&#x27;left&#x27;</span>,               <span class="comment">// 水波运动方向</span></span><br><span class="line">    <span class="attr">itemStyle</span>:&#123;&#125;,                   <span class="comment">// 水波样式内容下同  </span></span><br><span class="line">    <span class="attr">emphasis</span>:&#123;&#125;                     <span class="comment">// 鼠标移入之后的样式内容与  itemStyle一致        </span></span><br><span class="line">  &#125;               </span><br><span class="line">]，</span><br><span class="line"><span class="attr">radius</span>:<span class="string">&#x27;100%&#x27;</span>,</span><br><span class="line"><span class="attr">color</span>:[<span class="string">&#x27;#C23531&#x27;</span>,<span class="string">&#x27;#fff&#x27;</span>,<span class="string">&#x27;red&#x27;</span>]      <span class="comment">// 波浪颜色调色板</span></span><br><span class="line"><span class="attr">center</span>:[<span class="string">&#x27;50%&#x27;</span>,<span class="string">&#x27;50%&#x27;</span>],</span><br><span class="line"><span class="attr">waveAnimation</span>:<span class="literal">true</span>,                 <span class="comment">// 是否开启水波动画效果</span></span><br><span class="line"><span class="attr">amplitude</span>:<span class="number">8</span>,                        <span class="comment">// 水波的振幅大小</span></span><br><span class="line"><span class="attr">waveLength</span>:<span class="number">10</span>,                      <span class="comment">// 水波的长度</span></span><br><span class="line"><span class="attr">waveSpeed</span>:<span class="number">0.05</span>,                     <span class="comment">// 水波的速度</span></span><br><span class="line"><span class="attr">animationEasing</span>:<span class="string">&#x27;smooth&#x27;</span>,           <span class="comment">// 初始动画加载效果 linear、加速（ease-in）、减速（ease-out）</span></span><br><span class="line"><span class="attr">animationEasingUpdate</span>:<span class="string">&#x27;smooth&#x27;</span>,     <span class="comment">// 数据更新动画的缓动效果,同上</span></span><br><span class="line"><span class="attr">animationDuration</span>:<span class="number">100</span>,              <span class="comment">// 初始动画时长单位毫秒</span></span><br><span class="line"><span class="attr">animationDurationUpdate</span>:<span class="number">100</span>,        <span class="comment">// 数据更新时长单位毫秒</span></span><br><span class="line"><span class="comment">// 水波样式</span></span><br><span class="line"><span class="attr">itemStyle</span>:&#123;</span><br><span class="line">  <span class="attr">opacity</span>:<span class="number">0.5</span>,</span><br><span class="line">  <span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,                      <span class="comment">// 水的颜色 </span></span><br><span class="line">  <span class="attr">shadowBlur</span>:<span class="number">10</span>,                    <span class="comment">// 水波阴影大小</span></span><br><span class="line">  <span class="attr">shadowColor</span>:<span class="string">&#x27;red&#x27;</span>,                <span class="comment">// 水上方空气的颜色</span></span><br><span class="line">  <span class="attr">shadowOffsetX</span>:<span class="number">10</span>,</span><br><span class="line">  <span class="attr">shadowOffsetY</span>:<span class="number">10</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 鼠标移入水波时的样式(内容与 itemStyle 一致)</span></span><br><span class="line"><span class="attr">emphasis</span>:&#123;&#125;,</span><br><span class="line"><span class="comment">// 内圈的背景颜色</span></span><br><span class="line"><span class="attr">backgroundStyle</span>:&#123;</span><br><span class="line">  <span class="attr">borderWidth</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  <span class="attr">borderColor</span>:<span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">  <span class="attr">shadowBlur</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">shadowColor</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  <span class="attr">shadowOffsetX</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">shadowOffsetY</span>: <span class="number">0</span></span><br><span class="line">&#125;,         </span><br><span class="line"><span class="comment">// 外圈轮廓的样式</span></span><br><span class="line"><span class="attr">outline</span>:&#123;</span><br><span class="line">  <span class="attr">show</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">borderDistance</span>: <span class="number">10</span>,               <span class="comment">// 控制内圈与外圈间距</span></span><br><span class="line">  <span class="attr">itemStyle</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">    <span class="attr">borderWidth</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">borderColor</span>:<span class="string">&quot;rgba(40, 36, 36, 1)&quot;</span>,</span><br><span class="line">    <span class="attr">borderType</span>: <span class="string">&quot;dashed&quot;</span>,           <span class="comment">// &#x27;solid&#x27;、&#x27;dotted&#x27;</span></span><br><span class="line">    <span class="attr">borderDashOffset</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">shadowBlur</span>:<span class="number">2.5</span>,</span><br><span class="line">    <span class="attr">shadowColor</span>:<span class="string">&quot;rgba(228, 2, 2, 1)&quot;</span>,</span><br><span class="line">    <span class="attr">shadowOffsetX</span>: -<span class="number">1.5</span>,</span><br><span class="line">    <span class="attr">shadowOffsetY</span>: <span class="number">1.5</span>,</span><br><span class="line">    <span class="attr">opacity</span>:<span class="number">0.5</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">label</span>:&#123;</span><br><span class="line">  <span class="attr">show</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">position</span>: <span class="string">&#x27;inside&#x27;</span>,         <span class="comment">// 标签位置 &#x27;left&#x27;、&#x27;right&#x27;、&#x27;top&#x27;、&#x27;bottom&#x27;</span></span><br><span class="line">  <span class="attr">baseline</span>: <span class="string">&#x27;middle&#x27;</span>          <span class="comment">// 标签对齐 &quot;top&quot;、&quot;bottom&quot;</span></span><br><span class="line">  <span class="attr">align</span>:<span class="string">&#x27;left&#x27;</span>,               <span class="comment">// 水平对齐方式 &quot;right&quot; </span></span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;#000&#x27;</span>,              <span class="comment">// 文本没被水碰到的原色</span></span><br><span class="line">  <span class="attr">insideColor</span>:<span class="string">&#x27;red&#x27;</span>,          <span class="comment">// 文本碰水后的颜色</span></span><br><span class="line">  <span class="attr">fontSize</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">fontWeight</span>: <span class="string">&#x27;normal&#x27;</span>,</span><br><span class="line">  <span class="attr">fontFamily</span>: <span class="string">&#x27;sans-serif&#x27;</span>,</span><br><span class="line">  <span class="attr">formatter</span>: <span class="literal">null</span>,            <span class="comment">// 格式化标签文本的回调函数</span></span><br><span class="line">  <span class="attr">backgroundColor</span>: <span class="string">&#x27;none&#x27;</span>,    <span class="comment">// 文本框颜色</span></span><br><span class="line">  <span class="attr">borderRadius</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">borderColor</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  <span class="attr">borderWidth</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">padding</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  <span class="attr">shadowBlur</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">shadowColor</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  <span class="attr">shadowBlur</span>:<span class="number">20</span>,</span><br><span class="line">  <span class="attr">textBorderColor</span>:<span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  <span class="attr">textBorderWidth</span>:<span class="number">10</span>,</span><br><span class="line">  <span class="attr">textBorderType</span>:<span class="string">&#x27;solid&#x27;</span>,        <span class="comment">// 描边类型</span></span><br><span class="line">  <span class="attr">textBorderDashOffset</span>:<span class="number">10</span>,       <span class="comment">// 描边为虚线时的偏移量</span></span><br><span class="line">  <span class="attr">textShadowColor</span>:<span class="string">&#x27;transparent&#x27;</span>, <span class="comment">// 文字阴影颜色</span></span><br><span class="line">  <span class="attr">textShadowBlur</span>:<span class="number">10</span>,             <span class="comment">// 文字阴影长度</span></span><br><span class="line">  <span class="attr">textShadowOffsetX</span>:<span class="number">10</span>,          <span class="comment">// 文字阴影水平偏移量</span></span><br><span class="line">  <span class="attr">textShadowOffsetY</span>:<span class="number">10</span>,          <span class="comment">// 文字阴影竖直偏移量</span></span><br><span class="line">  <span class="attr">overflow</span>:<span class="string">&#x27;none&#x27;</span>,               <span class="comment">// 文字超出是否截断</span></span><br><span class="line">  <span class="attr">ellipsis</span>:<span class="string">&#x27;···&#x27;</span>,                <span class="comment">// 文字截断时末尾显示内容</span></span><br><span class="line">  <span class="attr">shadowOffsetX</span>:<span class="number">20</span>,              <span class="comment">// 文本标签的阴影水平偏移</span></span><br><span class="line">  <span class="attr">shadowOffsetY</span>:<span class="number">20</span>,              <span class="comment">// 文本标签的阴影竖直偏移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>词云图</title>
    <url>/2025/03/05/%E5%8F%AF%E8%A7%86%E5%8C%96/%E8%AF%8D%E4%BA%91%E5%9B%BE/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<p><img src="/../../img/echart/wordcloud.png" alt="词云图示例"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pnpm install echarts-wordcloud</span><br></pre></td></tr></table></figure>
<ul>
<li>注意wordcloud版本2 对应 echart版本5，wordcloud版本1 对应 echart4</li>
</ul>
<h3 id="自定义形状-maskImage"><a href="#自定义形状-maskImage" class="headerlink" title="自定义形状 maskImage"></a>自定义形状 maskImage</h3><ul>
<li>主要是改变maskImage，自定义配置，图片必须是base64格式,并且以Image的方法返回</li>
<li>图片必须是闭合的，填充区域必须为黑色，图片可以通过<a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a><br>下载图片</li>
</ul>
<h3 id="字体范围-sizeRange"><a href="#字体范围-sizeRange" class="headerlink" title="字体范围 sizeRange"></a>字体范围 sizeRange</h3><ul>
<li>如果sizeRange设置的范围差距过大，数据渲染时，数据量不会全部展示</li>
<li>因为图形的大小限制和drawOutOfBound: false不允许超过边界</li>
</ul>
<h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><ul>
<li>可以全局配置也可给单个字体配置<ul>
<li>全局：直接在全局的textStyle的color中设置随机颜色，当然也可以固定一种颜色</li>
<li>单个：给数据的每个对象单独配置颜色，如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">name</span>: <span class="string">&quot;深圳&quot;</span>, <span class="attr">value</span>: <span class="number">164910</span>, <span class="attr">textStyle</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>参考其他使用的应用，会发现存在使用基本是是统一色系颜色的随机颜色，这个如何实现？<ul>
<li>创建对应的配色主题，每个主题有若干颜色</li>
<li>配置option的主题颜色</li>
</ul>
</li>
</ul>
<h3 id="排列方式"><a href="#排列方式" class="headerlink" title="排列方式"></a>排列方式</h3><ul>
<li>主要使用 rotationRange 和 rotationStep<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">横向：<span class="attr">rotationRange</span>: [<span class="number">0</span>, <span class="number">0</span>], <span class="attr">rotationStep</span>: <span class="number">0</span></span><br><span class="line">对角线：<span class="attr">rotationRange</span>: [-<span class="number">90</span>, <span class="number">90</span>], <span class="attr">rotationStep</span>: <span class="number">7</span></span><br><span class="line">横竖混排：<span class="attr">rotationRange</span>: [<span class="number">0</span>, <span class="number">90</span>], <span class="attr">rotationStep</span>: <span class="number">90</span></span><br><span class="line">横切混排：<span class="attr">rotationRange</span>: [<span class="number">0</span>, <span class="number">90</span>], <span class="attr">rotationStep</span>: <span class="number">45</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">type</span>: <span class="string">&#x27;wordCloud&#x27;</span>, <span class="comment">// 类型</span></span><br><span class="line"></span><br><span class="line"><span class="attr">shape</span>: <span class="string">&#x27;circle&#x27;</span>, <span class="comment">// 词云形状，内置形状有circle，cardioid(心形),diamond(棱形),triangle-forward, triangle,triangle-upright, pentagon, and star</span></span><br><span class="line"></span><br><span class="line"><span class="attr">keepAspect</span>: <span class="literal">false</span>, <span class="comment">// v2.1.0时可以保持maskImage纵横比或1：1</span></span><br><span class="line"><span class="attr">maskImage</span>: maskImage, <span class="comment">// 背景图，白底不画，最好黑底，maskImage优先级比shape高</span></span><br><span class="line"></span><br><span class="line"><span class="attr">left</span>: <span class="string">&#x27;center&#x27;</span>, <span class="comment">// 调整词云位置</span></span><br><span class="line"><span class="attr">top</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line"><span class="attr">width</span>: <span class="string">&#x27;70%&#x27;</span>,</span><br><span class="line"><span class="attr">height</span>: <span class="string">&#x27;80%&#x27;</span>,</span><br><span class="line"><span class="attr">right</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">bottom</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"><span class="attr">sizeRange</span>: [<span class="number">12</span>, <span class="number">60</span>], <span class="comment">// 字体范围,默认最小12px，最大60px大小</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rotationRange</span>: [-<span class="number">90</span>, <span class="number">90</span>], <span class="comment">// 词云中文字的角度</span></span><br><span class="line"><span class="attr">rotationStep</span>: <span class="number">45</span>, <span class="comment">// 渲染梯度，越小角度种类越多</span></span><br><span class="line"></span><br><span class="line"><span class="attr">gridSize</span>: <span class="number">8</span>, <span class="comment">// 网格大小，越大，词之间间隙越大</span></span><br><span class="line"></span><br><span class="line"><span class="attr">drawOutOfBound</span>: <span class="literal">false</span>, <span class="comment">// v2.1.0时可以设置是否允许词云在边界外渲染，默认false，否则容易造成词重叠</span></span><br><span class="line"></span><br><span class="line"><span class="attr">shrinkToFit</span>: <span class="literal">false</span>, <span class="comment">// v2.1.0时可以允许当字体过大是否缩小字体，false不渲染，true缩小</span></span><br><span class="line"></span><br><span class="line"><span class="attr">layoutAnimation</span>: <span class="literal">true</span>, <span class="comment">// 是否开启动画</span></span><br><span class="line"></span><br><span class="line"><span class="attr">textStyle</span>: &#123;<span class="comment">// 全局文本样式</span></span><br><span class="line">  <span class="attr">fontFamily</span>: <span class="string">&#x27;sans-serif&#x27;</span>,</span><br><span class="line">  <span class="attr">fontWeight</span>: <span class="string">&#x27;bold&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;rgb(&#x27;</span> + [</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">160</span>),</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">160</span>),</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">160</span>)</span><br><span class="line">    ].<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">emphasis</span>: &#123;<span class="comment">// 鼠标移到文字上的样式</span></span><br><span class="line">  <span class="attr">focus</span>: <span class="string">&#x27;self&#x27;</span>,</span><br><span class="line">  <span class="attr">textStyle</span>: &#123;</span><br><span class="line">      <span class="attr">textShadowBlur</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="attr">textShadowColor</span>: <span class="string">&#x27;#333&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据格式</span></span><br><span class="line"><span class="attr">data</span>: [&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Farrah Abraham&#x27;</span>, <span class="comment">// 词云文本</span></span><br><span class="line">    <span class="attr">value</span>: <span class="number">366</span>, <span class="comment">// 词云大小通过value判断</span></span><br><span class="line">    <span class="attr">textStyle</span>: &#123;&#125; <span class="comment">// 可单独设置文本样式</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>echart 问题与解答</title>
    <url>/2025/03/03/%E5%8F%AF%E8%A7%86%E5%8C%96/%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E7%AD%94/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="echarts-has-instanced"><a href="#echarts-has-instanced" class="headerlink" title="echarts has instanced"></a>echarts has instanced</h3><ul>
<li>解决方法： 判断是否初始化过，初始化过就销毁然后重新初始化<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(chart !== <span class="literal">null</span> &amp;&amp; chart !== <span class="string">&#x27;&#x27;</span> &amp;&amp; chart !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  chart.<span class="title function_">dispose</span>() <span class="comment">// 有就销毁在重新初始化</span></span><br><span class="line">&#125;</span><br><span class="line">chart = echarts.<span class="title function_">init</span>(mychartRef.<span class="property">current</span> <span class="keyword">as</span> unknown <span class="keyword">as</span> <span class="title class_">HTMLDivElement</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">400</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="当itemStyle的-color-设置成渐变，label-的color无法映射到颜色"><a href="#当itemStyle的-color-设置成渐变，label-的color无法映射到颜色" class="headerlink" title="当itemStyle的 color 设置成渐变，label 的color无法映射到颜色"></a>当itemStyle的 color 设置成渐变，label 的color无法映射到颜色</h3><ul>
<li>原因：在label设置中的颜色没有回调函数，无法拿到渐变后data中的颜色值，所以只能单独配置</li>
<li>解法：如果想保持与柱体，label颜色一致，最好的处理方式是在数据中对单个对象添加<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">label</span>:&#123;</span><br><span class="line">  <span class="attr">textStyle</span>: &#123;<span class="attr">color</span>:<span class="string">&#x27;对应的颜色&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>Git找不到null文件</title>
    <url>/2024/11/01/%E6%8A%A5%E9%94%99%E6%8C%87%E5%8D%97/Git%E6%89%BE%E4%B8%8D%E5%88%B0null%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><ul>
<li>(二次)win10&#x2F;11安装git，出现 fatal: open &#x2F;dev&#x2F;null or dup failed: No Such file or directory</li>
</ul>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ol>
<li><p>首先打开注册表，win+R，输入regedit 打开:</p>
</li>
<li><p>根据以下路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Null</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有的从另一台好的电脑导出，然后在导入，顺便把下面的这个文件复制一份。有的把默认项数值改为1</p>
</li>
<li><p>前往这个路径，把旧的先删除，然后换上没问题的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c:\Windows\system32\drives\null.sys</span><br></pre></td></tr></table></figure>
</li>
<li><p>点击开始–&gt; 搜索 –&gt; cmd –&gt; 找到命令提示符用管理员身份打开（右键的命令无效，原因未知，最好按照这个路径找）</p>
</li>
<li><p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc query null</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行，成功则完成，以下步骤不用看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc start null</span><br></pre></td></tr></table></figure>
</li>
<li><p>失败，出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SC] StartService 失败 577: Windows 无法验证此文件的数字签名。某软件或硬件最近有所更改，可能安装了签名错误或损毁的文件，或者安装的文件可能是来路不明的恶意软件。</span><br></pre></td></tr></table></figure></li>
<li><p>执行后重启电脑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sfc /scannow</span><br></pre></td></tr></table></figure></li>
<li><p>继续执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sfc /scannow</span><br></pre></td></tr></table></figure></li>
<li><p>出现以下文字表示无问题，以下步骤不用看</p>
<ul>
<li>windows资源保护找了了损坏文件并成功修复了它们。</li>
<li>或者Windows 资源保护未找到任何完整性冲突</li>
</ul>
</li>
<li><p>再次执行以下命令然后重启电脑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sfc /scannow</span><br><span class="line"></span><br><span class="line">Dism /Online /Cleanup-Image /ScanHealth</span><br><span class="line"></span><br><span class="line">Dism /Online /Cleanup-Image /CheckHealth</span><br><span class="line"></span><br><span class="line">DISM /Online /Cleanup-image /RestoreHealth</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令，出现步骤10的情况，问题解决，以下步骤不用看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sfc /scannow</span><br></pre></td></tr></table></figure>
</li>
<li><p>仍未解决下载并运行<a href="https://go.microsoft.com/fwlink/?linkid=2156295">MediaCreationToolW11</a>，</p>
</li>
<li><p>在“选择语言和版本”的界面，选择正确的系统版本，（通常来讲默认是和当前系统一样的版本，不用选择），在“选择要使用的介质”界面，请选择“ISO文件”。</p>
</li>
<li><p>选择一个位置保存该文件（任意位置），下载完成后，双击打开该文件，找到setup.exe 文件，鼠标双击运行。</p>
</li>
<li><p>在【你想执行哪种类型的安装】界面选择【升级：安装Windows并保留文件、设置和应用程序】。</p>
</li>
<li><p>等待安装重启，完成后<code>sfc /scannow</code>，出现步骤10情况完成，安装git和TortiseGit（重启次数较多，扫描安装时间较长请耐心等待）</p>
</li>
<li><p>git重装后，拉取提示（重装git，一定要卸载干净git，从设置-应用中卸载，并确保C盘隐藏文件ProgramData中的Git是否存在，存在表示卸载不干净）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Could not open repository.libgit2 returned: repository path &#x27;F:/..../&#x27; isnot owned by current user.</span><br><span class="line">To add an exception for this directory, call:git config --global --add safe.directory F:/....</span><br></pre></td></tr></table></figure></li>
<li><p>在当前文件夹中右键打开Open Git Bash here ，输入, 然后抄提示的那句话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --add safe.directory 文件路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完，打开项目 npm i</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>问题与方案</tag>
      </tags>
  </entry>
  <entry>
    <title>关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒</title>
    <url>/2024/11/01/%E6%8A%A5%E9%94%99%E6%8C%87%E5%8D%97/vscode%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/js/enChangegreen.js"></script>
<link rel="stylesheet" type="text/css" href="/css/global.css">

<h3 id="关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒"><a href="#关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒" class="headerlink" title="关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒"></a>关于VScode设置中已配置好prettier但项目中不生效一直飘红线eslint提醒</h3><ol>
<li>在项目中创建一个.prettierrc.json文件，然后配置好后</li>
<li>在.eslintrc中也配置对应prettier配置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.prettierrc.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;endOfLine&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">  <span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;semi&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .eslintrc</span></span><br><span class="line"><span class="string">&quot;prettier/prettier&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;error&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;endOfLine&quot;</span>: <span class="string">&quot;auto&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端工程化工具</category>
      </categories>
      <tags>
        <tag>问题与方案</tag>
      </tags>
  </entry>
</search>
